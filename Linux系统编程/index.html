
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>Linux系统编程 - YuStone</title>

  
    <meta name="description" content="Linux系统编程学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程">
<meta property="og:url" content="http://yustonerain.top/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">
<meta property="og:site_name" content="YuStone">
<meta property="og:description" content="Linux系统编程学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yustonerain.top/images/avatar.jpg">
<meta property="article:published_time" content="2025-06-20T13:26:00.000Z">
<meta property="article:modified_time" content="2025-07-16T13:26:00.000Z">
<meta property="article:author" content="YuStone">
<meta property="article:tag" content="Linux System Programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yustonerain.top/images/avatar.jpg">
  
  
  
  <meta name="keywords" content="Linux System Programming">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="YuStone" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  
    <link rel="shortcut icon" href="/favicon1.ico">
  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"YuStone","sameAs":[],"image":"/images/avatar.jpg"},"dateCreated":"2025-06-20T21:26:00+08:00","dateModified":"2025-07-16T21:26:00+08:00","datePublished":"2025-06-20T21:26:00+08:00","description":"Linux系统编程学习","headline":"Linux系统编程","mainEntityOfPage":{"@type":"WebPage","@id":"http://yustonerain.top/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"YuStone","sameAs":[],"image":"/images/avatar.jpg","logo":{"@type":"ImageObject","url":"/images/avatar.jpg"}},"url":"http://yustonerain.top/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/","keywords":"Linux System Programming","image":[]}</script>
  
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">YuStone</div><div class="sub normal cap">我的独立博客</div><div class="sub hover cap" style="opacity:0"> 欢迎来到我的博客</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="关于" href="/about/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="朋友" href="/friends/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>



<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/Qt%E5%AD%A6%E4%B9%A0/"><span class="title">Qt学习</span></a><a class="item title" href="/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6/"><span class="title">分布式网络通信框架编写</span></a><a class="item title" href="/protobuf%E5%AE%9E%E8%B7%B5cpp/"><span class="title">protobuf实践基于cpp</span></a><a class="item title" href="/%E5%89%96%E6%9E%90muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/"><span class="title">剖析muduo网络库核心代码</span></a><a class="item title" href="/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/"><span class="title">mysql连接池</span></a><a class="item title" href="/C-%E6%8F%90%E5%8D%87/"><span class="title">C++提升</span></a><a class="item title" href="/C-basiclearning/"><span class="title">C++basiclearning</span></a><a class="item title" href="/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"><span class="title">git必知必会</span></a><a class="item title" href="/MYSQLlearning/"><span class="title">MYSQLlearning</span></a><a class="item title" href="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="title">Linux网络编程</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/YuStone0416" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder/social/08a41b181ce68.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder/social/3845874.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder/social/3616429.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder/social/942ebbf1a4b91.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Linux-System-Programming/">Linux System Programming</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-06-20T13:26:00.000Z">2025-06-20</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-07-16T13:26:00.000Z">2025-07-16</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Linux系统编程</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h2 id="Linux常见目录"><a href="#Linux常见目录" class="headerlink" title="Linux常见目录"></a>Linux常见目录</h2><table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/</code></td>
<td>根目录，所有目录的起点，Linux 文件系统的顶级目录</td>
</tr>
<tr>
<td><code>/bin</code></td>
<td>存放常用的二进制可执行文件（如 <code>ls</code>、<code>cp</code>、<code>mv</code> 等），普通用户和系统都可使用</td>
</tr>
<tr>
<td><code>/sbin</code></td>
<td>系统管理命令，只有 root 用户可用（如 <code>reboot</code>、<code>ifconfig</code>）</td>
</tr>
<tr>
<td><code>/etc</code></td>
<td>配置文件目录（如 <code>/etc/passwd</code>、<code>/etc/fstab</code>、<code>/etc/ssh/sshd_config</code>）</td>
</tr>
<tr>
<td><code>/home</code></td>
<td>普通用户的家目录（如 <code>/home/user1</code>）</td>
</tr>
<tr>
<td><code>/root</code></td>
<td>超级用户（root）的家目录</td>
</tr>
<tr>
<td><code>/lib</code></td>
<td>核心共享库和驱动模块，供 <code>/bin</code> 和 <code>/sbin</code> 下的程序使用</td>
</tr>
<tr>
<td><code>/usr</code></td>
<td>存放用户应用程序和文件，子目录中包括 <code>/usr/bin</code>、<code>/usr/lib</code> 等</td>
</tr>
<tr>
<td><code>/usr/bin</code></td>
<td>普通用户使用的应用程序（非基本命令）</td>
</tr>
<tr>
<td><code>/usr/sbin</code></td>
<td>非系统引导时使用的系统管理员命令</td>
</tr>
<tr>
<td><code>/var</code></td>
<td>可变数据，如日志文件 <code>/var/log</code>、邮件、缓存、锁等</td>
</tr>
<tr>
<td><code>/tmp</code></td>
<td>临时文件，系统重启后可能会被清空</td>
</tr>
<tr>
<td><code>/opt</code></td>
<td>第三方软件安装目录（如 Chrome、VMware 等）</td>
</tr>
<tr>
<td><code>/dev</code></td>
<td>设备文件（如硬盘 <code>/dev/sda</code>，终端 <code>/dev/tty</code>）</td>
</tr>
<tr>
<td><code>/proc</code></td>
<td>虚拟文件系统，内核和进程信息（如 <code>/proc/cpuinfo</code>、<code>/proc/meminfo</code>）</td>
</tr>
<tr>
<td><code>/sys</code></td>
<td>另一种虚拟文件系统，提供与内核、设备驱动的交互接口</td>
</tr>
<tr>
<td><code>/boot</code></td>
<td>存放启动相关文件，如内核、grub 等（如 <code>/boot/vmlinuz-*</code>）</td>
</tr>
<tr>
<td><code>/media</code></td>
<td>可移动媒体挂载点（如 U 盘、光盘）</td>
</tr>
<tr>
<td><code>/mnt</code></td>
<td>临时挂载点，一般管理员手动挂载文件系统用</td>
</tr>
<tr>
<td><code>/run</code></td>
<td>系统运行时临时文件（如 PID、Socket）</td>
</tr>
<tr>
<td><code>/srv</code></td>
<td>提供服务的数据目录（如 Web 服务、FTP 服务的数据）</td>
</tr>
</tbody></table>
<h2 id="Bash解析器常用快捷键"><a href="#Bash解析器常用快捷键" class="headerlink" title="Bash解析器常用快捷键"></a>Bash解析器常用快捷键</h2><p>1.tap键</p>
<p>补齐命令，补齐路径，显示当前目录下的所有目录</p>
<p>2.清屏 clear</p>
<p>3.中断进程 ctrl+c</p>
<p>4 遍历输入的历史命令箭头上（ctrl+p）箭头下(ctrl+n)</p>
<p>5 光标相关操作</p>
<p>光标左移： ctrl+b（箭头左）</p>
<p>光标右移： ctrl+f(箭头右)</p>
<p>移动到头部: ctrl+a(home键)</p>
<p>移动到尾部：ctrl+e(end键)</p>
<p>6字符删除</p>
<p>删除光标前面的字符：ctrl+h(Backspace)</p>
<p>删除光标后面的字符：ctrl+d</p>
<p>光标后面的字符即光标覆盖的字符</p>
<p>删除光标前的所有内容：ctrl+u</p>
<p>删除光标后的所有内容：ctrl+k</p>
<h2 id="终端相关快捷键"><a href="#终端相关快捷键" class="headerlink" title="终端相关快捷键"></a>终端相关快捷键</h2><p>（终端一定要选中）</p>
<p>ctrl+shift+N 新建一个终端</p>
<p>ctrl+shift+T 在终端里新建一个标签</p>
<p>ctrl+D 关闭当前一个终端</p>
<h2 id="内建命令和外部命令对比"><a href="#内建命令和外部命令对比" class="headerlink" title="内建命令和外部命令对比"></a>内建命令和外部命令对比</h2><p>内建命令 vs 外部命令 对比总结</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>内建命令（Builtin Command）</th>
<th>外部命令（External Command）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>由 Shell 内部直接实现的命令</td>
<td>是文件系统中的可执行程序（如 <code>/bin/ls</code>）</td>
</tr>
<tr>
<td><strong>执行速度</strong></td>
<td>快（不需新建进程）</td>
<td>较慢（需 fork 子进程执行）</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>少，执行在当前 Shell 进程中</td>
<td>多，执行时创建子进程</td>
</tr>
<tr>
<td><strong>路径查找</strong></td>
<td>不需要依赖 <code>PATH</code> 环境变量</td>
<td>需要从 <code>PATH</code> 中查找可执行文件</td>
</tr>
<tr>
<td><strong>是否可以替换</strong></td>
<td>一般不推荐重定义</td>
<td>可以覆盖、替换或删改（如 alias 覆盖）</td>
</tr>
<tr>
<td><strong>是否常驻内存</strong></td>
<td>是，Shell 启动时加载</td>
<td>否，执行时加载，执行完释放</td>
</tr>
<tr>
<td><strong>例子</strong></td>
<td><code>cd</code>, <code>echo</code>, <code>exit</code>, <code>pwd</code>, <code>type</code></td>
<td><code>ls</code>, <code>cp</code>, <code>gcc</code>, <code>vim</code>, <code>python</code></td>
</tr>
<tr>
<td><strong>查看方法</strong></td>
<td><code>type cd</code> → builtin</td>
<td><code>type ls</code> → file</td>
</tr>
</tbody></table>
<p>命令类型查看方法</p>
<p>使用type命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> [选项] 命令名</span><br></pre></td></tr></table></figure>

<p>使用 -a 显示所有同名命令（包括 alias、builtin、文件）</p>
<p>使用 -t 显示类型（简洁）</p>
<h2 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 [选项] [参数]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>部分</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>命令</strong></td>
<td>要执行的操作，如 <code>ls</code>、<code>cp</code>、<code>mkdir</code> 等</td>
</tr>
<tr>
<td><strong>选项</strong></td>
<td>用于控制命令行为的开关，通常以 <code>-</code> 或 <code>--</code> 开头，例如 <code>-l</code>、<code>--help</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>命令作用的对象，通常是文件名、目录名、用户名等</td>
</tr>
</tbody></table>
<p>选项类型说明</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>短选项</td>
<td><code>-l</code></td>
<td>通常是一个字母，多个可组合（如 <code>-al</code>）</td>
</tr>
<tr>
<td>长选项</td>
<td><code>--help</code></td>
<td>更易读，通常不可组合</td>
</tr>
<tr>
<td>组合选项</td>
<td><code>-avz</code></td>
<td>相当于 <code>-a -v -z</code></td>
</tr>
</tbody></table>
<h2 id="帮助文档查看方法"><a href="#帮助文档查看方法" class="headerlink" title="帮助文档查看方法"></a>帮助文档查看方法</h2><p>如果是内建命令（可以通过之前的type命令查看）使用 help +内建命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

<p>如果是外部命令 对应命令名 –help</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p><code>man</code> 是 Linux 中最常用的命令之一，全称是 <strong>manual（手册）</strong>，用于查看各种命令、函数、配置文件的使用说明。它是学习和查找 Linux 命令最权威的工具。</p>
<p><code>man</code> 命令基本语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man [选项] [命令名或函数名]</span><br></pre></td></tr></table></figure>

<p> man 手册的 9 个部分（章节）</p>
<table>
<thead>
<tr>
<th>章节号</th>
<th>内容</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户命令（常见终端命令）</td>
<td><code>man ls</code></td>
</tr>
<tr>
<td>2</td>
<td>系统调用（内核提供的函数）</td>
<td><code>man 2 open</code></td>
</tr>
<tr>
<td>3</td>
<td>C 库函数</td>
<td><code>man 3 printf</code></td>
</tr>
<tr>
<td>4</td>
<td>设备文件和特殊文件</td>
<td><code>man 4 tty</code></td>
</tr>
<tr>
<td>5</td>
<td>配置文件格式</td>
<td><code>man 5 crontab</code></td>
</tr>
<tr>
<td>6</td>
<td>游戏与趣味（极少）</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>杂项（宏定义、协议、约定等）</td>
<td><code>man 7 signal</code></td>
</tr>
<tr>
<td>8</td>
<td>系统管理员命令（只能 root 执行）</td>
<td><code>man 8 ifconfig</code></td>
</tr>
<tr>
<td>9</td>
<td>内核开发接口（不常见）</td>
<td></td>
</tr>
</tbody></table>
<p>常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>-k 关键词</code></td>
<td>搜索相关命令（相当于 <code>apropos</code>）</td>
</tr>
<tr>
<td><code>-f 命令名</code></td>
<td>显示命令属于哪个章节（相当于 <code>whatis</code>）</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>显示所有章节中匹配的 man 页</td>
</tr>
<tr>
<td><code>-M</code></td>
<td>指定手册路径</td>
</tr>
<tr>
<td><code>--help</code></td>
<td>查看 man 自身帮助信息</td>
</tr>
</tbody></table>
<h2 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h2><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>用于显示当前终端所在的<strong>工作目录</strong>（即当前绝对路径）。</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [目录路径]</span><br></pre></td></tr></table></figure>

<p>常见用法示例</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>cd /home/user</code></td>
<td>切换到绝对路径 <code>/home/user</code> 目录</td>
</tr>
<tr>
<td><code>cd ..</code></td>
<td>切换到上一级目录</td>
</tr>
<tr>
<td><code>cd</code> 或 <code>cd ~</code></td>
<td>切换到当前用户的主目录</td>
</tr>
<tr>
<td><code>cd -</code></td>
<td>切换到上一次所在的目录（切换目录的“切换”）</td>
</tr>
<tr>
<td><code>cd ./folder</code></td>
<td>切换到当前目录下的子目录 <code>folder</code></td>
</tr>
</tbody></table>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>用于<strong>创建新目录</strong>的命令，创建不了已存在目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [选项] 目录名</span><br></pre></td></tr></table></figure>

<p>mkdir test 在当前目录下创建test文件夹</p>
<p>mkdir &#x2F;tmp&#x2F;test</p>
<p>mkdir file{1..100}在当前目录创建100个文件夹，file1,file2,file3…file100</p>
<p>mkdir “file{1..100}”在当前目录创建file{1..100}文件夹，只会创建一个。</p>
<p>mkdir “a b” 在当前目录创建a b一个文件夹。</p>
<p>mkdir a b 在当前目录创建a b两个文件夹。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-p</code></td>
<td>递归创建目录（父目录不存在时自动创建）</td>
</tr>
<tr>
<td><code>-m MODE</code></td>
<td>设置新建目录的权限，如 <code>-m 755</code></td>
</tr>
<tr>
<td><code>-v</code></td>
<td>显示详细创建过程（verbose）</td>
</tr>
</tbody></table>
<h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>用法和mkdir相同</p>
<p>用于<strong>删除空目录</strong>的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>rmdir testdir</code></td>
<td>删除当前目录下的 <code>testdir</code>（需为空）</td>
</tr>
<tr>
<td><code>rmdir -p a/b/c</code></td>
<td>递归删除空目录链：先删 <code>c</code>，再删 <code>b</code>，再删 <code>a</code></td>
</tr>
<tr>
<td><code>rmdir ./mydir/</code></td>
<td>删除当前目录中的 <code>mydir</code>（需为空）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-p</code></td>
<td>递归删除路径中的所有空目录（从子到父）</td>
</tr>
<tr>
<td><code>--ignore-fail-on-non-empty</code></td>
<td>删除目录时忽略非空目录导致的错误</td>
</tr>
</tbody></table>
<h2 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h2><p>常用的文件类型有七种：普通文件，目录文件，设备文件，管道文件，链接文件和套接字。</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/1.png" alt="1"></p>
<p><strong>普通文件</strong> 是 Linux 中最常见的一类文件，主要用于存储用户数据。包括：</p>
<ul>
<li>文本文件（如 <code>.txt</code>, <code>.c</code>, <code>.py</code>）</li>
<li>二进制文件（如 可执行程序、图片、音频等）</li>
<li>脚本文件（如 <code>.sh</code>, <code>.py</code>，可以被解释执行）</li>
</ul>
<p>在 Linux 中，<strong>目录文件（Directory File）</strong> 是一种特殊的文件类型，用来组织和存放文件和其他目录（子目录）。<br> 它本质上是一个<strong>保存了文件名和 inode 编号之间映射关系</strong>的文件。</p>
<p><strong>设备文件</strong>（Device File）是 Linux 中用于访问硬件设备的接口，本质上就是一种特殊的文件，程序通过它来与硬件设备通信。</p>
<p>设备文件通常位于 <code>/dev</code> 目录中。</p>
<p>常见设备文件举例</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>/dev/sda</code></td>
<td>块设备</td>
<td>第一块硬盘</td>
</tr>
<tr>
<td><code>/dev/tty</code></td>
<td>字符设备</td>
<td>当前终端</td>
</tr>
<tr>
<td><code>/dev/null</code></td>
<td>字符设备</td>
<td>写入数据会被丢弃</td>
</tr>
<tr>
<td><code>/dev/zero</code></td>
<td>字符设备</td>
<td>会源源不断输出 0</td>
</tr>
<tr>
<td><code>/dev/random</code></td>
<td>字符设备</td>
<td>伪随机数生成器</td>
</tr>
</tbody></table>
<p><strong>管道文件</strong>（或称命名管道，FIFO &#x3D; First In First Out）是一种特殊文件，用于<strong>在不同进程之间传输数据</strong>。<br> 写入管道的数据会按顺序被读取，类似“排队喝水”的水管，先进先出。</p>
<p>管道文件与匿名管道不同之处在于它有名字，存在于文件系统中（通常创建在某个路径下），因此<strong>不同进程不必有父子关系</strong>也能通信。</p>
<p><strong>链接文件</strong> 是指向另一个文件的引用，常用于：</p>
<ul>
<li>创建多个路径指向同一个文件（节省空间）</li>
<li>为长路径或常用文件创建别名（提高效率）</li>
<li>实现共享与替代功能</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th><code>ls -l</code> 标识</th>
</tr>
</thead>
<tbody><tr>
<td><strong>软链接</strong>（符号链接）</td>
<td>类似 Windows 快捷方式，是一个指向目标路径的独立文件</td>
<td><code>l</code></td>
</tr>
<tr>
<td><strong>硬链接</strong></td>
<td>直接指向目标文件的 inode，本质上是同一个文件的另一个名字</td>
<td><code>-</code></td>
</tr>
</tbody></table>
<p>在 Linux 中，你可以使用 <code>ls -l</code> 命令来区分各种文件类型。<code>ls -l</code> 输出的每一行开头的第一个字符表示文件类型。下面是 <strong>七种常见文件类型及其 <code>ls -l</code> 显示符号</strong>：</p>
<p>七种常见文件类型及其标识</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th><code>ls -l</code> 类型字符</th>
<th>示例路径</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>普通文件</strong></td>
<td><code>-</code></td>
<td><code>-rw-r--r-- file.txt</code></td>
<td>常见的文本、二进制、可执行文件等</td>
</tr>
<tr>
<td><strong>目录文件</strong></td>
<td><code>d</code></td>
<td><code>drwxr-xr-x dir/</code></td>
<td>存储文件的容器</td>
</tr>
<tr>
<td><strong>字符设备文件</strong></td>
<td><code>c</code></td>
<td><code>crw------- /dev/tty</code></td>
<td>逐字符访问设备，如终端、串口等</td>
</tr>
<tr>
<td><strong>块设备文件</strong></td>
<td><code>b</code></td>
<td><code>brw-rw---- /dev/sda</code></td>
<td>按块访问设备，如硬盘、U 盘等</td>
</tr>
<tr>
<td><strong>管道文件</strong></td>
<td><code>p</code></td>
<td><code>prw-r--r-- mypipe</code></td>
<td>用于进程间通信的 FIFO 管道</td>
</tr>
<tr>
<td><strong>链接文件</strong></td>
<td><code>l</code></td>
<td><code>lrwxrwxrwx link -&gt; target</code></td>
<td>指向其他文件的软链接</td>
</tr>
<tr>
<td><strong>套接字文件</strong></td>
<td><code>s</code></td>
<td><code>srwxrwxrwx socket</code></td>
<td>进程间网络通信接口，如 <code>/tmp/.X11-unix/X0</code></td>
</tr>
</tbody></table>
<h2 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h2><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>简单列出当前目录内容</td>
</tr>
<tr>
<td><code>ls -a</code></td>
<td>显示所有文件，包括隐藏文件（以<code>.</code>开头）</td>
</tr>
<tr>
<td><code>ls -l</code></td>
<td>以长格式列出，显示权限、类型、时间等</td>
</tr>
<tr>
<td><code>ls -lh</code></td>
<td>长格式 + 人类可读大小（如 KB, MB）</td>
</tr>
<tr>
<td><code>ls -lt</code></td>
<td>按修改时间排序，最新的在前</td>
</tr>
<tr>
<td><code>ls -r</code></td>
<td>反向排序</td>
</tr>
<tr>
<td><code>ls -R</code></td>
<td>递归列出子目录</td>
</tr>
<tr>
<td><code>ls -d */</code></td>
<td>只列出目录 ls -d只显示一个.</td>
</tr>
</tbody></table>
<p>ls -l命令会输出长格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">权限       硬链接数 拥有者 所属组  大小    修改日期      文件名</span><br><span class="line">drwxr-xr-x   2    user   user  4096   Jun 21 13:00  mydir</span><br></pre></td></tr></table></figure>

<p>对权限部分说明一下权限部分总共10个字符</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>文件类型标识</td>
</tr>
<tr>
<td>2-4</td>
<td><strong>拥有者（user）</strong>权限</td>
</tr>
<tr>
<td>5-7</td>
<td><strong>同组用户（group）</strong>权限</td>
</tr>
<tr>
<td>8-10</td>
<td><strong>其他用户（others）</strong>权限</td>
</tr>
</tbody></table>
<p>文件类型标识（第1个字符）</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>-</code></td>
<td>普通文件</td>
</tr>
<tr>
<td><code>d</code></td>
<td>目录</td>
</tr>
<tr>
<td><code>l</code></td>
<td>软链接</td>
</tr>
<tr>
<td><code>c</code></td>
<td>字符设备文件</td>
</tr>
<tr>
<td><code>b</code></td>
<td>块设备文件</td>
</tr>
<tr>
<td><code>p</code></td>
<td>管道（FIFO）</td>
</tr>
<tr>
<td><code>s</code></td>
<td>套接字</td>
</tr>
</tbody></table>
<p>权限字符说明（2-10位置）</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>r</code></td>
<td>读权限 (read)</td>
</tr>
<tr>
<td><code>w</code></td>
<td>写权限 (write)</td>
</tr>
<tr>
<td><code>x</code></td>
<td>执行权限 (execute)</td>
</tr>
<tr>
<td><code>-</code></td>
<td>无该权限</td>
</tr>
<tr>
<td><code>s</code></td>
<td>setuid&#x2F;setgid 位（特殊执行权限）</td>
</tr>
<tr>
<td><code>t</code></td>
<td>粘滞位（sticky bit）</td>
</tr>
</tbody></table>
<p>三组权限详解</p>
<table>
<thead>
<tr>
<th>组别</th>
<th>位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>拥有者</strong></td>
<td>2~4 字符</td>
<td>拥有该文件&#x2F;目录的用户权限</td>
</tr>
<tr>
<td><strong>组用户</strong></td>
<td>5~7 字符</td>
<td>属于该文件组的用户权限</td>
</tr>
<tr>
<td><strong>其他用户</strong></td>
<td>8~10 字符</td>
<td>系统中除拥有者和组以外的所有用户权限</td>
</tr>
</tbody></table>
<h3 id="什么是通配符？"><a href="#什么是通配符？" class="headerlink" title="什么是通配符？"></a>什么是通配符？</h3><p>通配符是一种简化文件名匹配的符号，用于在命令中匹配多个文件或目录。它可以让你不用输入完整文件名，就能选中符合规则的文件。</p>
<p>常用的通配符类型</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
<th>例子</th>
<th>匹配结果示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配任意数量的任意字符（包括0个）</td>
<td><code>ls *.txt</code></td>
<td>匹配所有以 <code>.txt</code> 结尾的文件</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配任意一个单字符</td>
<td><code>ls file?.txt</code></td>
<td>匹配 <code>file1.txt</code>、<code>fileA.txt</code>，但不匹配 <code>file10.txt</code></td>
</tr>
<tr>
<td><code>[abc]</code></td>
<td>匹配括号内的任意一个字符</td>
<td><code>ls file[123].txt</code></td>
<td>匹配 <code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code></td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td>匹配指定范围内的任意一个字符</td>
<td><code>ls file[a-c].txt</code></td>
<td>匹配 <code>filea.txt</code>、<code>fileb.txt</code>、<code>filec.txt</code></td>
</tr>
<tr>
<td><code>[!abc]</code></td>
<td>匹配不在括号内的任意一个字符</td>
<td><code>ls file[!123].txt</code></td>
<td>匹配除 <code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code> 以外的文件</td>
</tr>
</tbody></table>
<h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p><code>touch</code> 是用来 <strong>创建空文件</strong> 或 <strong>更新已有文件的时间戳</strong> 的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> file.txt</span><br></pre></td></tr></table></figure>

<p>如果 <code>file.txt</code> 不存在，会被创建为空文件；如果存在，文件时间被更新。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> file1.txt file2.txt file3.txt</span><br></pre></td></tr></table></figure>

<p>一次创建或更新多个文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> file&#123;2,3,4&#125;#同时创建file2,file3,file4三个空文件和<span class="built_in">mkdir</span> file&#123;1..100&#125;用法是一样的。</span><br><span class="line"><span class="built_in">touch</span> <span class="string">&quot;file&#123;2,3,4&#125;&quot;</span>#创建file&#123;2,3,4&#125;这一个文件。</span><br></pre></td></tr></table></figure>

<h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p><code>cp</code> 是 Linux 中用于 <strong>复制文件或目录</strong> 的命令。</p>
<table>
<thead>
<tr>
<th>任务</th>
<th>命令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>复制文件</td>
<td><code>cp file1.txt file2.txt</code></td>
<td>把 <code>file1.txt</code> 内容复制为 <code>file2.txt</code></td>
</tr>
<tr>
<td>复制文件到目录</td>
<td><code>cp file1.txt /home/user/docs/</code></td>
<td>把 <code>file1.txt</code> 复制进目录</td>
</tr>
<tr>
<td>复制目录（加 <code>-r</code>）</td>
<td><code>cp -r dir1/ dir2/</code></td>
<td>递归复制整个目录 <code>dir1</code> 到 <code>dir2</code> 中</td>
</tr>
<tr>
<td>保留属性复制文件</td>
<td><code>cp -p file1.txt file2.txt</code></td>
<td>保留原文件的时间戳、权限等信息</td>
</tr>
<tr>
<td>强制覆盖目标文件</td>
<td><code>cp -f file1.txt file2.txt</code></td>
<td>如果 <code>file2.txt</code> 存在，强制覆盖</td>
</tr>
<tr>
<td>复制并提示</td>
<td><code>cp -i file1.txt file2.txt</code></td>
<td>有冲突时会提示确认</td>
</tr>
<tr>
<td>显示复制过程</td>
<td><code>cp -v file1.txt file2.txt</code></td>
<td>复制时显示详细过程（verbose 模式）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-r</code></td>
<td>递归复制目录（必须用于复制目录）</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>覆盖文件前提示确认</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>强制覆盖目标文件而不提示</td>
</tr>
<tr>
<td><code>-p</code></td>
<td>保留原文件的属性（权限、时间等）</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>只在源文件较新时才复制</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>显示复制过程（verbose）</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>归档模式，等价于 <code>-dpR</code>，用于备份</td>
</tr>
<tr>
<td><code>--parents</code></td>
<td>保留源路径结构复制文件（适用于目录结构迁移）</td>
</tr>
</tbody></table>
<h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><p>是用于在 Linux 中 <strong>删除文件和目录</strong> 的命令。注意：<code>rm</code> 删除后不会进入回收站，<strong>无法轻易恢复</strong>，请务必小心使用。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>删除单个文件</td>
<td><code>rm file.txt</code></td>
<td>删除文件 <code>file.txt</code></td>
</tr>
<tr>
<td>删除多个文件</td>
<td><code>rm file1.txt file2.txt</code></td>
<td>一次删除多个文件</td>
</tr>
<tr>
<td>递归删除目录及内容</td>
<td><code>rm -r mydir/</code></td>
<td>删除目录 <code>mydir</code> 及其所有子目录和文件</td>
</tr>
<tr>
<td>强制删除文件&#x2F;目录</td>
<td><code>rm -f file.txt</code> &#x2F; <code>rm -rf mydir/</code></td>
<td>忽略不存在的文件，且不提示确认</td>
</tr>
<tr>
<td>删除前确认</td>
<td><code>rm -i file.txt</code></td>
<td>删除前逐一询问确认</td>
</tr>
<tr>
<td>显示正在删除的文件</td>
<td><code>rm -v file.txt</code></td>
<td>显示被删除的文件名</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-r</code> 或 <code>--recursive</code></td>
<td>递归删除目录及其内容（删除整个目录树）</td>
</tr>
<tr>
<td><code>-f</code> 或 <code>--force</code></td>
<td>强制删除，不提示，即使目标不存在也不报错</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>删除前询问确认，适合新手使用以防误删</td>
</tr>
<tr>
<td><code>-I</code></td>
<td>删除多个文件或目录时才询问一次，比 <code>-i</code> 安全且不烦人</td>
</tr>
<tr>
<td><code>-v</code> 或 <code>--verbose</code></td>
<td>显示正在删除的每一个文件或目录</td>
</tr>
<tr>
<td><code>--preserve-root</code></td>
<td>默认保护根目录 <code>/</code> 不被删除（系统安全机制，防止 <code>rm -rf /</code> 误操作）</td>
</tr>
</tbody></table>
<h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p><strong>移动文件或目录</strong> 到新位置，<strong>重命名</strong> 文件或目录。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>移动文件</td>
<td><code>mv a.txt /home/user/docs/</code></td>
<td>把 <code>a.txt</code> 移动到 <code>/home/user/docs/</code> 目录</td>
</tr>
<tr>
<td>重命名文件</td>
<td><code>mv old.txt new.txt</code></td>
<td>将 <code>old.txt</code> 重命名为 <code>new.txt</code></td>
</tr>
<tr>
<td>移动并重命名</td>
<td><code>mv a.txt /home/user/docs/b.txt</code></td>
<td>移动 <code>a.txt</code> 到新目录并改名为 <code>b.txt</code></td>
</tr>
<tr>
<td>移动目录</td>
<td><code>mv dir1/ /home/user/backup/</code></td>
<td>移动整个目录到新的路径</td>
</tr>
<tr>
<td>覆盖已有文件</td>
<td><code>mv -f a.txt b.txt</code></td>
<td>如果 <code>b.txt</code> 存在，则强制覆盖</td>
</tr>
<tr>
<td>覆盖前确认</td>
<td><code>mv -i a.txt b.txt</code></td>
<td>如果 <code>b.txt</code> 存在，移动前会询问是否覆盖</td>
</tr>
<tr>
<td>显示移动过程</td>
<td><code>mv -v a.txt b.txt</code></td>
<td>显示正在移动的内容</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-f</code></td>
<td>强制覆盖已有目标文件，不提示</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>如果目标文件存在，提示是否覆盖（interactive）</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>不覆盖已有的目标文件（no-clobber）</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>显示移动过程（verbose）</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>仅在源文件较新或目标文件不存在时才移动</td>
</tr>
</tbody></table>
<h2 id="文件内容查看相关命令"><a href="#文件内容查看相关命令" class="headerlink" title="文件内容查看相关命令"></a>文件内容查看相关命令</h2><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>用于 <strong>查看、创建、合并文件</strong> 内容，常用于快速查看文本文件内容。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-n</code></td>
<td>给所有行编号</td>
</tr>
<tr>
<td><code>-b</code></td>
<td>只对非空行编号</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>压缩连续空白行为一行</td>
</tr>
<tr>
<td><code>-T</code></td>
<td>显示 Tab 为 <code>^I</code></td>
</tr>
<tr>
<td><code>-E</code></td>
<td>显示每行结尾的 <code>$</code>（换行符可见）</td>
</tr>
<tr>
<td><code>-A</code></td>
<td>相当于 <code>-vET</code>，显示所有不可见字符</td>
</tr>
</tbody></table>
<h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p>用于<strong>分页显示文件内容</strong>的命令，支持 <strong>向前&#x2F;向后翻页浏览</strong>，适合查看<strong>大型文本文件</strong>。它比 <code>cat</code> 更强大，且不会一次性加载全部内容到内存中。</p>
<p>使用时常用快捷键（进入 less 后）</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>空格</code></td>
<td>向下翻一页</td>
</tr>
<tr>
<td><code>b</code></td>
<td>向上翻一页</td>
</tr>
<tr>
<td><code>Enter</code></td>
<td>向下滚动一行</td>
</tr>
<tr>
<td><code>k</code></td>
<td>向上一行（vi 风格）</td>
</tr>
<tr>
<td><code>j</code></td>
<td>向下一行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>跳到文件末尾</td>
</tr>
<tr>
<td><code>g</code></td>
<td>跳到文件开头</td>
</tr>
<tr>
<td><code>/关键词</code></td>
<td>向下搜索（如 <code>/error</code>）</td>
</tr>
<tr>
<td><code>?关键词</code></td>
<td>向上搜索</td>
</tr>
<tr>
<td><code>n</code></td>
<td>重复上一次搜索</td>
</tr>
<tr>
<td><code>N</code></td>
<td>反向重复搜索</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出 less</td>
</tr>
</tbody></table>
<h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><p><code>head</code> 用于345</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>-n N</code></td>
<td>显示前 N 行（如 <code>head -n 15 file.txt</code>）</td>
</tr>
<tr>
<td><code>-c N</code></td>
<td>显示前 N 个<strong>字节</strong>（如 <code>head -c 100 file.txt</code>）</td>
</tr>
<tr>
<td><code>-q</code></td>
<td>多文件时不显示文件名头部（quiet）</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>总是显示文件名头部（verbose）</td>
</tr>
</tbody></table>
<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>用于<strong>显示文件的最后几行内容</strong>，默认是最后 10 行。常用于：</p>
<ul>
<li>查看日志尾部；</li>
<li>实时监控文件内容变化（配合 <code>-f</code> 选项）；</li>
<li>截取文件结尾部分数据。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> /etc/passwd <span class="comment">#默认显示后十行</span></span><br><span class="line"><span class="built_in">tail</span> -n 30 文件名 <span class="comment">#显示后30行内容</span></span><br><span class="line"><span class="built_in">tail</span> -c 30 文件名 <span class="comment">#显示后30个字符</span></span><br></pre></td></tr></table></figure>

<h2 id="du和df命令"><a href="#du和df命令" class="headerlink" title="du和df命令"></a>du和df命令</h2><h3 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h3><p>查看<strong>目录或文件占用的磁盘空间</strong>，会考虑磁盘块对齐、文件系统元数据、软链接等因素。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-h</code></td>
<td>以<strong>人类可读的方式</strong>显示（如 KB、MB）</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>显示指定文件&#x2F;目录占用的数据块</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>显示所有文件和目录的大小（默认只显示目录）</td>
</tr>
<tr>
<td><code>--max-depth=N</code></td>
<td>显示目录深度（限制递归层数）</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh 文件名/目录</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th><code>ls -l</code></th>
<th><code>du -sh</code></th>
</tr>
</thead>
<tbody><tr>
<td>显示内容</td>
<td>文件本身大小（内容字节数）</td>
<td>实际磁盘占用（包含对齐和元数据）</td>
</tr>
<tr>
<td>对目录</td>
<td>显示目录结构本身大小</td>
<td>显示目录下所有内容实际占用</td>
</tr>
<tr>
<td>单位</td>
<td>字节（Bytes）</td>
<td>自动转换为 KB&#x2F;MB&#x2F;GB</td>
</tr>
<tr>
<td>应用场景</td>
<td>看文件大小&#x2F;属性</td>
<td>查哪些文件&#x2F;目录占空间最多</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; file.txt</span><br><span class="line"><span class="built_in">ls</span> -l file.txt      <span class="comment"># 显示 6 bytes</span></span><br><span class="line"><span class="built_in">du</span> -sh file.txt     <span class="comment"># 显示 4.0K</span></span><br></pre></td></tr></table></figure>

<h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h3><p>查看<strong>整个磁盘的使用情况</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h <span class="comment"># 显示所有文件系统的使用情况（人类可读格式）</span></span><br><span class="line"><span class="built_in">df</span> -h /home <span class="comment"># 查看 /home 所在分区的磁盘使用情况</span></span><br></pre></td></tr></table></figure>

<h2 id="查找相关命令"><a href="#查找相关命令" class="headerlink" title="查找相关命令"></a>查找相关命令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find</code> 是 Linux 中功能非常强大的文件搜索命令，它可以根据名称、类型、时间、大小、权限等多种条件在目录中递归查找文件，还可以执行删除、移动、打印等操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [搜索路径] [搜索条件] [处理动作]</span><br></pre></td></tr></table></figure>

<p>按文件名查询：使用参数 -name</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name <span class="string">&quot;*.txt&quot;</span> <span class="comment">#查找当前路径下符合后缀是。txt的文件</span></span><br></pre></td></tr></table></figure>

<p>按文件大小查询：使用参数 -size</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -size +100k</span><br></pre></td></tr></table></figure>

<p>+100k 表示大于100k的文件</p>
<p>-100k表示小于100k的文件</p>
<p>100k 表示等于100k的文件</p>
<p>大小方面：k小写，M大写</p>
<p>查询大小范围</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -size +50k -size -100k</span><br></pre></td></tr></table></figure>

<p>按文件类型查询：使用参数 -type</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -<span class="built_in">type</span> f <span class="comment">#查询当前的普通文件</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型代号</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>f</code></td>
<td>普通文件</td>
<td><code>find . -type f</code> 查找所有普通文件（这里不是-，要和ls -l的文件类型区分）</td>
</tr>
<tr>
<td><code>d</code></td>
<td>目录</td>
<td><code>find . -type d</code> 查找所有目录</td>
</tr>
<tr>
<td><code>l</code></td>
<td>符号链接（软链接）</td>
<td><code>find . -type l</code> 查找所有软链接</td>
</tr>
<tr>
<td><code>c</code></td>
<td>字符设备文件</td>
<td><code>/dev/null</code> 等</td>
</tr>
<tr>
<td><code>b</code></td>
<td>块设备文件</td>
<td>硬盘等块设备</td>
</tr>
<tr>
<td><code>s</code></td>
<td>套接字文件</td>
<td>Socket 类型文件</td>
</tr>
<tr>
<td><code>p</code></td>
<td>命名管道（FIFO）</td>
<td>通信用的特殊文件</td>
</tr>
</tbody></table>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><code>grep</code> 是 Linux 中非常常用的文本搜索工具，用于<strong>在文件或标准输出中查找匹配的字符串</strong>，功能强大，灵活，适合日志分析、配置文件搜索、编程辅助等场景。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] <span class="string">&quot;模式&quot;</span> [文件]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-n</code></td>
<td>显示匹配行的行号</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>忽略大小写</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>反向匹配（即显示不包含该字符串的行）</td>
</tr>
<tr>
<td><code>-r</code> or <code>-R</code></td>
<td>递归搜索目录下的所有文件</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>只列出匹配的文件名</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>统计匹配的行数</td>
</tr>
<tr>
<td><code>--color=auto</code></td>
<td>高亮显示匹配的内容</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&quot;root&quot;</span> /etc/passwd <span class="comment">#不分大小写，在passwd查找root</span></span><br><span class="line">grep -w <span class="string">&quot;hello&quot;</span> /etc/passwd <span class="comment">#在passwd查找完全匹配hello单词的行</span></span><br><span class="line">grep -r <span class="string">&quot;u_char&quot;</span> ./  <span class="comment">#递归搜索当前目录下的符合u_char的行</span></span><br><span class="line">grep -i <span class="string">&quot;hello&quot;</span> /etc/passwd --color=auto <span class="comment">#在/etc/passwd文件中找hello并且忽略大小写，然后高亮显示匹配的关键字</span></span><br></pre></td></tr></table></figure>

<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道（|）一个命令的输出可以通过管道作为另一个命令的输入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig | grep <span class="string">&quot;ens33&quot;</span> <span class="comment">#在ifconfig输出的文字查找存在ens33的行</span></span><br></pre></td></tr></table></figure>

<h2 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>把一系列文件归档到一个文件，也可以把档案文件解开以恢复数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] -f [文件名.tar] [要打包或解压的文件/目录]#f必须放到选项的最后</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf sysctl.tar sysctl <span class="comment">#打包文件，但是不压缩</span></span><br><span class="line">tar -xvf sysctl.tar <span class="comment">#解包文件</span></span><br><span class="line">tar -tvf sysctl.tar <span class="comment">#查看压缩文件内容</span></span><br></pre></td></tr></table></figure>

<h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p><strong>对单个文件进行压缩或解压</strong>，压缩率高、速度快，默认生成 <code>.gz</code> 文件。</p>
<p>tar和gzip命令结合使用实现文件打包，压缩。</p>
<p>tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般为xxx.tar.gz。</p>
<p>gzip单独使用，只可以对文件压缩和解压，不可以对目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip test1 test2 <span class="comment">#不保留源文件压缩。 </span></span><br></pre></td></tr></table></figure>

<p>tar和gzip结合对目录压缩</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf sysctl.tar.gz sysctl <span class="comment">#打包和压缩文件</span></span><br><span class="line">tar -xzvf sysctl.tar.gz <span class="comment">#解包和解压文件</span></span><br><span class="line">tar -xzvf sysctl.tar.gz -C /temp <span class="comment">#解包和解压文件到temp目录</span></span><br></pre></td></tr></table></figure>

<h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>和gzip一样和tar结合。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cjvf test.tar.bz2 <span class="built_in">test</span> <span class="comment">#生成一个bz2压缩包</span></span><br><span class="line">tar -xjvf share.tar.bz2 <span class="comment">#解压</span></span><br></pre></td></tr></table></figure>

<h3 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h3><p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip [选项] 目标文件（没有扩展名）源文件/目录</span><br><span class="line">unzip -d 解压后目录文件 压缩文件 <span class="comment">#-d解压到指定目录</span></span><br></pre></td></tr></table></figure>

<h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><p>访问权限说明：</p>
<p>读权限（r）</p>
<p>对文件而言，具有读取文件内容的权限；对目录而言，具有浏览目录的权限。</p>
<p>写权限（w）</p>
<p>对文件而言，具有新增，修改文件内容的权限；对目录而言，具有删除，移动目录内文件的权限。</p>
<p>可执行权限（x）</p>
<p>对文件而言，具有执行文件的权限；对目录而言，该用户具有进入目录的权限。</p>
<p>通常。Unix&#x2F;Linux系统只允许文件的属主（所有者）或root用户改变文件的读写权限。</p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><code>chmod</code>（<strong>change mode</strong>）是 Linux&#x2F;Unix 系统中用于<strong>修改文件或目录权限</strong>的命令。它支持两种权限设置方式：<strong>数字方式</strong>和<strong>符号方式</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [选项] 模式 文件名</span><br></pre></td></tr></table></figure>

<p>符号方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u/g/o/a +/-/= rwx 文件 <span class="comment">#+添加权限 -撤销权限 =设定权限 u/g/o对应的是拥有者，同属组，其他。</span></span><br><span class="line">chomd o+w a <span class="comment">#向a的其他用户添加写权限</span></span><br><span class="line">chomd u=rw,g=r,o=r a#把a的拥有者权限为re,同属组权限为r,其他用户权限为r。</span><br></pre></td></tr></table></figure>

<p>数字方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#由于rwx通过二进制来区分 rwx就是111，十进制为7</span></span><br><span class="line"><span class="comment">#rwx   7</span></span><br><span class="line"><span class="comment">#rw-   6</span></span><br><span class="line"><span class="comment">#r--   4</span></span><br><span class="line"><span class="comment">#r-x   5</span></span><br><span class="line">chomd 0777 a#把a的对应用户的权限变为rwx.</span><br></pre></td></tr></table></figure>

<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><code>chown</code> 是 Linux&#x2F;Unix 中用于更改文件或目录 <strong>所属用户（owner）</strong> 和 <strong>所属用户组（group）</strong> 的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> [选项] [新用户][:[新用户组]] 文件/目录</span><br></pre></td></tr></table></figure>

<p><code>新用户</code>：新的文件拥有者</p>
<p><code>新用户组</code>：新的用户组（可选）</p>
<p>需要 <code>sudo</code> 权限（普通用户只能修改自己拥有的文件）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把文件所有者修改为root用户</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> root a</span><br><span class="line"><span class="comment">#把文件所属者改为yustone,所属组改为root</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> yustone:root a</span><br></pre></td></tr></table></figure>

<h2 id="软件安装和卸载"><a href="#软件安装和卸载" class="headerlink" title="软件安装和卸载"></a>软件安装和卸载</h2><h3 id="使用包管理器安装和卸载"><a href="#使用包管理器安装和卸载" class="headerlink" title="使用包管理器安装和卸载"></a>使用包管理器安装和卸载</h3><p>Ubuntu &#x2F; Debian 系列</p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update          <span class="comment"># 更新软件源</span></span><br><span class="line"><span class="built_in">sudo</span> apt install 软件名  <span class="comment"># 安装软件</span></span><br></pre></td></tr></table></figure>

<p>卸载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt remove 软件名           <span class="comment"># 删除程序但保留配置文件</span></span><br><span class="line"><span class="built_in">sudo</span> apt purge 软件名            <span class="comment"># 连配置文件一并删除</span></span><br></pre></td></tr></table></figure>

<p>离线软件包安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -i package.deb</span><br></pre></td></tr></table></figure>

<p>离线软件包卸载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -r 软件名</span><br></pre></td></tr></table></figure>

<p>使用 Snap 安装（跨平台容器化安装方式）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snap install 软件名</span><br></pre></td></tr></table></figure>

<p>使用 Snap 卸载（跨平台容器化安装方式）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snap remove 软件名</span><br></pre></td></tr></table></figure>

<p>从源代码编译安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>主要是把命令输出的内容（之前是屏幕）输入到文件里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /etc/passwd &gt; output.txt <span class="comment">#标准正确输出重定向到output.txt（这里是覆盖原文件）</span></span><br><span class="line"><span class="built_in">ls</span> /etc/passwd &gt;&gt; output.txt <span class="comment">#标准正确输出追加重定向到output.txt(这里是追加)</span></span><br><span class="line">llll 2&gt; error.txt <span class="comment">#标准错误输出重定向到error.txt(这里是覆盖原文件)</span></span><br><span class="line">llll 2&gt;&gt; error.txt <span class="comment">#标准错误输出追加重定向到error.txt</span></span><br><span class="line">lll 2&gt; /dev/null <span class="comment">#标准错误输出重定向到黑洞</span></span><br><span class="line"><span class="built_in">ls</span> ddddd /etc/passwd &amp;&gt; /dev/null <span class="comment">#标准正确输出和标准错误输出全部重定向到黑洞。</span></span><br><span class="line"><span class="built_in">ls</span> ddddd /etc/passwd &amp;&gt;&gt; output.txt <span class="comment">#标准正确输出和标准错误输出以追加的方式全部重定向到output.txt.</span></span><br></pre></td></tr></table></figure>

<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>tree以树状形式查看指定目录内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree 目录</span><br></pre></td></tr></table></figure>

<h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>ln命令主要用于创建链接文件。</p>
<p>链接文件分为软链接和硬链接：</p>
<p>硬链接只能链接普通文件，不能链接目录。软链接不占用磁盘空间，源文件删除则链接失效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> 源文件 链接文件 <span class="comment">#硬链接</span></span><br><span class="line"><span class="built_in">ln</span> -s 源文件 链接文件 <span class="comment">#软链接</span></span><br></pre></td></tr></table></figure>

<p>如果没有-s选项代表建立一个硬链接文件，两个文件占用同一块的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s比较常用。如果软链接文件和源文件不在同一目录，源文件最好使用绝对路径，不要使用相对路径。软链接文件存储的是目标文件的路径。</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p><code>vim</code> 是一款强大的 <strong>文本编辑器</strong>，常用于 <strong>Linux &#x2F; Unix 系统编程、脚本编辑、配置文件修改等场景</strong>。它是 <code>vi</code> 的增强版本，具有更强的功能，比如语法高亮、代码折叠、多窗口、多标签支持等。</p>
<h3 id="vim的三种模式"><a href="#vim的三种模式" class="headerlink" title="vim的三种模式"></a>vim的三种模式</h3><p><strong>普通模式</strong>（Normal Mode）</p>
<p><strong>默认启动模式</strong>，你一打开 Vim 就是在这个模式。</p>
<p><strong>作用</strong>：浏览、复制、剪切、粘贴、删除、移动光标、跳转、执行命令等。</p>
<p>常用命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>h</code>&#x2F;<code>l</code></td>
<td>左&#x2F;右移动光标</td>
</tr>
<tr>
<td><code>j</code>&#x2F;<code>k</code></td>
<td>下&#x2F;上移动光标</td>
</tr>
<tr>
<td><code>[n]dd</code></td>
<td>删除当前行开始的n行（准确说是剪切）</td>
</tr>
<tr>
<td>[n]x</td>
<td>删除光标后n个字符</td>
</tr>
<tr>
<td>[n]X</td>
<td>删除光标前n个字符</td>
</tr>
<tr>
<td><code>[n]yy</code></td>
<td>复制从当前行开始的n行</td>
</tr>
<tr>
<td><code>p</code></td>
<td>粘贴</td>
</tr>
<tr>
<td><code>u</code></td>
<td>撤销前一个命令</td>
</tr>
<tr>
<td><code>Ctrl + r</code></td>
<td>还原（恢复）</td>
</tr>
<tr>
<td><code>:</code></td>
<td>进入命令模式</td>
</tr>
<tr>
<td><code>i</code>、<code>a</code></td>
<td>进入插入模式</td>
</tr>
<tr>
<td>mG&#x2F;mgg</td>
<td>到指定行，m为目标行数</td>
</tr>
<tr>
<td>&#x2F;字符串</td>
<td>从当前光标位置向下查找（n,N查找内容切换）</td>
</tr>
<tr>
<td>?字符串</td>
<td>从当前光标位置向上查找（n,N查找内容切换）</td>
</tr>
</tbody></table>
<p><strong>插入模式</strong>（Insert Mode）</p>
<p><strong>按 <code>i</code>、<code>a</code>、<code>o</code> 等从普通模式进入插入模式。</strong></p>
<p><strong>作用</strong>：输入文字、写代码、编辑内容。</p>
<p>常用进入方式：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>i</code></td>
<td>在光标前插入</td>
</tr>
<tr>
<td><code>a</code></td>
<td>在光标后插入</td>
</tr>
<tr>
<td><code>o</code></td>
<td>在当前行下方新开一行并插入</td>
</tr>
<tr>
<td><code>I</code></td>
<td>跳到行首插入</td>
</tr>
<tr>
<td><code>A</code></td>
<td>跳到行尾插入</td>
</tr>
</tbody></table>
<p><strong>退出插入模式</strong>：按 <code>Esc</code> 返回普通模式。</p>
<p><strong>命令模式</strong>（Command-Line Mode）</p>
<p><strong>按 <code>:</code> 从普通模式进入命令模式。</strong></p>
<p>用于输入各种操作命令，如保存、退出、查找、替换等。</p>
<p>常用命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>:w</code></td>
<td>保存</td>
</tr>
<tr>
<td><code>:q</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>:wq</code> 或 <code>ZZ</code></td>
<td>保存并退出</td>
</tr>
<tr>
<td><code>:q!</code></td>
<td>强制退出（不保存）</td>
</tr>
<tr>
<td><code>:x</code></td>
<td>等同于 <code>:wq</code></td>
</tr>
<tr>
<td><code>:/关键字</code></td>
<td>向下查找关键字</td>
</tr>
<tr>
<td><code>:s/旧/新/g</code></td>
<td>当前行替换所有匹配项</td>
</tr>
<tr>
<td>:1,10s&#x2F;abc&#x2F;123&#x2F;g</td>
<td>把第一行到第十行之间的abc全部替换为123</td>
</tr>
<tr>
<td><code>:%s/旧/新/g</code></td>
<td>全文替换所有匹配项</td>
</tr>
<tr>
<td>:w filename</td>
<td>保存到指定文件（绝对路径）</td>
</tr>
<tr>
<td>:sp 文件名</td>
<td>当前文件和另一个文件水平分屏</td>
</tr>
<tr>
<td>:vsp 文件名</td>
<td>当前文件和另一个文件垂直分屏</td>
</tr>
<tr>
<td>ctrl+w+w</td>
<td>在多个窗口切换光标</td>
</tr>
</tbody></table>
<h2 id="gcc编译器"><a href="#gcc编译器" class="headerlink" title="gcc编译器"></a>gcc编译器</h2><p>GCC（<strong>GNU Compiler Collection</strong>）是由 GNU 项目开发的一组编译器，最初是为了 C 语言开发的，现在支持多种编程语言</p>
<p>gcc编译器从拿到一个c源文件到生成一个可执行文件，中间一共经历了四个步骤：</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/2.png" alt="2"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line">gcc hello.o -o hello</span><br><span class="line">./hello <span class="comment">#执行</span></span><br><span class="line">gcc 源文件 -o 可执行文件 <span class="comment">#一步到位</span></span><br><span class="line">gcc hello.c -o hello</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-o</code></td>
<td>指定输出文件名</td>
</tr>
<tr>
<td><code>-Wall</code></td>
<td>打开所有警告信息</td>
</tr>
<tr>
<td><code>-g</code></td>
<td>生成调试信息，用于 GDB 调试</td>
</tr>
<tr>
<td><code>-O0/-O1/-O2/-O3</code></td>
<td>优化等级（0 表示无优化）</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>只编译不链接，生成 <code>.o</code> 目标文件</td>
</tr>
<tr>
<td><code>-I</code></td>
<td>添加头文件搜索路径</td>
</tr>
<tr>
<td><code>-L</code></td>
<td>添加库文件搜索路径</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>链接指定的库（例如 <code>-lm</code> 表示链接 <code>math</code> 库）</td>
</tr>
<tr>
<td>-v&#x2F;–version</td>
<td>查看gcc版本号</td>
</tr>
<tr>
<td>-D</td>
<td>编译时定义宏</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall test.c <span class="comment">#显示所有的警告信息</span></span><br><span class="line">gcc -Wall -Werror test.c <span class="comment">#把警告信息当作错误处理</span></span><br><span class="line">gcc tmp.c -DDEBUG <span class="comment">#可以用来区分测试版和发布版,DEBUG是定义的宏</span></span><br></pre></td></tr></table></figure>

<h2 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h2><p>静态链接：由链接器在<strong>链接</strong>时把<strong>库的内容加入到可执行程序中。</strong></p>
<p>优点：对运行环境的依赖较小，具有较好的兼容性。</p>
<p>缺点：生成的程序比较大，在装入内存消耗更多的时间。库函数有了更新，必须重新编译。</p>
<p>动态链接：链接器在<strong>链接时仅仅建立和所需库函数的链接关系，在程序运行时才将所需资源调入可执行程序</strong>。</p>
<p>优点：在需要的时候才会调入对应的资源函数。简化程序的升级，有着较小的程序体积，实现进程间的资源共享（避免重复拷贝）</p>
<p>缺点：依赖动态库，不能独立运行，动态库依赖版本问题严重。</p>
<h3 id="静态和动态编译对比"><a href="#静态和动态编译对比" class="headerlink" title="静态和动态编译对比"></a>静态和动态编译对比</h3><p>我们编写的应用程序大量用到了库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入-static参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br><span class="line">gcc -static test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>静态编译是要比动态编译程序大的多。</p>
<h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。按照习惯，一般以”.a”作为文件后缀名。静态库的命名一般分为三个部分：前缀：lib,库名称：自己定义。后缀：.a。最终静态库的名字为libxxx.a</p>
<h3 id="静态库制作："><a href="#静态库制作：" class="headerlink" title="静态库制作："></a>静态库制作：</h3><p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/3.png" alt="3"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c -o add.o <span class="comment">#-c是只编译不链接输出.o文件</span></span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line">gcc -c mul.c -o mul.o</span><br><span class="line">gcc -c div.c -o dic.o</span><br><span class="line">ar -rcs libtest.a add.o sub.o mul.o div.o#使用打包工具ar将准备好的.o文件打包为.a文件libtest.a</span><br></pre></td></tr></table></figure>

<p>在使用ar工具需要添加参数：rcs </p>
<p>r更新，c创建，s建立索引</p>
<h3 id="静态库使用："><a href="#静态库使用：" class="headerlink" title="静态库使用："></a>静态库使用：</h3><p>静态库制作完成之后，需要将.a文件和头文件一起发布给用户。假设测试文件是main.c,静态库文件为libtest.a，头文件为head.h</p>
<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L./ -I./ -ltest -o main#注意这里链接库的名字</span><br></pre></td></tr></table></figure>

<p>-L：表示要连接的库所在目录。</p>
<p>-ltest:指定链接时需要的库，去掉前缀和后缀</p>
<p>-I(这里是大写的i):表示要连接的头文件目录</p>
<h3 id="动态库制作"><a href="#动态库制作" class="headerlink" title="动态库制作"></a>动态库制作</h3><p>共享库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</p>
<p>动态库在程序运行时才被载入，也解决了静态库对程序的更新，部署和发布的再次编译的问题，用户只需要更新动态库即可，增量更新。</p>
<p>一般以”.so”作为文件后缀名。共享库的命名一般分为三个部分：前缀lib,库名称:自己定义，后缀：.so。所以最终的动态库的名字应该为：libxxx.so。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成目标文件，此时要加编译选项：-fPIC(fpic)参数-fPIC创建与地址无关的编译程序（pic,position independent code）,是为了能在多个应用程序间共享。</span></span><br><span class="line">gcc -fPIC -c add.c</span><br><span class="line">gcc -fPIC -c sub.c</span><br><span class="line">gcc -fPIC -c mul.c</span><br><span class="line">gcc -fPIC -c div.c</span><br><span class="line"><span class="comment">#生成共享库，此时要加链接器选项：-shared(指定生成动态链接库)</span></span><br><span class="line">gcc -shared add.o sub.o mul.o div.o -o libtest.so</span><br><span class="line"><span class="comment">#通过nm命令查看对应的函数</span></span><br><span class="line">nm libtest.so | grep <span class="string">&quot;add&quot;</span></span><br><span class="line"><span class="comment">#通过ldd命令查看可执行文件依赖的动态库</span></span><br><span class="line">ldd <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h3 id="动态库使用"><a href="#动态库使用" class="headerlink" title="动态库使用"></a>动态库使用</h3><p>引用动态库编译成可执行文件（和静态库一样）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L./ -I./ -ltest -o main#注意这里链接库的名字</span><br></pre></td></tr></table></figure>

<p>这一步是可以过的，但是到了，执行main时发现找不到对应文件。第一种就是把libtest.so复制到&#x2F;lib里（需要sudo,这个方法不推荐，最好不要动Linux原本文件，覆盖了就不好玩了。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -I./ -ltest -o main#注意这里链接库的名字,执行可执行文件就可以执行了，这种方法不推荐</span><br></pre></td></tr></table></figure>

<h3 id="动态库加载失败问题解决"><a href="#动态库加载失败问题解决" class="headerlink" title="动态库加载失败问题解决"></a>动态库加载失败问题解决</h3><p>当系统加载可执行代码，能够知道其所依赖的库的名字，但还需要知道其绝对路径。此时就需要系统动态载入器（dynamic linker&#x2F;loader）。对于elf格式的可执行程序，是由ld-linux.so*来完成，他先后搜索elf文件的DT_RPATH段—环境变量LD_LIBRARY_PATH—&#x2F;etc&#x2F;ld.so.cache文件列表—&#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib目录找到库文件后将其载入内存。</p>
<p>拷贝自己制作的共享库到&#x2F;lib或者&#x2F;usr&#x2F;lib(不能是&#x2F;lib64目录)</p>
<p>临时设置LD_LIBRARY_PATH(只在当前终端生效):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:库路径#在原环境变量追加新的变量，库路径为绝对路径。</span><br></pre></td></tr></table></figure>

<p>永久设置:把export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:库路径这段话，设置到~&#x2F;.bashrc </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc <span class="comment">#让配置文件生效</span></span><br></pre></td></tr></table></figure>

<p>除了以上三种还有两种将其添加到&#x2F;etc&#x2F;ld.so.conf,这里只需要添加绝对路径，然后sudo ldconfig -v使路径生效。</p>
<p>还有使用符号链接，但一定要使用绝对路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s 库文件的绝对路径 /lib/库文件</span><br></pre></td></tr></table></figure>

<h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2><p>GDB主要完成下面四个功能：</p>
<p>1.启动程序，可以按照你的自定义的要求随心所欲的运行程序。</p>
<p>2.可让被调试的程序在你指定的断点停住。</p>
<p>3.当程序被停住时，可以检查此时你的程序中所发生的事。</p>
<p>4.动态的改变你程序的执行环境。</p>
<h3 id="生成调试信息"><a href="#生成调试信息" class="headerlink" title="生成调试信息"></a>生成调试信息</h3><p>一般来说GDB主要调试的是C&#x2F;C++的程序，要调试C&#x2F;C++的程序，首先在编译时，我们必须把调试信息加到可执行文件中。使用编译器（cc&#x2F;gcc&#x2F;g++）的-g参数可以做到这一点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g hello.c -o hello</span><br><span class="line">g++ -g hello.c -o hello</span><br></pre></td></tr></table></figure>

<h3 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h3><p>启动gdb:<strong>gdb program</strong></p>
<p>program也就是你的执行文件，一般在当前目录下。</p>
<p>设置启动参数:启动后设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> args <span class="comment">#可指定运行参数</span></span><br><span class="line"><span class="built_in">set</span> args 10 20 30 40 <span class="string">&quot;hello world&quot;</span></span><br><span class="line">show args <span class="comment">#命令可以查看设置好的运行参数</span></span><br></pre></td></tr></table></figure>

<p><strong>启动程序：</strong></p>
<p>run:程序开始执行，如果有断点，停在第一个断点处。</p>
<p>start:程序向下执行一行。</p>
<p>n:执行下一步。</p>
<h3 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h3><p>用list（也可直接打l）命令来打印程序的源代码。默认打印10行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list <span class="keyword">function</span>#显示函数名为<span class="keyword">function</span>的函数的源码</span><br><span class="line"><span class="built_in">set</span> listsize count <span class="comment">#设置一次显示源码的行数默认是10行</span></span><br><span class="line">show listsize <span class="comment">#查看当前listsize的设置</span></span><br></pre></td></tr></table></figure>

<h3 id="断点操作"><a href="#断点操作" class="headerlink" title="断点操作"></a>断点操作</h3><p>简单断点:</p>
<p>break设置断点，可以简写为b</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b 10 <span class="comment">#设置断点，在源程序第十行</span></span><br><span class="line">b func <span class="comment">#设置断点，在func函数入口处</span></span><br></pre></td></tr></table></figure>

<p>多文件设置断点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> filename:linenum <span class="comment">#在源文件filename的linenum行处停住</span></span><br><span class="line"><span class="built_in">break</span> filename:<span class="keyword">function</span> <span class="comment">#在源文件filename的function函数的入口处停住</span></span><br><span class="line"><span class="built_in">break</span> class::<span class="keyword">function</span>或者<span class="keyword">function</span>(<span class="built_in">type</span>,<span class="built_in">type</span>) <span class="comment">#在类class的function函数入口处停住</span></span><br><span class="line"><span class="built_in">break</span> namespace::class::<span class="keyword">function</span> <span class="comment">#在名称空间为namespace的类class的function函数的入口处停住。</span></span><br></pre></td></tr></table></figure>

<p>查询所有断点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info b</span><br><span class="line">info <span class="built_in">break</span></span><br><span class="line">i <span class="built_in">break</span></span><br><span class="line">i b</span><br></pre></td></tr></table></figure>

<h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。</p>
<p>设置一个条件断点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b test.c:8 <span class="keyword">if</span> Value == 5 <span class="comment">#对test.c文件的当变量Value满足为5时，在test.c文件的第8行产生断点</span></span><br></pre></td></tr></table></figure>

<h3 id="维护断点"><a href="#维护断点" class="headerlink" title="维护断点"></a>维护断点</h3><p>delete 范围 删除指定的断点，其简写命令为d。如果不指定断点号，则表示删除所有的断点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d 10-12 <span class="comment">#删除编号为10-12的断点。编号可以使用i b命令查看</span></span><br></pre></td></tr></table></figure>

<p>比删除更好的一种方法时disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> 断点编号 <span class="comment">#使指定断点无效，简写命令是dis。如果什么都不指定，表示disable所有的停止点。</span></span><br><span class="line"><span class="built_in">enable</span> 断点编号 <span class="comment">#使无效断点生效，简写命令是ena。如果什么都不指定，表示enable所有的停止点</span></span><br></pre></td></tr></table></figure>

<h3 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">run <span class="comment">#运行程序，可简写为r。程序开始执行，如果有断点，停在第一个断点处。</span></span><br><span class="line">next <span class="comment">#单步跟踪，函数调用当作一条简单语句执行，可简写为n。</span></span><br><span class="line">step <span class="comment">#单步跟踪，函数调用进入被调用函数体内，可简写为s。</span></span><br><span class="line">finish <span class="comment">#退出进入的函数</span></span><br><span class="line"><span class="keyword">until</span> <span class="comment">#在一个循环体单步跟踪时，这个命令可以运行程序直到退出循环体，可简写为u。</span></span><br><span class="line"><span class="built_in">continue</span> <span class="comment">#继续运行程序，停在下一个断点的位置，可简写为c。</span></span><br><span class="line">quit <span class="comment">#退出gdb,可简写为q。</span></span><br></pre></td></tr></table></figure>

<h3 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看运行时的数据</span></span><br><span class="line"><span class="comment">#print打印变量，字符串，表达式等的值，可简写为p。</span></span><br><span class="line">p count <span class="comment">#打印count的值</span></span><br></pre></td></tr></table></figure>

<h3 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h3><p>可以设置一些自动显示的变量，当程序停住时，或在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">display 变量名 <span class="comment">#在run启动程序后，使用该命令。</span></span><br><span class="line">info display <span class="comment">#查看display设置的自动显示的信息（可以看到对应变量名的编号）</span></span><br><span class="line">undisplay num <span class="comment">#info display是显示的编号 使对应编号的自动显示功能失效。</span></span><br><span class="line">delete display dnums <span class="comment">#删除自动显示，dnums意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围的编号，可以用减号表示。</span></span><br><span class="line"><span class="built_in">disable</span> display dnums</span><br><span class="line"><span class="built_in">enable</span> display dnums</span><br><span class="line"><span class="built_in">disable</span>和<span class="built_in">enable</span>#不删除自动显示的设置，而只是让其失效和恢复。</span><br></pre></td></tr></table></figure>

<h3 id="查看修改变量的值"><a href="#查看修改变量的值" class="headerlink" title="查看修改变量的值"></a>查看修改变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptype width <span class="comment">#查看变量width的类型</span></span><br><span class="line">p width <span class="comment">#打印变量width的值 p是print命令的缩写。</span></span><br><span class="line"><span class="built_in">set</span> var width=47 <span class="comment">#将变量var值设置为47。在改变程序变量取值时，最好都使用set var格式的GDB命令。</span></span><br></pre></td></tr></table></figure>

<h2 id="自动化编译工具Makefile"><a href="#自动化编译工具Makefile" class="headerlink" title="自动化编译工具Makefile"></a>自动化编译工具Makefile</h2><p>make是个命令工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install make <span class="comment">#下载make命令</span></span><br></pre></td></tr></table></figure>

<h3 id="Makefile语法规则"><a href="#Makefile语法规则" class="headerlink" title="Makefile语法规则"></a>Makefile语法规则</h3><p>一条规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标：依赖文件列表</span><br><span class="line">&lt;Tab&gt;命令列表</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:test1 test2</span></span><br><span class="line">	echo <span class="string">&quot;hello all&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">	echo <span class="string">&quot;hello test1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">test2:</span></span><br><span class="line">	echo <span class="string">&quot;hello test2&quot;</span></span><br><span class="line"><span class="comment">#总共三条规则</span></span><br><span class="line"><span class="comment">#执行结果：make -f 1.mk</span></span><br><span class="line">echo <span class="string">&quot;hello test1&quot;</span></span><br><span class="line">hello test1</span><br><span class="line">echo <span class="string">&quot;hello test2&quot;</span></span><br><span class="line">hello test2</span><br><span class="line">echo <span class="string">&quot;hello all&quot;</span></span><br><span class="line">hello all</span><br></pre></td></tr></table></figure>

<p>Makefile基本规则三要素：</p>
<p>目标:</p>
<p>​	通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作的名称。</p>
<p>依赖文件：</p>
<p>​	用来输入从而产生目标的文件。</p>
<p>​	一个目标通常有几个依赖文件（可以没有）</p>
<p>命令：</p>
<p>​	make执行的动作，一个规则可以含几个命令（可以没有）</p>
<p>​	有多个命令，每个命令占一行。</p>
<h3 id="make命令格式"><a href="#make命令格式" class="headerlink" title="make命令格式"></a>make命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">make [-f file][options][targets]</span><br><span class="line">[-f file]:</span><br><span class="line">make默认在工作目录中寻找为GNUmakefile,makefile,Makefile的文件作为makefile输入文件。</span><br><span class="line">-f可以指定以上名字以外的文件作为makefile输入文件。</span><br><span class="line">[options]:</span><br><span class="line">-v 显示make工具的版本</span><br><span class="line">-w 在处理makefile之前和之后显示工作路径</span><br><span class="line">-C <span class="built_in">dir</span> 读取makefile之前改变工作路径至<span class="built_in">dir</span>目录</span><br><span class="line">-n 只打印要执行的命令但不执行</span><br><span class="line">-s 执行但不显示执行的命令</span><br><span class="line">[targets]:</span><br><span class="line">若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个规则</span><br><span class="line">指定了make工具要实现的目标，目标可以是一个或多个（多个目标用空格隔开）</span><br><span class="line">make test1 -f 1.mk <span class="comment">#就会执行目标为test1对应的语句。</span></span><br></pre></td></tr></table></figure>

<h3 id="Makefile示例"><a href="#Makefile示例" class="headerlink" title="Makefile示例"></a>Makefile示例</h3><p>测试程序：test.c add.c sub.c mul.c div.c add.h sub.h mul.h div.h</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#最简单的Makefile(首先vim Makefile)</span></span><br><span class="line"><span class="section">test:test.c add.c sub.c mul.c div.c</span></span><br><span class="line">	gcc test.c add.c sub.c mul.c div.c -o test</span><br></pre></td></tr></table></figure>

<p>缺点：效率低，修改一个文件，所有文件都要重新编译。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.o add.o sub.o mul.o div.o </span></span><br><span class="line">	gcc test.o add.o sub.o mul.o div.o -o test</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c add.c -o add.o</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">	gcc -c sub.c -o sub.o</span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">	gcc -c mul.c -o mul.o</span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">	gcc -c div.c -o div.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">	gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure>

<p>这样，下次编译，他只会编译你修改的文件，最后再链接，这样是比较高效的。</p>
<h3 id="Makefile中的变量"><a href="#Makefile中的变量" class="headerlink" title="Makefile中的变量"></a>Makefile中的变量</h3><p>在Makefile中使用变量有点类似c语言的宏定义，使用该变量相当于内容替换，使用变量可以使Makefile易于维护。如果.o文件很多，难道我们要一个一个打吗，这也未免太麻烦，还可能漏打。</p>
<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><p>定义变量：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名=变量值</span><br></pre></td></tr></table></figure>

<p>引用变量：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(变量名)或$&#123;变量名&#125;</span><br></pre></td></tr></table></figure>

<p>makefile的变量名：</p>
<p>makefile变量名可以以数字开头。</p>
<p>变量是大小写敏感的。</p>
<p>变量一般在makefile的头部定义</p>
<p>变量几乎可在makefile的任何地方使用</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS = test.o add.o sub.o mul.o div.o</span><br><span class="line"><span class="section">test:<span class="variable">$(OBJS)</span></span></span><br><span class="line">	gcc <span class="variable">$(OBJS)</span> -o test</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c add.c -o add.o</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">	gcc -c sub.c -o sub.o</span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">	gcc -c mul.c -o mul.o</span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">	gcc -c div.c -o div.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">	gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure>

<p>除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户使用，我们可以直接对其进行赋值。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line"><span class="section">CPPFLAGS:</span></span><br><span class="line"><span class="section">CFLAGS:</span></span><br><span class="line"><span class="section">LDFLAGS:</span></span><br></pre></td></tr></table></figure>

<h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这些变量不能单独使用 必须在命令中使用</span></span><br><span class="line"><span class="comment"># $@ 表示目标</span></span><br><span class="line"><span class="comment"># $^ 表示所有的依赖</span></span><br><span class="line"><span class="comment"># $&lt; 表示第一个依赖</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OBJS = test.o add.o sub.o mul.o div.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<h4 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#模式规则匹配示例</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line"><span class="variable">$(cc)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJS=test.o add.o sub.o mul.o div.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">	gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="comment">#模式匹配 所有的.o都依赖对应的.c</span></span><br><span class="line"><span class="comment">#将所有的.c生成对应的.o</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<h3 id="Makefile的函数"><a href="#Makefile的函数" class="headerlink" title="Makefile的函数"></a>Makefile的函数</h3><p>常用的函数</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wildcard <span class="comment">#查找指定目录下的指定类型的文件</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="comment">#找到当前目录下所有后缀为.c的文件，赋值给src</span></span><br><span class="line">patsubst <span class="comment">#匹配替换</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(src)</span>)</span> <span class="comment">#把src变量里所有后缀为.c的文件替换成.o</span></span><br></pre></td></tr></table></figure>

<p>在makefile中所有的函数都是有返回值的。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取当前目录下所有的.c文件</span></span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"><span class="comment">#将SRC中所有出现的.c的替换成.o</span></span><br><span class="line">OBJS=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SRC)</span>)</span></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">	gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="comment">#模式匹配 所有的.o都依赖对应的.c</span></span><br><span class="line"><span class="comment">#将所有的.c生成对应的.o</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#clean目标清除编译生成的中间文件</span></span><br><span class="line"><span class="comment">#执行命令 make clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<h3 id="Makefile中的伪目标"><a href="#Makefile中的伪目标" class="headerlink" title="Makefile中的伪目标"></a>Makefile中的伪目标</h3><p>clean用途：清除编译生成的中间.o文件和最终目标文件</p>
<p>make clean 如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：</p>
<p>伪目标声明：.PHONY:clean 声明目标为伪目标之后，makefile将不会判断目标是否存在或者该目标是否需要更新。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取当前目录下所有的.c文件</span></span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"><span class="comment">#将SRC中所有出现的.c的替换成.o</span></span><br><span class="line">OBJS=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SRC)</span>)</span></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">	gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="comment">#模式匹配 所有的.o都依赖对应的.c</span></span><br><span class="line"><span class="comment">#将所有的.c生成对应的.o</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#clean目标清除编译生成的中间文件</span></span><br><span class="line"><span class="comment">#执行命令 make clean</span></span><br><span class="line"><span class="comment">#声明clean为伪目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>上面这个版本就是最终版。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="comment">#在命令前加上@符号，表示不显示命令本身（默认显示），只显示结果</span></span><br><span class="line">-gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="comment">#加上-符号，此条命令出错，make也会继续执行后续的命令。</span></span><br></pre></td></tr></table></figure>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用说的是操作系统提供给用户程序调用的一组”特殊”接口</p>
<h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h3><p>Linux下对文件操作有两种方式：系统调用和库函数调用</p>
<p>库函数调用有两类函数组成：</p>
<p>不需要系统调用：不需要切换到内核空间即可完成函数全部功能，并且结果反馈给应用程序，如strcpy,bzero等字符串操作函数。</p>
<p>需要调用系统调用：需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如printf,fread等。</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/4.png" alt="4"></p>
<h3 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h3><p>errno是记录系统的最后一次错误代码，代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。</p>
<p>当Linux C api函数出现异常时，一般会将errno全局变量赋一个整数值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//fopen</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> <span class="comment">//errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">//strerror(errno)</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *fp=fopen(<span class="string">&quot;xxxx&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,errno);<span class="comment">//打印错误码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,strerror(errno));<span class="comment">//把errno的数字转换为相应的文字</span></span><br><span class="line">        perror(<span class="string">&quot;fopen err&quot;</span>); <span class="comment">//打印错误原因的字符串</span></span><br><span class="line">        <span class="comment">//perror和printf(&quot;%d\n&quot;,strerror(errno));实现效果相同。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>每个进程都会分配虚拟地址空间，在32位机器上，该地址空间为4G。Linux每个运行的程序（进程），操作系统就会为其分配一个0<del>4G的地址空间（虚拟地址空间）。0</del>3G是用户区，3G~4G是内核区。在进程里平时所说的指针变量，保存的就是虚拟地址，当应用程序使用虚拟地址访问内存时，处理器会将其转换为物理地址（MMU）MMU将虚拟地址转换为物理地址。这样做的好处在于：进程隔离，更好的保护系统安全运行，屏蔽物理差异带来的麻烦，方便操作系统和编译器安排进程地址。</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>打开现存文件或新建文件时，系统内核会返回一个文件描述符，文件描述符用来指定已打开的的文件。这个文件描述符相当于已打开文件的标号，文件描述符是非负整数，是文件的标识，操作这个文件描述符相当于操作这个描述符所指定的文件。</p>
<p>程序运行起来后（每个进程）都有一张文件描述符的表，标准输入，标准输出，标准错误输出设备文件被打开，对应的文件描述符0，1，2记录在表中。程序运行起来后这三个文件描述符是默认打开的。</p>
<p>在程序运行起来后，打开其他文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中。</p>
<h4 id="最大打开的文件个数："><a href="#最大打开的文件个数：" class="headerlink" title="最大打开的文件个数："></a>最大打开的文件个数：</h4><p>​	Linux中一个进程最多只能打开NR_OPEN_DEFAULT(即1024)个文件（当然这个数量的设定是可以修改的），故当文件不再使用时应该及时调用close()函数关闭文件。</p>
<h3 id="常用文件IO函数"><a href="#常用文件IO函数" class="headerlink" title="常用文件IO函数"></a>常用文件IO函数</h3><h4 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">int</span> flags,<span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<p>​	打开文件，如果文件不存在则可以选择创建。</p>
<h4 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span></span><br></pre></td></tr></table></figure>

<p>功能：</p>
<p>​	关闭已打开的文件。</p>
<p>需要说明的是，当一个进程终止时，内核对该进程所有未关闭的文件描述符调用close关闭，所以即使用户程序不调用close,在终止时内核也会自动关闭它打开的文件。</p>
<p>但是对于一个常年累月的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量的文件描述符和系统资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/type.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//打开和关闭文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//以只读的方式打开一个文件，如果文件不存在就报错。</span></span><br><span class="line">    <span class="comment">//fd=open(&quot;txt&quot;,O_RDONLY);</span></span><br><span class="line">    <span class="comment">//以只写的方式打开一个文件 如果文件存在就直接打开 如果文件不存在就新建一个文件。</span></span><br><span class="line">    <span class="comment">//fd=open(&quot;txt&quot;,O_WRONLY|O_CREAT,644);</span></span><br><span class="line">    <span class="comment">//以只写的方式打开一个文件，如果文件存在就报错，如果文件不存在就新建一个。</span></span><br><span class="line">    <span class="comment">//fd=open(&quot;txt&quot;,O_WRONLY|O_CREAT|O_EXCL,644);</span></span><br><span class="line">    <span class="comment">//以读写方式打开一个文件，如果文件存在就打开，如果文件不存在就新建一个文件。</span></span><br><span class="line">    <span class="comment">//fd=open(&quot;txt&quot;,O_RDWR|O_CREAT,644);</span></span><br><span class="line">    <span class="comment">//O_TRUNC 清空文件内容,如果文件存在，打开并清空，不存在就新建一个文件。</span></span><br><span class="line">    <span class="comment">//fd=open(&quot;txt&quot;,O_WRONLY|O_TRUNC|O_CREAT,644);</span></span><br><span class="line">    <span class="comment">//O_APPEND 追加的方式</span></span><br><span class="line">    <span class="comment">//以只写的方式和追加的方式打开一个文件 如果文件不存在会报错。</span></span><br><span class="line">    fd=open(<span class="string">&quot;txt&quot;</span>,O_WRONLY|O_APPEND)</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">void</span>* buf,<span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据写到文件（fd）</span><br><span class="line">参数：</span><br><span class="line">    fd: 文件描述符</span><br><span class="line">    buf:数据首地址</span><br><span class="line">    count:写入数据的长度（字节）</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际写入数据的字节个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span> *buf,<span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据读到内存（缓冲区）</span><br><span class="line">参数：</span><br><span class="line">    fd:文件描述符</span><br><span class="line">    buf:内存首地址</span><br><span class="line">    count:读取的字节个数</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际读取的字节个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="阻塞和非阻塞的概念"><a href="#阻塞和非阻塞的概念" class="headerlink" title="阻塞和非阻塞的概念"></a>阻塞和非阻塞的概念</h4><p>读常规文件是不会阻塞，不管读多少字节，read一定会在有限的时间内返回。</p>
<p>从终端设备或网络则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会堵塞，如果网络上没有接受到数据包，调用read从网络读就会，至于会阻塞多久也是不确定的，如果没有一直收到数据到达就一直阻塞在那里。</p>
<p>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</p>
<p>阻塞和非阻塞是对于文件而言，而不是指read,write等的属性。</p>
<h4 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd,<span class="type">off_t</span> offset,<span class="type">int</span> whence)</span>;</span><br><span class="line">功能：</span><br><span class="line">    改变文件的偏移量</span><br><span class="line">参数：</span><br><span class="line">    fd:文件描述符</span><br><span class="line">    offset:根据whence来移动的位移数（偏移量），可以是正数，也可以是负数，如果正数，则相对于whence往右移动，如果是负数则相对于whence向左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</span><br><span class="line">    whence:其取值如下：</span><br><span class="line">        SEEK_SET:从文件开头移动offset个字节</span><br><span class="line">        SEEK_CUR:从当前位置移动offset个字节</span><br><span class="line">        SEEK_END:从文件末尾移动offset个字节</span><br><span class="line">返回值：</span><br><span class="line">   	若lseek成功执行，则返回新的偏移量</span><br><span class="line">    如果失败，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>所有打开的文件都有一个当前文件偏移量（current file offset）以下简称为cfo。cfo通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。</p>
<p>读写操作通常开始cfo,并且使cfo变大，增量为读写的字节数。文件被打开时，cfo会被初始化为0，除非使用了O_APPEND。</p>
<p>如果把文件偏移量移到最后，使用read函数，将不会读出数据。要将文件描述符提前移到开头或者其他可以读到的位置。所以要注意文件描述符的位置。</p>
<h3 id="文件操作相关函数"><a href="#文件操作相关函数" class="headerlink" title="文件操作相关函数"></a>文件操作相关函数</h3><h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path,<span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line">功能：</span><br><span class="line">	获取文件状态信息</span><br><span class="line">    stat和lstat的区别：</span><br><span class="line">    	当文件是一个符号链接时,lstat返回的是该符号链接本身的信息；</span><br><span class="line">    	而stat返回的是该链接指向的文件的信息。</span><br><span class="line">参数：</span><br><span class="line">    path:文件名</span><br><span class="line">    buf:保存文件信息的结构体</span><br><span class="line">返回值:</span><br><span class="line">	成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span> 文件不存在</span><br></pre></td></tr></table></figure>

<p>stat函数和命令stat 文件名的功能类似。</p>
<p>struct stat *buf结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">           <span class="type">dev_t</span>      st_dev;      <span class="comment">/* ID of device containing file */</span></span><br><span class="line">           <span class="type">ino_t</span>      st_ino;      <span class="comment">/* Inode number */</span></span><br><span class="line">           <span class="type">mode_t</span>     st_mode;     <span class="comment">/* File type and mode */</span></span><br><span class="line">           <span class="type">nlink_t</span>    st_nlink;    <span class="comment">/* Number of hard links */</span></span><br><span class="line">           <span class="type">uid_t</span>      st_uid;      <span class="comment">/* User ID of owner */</span></span><br><span class="line">           <span class="type">gid_t</span>      st_gid;      <span class="comment">/* Group ID of owner */</span></span><br><span class="line">           <span class="type">dev_t</span>      st_rdev;     <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">           <span class="type">off_t</span>      st_size;     <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">           <span class="type">blksize_t</span>  st_blksize;  <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">           <span class="type">blkcnt_t</span>   st_blocks;   <span class="comment">/* Number of 512 B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Since POSIX.1-2008, this structure supports nanosecond</span></span><br><span class="line"><span class="comment">              precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">              For the details before POSIX.1-2008, see VERSIONS. */</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>  <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>  <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>  <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">       <span class="meta">#<span class="keyword">define</span> st_atime  st_atim.tv_sec  <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">define</span> st_mtime  st_mtim.tv_sec</span></span><br><span class="line">       <span class="meta">#<span class="keyword">define</span> st_ctime  st_ctim.tv_sec</span></span><br><span class="line">       &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line">        <span class="comment">//获取指定文件信息</span></span><br><span class="line">        ret=stat(<span class="string">&quot;txt&quot;</span>,&amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文件属性信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st_dev:%lu\n&quot;</span>,s.st_dev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st_ino:%ld\n&quot;</span>,s.st_ino);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> st_mode;可以获取文件类型和文件三种用户的权限。</p>
<h4 id="access函数"><a href="#access函数" class="headerlink" title="access函数"></a>access函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">int</span> mode)</span>;</span><br><span class="line">功能：测试指定文件是否具有某种属性</span><br><span class="line">参数：</span><br><span class="line">    pathname:文件名</span><br><span class="line">    mode:文件权限，<span class="number">4</span>种权限（判断文件所属者）</span><br><span class="line">        R_OK:是否有读权限</span><br><span class="line">        W_OK:是否有写权限</span><br><span class="line">        X_OK:是否有执行权限</span><br><span class="line">        F_OK:测试文件是否存在</span><br><span class="line">返回值：</span><br><span class="line">     <span class="number">0</span>：有某种权限，或者文件存在</span><br><span class="line">     <span class="number">-1</span>：没有，或者文件不存在</span><br></pre></td></tr></table></figure>

<h4 id="chmod函数"><a href="#chmod函数" class="headerlink" title="chmod函数"></a>chmod函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*pathname,<span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：修改文件权限</span><br><span class="line">参数：</span><br><span class="line">    pathname:文件名</span><br><span class="line">    mode:权限（<span class="number">8</span>进制数）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="chown函数"><a href="#chown函数" class="headerlink" title="chown函数"></a>chown函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">uid_t</span> owner,<span class="type">gid_t</span> group)</span>;</span><br><span class="line">功能：修改文件所有者和所属组</span><br><span class="line">参数：</span><br><span class="line">    pathname:文件或目录名</span><br><span class="line">    owner:文件所有者id，通过查看/etc/passwd得到所有者id</span><br><span class="line">    group；文件所属组id,通过查看/etc/group得到用户组id</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="truncate函数"><a href="#truncate函数" class="headerlink" title="truncate函数"></a>truncate函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">off_t</span> length)</span>;</span><br><span class="line">功能：修改文件大小</span><br><span class="line">参数：</span><br><span class="line">    path:文件名字</span><br><span class="line">    length:指定的文件大小</span><br><span class="line">        比原来小，删掉后边的部分</span><br><span class="line">        比原来大，向后拓展</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="link函数"><a href="#link函数" class="headerlink" title="link函数"></a>link函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldpath,<span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br><span class="line">功能：创建一个硬链接</span><br><span class="line">参数：</span><br><span class="line">    oldpath:源文件名字</span><br><span class="line">    newpath:硬链接名字</span><br><span class="line">返回值：</span><br><span class="line">   	成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="symlink函数"><a href="#symlink函数" class="headerlink" title="symlink函数"></a>symlink函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* target,<span class="type">const</span> <span class="type">char</span>* linkpath)</span>;</span><br><span class="line">功能：创建一个软链接</span><br><span class="line">参数：</span><br><span class="line">    target：源文件名字</span><br><span class="line">    linKpath:软链接名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>剩下的还有<strong>readlink函数</strong>，<strong>unlink函数</strong>，<strong>rename函数</strong></p>
<h3 id="文件描述符复制"><a href="#文件描述符复制" class="headerlink" title="文件描述符复制"></a>文件描述符复制</h3><p>dup()和dup2()是两个非常有用的系统调用，都是用来复制一个文件的描述符，使新的文件描述符也标识旧的文件描述符所标识的文件</p>
<p>对比于dup(),dup2()也一样，通过原来的文件描述符复制出一个新的文件描述符，这样的话，原来的文件描述符和新的文件描述符都指向同一个文件，我们操作这两个文件描述符的任何一个，都能操作它所对应的文件。</p>
<h4 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    通过oldfd复制出一个新的文件描述符，新的文件描述符使调用进程文件描述符表中最小可用的文件描述符，最终oldfd和新的文件描述符都指向同一个文件。</span><br><span class="line">参数：</span><br><span class="line">    oldfd:需要复制的文件描述符oldfd</span><br><span class="line">返回值：</span><br><span class="line">    成功：新文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>函数示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//dup dup2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> newfd=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//1.打开文件</span></span><br><span class="line">        fd=open(<span class="string">&quot;txt&quot;</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		newfd=dup(fd);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span>==newfd)&#123;</span><br><span class="line">             perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newfd=%d\n&quot;</span>,newfd);</span><br><span class="line">        <span class="comment">//2.操作</span></span><br><span class="line">        write(fd,<span class="string">&quot;ABCDEFG&quot;</span>,<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//因为这两个文件描述符共享一张文件表，所以当前文件的偏移量是共享的，所以下次不会覆盖而是追加</span></span><br><span class="line">        <span class="comment">//使用另外一个文件描述符</span></span><br><span class="line">        write(newfd,<span class="string">&quot;1234567&quot;</span>,<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//3.关闭文件描述符</span></span><br><span class="line">        close(fd);</span><br><span class="line">        close(newfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dup2函数"><a href="#dup2函数" class="headerlink" title="dup2函数"></a>dup2函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd,<span class="type">int</span> newfd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    通过oldfd复制出一个新的文件描述符newfd,如果成功，newfd和函数返回值是同一个返回值，最终oldfd和新的文件描述符newfd都指向同一个文件。</span><br><span class="line">参数：</span><br><span class="line">    oldfd:需要复制的文件描述符</span><br><span class="line">    newfd:新的文件描述符，这个描述符可以人为指定一个合法数字（<span class="number">0</span><span class="number">-1023</span>），如果指定的数字已经被占用，此函数会自动关闭close()断开这个数字和某个文件的关联，再来使用这个合法数字。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回newfd</span><br><span class="line">    失败；返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<p>注意：这里有个场景，我有两个程序都是要打开同一个文件并且向里面写东西，当然这就有两个open函数，那我先后打开该文件，前者写的会被后者写的覆盖掉吗，这是会的。因为每次open函数都会把文件偏移量的位置放回0。但是dup函数和dup2函数不会，因为复制的文件描述符共享一个文件描述符表项的。</p>
<h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> cmd,...<span class="comment">/*arg */</span>)</span>;</span><br><span class="line">功能：改变已打开的文件性质，fcntl针对描述符提供控制。</span><br><span class="line">参数：</span><br><span class="line">    fd:操作的文件描述符</span><br><span class="line">    cmd:操作方式</span><br><span class="line">    arg:针对cmd的值，fcntl能够接受第三个参数<span class="type">int</span> arg。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回某个其他值</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//fcntl复制文件描述符功能</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> newfd=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.打开文件</span></span><br><span class="line">    fd=open(<span class="string">&quot;txt&quot;</span>,O_WRONLY|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd=%d\n&quot;</span>,fd);</span><br><span class="line">    <span class="comment">//2.文件描述符复制</span></span><br><span class="line">    <span class="comment">//功能等价于dup函数</span></span><br><span class="line">    <span class="comment">//第三个参数0 表示返回一个最小的可用的文件描述符，并且大于或者等于0</span></span><br><span class="line">    newfd=fcntl(fd,F_DUPFD,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==newfd)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;newfd=%d\n&quot;</span>,newfd);</span><br><span class="line">    <span class="comment">//3.写操作</span></span><br><span class="line">    write(fd,<span class="string">&quot;123456789&quot;</span>,<span class="number">9</span>);</span><br><span class="line">    write(newfd,<span class="string">&quot;ABCDEFGH&quot;</span>,<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//4.关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    close(newfd)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fcntl函数还可以改变文件状态标记。</p>
<h3 id="目录相关操作"><a href="#目录相关操作" class="headerlink" title="目录相关操作"></a>目录相关操作</h3><h4 id="getcwd函数"><a href="#getcwd函数" class="headerlink" title="getcwd函数"></a>getcwd函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf,<span class="type">size_t</span> size)</span>;</span><br><span class="line">功能：获取当前进程的工作目录</span><br><span class="line">参数：</span><br><span class="line">    buf:缓冲区，存储当前的工作目录</span><br><span class="line">    size:缓冲区大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：buf中保存当前进程工作目录位置</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="chdir函数"><a href="#chdir函数" class="headerlink" title="chdir函数"></a>chdir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line">功能：修改当前进程（应用程序）的路径</span><br><span class="line">参数：</span><br><span class="line">    path:切换的路径</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="opendir函数"><a href="#opendir函数" class="headerlink" title="opendir函数"></a>opendir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*name)</span>;</span><br><span class="line">功能：打开一个目录</span><br><span class="line">参数：</span><br><span class="line">    name:目录名</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回指向该目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="closedir函数"><a href="#closedir函数" class="headerlink" title="closedir函数"></a>closedir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">功能：关闭目录</span><br><span class="line">参数：</span><br><span class="line">    dirp:opendir返回指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent* <span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">功能：读取目录</span><br><span class="line">参数：</span><br><span class="line">    dirp:opendir的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p><strong>readdir函数要读取目录所有内容是要循环读取。</strong> </p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h3><p>我们平时写的C语言代码，通过编译器编译，最终它会成为一个可执行程序，当这个可执行程序运行起来后（没有结束前），他就成为了一个进程。程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建，调度和消亡。程序是静态的，进程是动态的。</p>
<p>在Linux系统中，操作系统是通过进程去完成一个一个的任务，<strong>进程是管理事务的基本单元</strong>。</p>
<p>进程拥有自己独立的处理环境（当前需要用到那些环境变量，程序运行的目录在哪里，当前是哪个用户在运行此程序）和系统资源（处理器cpu占用率，存储器，I&#x2F;O设备，数据，程序）。</p>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并行：指在同一时刻，有多条指令在多个处理器上同时执行。</p>
<p>并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<h3 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h3><p>MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器，物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。</p>
<h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><p>进程运行时，内核为进程每个进程分配一个PCB(进程控制块)，维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>这个结构体的内部成员有很多，我们要知道的：</p>
<ol>
<li>进程id。系统中每个进程有唯一的id,在C语言中用pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态，有就绪，运行，挂起，停止等状态。</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器。</li>
<li>描述虚拟地址空间的信息。</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录。</li>
<li>umask掩码</li>
<li>文件描述符表，包含很多指向file结构体的指针。</li>
<li>和信号相关的信息。</li>
<li>用户id和组id</li>
<li>会话（Session）和进程组。</li>
<li>进程可以使用的资源上限（Resource Limit）。</li>
</ol>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。</p>
<p>在三态模型中，进程状态分为三个基本状态，即运行态，就绪态，阻塞态。</p>
<p>在五态模型中，进程分为新建态，终止态，运行态，就绪态，阻塞态。</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/5.png" alt="5"></p>
<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。</p>
<p>ps命令可以查看进程的详细情况，常用选项（选项可以不加”-“）。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-a</code></td>
<td>显示终端上的所有进程，包括其他用户的进程</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>显示进程的详细状态&#96;</td>
</tr>
<tr>
<td><code>-x</code></td>
<td>显示无控制终端的进程</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>只显示正在运行的进程</td>
</tr>
</tbody></table>
<p>ps aux</p>
<p>ps ef和aux等价</p>
<p>ps -a</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>用来动态显示运行中的进程。</p>
<h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>kill命令指定进程号的进程，需要配合ps使用。</p>
<p>使用格式：</p>
<p>kill [-signal] pid</p>
<p>信号值从0-15，其中9为绝对终止，可以处理一般信号无法终止的进程。</p>
<p>有些进程不能直接杀死，这时候我们需要加一个参数”-9”,”-9”代表强制结束。</p>
<h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><p>通过进程名字杀死进程,进程名字是可以重复的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -9 <span class="built_in">sleep</span></span><br></pre></td></tr></table></figure>

<h3 id="进程号和相关函数"><a href="#进程号和相关函数" class="headerlink" title="进程号和相关函数"></a>进程号和相关函数</h3><p>每个进程都由一个进程号来标识，其类型为pid_t（整型），进程号的范围：0~32767（2的15次方-1）。进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用。</p>
<h4 id="三个不同的进程号"><a href="#三个不同的进程号" class="headerlink" title="三个不同的进程号"></a>三个不同的进程号</h4><p><strong>进程号（PID）</strong>:</p>
<p>标识进程的一个非负整型数。</p>
<p><strong>父进程号（PPID）</strong>:<br>任何进程（除init进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号成为父进程号（PPID）。如A进程创建了B进程，A的进程号就是B进程的父进程号。</p>
<p><strong>进程组号（PGID）</strong>:</p>
<p>进程组是一个或多个进程的集合，他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当作当前的进程组号。</p>
<h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a>getpid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">()</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取本进程号（PID）</span><br><span class="line">参数：无</span><br><span class="line">返回值：本进程号</span><br></pre></td></tr></table></figure>

<h4 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a>getppid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">()</span>;</span><br><span class="line">功能：获取调用此函数的进程的父进程号</span><br><span class="line">参数：无</span><br><span class="line">返回值：调用此函数的进程的父进程号（PPID）</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="getpgid函数"><a href="#getpgid函数" class="headerlink" title="getpgid函数"></a>getpgid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能：获取进程组号（PGID）</span><br><span class="line">参数：</span><br><span class="line">    pid:进程号</span><br><span class="line">返回值：</span><br><span class="line">    参数为<span class="number">0</span>时返回当前进程组号，否则返回参数指定的进程的进程组号。</span><br></pre></td></tr></table></figure>

<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">()</span>;</span><br><span class="line">功能：</span><br><span class="line">    用于从一个已存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。</span><br><span class="line">参数：无</span><br><span class="line">返回值：</span><br><span class="line">    成功：子进程返回<span class="number">0</span>，父进程中返回子进程ID，<span class="type">pid_t</span>为整型。</span><br><span class="line">    失败：返回<span class="number">-1</span>。</span><br><span class="line">    失败的两个主要原因:</span><br><span class="line">		<span class="number">1.</span>当前的进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN。</span><br><span class="line">        <span class="number">2.</span>系统内存不足，这时errno的值被设置为ENOMEM。</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个子进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    fork();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里的结果会输出两次hello world。这是为什么呢？</strong></p>
<p><strong>首先，fork函数创建子进程，子进程会将父进程的代码复制下来来执行了，当然这就有人说了，那么子进程执行fork函数，那就不是一直创建子进程了吗。这里涉及到了一个问题。当父进程调用fork函数，父进程会有一个pc指针指向fork函数调用后的代码，当然，子进程也把这个pc指针的值也继承了下来，所以子进程也是一样执行。</strong></p>
<h3 id="父子进程关系"><a href="#父子进程关系" class="headerlink" title="父子进程关系"></a>父子进程关系</h3><p>使用fork函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的的静态描述），进程堆栈，打开的文件描述符，信号控制设定，进程优先级，进程组号等。</p>
<p>子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用fork()函数的代价是很大的。</p>
<p>简单来说，一个进程调用fork函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值和原来的进程的值不同。相当于克隆了一个自己。</p>
<p><strong>实际上，Linux的fork函数使用是通过写时拷贝（copy-on-write）实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</strong></p>
<p><strong>fork之后父子进程共享文件，fork产生的子进程和父进程相同的文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</strong></p>
<h3 id="区分父子进程"><a href="#区分父子进程" class="headerlink" title="区分父子进程"></a>区分父子进程</h3><p>fork()函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是0，而父进程的返回值则是新子进程的进程ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//区分父子进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建一个子进程</span></span><br><span class="line">    <span class="comment">//fork函数在在子进程中返回0 在父进程中返回子进程的pid</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello pid:%d ppid:%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">       	<span class="comment">//这里pid返回的就是新子进程的进程id</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world pid:%d cpid:%d\n&quot;</span>,getpid(),pid);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="父子进程堆空间"><a href="#父子进程堆空间" class="headerlink" title="父子进程堆空间"></a>父子进程堆空间</h3><p>当在创建子进程前在堆声明时，一定要对该指针指向区域释放两次。不然会出现内存泄露。</p>
<h3 id="如何检测内存是否泄露"><a href="#如何检测内存是否泄露" class="headerlink" title="如何检测内存是否泄露"></a>如何检测内存是否泄露</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc zfork.c</span><br><span class="line">valgrind ./a.out</span><br></pre></td></tr></table></figure>

<h3 id="GDB调试多进程"><a href="#GDB调试多进程" class="headerlink" title="GDB调试多进程"></a>GDB调试多进程</h3><p>使用GDB调试的时候，GDB只能跟踪一个进程。可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者跟踪子进程。默认跟踪父进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-mode child <span class="comment">#设置gdb在fork之后跟踪子进程</span></span><br><span class="line"><span class="built_in">set</span> follow-fork-mode parent <span class="comment">#设置跟踪父进程（默认）</span></span><br><span class="line"><span class="comment">#注意，一定要在fork函数调用之前设置才有效。</span></span><br></pre></td></tr></table></figure>

<h3 id="进程退出函数"><a href="#进程退出函数" class="headerlink" title="进程退出函数"></a>进程退出函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line">功能：</span><br><span class="line">    结束调用此函数的进程</span><br><span class="line">参数：</span><br><span class="line">    status:返回给父进程的参数（低<span class="number">8</span>位有效），至于这个参数是多少根据需要来填写。</span><br><span class="line">返回值：</span><br><span class="line">    无</span><br></pre></td></tr></table></figure>

<p>exit()和_exit()函数功能和用法是一样的，无非是包含的头文件不一样，还有的区别就是：exit()属于标准库函数，_exit()属于系统调用函数。</p>
<p>_exit()函数不会关闭文件描述符和I刷新I&#x2F;O缓冲区。exit()函数会做这些。</p>
<h3 id="等待子进程退出函数"><a href="#等待子进程退出函数" class="headerlink" title="等待子进程退出函数"></a>等待子进程退出函数</h3><p>在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号，退出状态，运行时间）。</p>
<p>父进程可以调用wait或waitpid得到他的退出状态同时彻底清除掉这个进程。</p>
<p>wait()和waitpid函数的功能一样，区别在于wait()函数会堵塞，waitpid()可以设置不堵塞，waitpid()还可以指定等待那个子进程结束。</p>
<p>一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    status:进程退出时的状态信息。</span><br><span class="line">返回值：</span><br><span class="line">    成功：已经结束子进程的进程号</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>调用wait函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒（相当于继续往下执行）。</p>
<p>若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。</p>
<p><strong>所以wait函数的主要功能为回收已经结束子进程的资源。如果参数status的值不是NULL,wait函数就会把子进程退出时的状态取出并且存入其中，这是一个整数值（int）,指出了子进程是正常退出还是被非正常结束的。这个退出信息在一个int中包含了多个字段，直接使用这个值是没有意义的，我们需要宏定义取出其中的每个字段。</strong></p>
<p>使用对应的宏函数如WIFEXITED(status)为非0表明进程正常结束。WEXITSTATUS(status)若WIFEXITED(status)值为真，获取进程退出状态（exit的参数）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属于正常退出</span></span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程退出状态码：%d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">    <span class="comment">//在bash输入kill 子进程号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程被信号%d杀死了\n&quot;</span>,WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</span><br><span class="line">    <span class="comment">//向指定进程发送暂停信号</span></span><br><span class="line">    <span class="comment">//kill -19 子进程号</span></span><br><span class="line">    <span class="comment">//唤醒指定暂停的进程</span></span><br><span class="line">    <span class="comment">//kill -18 子进程号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程被信号%d暂停\n&quot;</span>,WSTOPSIG(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *status,<span class="type">int</span> options)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    pid:参数pid的值有以下几种类型：</span><br><span class="line">        pid&gt;<span class="number">0</span> 等待进程ID等于pid的子进程。</span><br><span class="line">        pid=<span class="number">0</span> 等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会等待他。</span><br><span class="line">        pid=<span class="number">-1</span> 等待任一子进程，此时waitpid和wait作用一样。</span><br><span class="line">        pid&lt;<span class="number">-1</span> 等待指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。</span><br><span class="line">    status:进程退出时的状态信息。和wait()用法一样。</span><br><span class="line">    options:options提供了一些额外的选项来控制waitpid().</span><br><span class="line">        <span class="number">0</span>:同wait(),阻塞父进程，等待子进程退出。</span><br><span class="line">        WNOHANG:没有任何已经结束的子进程，则立即返回</span><br><span class="line">        WUNTRACED:如果子进程暂停了则此函数马上返回，并且不予理会子进程的结束状态。</span><br><span class="line">返回值：</span><br><span class="line">     当正常返回时，返回收集到的已经回收子进程的进程号</span><br><span class="line">     如果设置了选项WNOHANG,而调用中waitpid()发现没有已经退出的子进程可等待，则返回<span class="number">0</span>;</span><br><span class="line">	 如果调用中出错，则返回<span class="number">-1</span>，这是errno会被设置成相应的值以指示错误所在。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于wait()</span></span><br><span class="line">waitpid(<span class="number">-1</span>,&amp;status,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//第三个参数表示不阻塞</span></span><br><span class="line">waitpid(<span class="number">-1</span>,&amp;status,WNOHANG)</span><br></pre></td></tr></table></figure>

<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p><strong>父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程。</strong></p>
<p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init,而init进程会循环wait()它的已经退出的子进程。所以init进程会处理孤儿进程的善后工作。</p>
<p><strong>孤儿进程并没有什么危害。</strong></p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p><strong>进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程。</strong>这样就导致了一个问题，如果进程不调用wait()或者waitpid（）的话，那么保留的那段信息就不会释放，其进程号就会一直被占用。如果产生大量的僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<h3 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h3><p>在Windows平台下，我们可以通过双击运行可执行程序，让这个可执行程序成为一个进程；而在Linux平台，我们可以通过.&#x2F;运行，让一个可执行程序成为一个进程。</p>
<p>但是，如果我们本来就运行着一个程序，我们如何在这个进程内部启动一个外部程序，由内核将这个外部程序读入内存，使其执行起来成为一个进程呢，我们通过exec函数族实现。</p>
<p>exec函数族是一组函数，在Linux并不存在exec函数。这组函数一共有6个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/*(char *) NULL*/</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file,<span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/*(char *) NULL*/</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/*,(char *) NULL,char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file,<span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file,<span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<p>其中只有execve()是真正意义的系统调用，其他都是在此基础上经过包装的库函数。</p>
<p><strong>exec函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容。</strong></p>
<p><strong>进程在调用一种exec函数时，该进程完全由新程序替换，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后进程ID(当然还有父进程号，进程组号，当前工作目录)并未改变。exec只是用另一个新程序替换了当前进程的正文，数据，堆和栈段（进程替换）。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello \n&quot;</span>);</span><br><span class="line">    <span class="comment">//arg0 arg1 arg2 ... argn</span></span><br><span class="line">    <span class="comment">//arg0一般是可执行文件名 argn必须是NULL</span></span><br><span class="line">    <span class="comment">//execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;-l&quot;,&quot;/home&quot;,NULL);</span></span><br><span class="line">    <span class="comment">//第一个参数是可执行文件的绝对路径或者相对路径</span></span><br><span class="line">    <span class="comment">//第二个参数一般是可执行文件的名字</span></span><br><span class="line">    <span class="comment">//中间的参数就是可执行文件的参数</span></span><br><span class="line">    <span class="comment">//最后一个参数是NULL</span></span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/home&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[]=&#123;<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/home&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *envp[]=&#123;<span class="string">&quot;ADDR=BEIJING&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="comment">//第一个参数是可执行文件</span></span><br><span class="line">    <span class="comment">//第二个参数是指针数组 最后一定以NULL结束</span></span><br><span class="line">    <span class="comment">//execvp(&quot;ls&quot;,argv);</span></span><br><span class="line">    <span class="comment">//第一个参数是可执行文件</span></span><br><span class="line">    <span class="comment">//第二个参数是指针数组 最后一定以NULL结束</span></span><br><span class="line">    <span class="comment">//execv(&quot;/bin/ls&quot;,argv);</span></span><br><span class="line">    <span class="comment">//最后一个参数是环境变量指针数组</span></span><br><span class="line">    <span class="comment">//execle(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,&quot;/home&quot;,NULL,envp);</span></span><br><span class="line">    <span class="comment">//第一个参数是可执行文件</span></span><br><span class="line">    <span class="comment">//第二个参数是参数列表 指针数组</span></span><br><span class="line">    <span class="comment">//第三个参数是环境变量列表 指针数组</span></span><br><span class="line">    execvpe(<span class="string">&quot;ls&quot;</span>,argv,envp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
<p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信。（IPC）</p>
<p><strong>进程间通信的目的：</strong></p>
<p><strong>数据传输：一个进程需要将它的数据发送给另一个进程。</strong></p>
<p><strong>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</strong></p>
<p><strong>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</strong></p>
<p><strong>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</strong></p>
<p><strong>Linux操作系统支持的主要进程间通信的通信机制：</strong></p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/6.png" alt="6"></p>
<h3 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h3><p>管道也叫无名管道，它是UNIX系统IPC(进程间通信)的最古老方式，所有的UNIX系统都支持这种通信机制。</p>
<p>管道有如下特点：</p>
<ol>
<li>半双工，数据在同一时刻只能在一个方向上流动。</li>
<li>数据只能从管道的一端写入，从另一端读出。</li>
<li>写入管道中的数据遵循先入先出的规则。</li>
<li>管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息。</li>
<li>管道不是普通文件，不属于某个文件系统，其只存在于<strong>内存</strong>中。</li>
<li>管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。</li>
<li><strong>从管道读数据是一次性操作</strong>，数据一旦被读走，他就从管道中被抛弃，释放空间以便写更多的数据。</li>
<li>管道没有名字，<strong>只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</strong></li>
</ol>
<p>管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/7.png" alt="7"></p>
<h4 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line">功能：创建无名管道</span><br><span class="line">参数：</span><br><span class="line">    pipefd:为<span class="type">int</span>型数组的首地址，其存放了管道的文件描述符pipefd[<span class="number">0</span>],pipefd[<span class="number">1</span>]。</span><br><span class="line">    当一个管道建立时，他会创建两个文件描述符fd[<span class="number">0</span>]和fd[<span class="number">1</span>]。其中fd[<span class="number">0</span>]固定用于读管道，而fd[<span class="number">1</span>]固定用于写管道。一般文件I/O的函数都可以用来操作管道（lseek()除外）。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//用于创建无名管道</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建一个无名管道</span></span><br><span class="line">    ret=pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fd[0]用于读 fd[1]用于写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd[0]:%d fd[1]:%d\n&quot;</span>,fd[<span class="number">0</span>],fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="父子进程通过无名管道通信"><a href="#父子进程通过无名管道通信" class="headerlink" title="父子进程通过无名管道通信"></a>父子进程通过无名管道通信</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 64</span></span><br><span class="line"><span class="comment">//父子进程使用无名管道进行通信</span></span><br><span class="line"><span class="comment">//父进程写管道 子进程读管道</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buffer[SIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//1.创建无名管道</span></span><br><span class="line">    ret=pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建子进程</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程 读管道</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">        <span class="comment">//关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">        ret=read(fd[<span class="number">0</span>],buf,SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process buf :%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="comment">//关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="comment">//父进程 写管道</span></span><br><span class="line">    <span class="comment">//关闭读端</span></span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    ret=write(fd[<span class="number">1</span>],<span class="string">&quot;ABCDE&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent process write: len:%d\n&quot;</span>,ret);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭写端</span></span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="管道读写特点"><a href="#管道读写特点" class="headerlink" title="管道读写特点"></a>管道读写特点</h4><p>四种情况：</p>
<p>​	第一种：</p>
<p>​			如果写端没有关闭，管道中没有数据，这个时候读管道进程去读管道会阻塞。</p>
<p>​			如果写端没有关闭，管道中有数据，这个时候读管道进程会将数据读出，下一次读没数据就会阻塞。</p>
<p>​	第二种：</p>
<p>​			管道所有的写端关闭，读进程去读管道的内容，读取全部内容，最后返回0。</p>
<p>​	第三种：</p>
<p>​			所有读端没有关闭，如果管道被写满了，写管道进程写管道会被阻塞。</p>
<p>​	第四种：</p>
<p>​			所有的读端被关闭，写管道进程写管道会收到一个信号，然后退出。</p>
<h4 id="设置为非阻塞的方法"><a href="#设置为非阻塞的方法" class="headerlink" title="设置为非阻塞的方法"></a>设置为非阻塞的方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取原来的flags</span></span><br><span class="line"><span class="type">int</span> flags=fcntl(fd[<span class="number">0</span>],F_GETFL);</span><br><span class="line"><span class="comment">//设置新的flags</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(fd[<span class="number">0</span>],F_SETFL,flags);</span><br></pre></td></tr></table></figure>

<p>如果写端没有关闭，读端设置为非阻塞，如果没有数据，直接返回-1。</p>
<h4 id="查看管道缓冲区的大小"><a href="#查看管道缓冲区的大小" class="headerlink" title="查看管道缓冲区的大小"></a>查看管道缓冲区的大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a#可以查看管道大小（大小为4k）</span><br></pre></td></tr></table></figure>

<p>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> name)</span>;</span><br><span class="line">功能：该函数可以通过name参数查看不同的属性值</span><br><span class="line">参数：</span><br><span class="line">    fd:文件描述符</span><br><span class="line">    name:</span><br><span class="line">		_PC_PIPE_BUF，查看管道缓冲区大小</span><br><span class="line">        _PC_NAME_MAX,文件名字字节数的上限</span><br><span class="line">返回值：</span><br><span class="line">    成功：根据name返回的值的意义也不同。</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h3><p>管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这一缺点，提出了命名管道（FIFO）,也叫有名管道，FIFO文件。</p>
<p>命名管道不同于无名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径马，就能够彼此通过FIFO互相通信，因此，通过FIFO不相关的进程也能交换数据。</p>
<ol>
<li>命名管道和无名管道有一些特点是相同的，不一样的地方在于：</li>
<li>FIFO在文件系统中作为一个特殊的文件而存在，但FIFO的内容却放在内存中。</li>
<li>当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。</li>
<li>FIFO有名字，不相关的进程可以通过打开命名管道进行通信。</li>
</ol>
<h4 id="通过命令创建有名管道"><a href="#通过命令创建有名管道" class="headerlink" title="通过命令创建有名管道"></a>通过命令创建有名管道</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> fifo <span class="comment">#创建有名管道 fifo是管道的名字</span></span><br></pre></td></tr></table></figure>

<h4 id="通过函数创建有名管道"><a href="#通过函数创建有名管道" class="headerlink" title="通过函数创建有名管道"></a>通过函数创建有名管道</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：</span><br><span class="line">    命名管道的创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname:普通的路径名，也就是创建后FIFO的名字。</span><br><span class="line">    mode:文件的权限，与打开普通文件的open()函数中的mode参数相同。（<span class="number">0644</span>）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span> 状态码</span><br><span class="line">    失败：如果文件已经存在，则会出错且返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过mkfifo函数创建一个管道文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建一个有名管道 管道的名字fifo</span></span><br><span class="line">    ret=mkfifo(<span class="string">&quot;fifo&quot;</span>,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建一个有名管道ok\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有名管道读写操作"><a href="#有名管道读写操作" class="headerlink" title="有名管道读写操作"></a>有名管道读写操作</h4><p>一旦使用mkfifo创建了FIFO,就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close，read,write,unlink等。</p>
<p>FIFO严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对他们的写则把数据添加到末尾。他们不支持诸如lseek()等文件定位操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程1，写操作</span></span><br><span class="line"><span class="type">int</span> fd=open(<span class="string">&quot;my_fifo&quot;</span>,O_WRONLY);</span><br><span class="line"><span class="type">char</span> send[<span class="number">100</span>]=<span class="string">&quot;hello Mike&quot;</span>;</span><br><span class="line">write(fd,send,<span class="built_in">strlen</span>(send));</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程2，读操作</span></span><br><span class="line"><span class="type">int</span> fd=open(<span class="string">&quot;my_fifo&quot;</span>,O_RDONLY);<span class="comment">//等着只写</span></span><br><span class="line"><span class="type">char</span> recv[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//读数据，命名管道没数据时会阻塞，有数据时就取出来</span></span><br><span class="line">read(fd,recv,<span class="keyword">sizeof</span>(revc));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read from my_fifo buf=[%s]\n&quot;</span>,recv);</span><br></pre></td></tr></table></figure>

<p>一个为只读而打开一个管道的进程会阻塞直到另外一个进程为只写打开该管道。</p>
<p>一个为只写而打开一个管道的进程会阻塞直到另外一个进程为只读打开该管道。</p>
<p>读管道：</p>
<p>​	管道中有数据，read返回实际读到的字节数。</p>
<p>​	管道无数据：</p>
<p>​		管道写端被全部关闭，read返回0（相当于读文件末尾）。</p>
<p>​		写端没有完全被关闭，read阻塞等待。</p>
<p>写管道：</p>
<p>​	管道读端全部被关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程终止）；</p>
<p>​	管道读端没有全部关闭：</p>
<p>​		管道已满，write阻塞。</p>
<p>​		管道未满，write将数据写入，并返回实际写入的字节数。</p>
<h3 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a>共享存储映射</h3><p>存储映射I&#x2F;O使一个磁盘文件与存储空间中的一个缓冲区相映射。</p>
<p>于是当从缓冲区中取数据，就相当于读文件中的相应字节。将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I&#x2F;O操作。</p>
<p>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式，因为进程可以直接读内存，而不需要任何数据的拷贝。</p>
<h4 id="存储映射函数"><a href="#存储映射函数" class="headerlink" title="存储映射函数"></a>存储映射函数</h4><h5 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    一个文件或者其他对象映射进内存</span><br><span class="line">参数：</span><br><span class="line">    addr:指定映射的起始地址，通常设为<span class="literal">NULL</span>,由系统指定</span><br><span class="line">    length:映射到内存的文件长度</span><br><span class="line">    prot:映射区的保护方式，最常用的：</span><br><span class="line">        读：PROT_READ</span><br><span class="line">        写：PROT_WRITE</span><br><span class="line">        读写：PROT_READ|PROT_WRITE</span><br><span class="line">    flags:映射区的特性，可以是</span><br><span class="line">        MAP_SHARED:写入映射区的数据会复制回文件，且允许其他映射该文件的进程共享。</span><br><span class="line">        MAP_PRIVATE:对映射区的写入操作会产生一个映射区的复制（copy-on-write）,对此区域所作的修改不会写回原文件。</span><br><span class="line">    fd:由open返回的文件描述符，代表要映射的文件。</span><br><span class="line">    offset:以文件开始处的偏移量，必须是<span class="number">4</span>k的整数倍（<span class="number">4</span>k为页的大小），通常为<span class="number">0</span>,表示从文件头开始映射</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回创建的映射区首地址</span><br><span class="line">    失败：MAP_FAILED宏</span><br></pre></td></tr></table></figure>

<h5 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a>munmap函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length)</span>;</span><br><span class="line">功能：</span><br><span class="line">    释放内存映射区</span><br><span class="line">参数：</span><br><span class="line">    addr:使用mmap函数创建的映射区的首地址</span><br><span class="line">    length:映射区的大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储映射</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> *addr=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1.以读写形式打开一个文件。</span></span><br><span class="line">    fd=open(<span class="string">&quot;txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==fd)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.将文件映射到内存</span></span><br><span class="line">    addr=mmap(<span class="literal">NULL</span>,<span class="number">1024</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(addr==MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">//4.写文件</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr,<span class="string">&quot;1234567890&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//5.断开存储映射</span></span><br><span class="line">    munmap(addr,<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名映射实现父子进程通信"><a href="#匿名映射实现父子进程通信" class="headerlink" title="匿名映射实现父子进程通信"></a>匿名映射实现父子进程通信</h3><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。</p>
<p>通常为了建立映射区要open一个temp文件，创建好了再unlink,close掉，比较麻烦。同样需要借助标志位flags来指定。使用MAP_ANONYMOUS（或者MAP_ANON）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//父子进程使用匿名映射进行进程间通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> *addr=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1.创建匿名映射</span></span><br><span class="line">    addr=mmap(<span class="literal">NULL</span>,<span class="number">4096</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(MAP_FAILED==addr)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建子进程</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        munmap(addr,<span class="number">4096</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.父子进程通信</span></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程写</span></span><br><span class="line">        <span class="built_in">memcpy</span>(addr,<span class="string">&quot;123456789&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程读</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process %s\n&quot;</span>,(<span class="type">char</span> *)addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.断开映射</span></span><br><span class="line">    munmap(addr,<span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是Linux进程间通信的最古老的方式。<strong>信号是软件中断</strong>，它是在<strong>软件层次上对中断机制的一次模拟，是一种异步通信的方式</strong>。信号可以导致一个正在运行的进程被另一个进程正在运行的异步进程中断，转而处理某一个突发事件。</p>
<p>信号的特点：简单，不能携带大量信息，满足某个特设条件才发送。</p>
<p>信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了那些系统事件。</p>
<p>一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数。</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/8.png" alt="8"></p>
<p>这里信号的产生，注册，注销是信号的内部机制，而不是信号的函数实现。</p>
<h3 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a>信号的编号</h3><p>Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley和AT&amp;T都对信号做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p>
<p>Linux可使用命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -l(字母l)#查看相应的信号。</span><br></pre></td></tr></table></figure>

<p>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。</p>
<p> <strong>Linux 常用信号（signals）一览表</strong></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>信号名</th>
<th>默认行为</th>
<th>说明（用途）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>终止进程</td>
<td>终端挂起或控制进程终止（如终端关闭）</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止进程</td>
<td>键盘中断（Ctrl+C）</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>创建核心转储</td>
<td>键盘退出（Ctrl+\），带 core dump</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>创建核心转储</td>
<td>非法指令</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>创建核心转储</td>
<td>调用 <code>abort()</code> 函数终止程序</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>创建核心转储</td>
<td>浮点异常（如除以0）</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>强制终止</td>
<td>无法被捕获或忽略，立即终止</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>创建核心转储</td>
<td>无效内存引用（段错误）</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>终止进程</td>
<td>管道破裂（写到没有读者的管道）</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>终止进程</td>
<td>计时器超时（<code>alarm()</code>）</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止进程</td>
<td>终止信号（kill 默认发送）</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>忽略&#x2F;捕获</td>
<td>子进程结束时通知父进程</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>继续执行</td>
<td>继续一个停止的进程</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止进程</td>
<td>无法被捕获或忽略，强制停止</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止进程</td>
<td>用户请求停止（Ctrl+Z）</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>停止进程</td>
<td>后台进程读终端输入</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>停止进程</td>
<td>后台进程写终端输出</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>忽略&#x2F;捕获</td>
<td>套接字有紧急数据</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>创建核心转储</td>
<td>超出 CPU 时间限制</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>创建核心转储</td>
<td>超出文件大小限制</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTALRM</td>
<td>终止进程</td>
<td>虚拟定时器到期</td>
</tr>
<tr>
<td>27</td>
<td>SIGPROF</td>
<td>终止进程</td>
<td>分析定时器到期</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>忽略&#x2F;捕获</td>
<td>终端窗口大小发生变化</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>忽略&#x2F;捕获</td>
<td>I&#x2F;O 事件通知</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>忽略&#x2F;终止</td>
<td>电源故障</td>
</tr>
<tr>
<td>31</td>
<td>SIGSYS</td>
<td>创建核心转储</td>
<td>非法的系统调用</td>
</tr>
</tbody></table>
<h3 id="信号四要素"><a href="#信号四要素" class="headerlink" title="信号四要素"></a>信号四要素</h3><p>每个信号必备四要素，分别是：</p>
<p>编号，名称，事件，默认处理动作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 7 signal#查看帮助文档获取信号的信息</span><br></pre></td></tr></table></figure>

<p>默认动作：</p>
<p>​	Term:终止进程</p>
<p>​	Ign:忽略信号（默认即时对该种信号忽略操作）</p>
<p>​	Core:终止进程，生成Core文件。（查验死亡原因，用于gdb调试）</p>
<p>​	Stop:停止（暂停）进程</p>
<p>​	Cont:继续运行进程</p>
<p>SIGKILL(9)和SIGSTOP(19)，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</p>
<p>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不应乱发信号。</p>
<h3 id="阻塞信号集和未决信号集"><a href="#阻塞信号集和未决信号集" class="headerlink" title="阻塞信号集和未决信号集"></a>阻塞信号集和未决信号集</h3><p>信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。</p>
<p>Linux内核的进程控制块PCB是一个结构体，task_struct,除了包含进程id，状态，工作目录，用户id,组id,文件描述符表，还包含了信号相关信息，主要指阻塞信号集和未决信号集。</p>
<p><strong>阻塞信号集</strong>：</p>
<p>将某些信号加入集合，对他们设置屏蔽，当屏蔽X信号后，再收到该信号，该信号的处理将推后（处理发生在解除屏蔽后）。</p>
<p><strong>未决信号集</strong>：</p>
<p>信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回0。这一时刻往往非常短暂。</p>
<p>信号产生后由于某些原因（主要是阻塞）不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</p>
<h3 id="信号产生函数"><a href="#信号产生函数" class="headerlink" title="信号产生函数"></a>信号产生函数</h3><h4 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给指定进程发送指定信号（不一定杀死）</span><br><span class="line">参数：</span><br><span class="line">    pid:取值有<span class="number">4</span>种情况：</span><br><span class="line">        pid&gt;<span class="number">0</span>:将信号传送给进程ID为pid的进程。</span><br><span class="line">        pid=<span class="number">0</span>：将信号传送给当前进程所在进程组中的所有进程。</span><br><span class="line">        pid=<span class="number">-1</span>:将信号传送给系统内所有的进程</span><br><span class="line">        pid&lt;<span class="number">-1</span>:将信号传送给指定进程组的所有进程。这个进程组号等于pid的绝对值。</span><br><span class="line">    sig:信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令kill -l进行查看，不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>超级用户（root）可以发送信号给任意用户，普通用户是不能向系统用户发送信号。也不能向其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//父进程杀死子进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建一个子进程</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;child process do work....\n&quot;</span>);</span><br><span class="line">           sleep(<span class="number">1</span>);</span><br><span class="line">       &#125; </span><br><span class="line">        <span class="comment">//进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程退出\n&quot;</span>);</span><br><span class="line">        kill(pid,SIGTERM);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程该结束了，已经完成了他的使命\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="raise函数"><a href="#raise函数" class="headerlink" title="raise函数"></a>raise函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给当前进程发送指定信号（自己给自己发），等价于kill(getpid(),sig);</span><br><span class="line">参数：</span><br><span class="line">    sig:信号编号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>值</span><br></pre></td></tr></table></figure>

<h4 id="abort函数"><a href="#abort函数" class="headerlink" title="abort函数"></a>abort函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：给自己发送异常终止信号编号为<span class="number">6</span> SIGABRT,并产生core文件，等价于kill(getpid(),SIGABRT);</span><br><span class="line">参数：无</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<h4 id="alarm函数（闹钟）"><a href="#alarm函数（闹钟）" class="headerlink" title="alarm函数（闹钟）"></a>alarm函数（闹钟）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line">功能：</span><br><span class="line">    设置定时器（闹钟）。在指定seconds后，内核会给当前进程发送编号<span class="number">14</span> SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有一个唯一的定时器。</span><br><span class="line">    取消定时器alarm(<span class="number">0</span>),返回旧闹钟余下秒数。</span><br><span class="line">参数：</span><br><span class="line">    seconds:指定的时间，以秒为单位</span><br><span class="line">返回值：</span><br><span class="line">    返回<span class="number">0</span>或剩余的秒数</span><br></pre></td></tr></table></figure>

<p>定时，与进程状态无关（自然定时法）。就绪，运行，挂起（阻塞。暂停），终止，僵尸。。。。无论进程处于何种状态，alarm都计时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试alarm函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一次设置闹钟 5秒钟之后就超时 发送对应的信号</span></span><br><span class="line">    ret=alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;上一次闹钟剩下的时间是%u\n&quot;</span>,ret);<span class="comment">//这时ret为0</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//之前没有超时的闹钟被新的设置给覆盖</span></span><br><span class="line">    ret=alarm(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;上一次闹钟剩下的时间是%u\n&quot;</span>,ret);<span class="comment">//这时ret为3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键继续。。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="setitimer函数（定时器）"><a href="#setitimer函数（定时器）" class="headerlink" title="setitimer函数（定时器）"></a>setitimer函数（定时器）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which,<span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value,<span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    设置定时器（闹钟）。可替代alarm函数。精度微妙us,可以实现周期定时。</span><br><span class="line">参数：</span><br><span class="line">    which:指定定时方式</span><br><span class="line">        自然定时:ITIMER_REAL 编号<span class="number">14</span>的信号SIGALRM计算自然时间</span><br><span class="line">        虚拟空间计时（用户空间）:ITIMER_VIRTUAL 编号<span class="number">26</span>的信号SIGVTALRM 只计算进程占用cpu的时间</span><br><span class="line">        运行时计时（用户+内核）:ITIMER_PROF 编号<span class="number">27</span>的信号SIGPROF计算占用cpu及执行系统调用的时间</span><br><span class="line">    new_value:<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>,负责设定<span class="title">timeout</span>时间</span></span><br><span class="line"><span class="class">        <span class="keyword">struct</span> <span class="title">itimerval</span>&#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_interval</span>;</span><span class="comment">//闹钟触发周期</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_value</span>;</span><span class="comment">//闹钟触发时间</span></span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timerval</span>&#123;</span></span><br><span class="line">            <span class="type">long</span> tv_sec;<span class="comment">//秒</span></span><br><span class="line">            <span class="type">long</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">        &#125;</span><br><span class="line">		itimerval.it_value:设定第一次执行function所延迟的秒数</span><br><span class="line">        itimerval.it_interval:设定以后每几秒执行function</span><br><span class="line">    old_value:存放旧的timeout值，一般指定为<span class="literal">NULL</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tmo</span>;</span></span><br><span class="line">    <span class="comment">//第一次触发时间</span></span><br><span class="line">    tmo.it_value.tv_sec=<span class="number">3</span>;</span><br><span class="line">    tmo.it_value.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//触发周期</span></span><br><span class="line">    tmo.it_interval.tv_sec=<span class="number">2</span>;</span><br><span class="line">    tmo.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置定时器</span></span><br><span class="line">    ret=setitimer(ITIMER_REAL,&amp;tmo,<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进程收到闹钟超时信号之后就会终止该进程，要想周期起来，要把信号捕捉</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键继续。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>在PCB中有两个非常重要的信号集。一个称之为”阻塞信号集”，另一个称之为”未决信号集”。</p>
<p>这两个信号集都是内核使用位图机制来实现的。但是操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。阻塞信号集可以读写，未决信号集不可以写，只可以读。</p>
<h4 id="自定义信号集函数"><a href="#自定义信号集函数" class="headerlink" title="自定义信号集函数"></a>自定义信号集函数</h4><p>信号集是一个能表示多个信号的数据类型，sigset_t set,set即一个数据集。既然是一个集合，就需要对集合进行添加&#x2F;删除等操作。</p>
<p>相关函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;<span class="comment">//将set集合置空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;<span class="comment">//将所有的信号加入set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>,<span class="type">int</span> signo)</span>;<span class="comment">//将signo信号加入到set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>,<span class="type">int</span> signo)</span>;<span class="comment">//将set集合中移除signo信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>,<span class="type">int</span> signo)</span>;<span class="comment">//判断信号是否存在</span></span><br></pre></td></tr></table></figure>

<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//显示信号集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_set</span><span class="params">(<span class="type">sigset_t</span> *s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//判断指定的信号是否在集合中</span></span><br><span class="line">        <span class="keyword">if</span>(sigismember(s,i))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号集处理函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//信号集集合</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">//清空集合</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    show_set(&amp;<span class="built_in">set</span>)</span><br><span class="line">    <span class="comment">//将所有的信号加入到set集合中</span></span><br><span class="line">    sigfillset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    show_set(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">//将信号2和信号3从信号集中移除</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>,SIGQUIT);</span><br><span class="line">    show_set(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">//将信号2添加到集合中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    show_set(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h4><p>信号阻塞集也称信号屏蔽集。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述那些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。</p>
<p>所谓阻塞并不是禁止传送信号，而是暂缓信号的传送。若将被阻塞的信号从信号阻塞中删除，且对应的信号在被阻塞时发生了，进程会收到相应的信号。</p>
<p>我们可以通过sigprocmask()修改当前的信号掩码来改变信号的阻塞情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how,<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>,<span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改信号阻塞集，根据how指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由<span class="built_in">set</span>指定，而原先的信号阻塞集合由oldset保存。</span><br><span class="line">参数：</span><br><span class="line">    how:信号阻塞集合的修改方法，有三种情况：</span><br><span class="line">		SIG_BLOCK:向信号阻塞集合中添加<span class="built_in">set</span>信号集，新的信号掩码是<span class="built_in">set</span>和旧信号掩码的并集。相当于mask=mask|<span class="built_in">set</span>.</span><br><span class="line">        SIG_UNBLOCK:从信号阻塞集合中删除<span class="built_in">set</span>信号集，从当前信号掩码中去除<span class="built_in">set</span>中的信号，相当于mask=mask&amp;~<span class="built_in">set</span>.</span><br><span class="line">        SIG_SETMASK:将信号阻塞集合设为<span class="built_in">set</span>信号集，相当于原来信号阻塞集内容清空，然后按照<span class="built_in">set</span>中的信号重新设置信号阻塞集。相当于mask=<span class="built_in">set</span>.</span><br><span class="line">    <span class="built_in">set</span>:要操作的信号集地址。</span><br><span class="line">    	若<span class="built_in">set</span>为<span class="literal">NULL</span>，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到oldset中。</span><br><span class="line">    oldset:保存原先信号阻塞集地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span>，失败时错误代码只可能是EINVAL,表示参数how不合法</span><br></pre></td></tr></table></figure>

<p>代码示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,signum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号处理函数2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,signum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号注册函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="type">sigset_t</span> oldset;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    <span class="comment">//Ctrl+C</span></span><br><span class="line">    signal(SIGINT,func1);</span><br><span class="line">    <span class="comment">//Ctrl+\</span></span><br><span class="line"><span class="comment">    signal(SIGQUIT,func2);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键 阻塞信号2\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigemptyset(&amp;oldset);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    <span class="comment">//设置屏蔽编号为2的信号</span></span><br><span class="line">    ret=sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;设置屏蔽编号为2的信号成功了。。。。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键 解除阻塞信号2\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">//将信号屏蔽集设置为原来的集合,解除屏蔽后，不管之前发了多少次相同的信号，最后只会捕捉一次</span></span><br><span class="line">    ret=sigprocmask(SIG_SETMASK,&amp;oldset,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键退出。。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">功能：读取当前进程的未决信号集</span><br><span class="line">参数：</span><br><span class="line">    <span class="built_in">set</span>：未决信号集</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><h4 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h4><p>一个进程收到一个信号的时候，可以用如下方法进行处理：</p>
<ol>
<li><p>执行系统默认动作</p>
<p>对大多数信号来说，系统默认动作是用来终止该进程。</p>
</li>
<li><p>忽略此信号（丢弃）</p>
<p>接受到此信号后没有任何动作。</p>
</li>
<li><p>执行自定义信号处理函数（捕获）</p>
<p>用用户自定义的信号处理函数处理该信号。</p>
</li>
</ol>
<p>SIGKILL和SIGSTOP不能更改信号的处理方式，因为他们向用户提供了一种使进程终止的可靠方法。</p>
<h4 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum,<span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">功能：</span><br><span class="line">    注册信号处理函数（不可用于SIGKILL,SIGSTOP信号），即可确定收到信号后处理函数的入口地址。此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    signum:信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令kill -l进行相应查看。</span><br><span class="line">    handler:取值有三种情况</span><br><span class="line">        SIG_IGN:忽略该信号。</span><br><span class="line">        SIG_DFL:执行系统默认动作</span><br><span class="line">        信号处理函数名：自定义信号处理函数。如：func</span><br><span class="line">        回调函数的定义如下：</span><br><span class="line">            <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">            <span class="comment">//signo 为触发的信号，为signal()第一个参数</span></span><br><span class="line">        &#125;</span><br><span class="line">返回值：</span><br><span class="line">    成功：第一次返回<span class="literal">NULL</span>,下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面声明此函数指针的类型。</span><br><span class="line">    失败：返回SIG_ERR</span><br></pre></td></tr></table></figure>

<p>该函数有ANSI定义，由于历史原因在不同版本的UNIX和不同版本的LINUX中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,signum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号处理函数2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,signum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号注册函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    <span class="comment">//Ctrl+C</span></span><br><span class="line">    signal(SIGINT,func1);</span><br><span class="line">    <span class="comment">//Ctrl+\</span></span><br><span class="line"><span class="comment">    signal(SIGQUIT,func2);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在学会捕捉后，对之前的setitimer函数实现的例子更新一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tmo</span>;</span></span><br><span class="line">    <span class="comment">//第一次触发时间</span></span><br><span class="line">    tmo.it_value.tv_sec=<span class="number">3</span>;</span><br><span class="line">    tmo.it_value.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//触发周期</span></span><br><span class="line">    tmo.it_interval.tv_sec=<span class="number">2</span>;</span><br><span class="line">    tmo.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//捕捉信号 SIGALRM</span></span><br><span class="line">    signal(SIGALRM,func);</span><br><span class="line">    <span class="comment">//设置定时器</span></span><br><span class="line">    ret=setitimer(ITIMER_REAL,&amp;tmo,<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进程收到闹钟超时信号之后就会终止该进程，要想周期起来，要把信号捕捉</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键继续。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum,<span class="type">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改指定信号的设置（或同时执行这两种操作）。</span><br><span class="line">操作：</span><br><span class="line">    signum:要操作的信号。</span><br><span class="line">    act: 要设置的对信号的新处理方式（传入参数）。</span><br><span class="line">    oldact:原来对信号的处理方式（传出参数）。</span><br><span class="line">    如果act指针非空，则要改变指定信号的处理方式（设置）,如果oldact指针非空，则系统将此前指定信号的处理方式存入oldact</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>struct sigaction 结构体</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">  <span class="type">void</span>(*sa_handler)(<span class="type">int</span>);<span class="comment">//旧的信号处理函数指针</span></span><br><span class="line">  <span class="type">void</span>(*sa_sigaction)(<span class="type">int</span>,<span class="type">siginfo_t</span>*,<span class="type">void</span> *);<span class="comment">//新的信号处理函数指针</span></span><br><span class="line">  <span class="type">sigset_t</span> sa_mask; <span class="comment">//信号阻塞集 在信号处理函数执行过程中，临时屏蔽指定的信号</span></span><br><span class="line">  <span class="type">int</span> sa_flags; <span class="comment">//信号处理方式</span></span><br><span class="line">  <span class="type">void</span>(*sa_restorer)(<span class="type">void</span>); <span class="comment">//已弃用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号 %d\n&quot;</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//演示sigaction函数使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用旧的信号处理函数指针</span></span><br><span class="line">    act.sa_handler=fun;</span><br><span class="line">    <span class="comment">//标志为默认 默认使用旧的信号处理函数指针</span></span><br><span class="line">    act.sa_flags=<span class="number">0</span>;</span><br><span class="line">    ret=sigaction(SIGINT,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键退出。。。。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//新的信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signo,<span class="type">siginfo_t</span> *info,<span class="type">void</span> *context)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号 %d\n&quot;</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//演示sigaction函数使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用新的信号处理函数指针</span></span><br><span class="line">  	act.sa_sigaction=fun1;</span><br><span class="line">    <span class="comment">//标志指定使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_flags=SA_SIGINFO;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键退出。。。。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sigqueue函数（一般不用，用kill函数）"><a href="#sigqueue函数（一般不用，用kill函数）" class="headerlink" title="sigqueue函数（一般不用，用kill函数）"></a>sigqueue函数（一般不用，用kill函数）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> sig,<span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    给指定进程发送信号</span><br><span class="line">参数：</span><br><span class="line">    pid:进程号</span><br><span class="line">    sig：信号的编号</span><br><span class="line">    value:通过信号传递的参数。</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">sigval</span>类型如下：</span></span><br><span class="line"><span class="class">        	<span class="title">union</span> <span class="title">sigval</span>&#123;</span></span><br><span class="line">        		<span class="type">int</span> sival_int;</span><br><span class="line">        		<span class="type">void</span> *sival_ptr;</span><br><span class="line">    		&#125;</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="不可重入，可重入函数"><a href="#不可重入，可重入函数" class="headerlink" title="不可重入，可重入函数"></a>不可重入，可重入函数</h3><p>如果有一个函数不幸被设计成为这样：那么不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。</p>
<p>满足下列条件的函数多数是不可重入（不安全）的：</p>
<ol>
<li><strong>函数体内使用了静态的数据结构；</strong></li>
<li><strong>函数体内调用了malloc()或者free()函数（谨慎使用堆）；</strong></li>
<li><strong>函数体内调用了标准I&#x2F;O函数（包含缓冲区）。</strong></li>
</ol>
<p>相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。</p>
<p>保证函数的可重入性的方法：</p>
<ol>
<li><strong>在写函数时候尽量使用局部变量（例如寄存器，栈中变量）；</strong></li>
<li><strong>对于要使用的全局变量要加以保护（如采取中断，信号量等互斥方法），这样构成的函数就一定是一个可重入的函数。</strong></li>
</ol>
<p>信号处理函数应为可重入函数。</p>
<h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h3><h4 id="SIGCHLD信号产生的条件"><a href="#SIGCHLD信号产生的条件" class="headerlink" title="SIGCHLD信号产生的条件"></a>SIGCHLD信号产生的条件</h4><ol>
<li>子进程终止时</li>
<li>子进程接收到SIGSTOP信号停止时</li>
<li>子进程处在停止态，接受到SIGCONT后唤醒时</li>
</ol>
<h3 id="如何避免僵尸进程"><a href="#如何避免僵尸进程" class="headerlink" title="如何避免僵尸进程"></a>如何避免僵尸进程</h3><ol>
<li>最简单的方法，父进程通过wait()和waitpid()等函数等待子进程结束，但是，这会导致父进程挂起。</li>
<li>如果父进程要处理的事情很多，不能够挂起，通过signal()函数人为处理信号SIGCHLD，只要有子进程退出自动调用指定好的回调函数，因为子进程结束后，父进程会收到该信号SIGCHLD（17号）,可以在其回调函数里调用wait()或waitpid()回收。</li>
</ol>
<p>示例程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号 %d\n&quot;</span>,signo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有子进程退出。。。。\n&quot;</span>);</span><br><span class="line">    <span class="comment">//以非阻塞方式</span></span><br><span class="line">    <span class="keyword">while</span>((waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//演示sigaction函数使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用旧的信号处理函数指针</span></span><br><span class="line">    act.sa_handler=fun;</span><br><span class="line">    <span class="comment">//标志为默认 默认使用旧的信号处理函数指针</span></span><br><span class="line">    act.sa_flags=<span class="number">0</span>;</span><br><span class="line">    sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程累&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程退出&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       		<span class="built_in">printf</span>(<span class="string">&quot;父进程do working&quot;</span>);</span><br><span class="line">           	sleep(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="守护进程和线程"><a href="#守护进程和线程" class="headerlink" title="守护进程和线程"></a>守护进程和线程</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>进程组，也称之为作业。代表一个或多个进程的集合。</p>
<p>每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用过。操作系统设计的进程组的概念，是为了简化堆多个进程的管理。</p>
<p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID为第一个进程ID（组长进程）。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话是一个或多个进程组的集合。</p>
<ol>
<li>一个会话可以有一个控制终端。这通常是终端设备或伪终端设备；</li>
<li>建立与控制终端连接的会话首进程被称为控制进程；</li>
<li>一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组；</li>
<li>如果一个会话有一个控制终端，则他有一个前台进程组，其他进程组为后台进程组。</li>
<li>如果终端接口检测到断开连接，则将挂断信号发送至控制进程（会话首进程）。</li>
</ol>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程也就是通常说的Daemon进程（精灵进程），是Linux的后台服务进程。它是一个生存期较长的进程，<strong>通常独立于控制终端并且周期性执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</strong></p>
<p>守护进程是一个<strong>特殊的孤儿进程</strong>，这种进程脱离终端，为了避免进程被任何终端产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在Linux中，每个系统与用户进行交流的界面叫做终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程会自动关闭。</p>
<h4 id="守护进程模型"><a href="#守护进程模型" class="headerlink" title="守护进程模型"></a>守护进程模型</h4><ol>
<li><p>创建子进程，父进程退出（必须）</p>
<p>所有工作在子进程中进行形式上脱离了控制终端</p>
</li>
<li><p>在子进程中创建新会话（必须）</p>
<p>setsid()函数</p>
<p>使子进程完全独立出来，脱离控制</p>
</li>
<li><p>改变当前目录为根目录（不是必须）</p>
<p>chdir()函数</p>
<p>防止占用可卸载的文件系统</p>
<p>也可以换成其他路径</p>
</li>
<li><p>重设文件权限掩码（不是必须）</p>
<p>umask()函数(可以对文件权限进行修改，如果umask为0000,那创建普通文件文件权限为0666，目录文件文件权限为0777，但是umask默认为0002)</p>
<p>防止继承的文件创建屏蔽字拒绝某些权限</p>
<p>增加守护进程灵活性</p>
</li>
<li><p>关闭文件描述符（不是必须）</p>
<p>继承的打开文件不会用到，浪费系统资源，无法卸载。标准输入，标准输出，标准错误输出设备文件默认被打开</p>
</li>
<li><p>开始执行守护进程核心工作（必须）</p>
<p>守护进程退出处理程序模型</p>
</li>
</ol>
<h4 id="守护进程参考代码"><a href="#守护进程参考代码" class="headerlink" title="守护进程参考代码"></a>守护进程参考代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建守护进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//1.创建子进程 父进程退出</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建新的会话 完全脱离控制终端</span></span><br><span class="line">    pid=setsid();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.改变当前工作目录</span></span><br><span class="line">    ret=chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.设置权限掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//5.关闭文件描述符</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line">    <span class="comment">//6.执行核心的任务</span></span><br><span class="line">    <span class="comment">//每隔一秒钟输出当前的时间到/tmp/txt.log文件中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        system(<span class="string">&quot;date &gt;&gt; /tmp/txt.log&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取系统时间，日志文件需要创建当天的文件，文件名为当天的日期。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 64</span></span><br><span class="line"><span class="comment">//创建守护进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">time_t</span> t=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">pT</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> file_name[SIZE];</span><br><span class="line">    <span class="comment">//1.创建子进程 父进程退出</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建新的会话 完全脱离控制终端</span></span><br><span class="line">    pid=setsid();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.改变当前工作目录</span></span><br><span class="line">    ret=chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.设置权限掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//5.关闭文件描述符</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line">    <span class="comment">//6.执行核心的任务</span></span><br><span class="line">    <span class="comment">//每隔一秒钟输出当前的时间到/tmp/txt.log文件中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//获取当前时间 以秒为单位 从1970-01-01 00:00:00 开始到现在秒数。</span></span><br><span class="line">        t=time(<span class="literal">NULL</span>);</span><br><span class="line">      	<span class="comment">//转化为时间</span></span><br><span class="line">        pT=localtime(&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(pT==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转化为文件名</span></span><br><span class="line">        <span class="built_in">memset</span>(file_name,<span class="number">0</span>,SIZE);</span><br><span class="line">        <span class="built_in">sprintf</span>(file_name,<span class="string">&quot;%s%d%d%d%d%d%d.log&quot;</span>,<span class="string">&quot;touch /home/deng/log/&quot;</span>,pT-&gt;tm_year+<span class="number">1990</span>,pT-&gt;tm_mon+<span class="number">1</span>,pT-&gt;tm_mday,pT-&gt;tm_hour,pT-&gt;tm_min,pT-&gt;tm_sec);</span><br><span class="line">        system(file_name);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在许多经典的操作系统教科书中，总是把进程定义为程序的执行实例，她并不执行什么，只是维护应用程序所需的各种资源，而<strong>线程才是真正的执行实体。</strong></p>
<p>所以线程是轻量级的线程，在Linux环境下线程的本质仍是进程。</p>
<p>为了让进程完成一定的工作，进程必须至少包含一个线程。</p>
<p><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/9.png" alt="9"></p>
<p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统以进程为单位，分配系统资源，所以我们也说，<strong>进程是CPU分配资源的最小单位。</strong></p>
<p><strong>线程存在进程当中，是操作系统调度执行的最小单位。</strong></p>
<h4 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h4><ol>
<li>线程是轻量级进程（light-weight process），也有PCB,创建线程使用的底层函数和进程一样，都是clone。</li>
<li>从内核里看进程和线程是一样的，都有各自不同的PCB。</li>
<li>进程可以蜕变成线程。</li>
<li>在Linux下，线程是最小的执行单位；进程是最小的分配资源单位。</li>
</ol>
<p>查看指定进程的LWP号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -Lf pid</span><br></pre></td></tr></table></figure>

<p>实际上，无论是创建进程的fork,还是创建线程的pthread_create,底层实现都是调用同一个内核函数clone。</p>
<ol>
<li><strong>如果复制对方的地址空间（深拷贝），那么就产生一个进程</strong></li>
<li><strong>如果共享对方的地址空间（浅拷贝），就产生一个线程。</strong></li>
</ol>
<p>*<em>Linux内核是不区分进程和线程的，只在用户层面上进行区分。所以，线程所有操作函数pthread_<em>是库函数，而非系统调用。</em></em></p>
<h4 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h4><ol>
<li><strong>文件描述符表</strong></li>
<li><strong>每种信号的处理方式</strong></li>
<li><strong>当前工作目录</strong></li>
<li><strong>用户ID和组ID</strong></li>
<li><strong>内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)(这里是多线程共享)</strong></li>
</ol>
<h4 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h4><ol>
<li><strong>线程id</strong></li>
<li><strong>处理器现场和栈指针（内核栈）</strong></li>
<li><strong>独立的栈空间（用户空间栈）</strong></li>
<li><strong>errno变量</strong></li>
<li><strong>信号屏蔽字</strong></li>
<li><strong>调度优先级</strong></li>
</ol>
<h4 id="线程常用操作"><a href="#线程常用操作" class="headerlink" title="线程常用操作"></a>线程常用操作</h4><p>进程号在整个系统中是唯一的，但线程号不同，线程号只在它所属的进程环境中有效。</p>
<p>进程号用pid_t数据类型表示，是一个非负整数。<strong>线程号则用pthread_t数据类型来表示，Linux使用无符号长整数表示。</strong></p>
<p><strong>有的系统在实现pthread_t的时候，用一个结构体来表示，所以在可移植的操作系统实现不能把他作为整数处理。</strong></p>
<p>pthread_self函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取线程号</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    调用线程的线程id。</span><br></pre></td></tr></table></figure>

<p>pthread_equal函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1,<span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">功能：</span><br><span class="line">    判断线程号t1和t2是否相等。为了方便移植，尽量使用函数来比较线程ID.</span><br><span class="line">参数：</span><br><span class="line">    t1,t2:待判断的线程号</span><br><span class="line">返回值：</span><br><span class="line">    相等：非<span class="number">0</span></span><br><span class="line">    不相等：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参考程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定链接线程库</span></span><br><span class="line"><span class="comment">//gcc pthread_self.c -pthread </span></span><br><span class="line"><span class="comment">//线程常用函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取当前线程的线程号</span></span><br><span class="line">    tid=pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid: %lu\n&quot;</span>,tid);</span><br><span class="line">    <span class="comment">//比较两个线程ID是否相同</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_equal(tid,pthread_self()))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个线程ID相同\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个线程ID不相同\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h5><p>pthread_create函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread,<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,<span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    创建一个线程。</span><br><span class="line">参数：</span><br><span class="line">    thread:线程标识符地址</span><br><span class="line">    attr:线程属性结构体地址，通常设置为<span class="literal">NULL</span></span><br><span class="line">    start_routine:线程函数的入口地址</span><br><span class="line">    arg:传入线程函数的参数</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在一个线程中调用pthread_create()函数创建新的进程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。</p>
<p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以用strerror()把错误码转换成错误信息再打印。</p>
<p>参考程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//线程调度后执行的任务</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新的线程执行任务 tid:%lu\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> var=(<span class="type">int</span>)(<span class="type">long</span>)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程2 var=%d\n&quot;</span>,var);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid2=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建一个线程</span></span><br><span class="line">    ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_Create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个线程</span></span><br><span class="line">    ret=pthread_create(&amp;tid2,<span class="literal">NULL</span>,fun1,(<span class="type">void</span> *)<span class="number">0x3</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_Create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread....tid:%lu\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键主线程退出&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程资源回收"><a href="#线程资源回收" class="headerlink" title="线程资源回收"></a>线程资源回收</h5><p>pthread_join函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread,<span class="type">void</span> **retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待线程结束（此函数会阻塞），并回收线程资源，类似进程的wait函数。如果线程已经结束，那么该函数会立即返回。</span><br><span class="line">参数：</span><br><span class="line">    thread:被等待的线程号。</span><br><span class="line">    retval:用来存储线程退出状态的指针的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>参考程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//线程处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun thread do working %d\n&quot;</span>,i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">0x3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回收线程的资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> *retp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//创建一个线程</span></span><br><span class="line">    ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread running...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//等待线程结束 会阻塞</span></span><br><span class="line">    ret=pthread_join(tid,&amp;retp);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_join failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;retp: %p\n&quot;</span>,retp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main thread running...</span><br><span class="line">fun thread <span class="keyword">do</span> working 0</span><br><span class="line">fun thread <span class="keyword">do</span> working 1</span><br><span class="line">fun thread <span class="keyword">do</span> working 2</span><br><span class="line">fun thread <span class="keyword">do</span> working 3</span><br><span class="line">fun thread <span class="keyword">do</span> working 4</span><br><span class="line">retp: 0x3</span><br><span class="line">main thread <span class="built_in">exit</span>...</span><br></pre></td></tr></table></figure>

<h5 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h5><p>一般情况下，<strong>线程终止后，其终止状态一直保留到其他线程调用pthread_join获取它的状态为止。</strong>但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它所占用的资源，而不保留终止状态。</p>
<p>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。</p>
<p>pthread_detach函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    使调用线程与当前进程分离，分离后不代表此线程不依赖当前进程（进程退出，线程也结束），线程分离的目的是将线程资源的回收工作交由系统自动完成，也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以。此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    thread:线程号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun thread do working %d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回收线程的资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread running...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">    ret=pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_detach failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键主线程退出。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main thread running...</span><br><span class="line">按下任意键主线程退出。。。</span><br><span class="line">fun thread <span class="keyword">do</span> working 0</span><br><span class="line">fun thread <span class="keyword">do</span> working 1</span><br><span class="line">fun thread <span class="keyword">do</span> working 2</span><br><span class="line">fun thread <span class="keyword">do</span> working 3</span><br><span class="line">fun thread <span class="keyword">do</span> working 4</span><br></pre></td></tr></table></figure>

<h5 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h5><p>在进程中我们可以用exit函数或_exit函数来结束进程，在一个线程中我们可以通过一下三种在不终止整个进程的情况下停止它的控制流。</p>
<ol>
<li>线程从执行函数返回。</li>
<li>线程调用pthread_exit退出线程</li>
<li>线程可以被同一进程中的其他线程取消。</li>
</ol>
<p>pthread_exit函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    退出调用线程。一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源并不会释放。</span><br><span class="line">参数：</span><br><span class="line">    retval:存储线程退出状态的指针。</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun thread do working %d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return NULL;</span></span><br><span class="line">    <span class="comment">//相当于return NULL</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//终止整个进程</span></span><br><span class="line">    <span class="comment">//exit(0);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回收线程的资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread running...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">    ret=pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_detach failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键主线程退出。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    杀死（取消）线程</span><br><span class="line">参数：</span><br><span class="line">    thread:目标线程ID</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：出错编号</span><br></pre></td></tr></table></figure>

<p><strong>注:线程的取消并不是实时的，而又一定的延时。需要等待线程到达某个取消点（检查点）。</strong></p>
<p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat,open，pause,close,read,write…可粗略认为一个系统调用（进入内核）为一个取消点。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun thread do working %d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回收线程的资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread running...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">    ret=pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_detach failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   sleep(<span class="number">3</span>);</span><br><span class="line">   pthread_cancel(tid);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;主线程睡眠了3秒 取消子线程。。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main thread running...</span><br><span class="line">fun thread <span class="keyword">do</span> working 0</span><br><span class="line">fun thread <span class="keyword">do</span> working 1</span><br><span class="line">fun thread <span class="keyword">do</span> working 2</span><br><span class="line">主线程睡眠了3秒 取消子线程。。</span><br></pre></td></tr></table></figure>

<h5 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h5><ol>
<li>主线程退出其他线程不退出，主线程应调用pthread_exit</li>
<li>避免僵尸线程，pthread_join&#x2F;pthread_detach&#x2F;pthread_create指定分离属性</li>
<li>malloc和mmap申请的内存可以被其他线程释放。</li>
<li>避免在多线程模型中调用fork,除非马上exec,子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</li>
<li>信号的复杂语义很难和多线程共存，避免在多线程引入信号机制。</li>
</ol>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>现代操作系统基本都是多任务操作系统，即同时有大量可调度实体在运行。在多任务操作系统中，同时运行的多个任务：</p>
<ol>
<li>都需要访问&#x2F;使用同一种资源</li>
<li>多个任务之间有依赖关系，某个任务的运行依赖另一个任务</li>
</ol>
<p>同步和互斥就是用于解决这两个问题。</p>
<p><strong>互斥：是指散步在不同任务之间的若干程序片段，当某个任务运行其中一个程序片段时，其他任务就不能运行他们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</strong></p>
<p><strong>同步：是指散步在不同任务之间的若干程序片段，他们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如A任务的运行依赖于B任务产生的数据。</strong></p>
<h4 id="互斥锁Mutex介绍"><a href="#互斥锁Mutex介绍" class="headerlink" title="互斥锁Mutex介绍"></a>互斥锁Mutex介绍</h4><p>在线程里，也有这么一把锁：互斥锁（mutex）,也叫互斥量，互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态，即加锁（lock）和解锁（unlock）。</p>
<p>互斥锁的操作流程如下：</p>
<ol>
<li>在访问共享资源后临界区域前，对互斥锁进行加锁。</li>
<li>在访问完成后释放互斥锁</li>
<li>对互斥锁进行加锁后，任何试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。</li>
</ol>
<p>互斥锁的数据类型是：pthread_mutex_t</p>
<h4 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a>pthread_mutex_init函数</h4><p>初始化互斥锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个互斥锁</span><br><span class="line">参数：</span><br><span class="line">    mutex:互斥锁地址。类型是<span class="type">pthread_mutex_t</span>.</span><br><span class="line">    attr:设置互斥量的属性，通常采用默认属性，即可将attr设为<span class="literal">NULL</span>.</span><br><span class="line">        </span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，成功申请的锁是默认打开的。</span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="pthread-mutex-destory函数"><a href="#pthread-mutex-destory函数" class="headerlink" title="pthread_mutex_destory函数"></a>pthread_mutex_destory函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁指定的一个互斥锁。互斥锁在使用完毕，必须要对互斥锁进行销毁，以释放资源。</span><br><span class="line">参数：</span><br><span class="line">    mutex:互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a>pthread_mutex_lock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对互斥锁上锁，若互斥锁已经上锁，则调用者阻塞，直到互斥锁解锁后上锁。</span><br><span class="line">参数:</span><br><span class="line">	mutex:互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">	调用该函数时，若互斥锁未加锁，则上锁，返回<span class="number">0</span>；</span><br><span class="line">    若互斥锁已加锁，则函数直接返回失败，即EBUSY.</span><br></pre></td></tr></table></figure>

<h4 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a>pthread_mutex_unlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对指定的互斥锁解锁</span><br><span class="line">参数：</span><br><span class="line">    mutex:互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出大写字母</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&#x27;A&#x27;</span>;i&lt;<span class="string">&#x27;Z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出小写字母</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&#x27;a&#x27;</span>;i&lt;<span class="string">&#x27;z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="comment">//初始化一个互斥量 互斥锁</span></span><br><span class="line">    ret=pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>!=ret)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化一个互斥量成功。。。。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,fun1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,fun2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//等待两个线程结束</span></span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//销毁互斥量 互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化一个互斥量成功。。。。</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy</span><br><span class="line">main thread <span class="built_in">exit</span>...</span><br></pre></td></tr></table></figure>

<h3 id="死锁（DeadLock）"><a href="#死锁（DeadLock）" class="headerlink" title="死锁（DeadLock）"></a>死锁（DeadLock）</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。若无外力作用，他们将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<h4 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h4><p><strong>破坏请求和保持条件</strong></p>
<p> 协议1：所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会提出资源需求，破坏了请求条件，即使有一种资源不能满足需求，也不会给他分配正在空闲的进程，这样他就没有资源，这样他就没有资源，就破环了保持条件，从而预防。</p>
<p>协议2：允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来。然后再请求新的资源。</p>
<p><strong>破坏不可抢占条件</strong></p>
<p>当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能满足时，他必须释放已经保持的所有资源，以后需要时再重新申请。</p>
<p><strong>破坏循环等待条件</strong></p>
<p>对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其他几个线程也想读取这个共享资源，但是由于互斥锁的排他性，所有其他线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。</p>
<p>为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。</p>
<p>读写锁的特点如下：</p>
<ol>
<li>如果有其他线程读数据，则允许其他线程执行读操作，但不允许写操作。</li>
<li>如果有其他线程写数据，则其他线程都不允许读，写操作。</li>
</ol>
<p>POSIX定义的读写锁的数据类型是：pthread_rwlock_t。</p>
<h4 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a>pthread_rwlock_init函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,<span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用来初始化rwlock所指向的读写锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock:指向要初始化的读写指针。</span><br><span class="line">    attr:读写锁的属性指针。如果attr为<span class="literal">NULL</span>则会使用默认的属性初始化读写锁，否则使用指定的attr初始化读写锁。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>,读写锁的状态将成为已初始化和已解锁</span><br><span class="line">    失败:非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="pthread-rwlock-destroy函数"><a href="#pthread-rwlock-destroy函数" class="headerlink" title="pthread_rwlock_destroy函数"></a>pthread_rwlock_destroy函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用于销毁一个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init()自动申请的资源）</span><br><span class="line">参数：</span><br><span class="line">    rwlock:读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="pthread-rwlock-rdlock函数"><a href="#pthread-rwlock-rdlock函数" class="headerlink" title="pthread_rwlock_rdlock函数"></a>pthread_rwlock_rdlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    以阻塞方式在读写锁上获取读锁（读锁定）</span><br><span class="line">    如果没有写者持有该锁，并且没有写者阻塞在该锁上，则调用线程会获取读锁。</span><br><span class="line">    如果调用线程未获取读锁，则它将阻塞直到他获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。线程可以成功调用pthread_rwlock_rdlock函数多次，但是之后该线程必须调用pthread_rwlock_unlock函数n次才能解除锁定。</span><br><span class="line">参数：</span><br><span class="line">    rwlock；读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">	用于尝试以非阻塞的方式来在读写锁上获取读锁</span><br><span class="line">    如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。</span><br></pre></td></tr></table></figure>

<h4 id="pthread-rwlock-wrlock函数"><a href="#pthread-rwlock-wrlock函数" class="headerlink" title="pthread_rwlock_wrlock函数"></a>pthread_rwlock_wrlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在读写锁上获取写锁（写锁定）</span><br><span class="line">    如果没有写者持有该锁，并且没有读者持有该锁，则调用线程获取写锁</span><br><span class="line">    如果调用线程未获取写锁，则它将阻塞直到它获取了该锁。</span><br><span class="line">参数：</span><br><span class="line">    rwlock:读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">	用于尝试以非阻塞的方式来在读写锁上获取写锁</span><br><span class="line">    如果有任何的读者和写者持有该锁，则立即失败返回。</span><br></pre></td></tr></table></figure>

<h4 id="pthread-rwlock-unlock函数"><a href="#pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_unlock函数"></a>pthread_rwlock_unlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    无论是写锁还是读锁，都可以通过此函数解锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock:读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">   	成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读写锁变量</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//读线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun_read</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//获取线程的编号</span></span><br><span class="line">    <span class="type">int</span> index=(<span class="type">int</span>)(<span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="comment">//加读写锁读锁</span></span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程%d 读取num的值 %d\n&quot;</span>,index,num);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">//随机睡眠1到3秒</span></span><br><span class="line">        sleep(random()%<span class="number">3</span>+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun_write</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程的编号</span></span><br><span class="line">    <span class="type">int</span> index=(<span class="type">int</span>)(<span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//加读写锁的写锁</span></span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程%d 修改num的值 %d\n&quot;</span>,index,num);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">//随机睡眠1到3秒</span></span><br><span class="line">        sleep(random()%<span class="number">3</span>+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//设置随机种子</span></span><br><span class="line">    srandom(getpid());</span><br><span class="line">    <span class="comment">//初始化读写锁</span></span><br><span class="line">    ret=pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_rwlock_init failed..\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建8个线程</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//创建读线程</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">           </span><br><span class="line">            pthread_create(&amp;tid[i],<span class="literal">NULL</span>,fun_read,(<span class="type">void</span> *)(<span class="type">long</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//创建写线程</span></span><br><span class="line">            pthread_create(&amp;tid[i],<span class="literal">NULL</span>,fun_write,(<span class="type">void</span> *)(<span class="type">long</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收八个线程的资源</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">线程0 读取num的值 0</span><br><span class="line">线程1 读取num的值 0</span><br><span class="line">线程2 读取num的值 0</span><br><span class="line">线程3 读取num的值 0</span><br><span class="line">线程4 读取num的值 0</span><br><span class="line">线程5 修改num的值 1</span><br><span class="line">线程7 修改num的值 2</span><br><span class="line">线程6 修改num的值 3</span><br><span class="line">线程3 读取num的值 3</span><br><span class="line">线程4 读取num的值 3</span><br><span class="line">线程6 修改num的值 4</span><br><span class="line">线程0 读取num的值 4</span><br><span class="line">线程2 读取num的值 4</span><br><span class="line">线程5 修改num的值 5</span><br><span class="line">线程6 修改num的值 6</span><br><span class="line">线程1 读取num的值 6</span><br><span class="line">线程0 读取num的值 6</span><br><span class="line">线程2 读取num的值 6</span><br><span class="line">线程4 读取num的值 6</span><br><span class="line">线程7 修改num的值 7</span><br><span class="line">线程5 修改num的值 8</span><br><span class="line">线程6 修改num的值 9</span><br><span class="line">线程3 读取num的值 9</span><br><span class="line">线程7 修改num的值 10</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是用来等待而不是用来上锁的，条件变量本身不是锁。</p>
<p>条件变量用来自动阻塞一个线程，直到某种特殊情况发生为止。<strong>通常条件变量和互斥锁同时使用。</strong></p>
<p>条件变量的两个动作：</p>
<ol>
<li>条件不满足，阻塞线程</li>
<li>当条件满足时，通知阻塞的线程开始工作</li>
</ol>
<p>条件变量的类型：pthread_cond_t</p>
<h4 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a>pthread_cond_init函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    初始化一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond:指向要初始化的条件变量指针。</span><br><span class="line">    attr:条件变量属性，通常为默认值，传<span class="literal">NULL</span>即可</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="pthread-cond-destroy函数"><a href="#pthread-cond-destroy函数" class="headerlink" title="pthread_cond_destroy函数"></a>pthread_cond_destroy函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁一个条件变量</span><br><span class="line">参数:</span><br><span class="line">	cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a>pthread_cond_wait函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待一个条件变量</span><br><span class="line">      <span class="number">1.</span>阻塞等待条件变量cond(参数<span class="number">1</span>)满足</span><br><span class="line">      <span class="number">2.</span>释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		以上的两步为一个原子操作（不可中断，取消）</span><br><span class="line">      <span class="number">3.</span>当被唤醒时，pthread_cond_wait函数返回时，解除阻塞并重新申请互斥锁pthread_mutex_lock(&amp;mutex);</span><br><span class="line">参数：</span><br><span class="line">    cond:指向要初始化的条件变量指针</span><br><span class="line">    mutex:互斥锁</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<h4 id="pthread-cond-signal函数"><a href="#pthread-cond-signal函数" class="headerlink" title="pthread_cond_signal函数"></a>pthread_cond_signal函数</h4><p>唤醒阻塞在条件变量上的线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond:指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒全部阻塞在条件变量上的线程</span><br><span class="line">参数:</span><br><span class="line">	cond:指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变条件的线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒因为条件而阻塞线程</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待条件的线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//表示条件不满足</span></span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待条件满足 会阻塞</span></span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程2因为条件满足 开始运行。。。\n&quot;</span>);</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//条件变量的应用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="comment">//初始化条件变量</span></span><br><span class="line">    ret=pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_cond_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化互斥量</span></span><br><span class="line">    ret=pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,fun1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,fun2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收线程</span></span><br><span class="line">    ret=pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_join failed..\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret=pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_join failed..\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁互斥量</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="comment">//销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br></pre></td></tr></table></figure>

<h4 id="生产者和消费者模型（由条件变量实现）"><a href="#生产者和消费者模型（由条件变量实现）" class="headerlink" title="生产者和消费者模型（由条件变量实现）"></a>生产者和消费者模型（由条件变量实现）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">node_t</span> *head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环生产产品</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(new, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="comment">// 1-100</span></span><br><span class="line">        new-&gt;data = random() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头插法</span></span><br><span class="line">        new-&gt;next = head;</span><br><span class="line">        head = new;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者生产产品%d\n&quot;</span>,new-&gt;data);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//唤醒因为条件变量阻塞的线程</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        <span class="comment">// 随机睡眠</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">customer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环消费</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果链表为空 就阻塞</span></span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;消费者消费 %d\n&quot;</span>,tmp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者和消费者模型 条件变量的版本</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1 = <span class="number">-1</span>, tid2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//设置随机种子</span></span><br><span class="line">    srandom(getpid());</span><br><span class="line">    <span class="comment">//初始化条件变量</span></span><br><span class="line">    ret=pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_cond_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化互斥量</span></span><br><span class="line">    ret=pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个线程 生产者线程 消费者线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个线程结束</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">产者生产产品71</span><br><span class="line">消费者消费 71</span><br><span class="line">生产者生产产品69</span><br><span class="line">消费者消费 69</span><br><span class="line">生产者生产产品69</span><br><span class="line">消费者消费 69</span><br><span class="line">生产者生产产品54</span><br><span class="line">消费者消费 54</span><br><span class="line">生产者生产产品20</span><br><span class="line">消费者消费 20</span><br><span class="line">生产者生产产品4</span><br><span class="line">消费者消费 4</span><br><span class="line">生产者生产产品33</span><br><span class="line">消费者消费 33</span><br><span class="line">生产者生产产品23</span><br><span class="line">消费者消费 23</span><br></pre></td></tr></table></figure>

<h4 id="条件变量的优缺点"><a href="#条件变量的优缺点" class="headerlink" title="条件变量的优缺点"></a>条件变量的优缺点</h4><p>相对于mutex而言，条件变量可以减少竞争。</p>
<p>如直接使用mutex,除了生产者，消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果链表中没有数据，消费者之间竞争互斥锁是无意义的。</p>
<p>有了条件变量机制后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>信号量广泛用于进程或进程间的同步和互斥，信号量本质上是一个非负的整数计数器，它用来控制对公共资源的访问。</strong></p>
<p><strong>编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号值大于0时，则可以访问，否则将阻塞。</strong></p>
<p><strong>PV原语对信号量的操作，一次P操作使信号量减1，一次V操作使信号量加1.</strong></p>
<p><strong>信号量主要用于进程或线程间的同步和互斥这两种典型情况。</strong></p>
<p><strong>信号量数据类型：sem_t</strong></p>
<h4 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a>sem_init函数</h4><p>初始化信号量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">int</span> pshared,<span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化。</span><br><span class="line">参数：</span><br><span class="line">    sem:信号量地址</span><br><span class="line">    pshared:等于<span class="number">0</span>，信号量在线程间共享（常用）；不等于<span class="number">0</span>，信号量在进程间共享</span><br><span class="line">    value:信号量的初始值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a>sem_destroy函数</h4><p>销毁信号量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    删除sem标识的信号量</span><br><span class="line">参数：</span><br><span class="line">    sem:信号量地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="信号量P操作（减1）"><a href="#信号量P操作（减1）" class="headerlink" title="信号量P操作（减1）"></a>信号量P操作（减1）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值减<span class="number">1</span>，操作前，先检查信号量（sem）的值是否为<span class="number">0</span>，若信号量为<span class="number">0</span>，此函数会阻塞，直到信号量大于<span class="number">0</span>时才进行减<span class="number">1</span>操作。</span><br><span class="line">参数：</span><br><span class="line">    sem:信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">	以阻塞的方式来对信号量进行减<span class="number">1</span>操作。</span><br><span class="line">    若操作前，信号量的值等于<span class="number">0</span>，则对信号量的操作失败，函数立即返回。</span><br></pre></td></tr></table></figure>

<h4 id="信号量V操作（加1）"><a href="#信号量V操作（加1）" class="headerlink" title="信号量V操作（加1）"></a>信号量V操作（加1）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值加<span class="number">1</span>并发出信号唤醒等待线程（ sem_wait() ）;</span><br><span class="line">参数：</span><br><span class="line">    sem:信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">	失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="获取信号量的值"><a href="#获取信号量的值" class="headerlink" title="获取信号量的值"></a>获取信号量的值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    获取sem标识的信号量的值，保存在sval中</span><br><span class="line">参数：</span><br><span class="line">    sem:信号量地址</span><br><span class="line">    sval:保存信号量值的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="信号量用于互斥"><a href="#信号量用于互斥" class="headerlink" title="信号量用于互斥"></a>信号量用于互斥</h4><p>一次性打印完大写或者小写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量变量</span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出大写字母</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//申请资源 将可用资源减1</span></span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&#x27;A&#x27;</span>;i&lt;<span class="string">&#x27;Z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源 将可用资源加1</span></span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出小写字母</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//申请资源 将可用资源减1</span></span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&#x27;a&#x27;</span>;i&lt;<span class="string">&#x27;z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源 将可用资源加1</span></span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="comment">//初始化一个信号量</span></span><br><span class="line">    ret=sem_init(&amp;sem,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>!=ret)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化一个信号量成功。。。。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,fun1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,fun2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//等待两个线程结束</span></span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化一个信号量成功。。。。</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy</span><br><span class="line">main thread <span class="built_in">exit</span>...</span><br></pre></td></tr></table></figure>

<h4 id="信号量用于同步"><a href="#信号量用于同步" class="headerlink" title="信号量用于同步"></a>信号量用于同步</h4><p>生产者和消费者模型（信号量）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"><span class="type">node_t</span> *head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 信号量变量</span></span><br><span class="line"><span class="comment">// 容器的个数</span></span><br><span class="line"><span class="type">sem_t</span> sem_producer;</span><br><span class="line"><span class="comment">// 可以卖产品的个数</span></span><br><span class="line"><span class="type">sem_t</span> sem_customer;</span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环生产产品</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请一个资源 容器</span></span><br><span class="line">        sem_wait(&amp;sem_producer);</span><br><span class="line">        <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(new, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="comment">// 1-100</span></span><br><span class="line">        new-&gt;data = random() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头插法</span></span><br><span class="line">        new-&gt;next = head;</span><br><span class="line">        head = new;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者生产产品%d\n&quot;</span>, new-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费 将可以卖的商品个数加1</span></span><br><span class="line">        sem_post(&amp;sem_customer);</span><br><span class="line">        <span class="comment">// 随机睡眠</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">customer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环消费</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请资源 可以卖的商品个数减1</span></span><br><span class="line">        sem_wait(&amp;sem_customer);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果链表为空 就阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;产品为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者消费 %d\n&quot;</span>, tmp-&gt;data);</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        <span class="comment">// 释放资源 将容器个数加1</span></span><br><span class="line">        sem_post(&amp;sem_producer);</span><br><span class="line">        <span class="comment">// 睡眠1-3秒</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者和消费者模型 条件变量的版本</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1 = <span class="number">-1</span>, tid2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    srandom(getpid());</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    ret = sem_init(&amp;sem_producer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem_producer_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = sem_init(&amp;sem_customer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem_customer_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建两个线程 生产者线程 消费者线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个线程结束</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    sem_destroy(&amp;sem_producer);</span><br><span class="line">    sem_destroy(&amp;sem_customer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">生产者生产产品7</span><br><span class="line">消费者消费 7</span><br><span class="line">生产者生产产品10</span><br><span class="line">消费者消费 10</span><br><span class="line">生产者生产产品65</span><br><span class="line">消费者消费 65</span><br><span class="line">生产者生产产品84</span><br><span class="line">消费者消费 84</span><br><span class="line">生产者生产产品13</span><br><span class="line">消费者消费 13</span><br><span class="line">生产者生产产品10</span><br><span class="line">消费者消费 10</span><br><span class="line">生产者生产产品51</span><br></pre></td></tr></table></figure>

<p><strong>多生产者和多消费者</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"><span class="type">node_t</span> *head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 信号量变量</span></span><br><span class="line"><span class="comment">// 容器的个数</span></span><br><span class="line"><span class="type">sem_t</span> sem_producer;</span><br><span class="line"><span class="comment">// 可以卖产品的个数</span></span><br><span class="line"><span class="type">sem_t</span> sem_customer;</span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环生产产品</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请一个资源 容器</span></span><br><span class="line">        sem_wait(&amp;sem_producer);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(new, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="comment">// 1-100</span></span><br><span class="line">        new-&gt;data = random() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头插法</span></span><br><span class="line">        new-&gt;next = head;</span><br><span class="line">        head = new;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者生产产品%d\n&quot;</span>, new-&gt;data);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知消费者消费 将可以卖的商品个数加1</span></span><br><span class="line">        sem_post(&amp;sem_customer);</span><br><span class="line">        <span class="comment">// 随机睡眠</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">customer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环消费</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请资源 可以卖的商品个数减1</span></span><br><span class="line">        sem_wait(&amp;sem_customer);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果链表为空 就阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;产品为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者消费 %d\n&quot;</span>, tmp-&gt;data);</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 释放资源 将容器个数加1</span></span><br><span class="line">        sem_post(&amp;sem_producer);</span><br><span class="line">        <span class="comment">// 睡眠1-3秒</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者和消费者模型 条件变量的版本</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">6</span>];</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    srandom(getpid());</span><br><span class="line">    <span class="comment">//互斥锁初始化</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    ret = sem_init(&amp;sem_producer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem_producer_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = sem_init(&amp;sem_customer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem_customer_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            pthread_create(&amp;tid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pthread_create(&amp;tid[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    sem_destroy(&amp;sem_producer);</span><br><span class="line">    sem_destroy(&amp;sem_customer);</span><br><span class="line">    <span class="comment">//互斥锁销毁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">生产者生产产品59</span><br><span class="line">消费者消费 59</span><br><span class="line">生产者生产产品68</span><br><span class="line">消费者消费 68</span><br><span class="line">生产者生产产品12</span><br><span class="line">消费者消费 12</span><br><span class="line">生产者生产产品28</span><br><span class="line">消费者消费 28</span><br><span class="line">生产者生产产品97</span><br><span class="line">消费者消费 97</span><br><span class="line">生产者生产产品12</span><br><span class="line">消费者消费 12</span><br><span class="line">生产者生产产品51</span><br><span class="line">消费者消费 51</span><br><span class="line">生产者生产产品99</span><br><span class="line">消费者消费 99</span><br><span class="line">生产者生产产品96</span><br></pre></td></tr></table></figure>

<h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2></article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    


    <section id="share">
      <div class="header"><span>分享文章</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="http://yustonerain.top/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=http://yustonerain.top/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/&title=Linux系统编程 - YuStone&summary=Linux系统编程学习"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg" /></a><a class="social share-item email" href="mailto:?subject=Linux系统编程 - YuStone&amp;body=http://yustonerain.top/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=http://yustonerain.top/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
        </div>
        
      </div>
    </section>
    </div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Linux网络编程</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84100%E9%A2%98/">数据结构100题</a></div></section></div>

<div class="related-wrap" id="related-posts"></div>


  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body utterances'>
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="utterances" repo="YuStone0416/YuStone0416.github.io" issue-term="pathname" theme="preferred-color-scheme"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">YuStone</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95"><span class="toc-text">Linux常见目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bash%E8%A7%A3%E6%9E%90%E5%99%A8%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">Bash解析器常用快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E7%9B%B8%E5%85%B3%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">终端相关快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4%E5%92%8C%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94"><span class="toc-text">内建命令和外部命令对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-text">Linux命令格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95"><span class="toc-text">帮助文档查看方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">目录相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pwd"><span class="toc-text">pwd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cd"><span class="toc-text">cd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mkdir"><span class="toc-text">mkdir</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rmdir"><span class="toc-text">rmdir</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">Linux文件类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">文件相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ls%E5%91%BD%E4%BB%A4"><span class="toc-text">ls命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F"><span class="toc-text">什么是通配符？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#touch%E5%91%BD%E4%BB%A4"><span class="toc-text">touch命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cp%E5%91%BD%E4%BB%A4"><span class="toc-text">cp命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rm%E5%91%BD%E4%BB%A4"><span class="toc-text">rm命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mv%E5%91%BD%E4%BB%A4"><span class="toc-text">mv命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">文件内容查看相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cat%E5%91%BD%E4%BB%A4"><span class="toc-text">cat命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#less%E5%91%BD%E4%BB%A4"><span class="toc-text">less命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#head%E5%91%BD%E4%BB%A4"><span class="toc-text">head命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tail%E5%91%BD%E4%BB%A4"><span class="toc-text">tail命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#du%E5%92%8Cdf%E5%91%BD%E4%BB%A4"><span class="toc-text">du和df命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#du%E5%91%BD%E4%BB%A4"><span class="toc-text">du命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#df%E5%91%BD%E4%BB%A4"><span class="toc-text">df命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">查找相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#find"><span class="toc-text">find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-text">grep</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-text">压缩包管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tar"><span class="toc-text">tar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip"><span class="toc-text">gzip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bzip2"><span class="toc-text">bzip2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zip%E5%92%8Cunzip"><span class="toc-text">zip和unzip</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">文件权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chmod"><span class="toc-text">chmod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chown"><span class="toc-text">chown</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="toc-text">软件安装和卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="toc-text">使用包管理器安装和卸载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-text">其他命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tree"><span class="toc-text">tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ln"><span class="toc-text">ln</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vim"><span class="toc-text">vim</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vim%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-text">vim的三种模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gcc%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">gcc编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">静态链接和动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E5%AF%B9%E6%AF%94"><span class="toc-text">静态和动态编译对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-text">静态库和动态库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%EF%BC%9A"><span class="toc-text">静态库制作：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-text">静态库使用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C"><span class="toc-text">动态库制作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8"><span class="toc-text">动态库使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">动态库加载失败问题解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-text">GDB调试器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="toc-text">生成调试信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8GDB"><span class="toc-text">启动GDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-text">显示源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">断点操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-text">条件断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E6%96%AD%E7%82%B9"><span class="toc-text">维护断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-text">调试代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E7%9C%8B"><span class="toc-text">数据查看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%98%BE%E7%A4%BA"><span class="toc-text">自动显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-text">查看修改变量的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7Makefile"><span class="toc-text">自动化编译工具Makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-text">Makefile语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-text">make命令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E7%A4%BA%E4%BE%8B"><span class="toc-text">Makefile示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">Makefile中的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-text">自定义变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="toc-text">自动变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-text">模式规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">Makefile的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E4%B8%AD%E7%9A%84%E4%BC%AA%E7%9B%AE%E6%A0%87"><span class="toc-text">Makefile中的伪目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">系统调用和库函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">错误处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-text">虚拟地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">文件描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AA%E6%95%B0%EF%BC%9A"><span class="toc-text">最大打开的文件个数：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6IO%E5%87%BD%E6%95%B0"><span class="toc-text">常用文件IO函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0"><span class="toc-text">open函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#close%E5%87%BD%E6%95%B0"><span class="toc-text">close函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write%E5%87%BD%E6%95%B0"><span class="toc-text">write函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read%E5%87%BD%E6%95%B0"><span class="toc-text">read函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">阻塞和非阻塞的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lseek%E5%87%BD%E6%95%B0"><span class="toc-text">lseek函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">文件操作相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stat%E5%87%BD%E6%95%B0"><span class="toc-text">stat函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#access%E5%87%BD%E6%95%B0"><span class="toc-text">access函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chmod%E5%87%BD%E6%95%B0"><span class="toc-text">chmod函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chown%E5%87%BD%E6%95%B0"><span class="toc-text">chown函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#truncate%E5%87%BD%E6%95%B0"><span class="toc-text">truncate函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#link%E5%87%BD%E6%95%B0"><span class="toc-text">link函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symlink%E5%87%BD%E6%95%B0"><span class="toc-text">symlink函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%A4%8D%E5%88%B6"><span class="toc-text">文件描述符复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dup%E5%87%BD%E6%95%B0"><span class="toc-text">dup函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dup2%E5%87%BD%E6%95%B0"><span class="toc-text">dup2函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fcntl%E5%87%BD%E6%95%B0"><span class="toc-text">fcntl函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-text">目录相关操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getcwd%E5%87%BD%E6%95%B0"><span class="toc-text">getcwd函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chdir%E5%87%BD%E6%95%B0"><span class="toc-text">chdir函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#opendir%E5%87%BD%E6%95%B0"><span class="toc-text">opendir函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#closedir%E5%87%BD%E6%95%B0"><span class="toc-text">closedir函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readdir%E5%87%BD%E6%95%B0"><span class="toc-text">readdir函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F"><span class="toc-text">进程和程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-text">并行和并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MMU"><span class="toc-text">MMU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="toc-text">进程控制块PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">进程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ps"><span class="toc-text">ps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#top"><span class="toc-text">top</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kill"><span class="toc-text">kill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#killall"><span class="toc-text">killall</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7%E5%92%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">进程号和相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-text">三个不同的进程号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getpid%E5%87%BD%E6%95%B0"><span class="toc-text">getpid函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getppid%E5%87%BD%E6%95%B0"><span class="toc-text">getppid函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getpgid%E5%87%BD%E6%95%B0"><span class="toc-text">getpgid函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">进程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB"><span class="toc-text">父子进程关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-text">区分父子进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="toc-text">父子进程堆空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%98%AF%E5%90%A6%E6%B3%84%E9%9C%B2"><span class="toc-text">如何检测内存是否泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GDB%E8%B0%83%E8%AF%95%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-text">GDB调试多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-text">进程退出函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-text">等待子进程退出函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait%E5%87%BD%E6%95%B0"><span class="toc-text">wait函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="toc-text">waitpid函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-text">孤儿进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2"><span class="toc-text">进程替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-text">无名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pipe%E5%87%BD%E6%95%B0"><span class="toc-text">pipe函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%BF%87%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-text">父子进程通过无名管道通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E8%AF%BB%E5%86%99%E7%89%B9%E7%82%B9"><span class="toc-text">管道读写特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%BA%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">设置为非阻塞的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">查看管道缓冲区的大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-text">有名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-text">通过命令创建有名管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-text">通过函数创建有名管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">有名管道读写操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84"><span class="toc-text">共享存储映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0"><span class="toc-text">存储映射函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mmap%E5%87%BD%E6%95%B0"><span class="toc-text">mmap函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#munmap%E5%87%BD%E6%95%B0"><span class="toc-text">munmap函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">匿名映射实现父子进程通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%96%E5%8F%B7"><span class="toc-text">信号的编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%9B%9B%E8%A6%81%E7%B4%A0"><span class="toc-text">信号四要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-text">阻塞信号集和未决信号集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E5%87%BD%E6%95%B0"><span class="toc-text">信号产生函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kill%E5%87%BD%E6%95%B0"><span class="toc-text">kill函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raise%E5%87%BD%E6%95%B0"><span class="toc-text">raise函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abort%E5%87%BD%E6%95%B0"><span class="toc-text">abort函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alarm%E5%87%BD%E6%95%B0%EF%BC%88%E9%97%B9%E9%92%9F%EF%BC%89"><span class="toc-text">alarm函数（闹钟）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setitimer%E5%87%BD%E6%95%B0%EF%BC%88%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%89"><span class="toc-text">setitimer函数（定时器）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-text">信号集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-text">自定义信号集函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigprocmask%E5%87%BD%E6%95%B0"><span class="toc-text">sigprocmask函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigpending%E5%87%BD%E6%95%B0"><span class="toc-text">sigpending函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="toc-text">信号捕捉</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">信号处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#signal%E5%87%BD%E6%95%B0"><span class="toc-text">signal函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigaction%E5%87%BD%E6%95%B0"><span class="toc-text">sigaction函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigqueue%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%E8%88%AC%E4%B8%8D%E7%94%A8%EF%BC%8C%E7%94%A8kill%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">sigqueue函数（一般不用，用kill函数）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%EF%BC%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-text">不可重入，可重入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="toc-text">SIGCHLD信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">SIGCHLD信号产生的条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-text">如何避免僵尸进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">守护进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-text">进程组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-text">会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">守护进程模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81"><span class="toc-text">守护进程参考代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">线程的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-text">线程共享资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%9D%9E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-text">线程非共享资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">线程常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">线程的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-text">线程资源回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="toc-text">线程分离</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA"><span class="toc-text">线程退出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="toc-text">线程取消</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">线程使用注意事项</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81Mutex%E4%BB%8B%E7%BB%8D"><span class="toc-text">互斥锁Mutex介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-init%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_mutex_init函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-destory%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_mutex_destory函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-lock%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_mutex_lock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-unlock%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_mutex_unlock函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%EF%BC%88DeadLock%EF%BC%89"><span class="toc-text">死锁（DeadLock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">预防死锁的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-init%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_rwlock_init函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-destroy%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_rwlock_destroy函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-rdlock%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_rwlock_rdlock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-wrlock%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_rwlock_wrlock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-unlock%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_rwlock_unlock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cond-init%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_cond_init函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cond-destroy%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_cond_destroy函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cond-wait%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_cond_wait函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cond-signal%E5%87%BD%E6%95%B0"><span class="toc-text">pthread_cond_signal函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%EF%BC%88%E7%94%B1%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-text">生产者和消费者模型（由条件变量实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">条件变量的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sem-init%E5%87%BD%E6%95%B0"><span class="toc-text">sem_init函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sem-destroy%E5%87%BD%E6%95%B0"><span class="toc-text">sem_destroy函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8FP%E6%93%8D%E4%BD%9C%EF%BC%88%E5%87%8F1%EF%BC%89"><span class="toc-text">信号量P操作（减1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8FV%E6%93%8D%E4%BD%9C%EF%BC%88%E5%8A%A01%EF%BC%89"><span class="toc-text">信号量V操作（加1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-text">获取信号量的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%A8%E4%BA%8E%E4%BA%92%E6%96%A5"><span class="toc-text">信号量用于互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%A8%E4%BA%8E%E5%90%8C%E6%AD%A5"><span class="toc-text">信号量用于同步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1"><span class="toc-text">完结撒花</span></a></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5" d="M8 10.5h8M8 14h5.5M17 3.338A9.95 9.95 0 0 0 12 2C6.477 2 2 6.477 2 12c0 1.6.376 3.112 1.043 4.453c.178.356.237.763.134 1.148l-.595 2.226a1.3 1.3 0 0 0 1.591 1.592l2.226-.596a1.63 1.63 0 0 1 1.149.133A9.96 9.96 0 0 0 12 22c5.523 0 10-4.477 10-10c0-1.821-.487-3.53-1.338-5"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->

  <script type="module">
  const el = document.querySelector("#comments #utterances");
  util.viewportLazyload(el, load_utterances, false);

  function load_utterances() {
    if (!el) return;
    try {
      el.innerHTML = '';
    } catch (error) {
      console.error(error);
    }
    const script = document.createElement('script');
    script.src = 'https://utteranc.es/client.js';
    script.async = true;
    for (const key of Object.keys(el.attributes)) {
      const attr = el.attributes[key];
      if (['class', 'id'].includes(attr.name) === false) {
        script.setAttribute(attr.name, attr.value);
      }
    }
    el.appendChild(script);
  }
</script>




<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
