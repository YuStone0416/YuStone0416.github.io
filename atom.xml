<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YuStone Blogs</title>
  
  <subtitle>the world</subtitle>
  <link href="http://yustonerain.top/atom.xml" rel="self"/>
  
  <link href="http://yustonerain.top/"/>
  <updated>2025-07-04T13:26:00.000Z</updated>
  <id>http://yustonerain.top/</id>
  
  <author>
    <name>YuStone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql连接池</title>
    <link href="http://yustonerain.top/2025/07/03/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0.html"/>
    <id>http://yustonerain.top/2025/07/03/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0.html</id>
    <published>2025-07-03T12:48:36.000Z</published>
    <updated>2025-07-04T13:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目目的"><a href="#项目目的" class="headerlink" title="项目目的"></a>项目目的</h2><p>为了提高MySQL数据库(基于C&#x2F;S设计)的访问瓶颈，除了在服务端增加缓存服务器缓存常用的数据之外，还可增加连接池，来提高MySQL Server的访问效率，在高并发情况下，大量的TCP三次握手，MySQL Server连接认证，MySQL Server关闭连接回收资源和TCP四次挥手所耗费的性能时间也是很明显的，增加连接池就是为了减少这一部分的损耗。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目目的&quot;&gt;&lt;a href=&quot;#项目目的&quot; class=&quot;headerlink&quot; title=&quot;项目目的&quot;&gt;&lt;/a&gt;项目目的&lt;/h2&gt;&lt;p&gt;为了提高MySQL数据库(基于C&amp;#x2F;S设计)的访问瓶颈，除了在服务端增加缓存服务器缓存常用的数据之外，还可增加连接池</summary>
      
    
    
    
    <category term="项目" scheme="http://yustonerain.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="mysql" scheme="http://yustonerain.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程</title>
    <link href="http://yustonerain.top/2025/06/20/Linux-System%20Programming.html"/>
    <id>http://yustonerain.top/2025/06/20/Linux-System%20Programming.html</id>
    <published>2025-06-20T13:26:00.000Z</published>
    <updated>2025-06-28T13:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux常见目录"><a href="#Linux常见目录" class="headerlink" title="Linux常见目录"></a>Linux常见目录</h2><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td><code>/</code></td><td>根目录，所有目录的起点，Linux 文件系统的顶级目录</td></tr><tr><td><code>/bin</code></td><td>存放常用的二进制可执行文件（如 <code>ls</code>、<code>cp</code>、<code>mv</code> 等），普通用户和系统都可使用</td></tr><tr><td><code>/sbin</code></td><td>系统管理命令，只有 root 用户可用（如 <code>reboot</code>、<code>ifconfig</code>）</td></tr><tr><td><code>/etc</code></td><td>配置文件目录（如 <code>/etc/passwd</code>、<code>/etc/fstab</code>、<code>/etc/ssh/sshd_config</code>）</td></tr><tr><td><code>/home</code></td><td>普通用户的家目录（如 <code>/home/user1</code>）</td></tr><tr><td><code>/root</code></td><td>超级用户（root）的家目录</td></tr><tr><td><code>/lib</code></td><td>核心共享库和驱动模块，供 <code>/bin</code> 和 <code>/sbin</code> 下的程序使用</td></tr><tr><td><code>/usr</code></td><td>存放用户应用程序和文件，子目录中包括 <code>/usr/bin</code>、<code>/usr/lib</code> 等</td></tr><tr><td><code>/usr/bin</code></td><td>普通用户使用的应用程序（非基本命令）</td></tr><tr><td><code>/usr/sbin</code></td><td>非系统引导时使用的系统管理员命令</td></tr><tr><td><code>/var</code></td><td>可变数据，如日志文件 <code>/var/log</code>、邮件、缓存、锁等</td></tr><tr><td><code>/tmp</code></td><td>临时文件，系统重启后可能会被清空</td></tr><tr><td><code>/opt</code></td><td>第三方软件安装目录（如 Chrome、VMware 等）</td></tr><tr><td><code>/dev</code></td><td>设备文件（如硬盘 <code>/dev/sda</code>，终端 <code>/dev/tty</code>）</td></tr><tr><td><code>/proc</code></td><td>虚拟文件系统，内核和进程信息（如 <code>/proc/cpuinfo</code>、<code>/proc/meminfo</code>）</td></tr><tr><td><code>/sys</code></td><td>另一种虚拟文件系统，提供与内核、设备驱动的交互接口</td></tr><tr><td><code>/boot</code></td><td>存放启动相关文件，如内核、grub 等（如 <code>/boot/vmlinuz-*</code>）</td></tr><tr><td><code>/media</code></td><td>可移动媒体挂载点（如 U 盘、光盘）</td></tr><tr><td><code>/mnt</code></td><td>临时挂载点，一般管理员手动挂载文件系统用</td></tr><tr><td><code>/run</code></td><td>系统运行时临时文件（如 PID、Socket）</td></tr><tr><td><code>/srv</code></td><td>提供服务的数据目录（如 Web 服务、FTP 服务的数据）</td></tr></tbody></table><h2 id="Bash解析器常用快捷键"><a href="#Bash解析器常用快捷键" class="headerlink" title="Bash解析器常用快捷键"></a>Bash解析器常用快捷键</h2><p>1.tap键</p><p>补齐命令，补齐路径，显示当前目录下的所有目录</p><p>2.清屏 clear</p><p>3.中断进程 ctrl+c</p><p>4 遍历输入的历史命令箭头上（ctrl+p）箭头下(ctrl+n)</p><p>5 光标相关操作</p><p>光标左移： ctrl+b（箭头左）</p><p>光标右移： ctrl+f(箭头右)</p><p>移动到头部: ctrl+a(home键)</p><p>移动到尾部：ctrl+e(end键)</p><p>6字符删除</p><p>删除光标前面的字符：ctrl+h(Backspace)</p><p>删除光标后面的字符：ctrl+d</p><p>光标后面的字符即光标覆盖的字符</p><p>删除光标前的所有内容：ctrl+u</p><p>删除光标后的所有内容：ctrl+k</p><h2 id="终端相关快捷键"><a href="#终端相关快捷键" class="headerlink" title="终端相关快捷键"></a>终端相关快捷键</h2><p>（终端一定要选中）</p><p>ctrl+shift+N 新建一个终端</p><p>ctrl+shift+T 在终端里新建一个标签</p><p>ctrl+D 关闭当前一个终端</p><h2 id="内建命令和外部命令对比"><a href="#内建命令和外部命令对比" class="headerlink" title="内建命令和外部命令对比"></a>内建命令和外部命令对比</h2><p>内建命令 vs 外部命令 对比总结</p><table><thead><tr><th>比较项</th><th>内建命令（Builtin Command）</th><th>外部命令（External Command）</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>由 Shell 内部直接实现的命令</td><td>是文件系统中的可执行程序（如 <code>/bin/ls</code>）</td></tr><tr><td><strong>执行速度</strong></td><td>快（不需新建进程）</td><td>较慢（需 fork 子进程执行）</td></tr><tr><td><strong>资源消耗</strong></td><td>少，执行在当前 Shell 进程中</td><td>多，执行时创建子进程</td></tr><tr><td><strong>路径查找</strong></td><td>不需要依赖 <code>PATH</code> 环境变量</td><td>需要从 <code>PATH</code> 中查找可执行文件</td></tr><tr><td><strong>是否可以替换</strong></td><td>一般不推荐重定义</td><td>可以覆盖、替换或删改（如 alias 覆盖）</td></tr><tr><td><strong>是否常驻内存</strong></td><td>是，Shell 启动时加载</td><td>否，执行时加载，执行完释放</td></tr><tr><td><strong>例子</strong></td><td><code>cd</code>, <code>echo</code>, <code>exit</code>, <code>pwd</code>, <code>type</code></td><td><code>ls</code>, <code>cp</code>, <code>gcc</code>, <code>vim</code>, <code>python</code></td></tr><tr><td><strong>查看方法</strong></td><td><code>type cd</code> → builtin</td><td><code>type ls</code> → file</td></tr></tbody></table><p>命令类型查看方法</p><p>使用type命令</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">type</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 命令名</code></pre><p>使用 -a 显示所有同名命令（包括 alias、builtin、文件）</p><p>使用 -t 显示类型（简洁）</p><h2 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h2><pre class="language-bash" data-language="bash"><code class="language-bash">命令 <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span></code></pre><table><thead><tr><th>部分</th><th>说明</th></tr></thead><tbody><tr><td><strong>命令</strong></td><td>要执行的操作，如 <code>ls</code>、<code>cp</code>、<code>mkdir</code> 等</td></tr><tr><td><strong>选项</strong></td><td>用于控制命令行为的开关，通常以 <code>-</code> 或 <code>--</code> 开头，例如 <code>-l</code>、<code>--help</code></td></tr><tr><td><strong>参数</strong></td><td>命令作用的对象，通常是文件名、目录名、用户名等</td></tr></tbody></table><p>选项类型说明</p><table><thead><tr><th>类型</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>短选项</td><td><code>-l</code></td><td>通常是一个字母，多个可组合（如 <code>-al</code>）</td></tr><tr><td>长选项</td><td><code>--help</code></td><td>更易读，通常不可组合</td></tr><tr><td>组合选项</td><td><code>-avz</code></td><td>相当于 <code>-a -v -z</code></td></tr></tbody></table><h2 id="帮助文档查看方法"><a href="#帮助文档查看方法" class="headerlink" title="帮助文档查看方法"></a>帮助文档查看方法</h2><p>如果是内建命令（可以通过之前的type命令查看）使用 help +内建命令</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">help</span> <span class="token builtin class-name">pwd</span></code></pre><p>如果是外部命令 对应命令名 –help</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">--help</span></code></pre><p><code>man</code> 是 Linux 中最常用的命令之一，全称是 <strong>manual（手册）</strong>，用于查看各种命令、函数、配置文件的使用说明。它是学习和查找 Linux 命令最权威的工具。</p><p><code>man</code> 命令基本语法：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">man</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>命令名或函数名<span class="token punctuation">]</span></code></pre><p> man 手册的 9 个部分（章节）</p><table><thead><tr><th>章节号</th><th>内容</th><th>示例</th></tr></thead><tbody><tr><td>1</td><td>用户命令（常见终端命令）</td><td><code>man ls</code></td></tr><tr><td>2</td><td>系统调用（内核提供的函数）</td><td><code>man 2 open</code></td></tr><tr><td>3</td><td>C 库函数</td><td><code>man 3 printf</code></td></tr><tr><td>4</td><td>设备文件和特殊文件</td><td><code>man 4 tty</code></td></tr><tr><td>5</td><td>配置文件格式</td><td><code>man 5 crontab</code></td></tr><tr><td>6</td><td>游戏与趣味（极少）</td><td></td></tr><tr><td>7</td><td>杂项（宏定义、协议、约定等）</td><td><code>man 7 signal</code></td></tr><tr><td>8</td><td>系统管理员命令（只能 root 执行）</td><td><code>man 8 ifconfig</code></td></tr><tr><td>9</td><td>内核开发接口（不常见）</td><td></td></tr></tbody></table><p>常用选项</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><code>-k 关键词</code></td><td>搜索相关命令（相当于 <code>apropos</code>）</td></tr><tr><td><code>-f 命令名</code></td><td>显示命令属于哪个章节（相当于 <code>whatis</code>）</td></tr><tr><td><code>-a</code></td><td>显示所有章节中匹配的 man 页</td></tr><tr><td><code>-M</code></td><td>指定手册路径</td></tr><tr><td><code>--help</code></td><td>查看 man 自身帮助信息</td></tr></tbody></table><h2 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h2><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>用于显示当前终端所在的<strong>工作目录</strong>（即当前绝对路径）。</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token punctuation">[</span>目录路径<span class="token punctuation">]</span></code></pre><p>常见用法示例</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>cd /home/user</code></td><td>切换到绝对路径 <code>/home/user</code> 目录</td></tr><tr><td><code>cd ..</code></td><td>切换到上一级目录</td></tr><tr><td><code>cd</code> 或 <code>cd ~</code></td><td>切换到当前用户的主目录</td></tr><tr><td><code>cd -</code></td><td>切换到上一次所在的目录（切换目录的“切换”）</td></tr><tr><td><code>cd ./folder</code></td><td>切换到当前目录下的子目录 <code>folder</code></td></tr></tbody></table><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>用于<strong>创建新目录</strong>的命令，创建不了已存在目录。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 目录名</code></pre><p>mkdir test 在当前目录下创建test文件夹</p><p>mkdir &#x2F;tmp&#x2F;test</p><p>mkdir file{1..100}在当前目录创建100个文件夹，file1,file2,file3…file100</p><p>mkdir “file{1..100}”在当前目录创建file{1..100}文件夹，只会创建一个。</p><p>mkdir “a b” 在当前目录创建a b一个文件夹。</p><p>mkdir a b 在当前目录创建a b两个文件夹。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code></td><td>递归创建目录（父目录不存在时自动创建）</td></tr><tr><td><code>-m MODE</code></td><td>设置新建目录的权限，如 <code>-m 755</code></td></tr><tr><td><code>-v</code></td><td>显示详细创建过程（verbose）</td></tr></tbody></table><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>用法和mkdir相同</p><p>用于<strong>删除空目录</strong>的命令</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>rmdir testdir</code></td><td>删除当前目录下的 <code>testdir</code>（需为空）</td></tr><tr><td><code>rmdir -p a/b/c</code></td><td>递归删除空目录链：先删 <code>c</code>，再删 <code>b</code>，再删 <code>a</code></td></tr><tr><td><code>rmdir ./mydir/</code></td><td>删除当前目录中的 <code>mydir</code>（需为空）</td></tr></tbody></table><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code></td><td>递归删除路径中的所有空目录（从子到父）</td></tr><tr><td><code>--ignore-fail-on-non-empty</code></td><td>删除目录时忽略非空目录导致的错误</td></tr></tbody></table><h2 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h2><p>常用的文件类型有七种：普通文件，目录文件，设备文件，管道文件，链接文件和套接字。</p><p><img src="/2025/06/20/Linux-System%20Programming/1.png" alt="1" loading="lazy"></p><p><strong>普通文件</strong> 是 Linux 中最常见的一类文件，主要用于存储用户数据。包括：</p><ul><li>文本文件（如 <code>.txt</code>, <code>.c</code>, <code>.py</code>）</li><li>二进制文件（如 可执行程序、图片、音频等）</li><li>脚本文件（如 <code>.sh</code>, <code>.py</code>，可以被解释执行）</li></ul><p>在 Linux 中，<strong>目录文件（Directory File）</strong> 是一种特殊的文件类型，用来组织和存放文件和其他目录（子目录）。<br> 它本质上是一个<strong>保存了文件名和 inode 编号之间映射关系</strong>的文件。</p><p><strong>设备文件</strong>（Device File）是 Linux 中用于访问硬件设备的接口，本质上就是一种特殊的文件，程序通过它来与硬件设备通信。</p><p>设备文件通常位于 <code>/dev</code> 目录中。</p><p>常见设备文件举例</p><table><thead><tr><th>路径</th><th>类型</th><th>功能描述</th></tr></thead><tbody><tr><td><code>/dev/sda</code></td><td>块设备</td><td>第一块硬盘</td></tr><tr><td><code>/dev/tty</code></td><td>字符设备</td><td>当前终端</td></tr><tr><td><code>/dev/null</code></td><td>字符设备</td><td>写入数据会被丢弃</td></tr><tr><td><code>/dev/zero</code></td><td>字符设备</td><td>会源源不断输出 0</td></tr><tr><td><code>/dev/random</code></td><td>字符设备</td><td>伪随机数生成器</td></tr></tbody></table><p><strong>管道文件</strong>（或称命名管道，FIFO &#x3D; First In First Out）是一种特殊文件，用于<strong>在不同进程之间传输数据</strong>。<br> 写入管道的数据会按顺序被读取，类似“排队喝水”的水管，先进先出。</p><p>管道文件与匿名管道不同之处在于它有名字，存在于文件系统中（通常创建在某个路径下），因此<strong>不同进程不必有父子关系</strong>也能通信。</p><p><strong>链接文件</strong> 是指向另一个文件的引用，常用于：</p><ul><li>创建多个路径指向同一个文件（节省空间）</li><li>为长路径或常用文件创建别名（提高效率）</li><li>实现共享与替代功能</li></ul><table><thead><tr><th>类型</th><th>描述</th><th><code>ls -l</code> 标识</th></tr></thead><tbody><tr><td><strong>软链接</strong>（符号链接）</td><td>类似 Windows 快捷方式，是一个指向目标路径的独立文件</td><td><code>l</code></td></tr><tr><td><strong>硬链接</strong></td><td>直接指向目标文件的 inode，本质上是同一个文件的另一个名字</td><td><code>-</code></td></tr></tbody></table><p>在 Linux 中，你可以使用 <code>ls -l</code> 命令来区分各种文件类型。<code>ls -l</code> 输出的每一行开头的第一个字符表示文件类型。下面是 <strong>七种常见文件类型及其 <code>ls -l</code> 显示符号</strong>：</p><p>七种常见文件类型及其标识</p><table><thead><tr><th>文件类型</th><th><code>ls -l</code> 类型字符</th><th>示例路径</th><th>含义说明</th></tr></thead><tbody><tr><td><strong>普通文件</strong></td><td><code>-</code></td><td><code>-rw-r--r-- file.txt</code></td><td>常见的文本、二进制、可执行文件等</td></tr><tr><td><strong>目录文件</strong></td><td><code>d</code></td><td><code>drwxr-xr-x dir/</code></td><td>存储文件的容器</td></tr><tr><td><strong>字符设备文件</strong></td><td><code>c</code></td><td><code>crw------- /dev/tty</code></td><td>逐字符访问设备，如终端、串口等</td></tr><tr><td><strong>块设备文件</strong></td><td><code>b</code></td><td><code>brw-rw---- /dev/sda</code></td><td>按块访问设备，如硬盘、U 盘等</td></tr><tr><td><strong>管道文件</strong></td><td><code>p</code></td><td><code>prw-r--r-- mypipe</code></td><td>用于进程间通信的 FIFO 管道</td></tr><tr><td><strong>链接文件</strong></td><td><code>l</code></td><td><code>lrwxrwxrwx link -&gt; target</code></td><td>指向其他文件的软链接</td></tr><tr><td><strong>套接字文件</strong></td><td><code>s</code></td><td><code>srwxrwxrwx socket</code></td><td>进程间网络通信接口，如 <code>/tmp/.X11-unix/X0</code></td></tr></tbody></table><h2 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h2><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>ls</code></td><td>简单列出当前目录内容</td></tr><tr><td><code>ls -a</code></td><td>显示所有文件，包括隐藏文件（以<code>.</code>开头）</td></tr><tr><td><code>ls -l</code></td><td>以长格式列出，显示权限、类型、时间等</td></tr><tr><td><code>ls -lh</code></td><td>长格式 + 人类可读大小（如 KB, MB）</td></tr><tr><td><code>ls -lt</code></td><td>按修改时间排序，最新的在前</td></tr><tr><td><code>ls -r</code></td><td>反向排序</td></tr><tr><td><code>ls -R</code></td><td>递归列出子目录</td></tr><tr><td><code>ls -d */</code></td><td>只列出目录 ls -d只显示一个.</td></tr></tbody></table><p>ls -l命令会输出长格式</p><pre class="language-none"><code class="language-none">权限       硬链接数 拥有者 所属组  大小    修改日期      文件名drwxr-xr-x   2    user   user  4096   Jun 21 13:00  mydir</code></pre><p>对权限部分说明一下权限部分总共10个字符</p><table><thead><tr><th>位置</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>文件类型标识</td></tr><tr><td>2-4</td><td><strong>拥有者（user）</strong>权限</td></tr><tr><td>5-7</td><td><strong>同组用户（group）</strong>权限</td></tr><tr><td>8-10</td><td><strong>其他用户（others）</strong>权限</td></tr></tbody></table><p>文件类型标识（第1个字符）</p><table><thead><tr><th>字符</th><th>类型</th></tr></thead><tbody><tr><td><code>-</code></td><td>普通文件</td></tr><tr><td><code>d</code></td><td>目录</td></tr><tr><td><code>l</code></td><td>软链接</td></tr><tr><td><code>c</code></td><td>字符设备文件</td></tr><tr><td><code>b</code></td><td>块设备文件</td></tr><tr><td><code>p</code></td><td>管道（FIFO）</td></tr><tr><td><code>s</code></td><td>套接字</td></tr></tbody></table><p>权限字符说明（2-10位置）</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>r</code></td><td>读权限 (read)</td></tr><tr><td><code>w</code></td><td>写权限 (write)</td></tr><tr><td><code>x</code></td><td>执行权限 (execute)</td></tr><tr><td><code>-</code></td><td>无该权限</td></tr><tr><td><code>s</code></td><td>setuid&#x2F;setgid 位（特殊执行权限）</td></tr><tr><td><code>t</code></td><td>粘滞位（sticky bit）</td></tr></tbody></table><p>三组权限详解</p><table><thead><tr><th>组别</th><th>位置</th><th>含义</th></tr></thead><tbody><tr><td><strong>拥有者</strong></td><td>2~4 字符</td><td>拥有该文件&#x2F;目录的用户权限</td></tr><tr><td><strong>组用户</strong></td><td>5~7 字符</td><td>属于该文件组的用户权限</td></tr><tr><td><strong>其他用户</strong></td><td>8~10 字符</td><td>系统中除拥有者和组以外的所有用户权限</td></tr></tbody></table><h3 id="什么是通配符？"><a href="#什么是通配符？" class="headerlink" title="什么是通配符？"></a>什么是通配符？</h3><p>通配符是一种简化文件名匹配的符号，用于在命令中匹配多个文件或目录。它可以让你不用输入完整文件名，就能选中符合规则的文件。</p><p>常用的通配符类型</p><table><thead><tr><th>通配符</th><th>作用</th><th>例子</th><th>匹配结果示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意数量的任意字符（包括0个）</td><td><code>ls *.txt</code></td><td>匹配所有以 <code>.txt</code> 结尾的文件</td></tr><tr><td><code>?</code></td><td>匹配任意一个单字符</td><td><code>ls file?.txt</code></td><td>匹配 <code>file1.txt</code>、<code>fileA.txt</code>，但不匹配 <code>file10.txt</code></td></tr><tr><td><code>[abc]</code></td><td>匹配括号内的任意一个字符</td><td><code>ls file[123].txt</code></td><td>匹配 <code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code></td></tr><tr><td><code>[a-z]</code></td><td>匹配指定范围内的任意一个字符</td><td><code>ls file[a-c].txt</code></td><td>匹配 <code>filea.txt</code>、<code>fileb.txt</code>、<code>filec.txt</code></td></tr><tr><td><code>[!abc]</code></td><td>匹配不在括号内的任意一个字符</td><td><code>ls file[!123].txt</code></td><td>匹配除 <code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code> 以外的文件</td></tr></tbody></table><h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p><code>touch</code> 是用来 <strong>创建空文件</strong> 或 <strong>更新已有文件的时间戳</strong> 的命令。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> file.txt</code></pre><p>如果 <code>file.txt</code> 不存在，会被创建为空文件；如果存在，文件时间被更新。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> file1.txt file2.txt file3.txt</code></pre><p>一次创建或更新多个文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> file<span class="token punctuation">&#123;</span><span class="token number">2,3</span>,4<span class="token punctuation">&#125;</span><span class="token comment">#同时创建file2,file3,file4三个空文件和mkdir file&#123;1..100&#125;用法是一样的。</span><span class="token function">touch</span> <span class="token string">"file&#123;2,3,4&#125;"</span>#创建file<span class="token punctuation">&#123;</span><span class="token number">2,3</span>,4<span class="token punctuation">&#125;</span>这一个文件。</code></pre><h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p><code>cp</code> 是 Linux 中用于 <strong>复制文件或目录</strong> 的命令。</p><table><thead><tr><th>任务</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td>复制文件</td><td><code>cp file1.txt file2.txt</code></td><td>把 <code>file1.txt</code> 内容复制为 <code>file2.txt</code></td></tr><tr><td>复制文件到目录</td><td><code>cp file1.txt /home/user/docs/</code></td><td>把 <code>file1.txt</code> 复制进目录</td></tr><tr><td>复制目录（加 <code>-r</code>）</td><td><code>cp -r dir1/ dir2/</code></td><td>递归复制整个目录 <code>dir1</code> 到 <code>dir2</code> 中</td></tr><tr><td>保留属性复制文件</td><td><code>cp -p file1.txt file2.txt</code></td><td>保留原文件的时间戳、权限等信息</td></tr><tr><td>强制覆盖目标文件</td><td><code>cp -f file1.txt file2.txt</code></td><td>如果 <code>file2.txt</code> 存在，强制覆盖</td></tr><tr><td>复制并提示</td><td><code>cp -i file1.txt file2.txt</code></td><td>有冲突时会提示确认</td></tr><tr><td>显示复制过程</td><td><code>cp -v file1.txt file2.txt</code></td><td>复制时显示详细过程（verbose 模式）</td></tr></tbody></table><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-r</code></td><td>递归复制目录（必须用于复制目录）</td></tr><tr><td><code>-i</code></td><td>覆盖文件前提示确认</td></tr><tr><td><code>-f</code></td><td>强制覆盖目标文件而不提示</td></tr><tr><td><code>-p</code></td><td>保留原文件的属性（权限、时间等）</td></tr><tr><td><code>-u</code></td><td>只在源文件较新时才复制</td></tr><tr><td><code>-v</code></td><td>显示复制过程（verbose）</td></tr><tr><td><code>-a</code></td><td>归档模式，等价于 <code>-dpR</code>，用于备份</td></tr><tr><td><code>--parents</code></td><td>保留源路径结构复制文件（适用于目录结构迁移）</td></tr></tbody></table><h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><p>是用于在 Linux 中 <strong>删除文件和目录</strong> 的命令。注意：<code>rm</code> 删除后不会进入回收站，<strong>无法轻易恢复</strong>，请务必小心使用。</p><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>删除单个文件</td><td><code>rm file.txt</code></td><td>删除文件 <code>file.txt</code></td></tr><tr><td>删除多个文件</td><td><code>rm file1.txt file2.txt</code></td><td>一次删除多个文件</td></tr><tr><td>递归删除目录及内容</td><td><code>rm -r mydir/</code></td><td>删除目录 <code>mydir</code> 及其所有子目录和文件</td></tr><tr><td>强制删除文件&#x2F;目录</td><td><code>rm -f file.txt</code> &#x2F; <code>rm -rf mydir/</code></td><td>忽略不存在的文件，且不提示确认</td></tr><tr><td>删除前确认</td><td><code>rm -i file.txt</code></td><td>删除前逐一询问确认</td></tr><tr><td>显示正在删除的文件</td><td><code>rm -v file.txt</code></td><td>显示被删除的文件名</td></tr></tbody></table><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-r</code> 或 <code>--recursive</code></td><td>递归删除目录及其内容（删除整个目录树）</td></tr><tr><td><code>-f</code> 或 <code>--force</code></td><td>强制删除，不提示，即使目标不存在也不报错</td></tr><tr><td><code>-i</code></td><td>删除前询问确认，适合新手使用以防误删</td></tr><tr><td><code>-I</code></td><td>删除多个文件或目录时才询问一次，比 <code>-i</code> 安全且不烦人</td></tr><tr><td><code>-v</code> 或 <code>--verbose</code></td><td>显示正在删除的每一个文件或目录</td></tr><tr><td><code>--preserve-root</code></td><td>默认保护根目录 <code>/</code> 不被删除（系统安全机制，防止 <code>rm -rf /</code> 误操作）</td></tr></tbody></table><h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p><strong>移动文件或目录</strong> 到新位置，<strong>重命名</strong> 文件或目录。</p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td>移动文件</td><td><code>mv a.txt /home/user/docs/</code></td><td>把 <code>a.txt</code> 移动到 <code>/home/user/docs/</code> 目录</td></tr><tr><td>重命名文件</td><td><code>mv old.txt new.txt</code></td><td>将 <code>old.txt</code> 重命名为 <code>new.txt</code></td></tr><tr><td>移动并重命名</td><td><code>mv a.txt /home/user/docs/b.txt</code></td><td>移动 <code>a.txt</code> 到新目录并改名为 <code>b.txt</code></td></tr><tr><td>移动目录</td><td><code>mv dir1/ /home/user/backup/</code></td><td>移动整个目录到新的路径</td></tr><tr><td>覆盖已有文件</td><td><code>mv -f a.txt b.txt</code></td><td>如果 <code>b.txt</code> 存在，则强制覆盖</td></tr><tr><td>覆盖前确认</td><td><code>mv -i a.txt b.txt</code></td><td>如果 <code>b.txt</code> 存在，移动前会询问是否覆盖</td></tr><tr><td>显示移动过程</td><td><code>mv -v a.txt b.txt</code></td><td>显示正在移动的内容</td></tr></tbody></table><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-f</code></td><td>强制覆盖已有目标文件，不提示</td></tr><tr><td><code>-i</code></td><td>如果目标文件存在，提示是否覆盖（interactive）</td></tr><tr><td><code>-n</code></td><td>不覆盖已有的目标文件（no-clobber）</td></tr><tr><td><code>-v</code></td><td>显示移动过程（verbose）</td></tr><tr><td><code>-u</code></td><td>仅在源文件较新或目标文件不存在时才移动</td></tr></tbody></table><h2 id="文件内容查看相关命令"><a href="#文件内容查看相关命令" class="headerlink" title="文件内容查看相关命令"></a>文件内容查看相关命令</h2><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>用于 <strong>查看、创建、合并文件</strong> 内容，常用于快速查看文本文件内容。</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-n</code></td><td>给所有行编号</td></tr><tr><td><code>-b</code></td><td>只对非空行编号</td></tr><tr><td><code>-s</code></td><td>压缩连续空白行为一行</td></tr><tr><td><code>-T</code></td><td>显示 Tab 为 <code>^I</code></td></tr><tr><td><code>-E</code></td><td>显示每行结尾的 <code>$</code>（换行符可见）</td></tr><tr><td><code>-A</code></td><td>相当于 <code>-vET</code>，显示所有不可见字符</td></tr></tbody></table><h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p>用于<strong>分页显示文件内容</strong>的命令，支持 <strong>向前&#x2F;向后翻页浏览</strong>，适合查看<strong>大型文本文件</strong>。它比 <code>cat</code> 更强大，且不会一次性加载全部内容到内存中。</p><p>使用时常用快捷键（进入 less 后）</p><table><thead><tr><th>快捷键</th><th>功能说明</th></tr></thead><tbody><tr><td><code>空格</code></td><td>向下翻一页</td></tr><tr><td><code>b</code></td><td>向上翻一页</td></tr><tr><td><code>Enter</code></td><td>向下滚动一行</td></tr><tr><td><code>k</code></td><td>向上一行（vi 风格）</td></tr><tr><td><code>j</code></td><td>向下一行</td></tr><tr><td><code>G</code></td><td>跳到文件末尾</td></tr><tr><td><code>g</code></td><td>跳到文件开头</td></tr><tr><td><code>/关键词</code></td><td>向下搜索（如 <code>/error</code>）</td></tr><tr><td><code>?关键词</code></td><td>向上搜索</td></tr><tr><td><code>n</code></td><td>重复上一次搜索</td></tr><tr><td><code>N</code></td><td>反向重复搜索</td></tr><tr><td><code>q</code></td><td>退出 less</td></tr></tbody></table><h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><p><code>head</code> 用于<strong>查看文件的前几行内容</strong>，默认显示前 10 行。适合快速预览文件开头，尤其是大型文件或日志文件。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-n N</code></td><td>显示前 N 行（如 <code>head -n 15 file.txt</code>）</td></tr><tr><td><code>-c N</code></td><td>显示前 N 个<strong>字节</strong>（如 <code>head -c 100 file.txt</code>）</td></tr><tr><td><code>-q</code></td><td>多文件时不显示文件名头部（quiet）</td></tr><tr><td><code>-v</code></td><td>总是显示文件名头部（verbose）</td></tr></tbody></table><h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>用于<strong>显示文件的最后几行内容</strong>，默认是最后 10 行。常用于：</p><ul><li>查看日志尾部；</li><li>实时监控文件内容变化（配合 <code>-f</code> 选项）；</li><li>截取文件结尾部分数据。</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tail</span> /etc/passwd <span class="token comment">#默认显示后十行</span><span class="token function">tail</span> <span class="token parameter variable">-n</span> <span class="token number">30</span> 文件名 <span class="token comment">#显示后30行内容</span><span class="token function">tail</span> <span class="token parameter variable">-c</span> <span class="token number">30</span> 文件名 <span class="token comment">#显示后30个字符</span></code></pre><h2 id="du和df命令"><a href="#du和df命令" class="headerlink" title="du和df命令"></a>du和df命令</h2><h3 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h3><p>查看<strong>目录或文件占用的磁盘空间</strong>，会考虑磁盘块对齐、文件系统元数据、软链接等因素。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-h</code></td><td>以<strong>人类可读的方式</strong>显示（如 KB、MB）</td></tr><tr><td><code>-s</code></td><td>显示指定文件&#x2F;目录占用的数据块</td></tr><tr><td><code>-a</code></td><td>显示所有文件和目录的大小（默认只显示目录）</td></tr><tr><td><code>--max-depth=N</code></td><td>显示目录深度（限制递归层数）</td></tr></tbody></table><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">du</span> <span class="token parameter variable">-sh</span> 文件名/目录</code></pre><table><thead><tr><th>项目</th><th><code>ls -l</code></th><th><code>du -sh</code></th></tr></thead><tbody><tr><td>显示内容</td><td>文件本身大小（内容字节数）</td><td>实际磁盘占用（包含对齐和元数据）</td></tr><tr><td>对目录</td><td>显示目录结构本身大小</td><td>显示目录下所有内容实际占用</td></tr><tr><td>单位</td><td>字节（Bytes）</td><td>自动转换为 KB&#x2F;MB&#x2F;GB</td></tr><tr><td>应用场景</td><td>看文件大小&#x2F;属性</td><td>查哪些文件&#x2F;目录占空间最多</td></tr></tbody></table><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"hello"</span> <span class="token operator">></span> file.txt<span class="token function">ls</span> <span class="token parameter variable">-l</span> file.txt      <span class="token comment"># 显示 6 bytes</span><span class="token function">du</span> <span class="token parameter variable">-sh</span> file.txt     <span class="token comment"># 显示 4.0K</span></code></pre><h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h3><p>查看<strong>整个磁盘的使用情况</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">df</span> <span class="token parameter variable">-h</span> <span class="token comment"># 显示所有文件系统的使用情况（人类可读格式）</span><span class="token function">df</span> <span class="token parameter variable">-h</span> /home <span class="token comment"># 查看 /home 所在分区的磁盘使用情况</span></code></pre><h2 id="查找相关命令"><a href="#查找相关命令" class="headerlink" title="查找相关命令"></a>查找相关命令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find</code> 是 Linux 中功能非常强大的文件搜索命令，它可以根据名称、类型、时间、大小、权限等多种条件在目录中递归查找文件，还可以执行删除、移动、打印等操作。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> <span class="token punctuation">[</span>搜索路径<span class="token punctuation">]</span> <span class="token punctuation">[</span>搜索条件<span class="token punctuation">]</span> <span class="token punctuation">[</span>处理动作<span class="token punctuation">]</span></code></pre><p>按文件名查询：使用参数 -name</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./ <span class="token parameter variable">-name</span> <span class="token string">"*.txt"</span> <span class="token comment">#查找当前路径下符合后缀是。txt的文件</span></code></pre><p>按文件大小查询：使用参数 -size</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./ <span class="token parameter variable">-size</span> +100k</code></pre><p>+100k 表示大于100k的文件</p><p>-100k表示小于100k的文件</p><p>100k 表示等于100k的文件</p><p>大小方面：k小写，M大写</p><p>查询大小范围</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./ <span class="token parameter variable">-size</span> +50k <span class="token parameter variable">-size</span> <span class="token parameter variable">-100k</span></code></pre><p>按文件类型查询：使用参数 -type</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./ <span class="token parameter variable">-type</span> f <span class="token comment">#查询当前的普通文件</span></code></pre><table><thead><tr><th>类型代号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>f</code></td><td>普通文件</td><td><code>find . -type f</code> 查找所有普通文件（这里不是-，要和ls -l的文件类型区分）</td></tr><tr><td><code>d</code></td><td>目录</td><td><code>find . -type d</code> 查找所有目录</td></tr><tr><td><code>l</code></td><td>符号链接（软链接）</td><td><code>find . -type l</code> 查找所有软链接</td></tr><tr><td><code>c</code></td><td>字符设备文件</td><td><code>/dev/null</code> 等</td></tr><tr><td><code>b</code></td><td>块设备文件</td><td>硬盘等块设备</td></tr><tr><td><code>s</code></td><td>套接字文件</td><td>Socket 类型文件</td></tr><tr><td><code>p</code></td><td>命名管道（FIFO）</td><td>通信用的特殊文件</td></tr></tbody></table><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><code>grep</code> 是 Linux 中非常常用的文本搜索工具，用于<strong>在文件或标准输出中查找匹配的字符串</strong>，功能强大，灵活，适合日志分析、配置文件搜索、编程辅助等场景。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token string">"模式"</span> <span class="token punctuation">[</span>文件<span class="token punctuation">]</span></code></pre><table><thead><tr><th>选项</th><th>含义说明</th></tr></thead><tbody><tr><td><code>-n</code></td><td>显示匹配行的行号</td></tr><tr><td><code>-i</code></td><td>忽略大小写</td></tr><tr><td><code>-v</code></td><td>反向匹配（即显示不包含该字符串的行）</td></tr><tr><td><code>-r</code> or <code>-R</code></td><td>递归搜索目录下的所有文件</td></tr><tr><td><code>-l</code></td><td>只列出匹配的文件名</td></tr><tr><td><code>-c</code></td><td>统计匹配的行数</td></tr><tr><td><code>--color=auto</code></td><td>高亮显示匹配的内容</td></tr></tbody></table><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">"root"</span> /etc/passwd <span class="token comment">#不分大小写，在passwd查找root</span><span class="token function">grep</span> <span class="token parameter variable">-w</span> <span class="token string">"hello"</span> /etc/passwd <span class="token comment">#在passwd查找完全匹配hello单词的行</span><span class="token function">grep</span> <span class="token parameter variable">-r</span> <span class="token string">"u_char"</span> ./  <span class="token comment">#递归搜索当前目录下的符合u_char的行</span><span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">"hello"</span> /etc/passwd <span class="token parameter variable">--color</span><span class="token operator">=</span>auto <span class="token comment">#在/etc/passwd文件中找hello并且忽略大小写，然后高亮显示匹配的关键字</span></code></pre><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道（|）一个命令的输出可以通过管道作为另一个命令的输入。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ifconfig</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"ens33"</span> <span class="token comment">#在ifconfig输出的文字查找存在ens33的行</span></code></pre><h2 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>把一系列文件归档到一个文件，也可以把档案文件解开以恢复数据。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token parameter variable">-f</span> <span class="token punctuation">[</span>文件名.tar<span class="token punctuation">]</span> <span class="token punctuation">[</span>要打包或解压的文件/目录<span class="token punctuation">]</span><span class="token comment">#f必须放到选项的最后</span></code></pre><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-cvf</span> sysctl.tar <span class="token function">sysctl</span> <span class="token comment">#打包文件，但是不压缩</span><span class="token function">tar</span> <span class="token parameter variable">-xvf</span> sysctl.tar <span class="token comment">#解包文件</span><span class="token function">tar</span> <span class="token parameter variable">-tvf</span> sysctl.tar <span class="token comment">#查看压缩文件内容</span></code></pre><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p><strong>对单个文件进行压缩或解压</strong>，压缩率高、速度快，默认生成 <code>.gz</code> 文件。</p><p>tar和gzip命令结合使用实现文件打包，压缩。</p><p>tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般为xxx.tar.gz。</p><p>gzip单独使用，只可以对文件压缩和解压，不可以对目录。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">gzip</span> test1 test2 <span class="token comment">#不保留源文件压缩。 </span></code></pre><p>tar和gzip结合对目录压缩</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-czvf</span> sysctl.tar.gz <span class="token function">sysctl</span> <span class="token comment">#打包和压缩文件</span><span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> sysctl.tar.gz <span class="token comment">#解包和解压文件</span><span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> sysctl.tar.gz <span class="token parameter variable">-C</span> /temp <span class="token comment">#解包和解压文件到temp目录</span></code></pre><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>和gzip一样和tar结合。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-cjvf</span> test.tar.bz2 <span class="token builtin class-name">test</span> <span class="token comment">#生成一个bz2压缩包</span><span class="token function">tar</span> <span class="token parameter variable">-xjvf</span> share.tar.bz2 <span class="token comment">#解压</span></code></pre><h3 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h3><p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">zip</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 目标文件（没有扩展名）源文件/目录<span class="token function">unzip</span> <span class="token parameter variable">-d</span> 解压后目录文件 压缩文件 <span class="token comment">#-d解压到指定目录</span></code></pre><h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><p>访问权限说明：</p><p>读权限（r）</p><p>对文件而言，具有读取文件内容的权限；对目录而言，具有浏览目录的权限。</p><p>写权限（w）</p><p>对文件而言，具有新增，修改文件内容的权限；对目录而言，具有删除，移动目录内文件的权限。</p><p>可执行权限（x）</p><p>对文件而言，具有执行文件的权限；对目录而言，该用户具有进入目录的权限。</p><p>通常。Unix&#x2F;Linux系统只允许文件的属主（所有者）或root用户改变文件的读写权限。</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><code>chmod</code>（<strong>change mode</strong>）是 Linux&#x2F;Unix 系统中用于<strong>修改文件或目录权限</strong>的命令。它支持两种权限设置方式：<strong>数字方式</strong>和<strong>符号方式</strong>。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 模式 文件名</code></pre><p>符号方式：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> u/g/o/a +/-/<span class="token operator">=</span> rwx 文件 <span class="token comment">#+添加权限 -撤销权限 =设定权限 u/g/o对应的是拥有者，同属组，其他。</span>chomd o+w a <span class="token comment">#向a的其他用户添加写权限</span>chomd <span class="token assign-left variable">u</span><span class="token operator">=</span>rw,g<span class="token operator">=</span>r,o<span class="token operator">=</span>r a<span class="token comment">#把a的拥有者权限为re,同属组权限为r,其他用户权限为r。</span></code></pre><p>数字方式：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#由于rwx通过二进制来区分 rwx就是111，十进制为7</span><span class="token comment">#rwx   7</span><span class="token comment">#rw-   6</span><span class="token comment">#r--   4</span><span class="token comment">#r-x   5</span>chomd 0777 a<span class="token comment">#把a的对应用户的权限变为rwx.</span></code></pre><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><code>chown</code> 是 Linux&#x2F;Unix 中用于更改文件或目录 <strong>所属用户（owner）</strong> 和 <strong>所属用户组（group）</strong> 的命令。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>新用户<span class="token punctuation">]</span><span class="token punctuation">[</span>:<span class="token punctuation">[</span>新用户组<span class="token punctuation">]</span><span class="token punctuation">]</span> 文件/目录</code></pre><p><code>新用户</code>：新的文件拥有者</p><p><code>新用户组</code>：新的用户组（可选）</p><p>需要 <code>sudo</code> 权限（普通用户只能修改自己拥有的文件）</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#把文件所有者修改为root用户</span><span class="token function">sudo</span> <span class="token function">chown</span> root a<span class="token comment">#把文件所属者改为yustone,所属组改为root</span><span class="token function">sudo</span> <span class="token function">chown</span> yustone:root a</code></pre><h2 id="软件安装和卸载"><a href="#软件安装和卸载" class="headerlink" title="软件安装和卸载"></a>软件安装和卸载</h2><h3 id="使用包管理器安装和卸载"><a href="#使用包管理器安装和卸载" class="headerlink" title="使用包管理器安装和卸载"></a>使用包管理器安装和卸载</h3><p>Ubuntu &#x2F; Debian 系列</p><p>安装</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update          <span class="token comment"># 更新软件源</span><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> 软件名  <span class="token comment"># 安装软件</span></code></pre><p>卸载</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> remove 软件名           <span class="token comment"># 删除程序但保留配置文件</span><span class="token function">sudo</span> <span class="token function">apt</span> purge 软件名            <span class="token comment"># 连配置文件一并删除</span></code></pre><p>离线软件包安装：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg <span class="token parameter variable">-i</span> package.deb</code></pre><p>离线软件包卸载：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg <span class="token parameter variable">-r</span> 软件名</code></pre><p>使用 Snap 安装（跨平台容器化安装方式）</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> snap <span class="token function">install</span> 软件名</code></pre><p>使用 Snap 卸载（跨平台容器化安装方式）</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> snap remove 软件名</code></pre><p>从源代码编译安装</p><pre class="language-bash" data-language="bash"><code class="language-bash">./configure<span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span></code></pre><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>主要是把命令输出的内容（之前是屏幕）输入到文件里。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /etc/passwd <span class="token operator">></span> output.txt <span class="token comment">#标准正确输出重定向到output.txt（这里是覆盖原文件）</span><span class="token function">ls</span> /etc/passwd <span class="token operator">>></span> output.txt <span class="token comment">#标准正确输出追加重定向到output.txt(这里是追加)</span>llll <span class="token operator"><span class="token file-descriptor important">2</span>></span> error.txt <span class="token comment">#标准错误输出重定向到error.txt(这里是覆盖原文件)</span>llll <span class="token operator"><span class="token file-descriptor important">2</span>>></span> error.txt <span class="token comment">#标准错误输出追加重定向到error.txt</span>lll <span class="token operator"><span class="token file-descriptor important">2</span>></span> /dev/null <span class="token comment">#标准错误输出重定向到黑洞</span><span class="token function">ls</span> ddddd /etc/passwd <span class="token operator">&amp;></span> /dev/null <span class="token comment">#标准正确输出和标准错误输出全部重定向到黑洞。</span><span class="token function">ls</span> ddddd /etc/passwd <span class="token operator">&amp;>></span> output.txt <span class="token comment">#标准正确输出和标准错误输出以追加的方式全部重定向到output.txt.</span></code></pre><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>tree以树状形式查看指定目录内容。</p><pre class="language-bash" data-language="bash"><code class="language-bash">tree 目录</code></pre><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>ln命令主要用于创建链接文件。</p><p>链接文件分为软链接和硬链接：</p><p>硬链接只能链接普通文件，不能链接目录。软链接不占用磁盘空间，源文件删除则链接失效。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ln</span> 源文件 链接文件 <span class="token comment">#硬链接</span><span class="token function">ln</span> <span class="token parameter variable">-s</span> 源文件 链接文件 <span class="token comment">#软链接</span></code></pre><p>如果没有-s选项代表建立一个硬链接文件，两个文件占用同一块的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s比较常用。如果软链接文件和源文件不在同一目录，源文件最好使用绝对路径，不要使用相对路径。软链接文件存储的是目标文件的路径。</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p><code>vim</code> 是一款强大的 <strong>文本编辑器</strong>，常用于 <strong>Linux &#x2F; Unix 系统编程、脚本编辑、配置文件修改等场景</strong>。它是 <code>vi</code> 的增强版本，具有更强的功能，比如语法高亮、代码折叠、多窗口、多标签支持等。</p><h3 id="vim的三种模式"><a href="#vim的三种模式" class="headerlink" title="vim的三种模式"></a>vim的三种模式</h3><p><strong>普通模式</strong>（Normal Mode）</p><p><strong>默认启动模式</strong>，你一打开 Vim 就是在这个模式。</p><p><strong>作用</strong>：浏览、复制、剪切、粘贴、删除、移动光标、跳转、执行命令等。</p><p>常用命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>h</code>&#x2F;<code>l</code></td><td>左&#x2F;右移动光标</td></tr><tr><td><code>j</code>&#x2F;<code>k</code></td><td>下&#x2F;上移动光标</td></tr><tr><td><code>[n]dd</code></td><td>删除当前行开始的n行（准确说是剪切）</td></tr><tr><td>[n]x</td><td>删除光标后n个字符</td></tr><tr><td>[n]X</td><td>删除光标前n个字符</td></tr><tr><td><code>[n]yy</code></td><td>复制从当前行开始的n行</td></tr><tr><td><code>p</code></td><td>粘贴</td></tr><tr><td><code>u</code></td><td>撤销前一个命令</td></tr><tr><td><code>Ctrl + r</code></td><td>还原（恢复）</td></tr><tr><td><code>:</code></td><td>进入命令模式</td></tr><tr><td><code>i</code>、<code>a</code></td><td>进入插入模式</td></tr><tr><td>mG&#x2F;mgg</td><td>到指定行，m为目标行数</td></tr><tr><td>&#x2F;字符串</td><td>从当前光标位置向下查找（n,N查找内容切换）</td></tr><tr><td>?字符串</td><td>从当前光标位置向上查找（n,N查找内容切换）</td></tr></tbody></table><p><strong>插入模式</strong>（Insert Mode）</p><p><strong>按 <code>i</code>、<code>a</code>、<code>o</code> 等从普通模式进入插入模式。</strong></p><p><strong>作用</strong>：输入文字、写代码、编辑内容。</p><p>常用进入方式：</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>i</code></td><td>在光标前插入</td></tr><tr><td><code>a</code></td><td>在光标后插入</td></tr><tr><td><code>o</code></td><td>在当前行下方新开一行并插入</td></tr><tr><td><code>I</code></td><td>跳到行首插入</td></tr><tr><td><code>A</code></td><td>跳到行尾插入</td></tr></tbody></table><p><strong>退出插入模式</strong>：按 <code>Esc</code> 返回普通模式。</p><p><strong>命令模式</strong>（Command-Line Mode）</p><p><strong>按 <code>:</code> 从普通模式进入命令模式。</strong></p><p>用于输入各种操作命令，如保存、退出、查找、替换等。</p><p>常用命令：</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>:w</code></td><td>保存</td></tr><tr><td><code>:q</code></td><td>退出</td></tr><tr><td><code>:wq</code> 或 <code>ZZ</code></td><td>保存并退出</td></tr><tr><td><code>:q!</code></td><td>强制退出（不保存）</td></tr><tr><td><code>:x</code></td><td>等同于 <code>:wq</code></td></tr><tr><td><code>:/关键字</code></td><td>向下查找关键字</td></tr><tr><td><code>:s/旧/新/g</code></td><td>当前行替换所有匹配项</td></tr><tr><td>:1,10s&#x2F;abc&#x2F;123&#x2F;g</td><td>把第一行到第十行之间的abc全部替换为123</td></tr><tr><td><code>:%s/旧/新/g</code></td><td>全文替换所有匹配项</td></tr><tr><td>:w filename</td><td>保存到指定文件（绝对路径）</td></tr><tr><td>:sp 文件名</td><td>当前文件和另一个文件水平分屏</td></tr><tr><td>:vsp 文件名</td><td>当前文件和另一个文件垂直分屏</td></tr><tr><td>ctrl+w+w</td><td>在多个窗口切换光标</td></tr></tbody></table><h2 id="gcc编译器"><a href="#gcc编译器" class="headerlink" title="gcc编译器"></a>gcc编译器</h2><p>GCC（<strong>GNU Compiler Collection</strong>）是由 GNU 项目开发的一组编译器，最初是为了 C 语言开发的，现在支持多种编程语言</p><p>gcc编译器从拿到一个c源文件到生成一个可执行文件，中间一共经历了四个步骤：</p><p><img src="/2025/06/20/Linux-System%20Programming/2.png" alt="2" loading="lazy"></p><pre class="language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-E</span> hello.c <span class="token parameter variable">-o</span> hello.igcc <span class="token parameter variable">-S</span> hello.i <span class="token parameter variable">-o</span> hello.sgcc <span class="token parameter variable">-c</span> hello.s <span class="token parameter variable">-o</span> hello.ogcc hello.o <span class="token parameter variable">-o</span> hello./hello <span class="token comment">#执行</span>gcc 源文件 <span class="token parameter variable">-o</span> 可执行文件 <span class="token comment">#一步到位</span>gcc hello.c <span class="token parameter variable">-o</span> hello./hello</code></pre><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-o</code></td><td>指定输出文件名</td></tr><tr><td><code>-Wall</code></td><td>打开所有警告信息</td></tr><tr><td><code>-g</code></td><td>生成调试信息，用于 GDB 调试</td></tr><tr><td><code>-O0/-O1/-O2/-O3</code></td><td>优化等级（0 表示无优化）</td></tr><tr><td><code>-c</code></td><td>只编译不链接，生成 <code>.o</code> 目标文件</td></tr><tr><td><code>-I</code></td><td>添加头文件搜索路径</td></tr><tr><td><code>-L</code></td><td>添加库文件搜索路径</td></tr><tr><td><code>-l</code></td><td>链接指定的库（例如 <code>-lm</code> 表示链接 <code>math</code> 库）</td></tr><tr><td>-v&#x2F;–version</td><td>查看gcc版本号</td></tr><tr><td>-D</td><td>编译时定义宏</td></tr></tbody></table><pre class="language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-Wall</span> test.c <span class="token comment">#显示所有的警告信息</span>gcc <span class="token parameter variable">-Wall</span> <span class="token parameter variable">-Werror</span> test.c <span class="token comment">#把警告信息当作错误处理</span>gcc tmp.c <span class="token parameter variable">-DDEBUG</span> <span class="token comment">#可以用来区分测试版和发布版,DEBUG是定义的宏</span></code></pre><h2 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h2><p>静态链接：由链接器在<strong>链接</strong>时把<strong>库的内容加入到可执行程序中。</strong></p><p>优点：对运行环境的依赖较小，具有较好的兼容性。</p><p>缺点：生成的程序比较大，在装入内存消耗更多的时间。库函数有了更新，必须重新编译。</p><p>动态链接：链接器在<strong>链接时仅仅建立和所需库函数的链接关系，在程序运行时才将所需资源调入可执行程序</strong>。</p><p>优点：在需要的时候才会调入对应的资源函数。简化程序的升级，有着较小的程序体积，实现进程间的资源共享（避免重复拷贝）</p><p>缺点：依赖动态库，不能独立运行，动态库依赖版本问题严重。</p><h3 id="静态和动态编译对比"><a href="#静态和动态编译对比" class="headerlink" title="静态和动态编译对比"></a>静态和动态编译对比</h3><p>我们编写的应用程序大量用到了库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入-static参数。</p><pre class="language-bash" data-language="bash"><code class="language-bash">gcc test.c <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>gcc <span class="token parameter variable">-static</span> test.c <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span></code></pre><p>静态编译是要比动态编译程序大的多。</p><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。按照习惯，一般以”.a”作为文件后缀名。静态库的命名一般分为三个部分：前缀：lib,库名称：自己定义。后缀：.a。最终静态库的名字为libxxx.a</p><h3 id="静态库制作："><a href="#静态库制作：" class="headerlink" title="静态库制作："></a>静态库制作：</h3><p><img src="/2025/06/20/Linux-System%20Programming/3.png" alt="3" loading="lazy"></p><pre class="language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-c</span> add.c <span class="token parameter variable">-o</span> add.o <span class="token comment">#-c是只编译不链接输出.o文件</span>gcc <span class="token parameter variable">-c</span> sub.c <span class="token parameter variable">-o</span> sub.ogcc <span class="token parameter variable">-c</span> mul.c <span class="token parameter variable">-o</span> mul.ogcc <span class="token parameter variable">-c</span> div.c <span class="token parameter variable">-o</span> dic.oar <span class="token parameter variable">-rcs</span> libtest.a add.o sub.o mul.o div.o<span class="token comment">#使用打包工具ar将准备好的.o文件打包为.a文件libtest.a</span></code></pre><p>在使用ar工具需要添加参数：rcs </p><p>r更新，c创建，s建立索引</p><h3 id="静态库使用："><a href="#静态库使用：" class="headerlink" title="静态库使用："></a>静态库使用：</h3><p>静态库制作完成之后，需要将.a文件和头文件一起发布给用户。假设测试文件是main.c,静态库文件为libtest.a，头文件为head.h</p><p>编译命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash">gcc main.c -L./ -I./ <span class="token parameter variable">-ltest</span> <span class="token parameter variable">-o</span> main<span class="token comment">#注意这里链接库的名字</span></code></pre><p>-L：表示要连接的库所在目录。</p><p>-ltest:指定链接时需要的库，去掉前缀和后缀</p><p>-I(这里是大写的i):表示要连接的头文件目录</p><h3 id="动态库制作"><a href="#动态库制作" class="headerlink" title="动态库制作"></a>动态库制作</h3><p>共享库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</p><p>动态库在程序运行时才被载入，也解决了静态库对程序的更新，部署和发布的再次编译的问题，用户只需要更新动态库即可，增量更新。</p><p>一般以”.so”作为文件后缀名。共享库的命名一般分为三个部分：前缀lib,库名称:自己定义，后缀：.so。所以最终的动态库的名字应该为：libxxx.so。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#生成目标文件，此时要加编译选项：-fPIC(fpic)参数-fPIC创建与地址无关的编译程序（pic,position independent code）,是为了能在多个应用程序间共享。</span>gcc <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-c</span> add.cgcc <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-c</span> sub.cgcc <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-c</span> mul.cgcc <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-c</span> div.c<span class="token comment">#生成共享库，此时要加链接器选项：-shared(指定生成动态链接库)</span>gcc <span class="token parameter variable">-shared</span> add.o sub.o mul.o div.o <span class="token parameter variable">-o</span> libtest.so<span class="token comment">#通过nm命令查看对应的函数</span>nm libtest.so <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"add"</span><span class="token comment">#通过ldd命令查看可执行文件依赖的动态库</span>ldd <span class="token builtin class-name">test</span></code></pre><h3 id="动态库使用"><a href="#动态库使用" class="headerlink" title="动态库使用"></a>动态库使用</h3><p>引用动态库编译成可执行文件（和静态库一样）</p><pre class="language-bash" data-language="bash"><code class="language-bash">gcc main.c -L./ -I./ <span class="token parameter variable">-ltest</span> <span class="token parameter variable">-o</span> main<span class="token comment">#注意这里链接库的名字</span></code></pre><p>这一步是可以过的，但是到了，执行main时发现找不到对应文件。第一种就是把libtest.so复制到&#x2F;lib里（需要sudo,这个方法不推荐，最好不要动Linux原本文件，覆盖了就不好玩了。）</p><pre class="language-bash" data-language="bash"><code class="language-bash">gcc main.c -I./ <span class="token parameter variable">-ltest</span> <span class="token parameter variable">-o</span> main<span class="token comment">#注意这里链接库的名字,执行可执行文件就可以执行了，这种方法不推荐</span></code></pre><h3 id="动态库加载失败问题解决"><a href="#动态库加载失败问题解决" class="headerlink" title="动态库加载失败问题解决"></a>动态库加载失败问题解决</h3><p>当系统加载可执行代码，能够知道其所依赖的库的名字，但还需要知道其绝对路径。此时就需要系统动态载入器（dynamic linker&#x2F;loader）。对于elf格式的可执行程序，是由ld-linux.so*来完成，他先后搜索elf文件的DT_RPATH段—环境变量LD_LIBRARY_PATH—&#x2F;etc&#x2F;ld.so.cache文件列表—&#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib目录找到库文件后将其载入内存。</p><p>拷贝自己制作的共享库到&#x2F;lib或者&#x2F;usr&#x2F;lib(不能是&#x2F;lib64目录)</p><p>临时设置LD_LIBRARY_PATH(只在当前终端生效):</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:库路径<span class="token comment">#在原环境变量追加新的变量，库路径为绝对路径。</span></code></pre><p>永久设置:把export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:库路径这段话，设置到~&#x2F;.bashrc </p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.bashrc <span class="token comment">#让配置文件生效</span></code></pre><p>除了以上三种还有两种将其添加到&#x2F;etc&#x2F;ld.so.conf,这里只需要添加绝对路径，然后sudo ldconfig -v使路径生效。</p><p>还有使用符号链接，但一定要使用绝对路径。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> 库文件的绝对路径 /lib/库文件</code></pre><h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2><p>GDB主要完成下面四个功能：</p><p>1.启动程序，可以按照你的自定义的要求随心所欲的运行程序。</p><p>2.可让被调试的程序在你指定的断点停住。</p><p>3.当程序被停住时，可以检查此时你的程序中所发生的事。</p><p>4.动态的改变你程序的执行环境。</p><h3 id="生成调试信息"><a href="#生成调试信息" class="headerlink" title="生成调试信息"></a>生成调试信息</h3><p>一般来说GDB主要调试的是C&#x2F;C++的程序，要调试C&#x2F;C++的程序，首先在编译时，我们必须把调试信息加到可执行文件中。使用编译器（cc&#x2F;gcc&#x2F;g++）的-g参数可以做到这一点。</p><pre class="language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-g</span> hello.c <span class="token parameter variable">-o</span> hellog++ <span class="token parameter variable">-g</span> hello.c <span class="token parameter variable">-o</span> hello</code></pre><h3 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h3><p>启动gdb:<strong>gdb program</strong></p><p>program也就是你的执行文件，一般在当前目录下。</p><p>设置启动参数:启动后设置</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> args <span class="token comment">#可指定运行参数</span><span class="token builtin class-name">set</span> args <span class="token number">10</span> <span class="token number">20</span> <span class="token number">30</span> <span class="token number">40</span> <span class="token string">"hello world"</span>show args <span class="token comment">#命令可以查看设置好的运行参数</span></code></pre><p><strong>启动程序：</strong></p><p>run:程序开始执行，如果有断点，停在第一个断点处。</p><p>start:程序向下执行一行。</p><p>n:执行下一步。</p><h3 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h3><p>用list（也可直接打l）命令来打印程序的源代码。默认打印10行。</p><pre class="language-bash" data-language="bash"><code class="language-bash">list <span class="token keyword">function</span><span class="token comment">#显示函数名为function的函数的源码</span><span class="token builtin class-name">set</span> listsize count <span class="token comment">#设置一次显示源码的行数默认是10行</span>show listsize <span class="token comment">#查看当前listsize的设置</span></code></pre><h3 id="断点操作"><a href="#断点操作" class="headerlink" title="断点操作"></a>断点操作</h3><p>简单断点:</p><p>break设置断点，可以简写为b</p><pre class="language-bash" data-language="bash"><code class="language-bash">b <span class="token number">10</span> <span class="token comment">#设置断点，在源程序第十行</span>b func <span class="token comment">#设置断点，在func函数入口处</span></code></pre><p>多文件设置断点</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">break</span> filename:linenum <span class="token comment">#在源文件filename的linenum行处停住</span><span class="token builtin class-name">break</span> filename:function <span class="token comment">#在源文件filename的function函数的入口处停住</span><span class="token builtin class-name">break</span> class::function或者function<span class="token punctuation">(</span>type,type<span class="token punctuation">)</span> <span class="token comment">#在类class的function函数入口处停住</span><span class="token builtin class-name">break</span> namespace::class::function <span class="token comment">#在名称空间为namespace的类class的function函数的入口处停住。</span></code></pre><p>查询所有断点</p><pre class="language-bash" data-language="bash"><code class="language-bash">info binfo <span class="token builtin class-name">break</span>i <span class="token builtin class-name">break</span>i b</code></pre><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。</p><p>设置一个条件断点：</p><pre class="language-bash" data-language="bash"><code class="language-bash">b test.c:8 <span class="token keyword">if</span> Value <span class="token operator">==</span> <span class="token number">5</span> <span class="token comment">#对test.c文件的当变量Value满足为5时，在test.c文件的第8行产生断点</span></code></pre><h3 id="维护断点"><a href="#维护断点" class="headerlink" title="维护断点"></a>维护断点</h3><p>delete 范围 删除指定的断点，其简写命令为d。如果不指定断点号，则表示删除所有的断点。</p><pre class="language-bash" data-language="bash"><code class="language-bash">d <span class="token number">10</span>-12 <span class="token comment">#删除编号为10-12的断点。编号可以使用i b命令查看</span></code></pre><p>比删除更好的一种方法时disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可。</p><pre class="language-bash" data-language="bash"><code class="language-bash">disable 断点编号 <span class="token comment">#使指定断点无效，简写命令是dis。如果什么都不指定，表示disable所有的停止点。</span><span class="token builtin class-name">enable</span> 断点编号 <span class="token comment">#使无效断点生效，简写命令是ena。如果什么都不指定，表示enable所有的停止点</span></code></pre><h3 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h3><pre class="language-bash" data-language="bash"><code class="language-bash">run <span class="token comment">#运行程序，可简写为r。程序开始执行，如果有断点，停在第一个断点处。</span>next <span class="token comment">#单步跟踪，函数调用当作一条简单语句执行，可简写为n。</span>step <span class="token comment">#单步跟踪，函数调用进入被调用函数体内，可简写为s。</span>finish <span class="token comment">#退出进入的函数</span><span class="token keyword">until</span> <span class="token comment">#在一个循环体单步跟踪时，这个命令可以运行程序直到退出循环体，可简写为u。</span><span class="token builtin class-name">continue</span> <span class="token comment">#继续运行程序，停在下一个断点的位置，可简写为c。</span>quit <span class="token comment">#退出gdb,可简写为q。</span></code></pre><h3 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看运行时的数据</span><span class="token comment">#print打印变量，字符串，表达式等的值，可简写为p。</span>p count <span class="token comment">#打印count的值</span></code></pre><h3 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h3><p>可以设置一些自动显示的变量，当程序停住时，或在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display</p><pre class="language-bash" data-language="bash"><code class="language-bash">display 变量名 <span class="token comment">#在run启动程序后，使用该命令。</span>info display <span class="token comment">#查看display设置的自动显示的信息（可以看到对应变量名的编号）</span>undisplay num <span class="token comment">#info display是显示的编号 使对应编号的自动显示功能失效。</span>delete display dnums <span class="token comment">#删除自动显示，dnums意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围的编号，可以用减号表示。</span>disable display dnums<span class="token builtin class-name">enable</span> display dnumsdisable和enable<span class="token comment">#不删除自动显示的设置，而只是让其失效和恢复。</span></code></pre><h3 id="查看修改变量的值"><a href="#查看修改变量的值" class="headerlink" title="查看修改变量的值"></a>查看修改变量的值</h3><pre class="language-bash" data-language="bash"><code class="language-bash">ptype width <span class="token comment">#查看变量width的类型</span>p width <span class="token comment">#打印变量width的值 p是print命令的缩写。</span><span class="token builtin class-name">set</span> var <span class="token assign-left variable">width</span><span class="token operator">=</span><span class="token number">47</span> <span class="token comment">#将变量var值设置为47。在改变程序变量取值时，最好都使用set var格式的GDB命令。</span></code></pre><h2 id="自动化编译工具Makefile"><a href="#自动化编译工具Makefile" class="headerlink" title="自动化编译工具Makefile"></a>自动化编译工具Makefile</h2><p>make是个命令工具。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">make</span> <span class="token comment">#下载make命令</span></code></pre><h3 id="Makefile语法规则"><a href="#Makefile语法规则" class="headerlink" title="Makefile语法规则"></a>Makefile语法规则</h3><p>一条规则：</p><pre class="language-bash" data-language="bash"><code class="language-bash">目标：依赖文件列表<span class="token operator">&lt;</span>Tab<span class="token operator">></span>命令列表</code></pre><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span>test1 test2echo <span class="token string">"hello all"</span><span class="token target symbol">test1</span><span class="token punctuation">:</span>echo <span class="token string">"hello test1"</span><span class="token target symbol">test2</span><span class="token punctuation">:</span>echo <span class="token string">"hello test2"</span><span class="token comment">#总共三条规则</span><span class="token comment">#执行结果：make -f 1.mk</span>echo <span class="token string">"hello test1"</span>hello test1echo <span class="token string">"hello test2"</span>hello test2echo <span class="token string">"hello all"</span>hello all</code></pre><p>Makefile基本规则三要素：</p><p>目标:</p><p>​通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作的名称。</p><p>依赖文件：</p><p>​用来输入从而产生目标的文件。</p><p>​一个目标通常有几个依赖文件（可以没有）</p><p>命令：</p><p>​make执行的动作，一个规则可以含几个命令（可以没有）</p><p>​有多个命令，每个命令占一行。</p><h3 id="make命令格式"><a href="#make命令格式" class="headerlink" title="make命令格式"></a>make命令格式</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token punctuation">[</span>-f file<span class="token punctuation">]</span><span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">[</span>targets<span class="token punctuation">]</span><span class="token punctuation">[</span>-f file<span class="token punctuation">]</span>:make默认在工作目录中寻找为GNUmakefile,makefile,Makefile的文件作为makefile输入文件。-f可以指定以上名字以外的文件作为makefile输入文件。<span class="token punctuation">[</span>options<span class="token punctuation">]</span>:<span class="token parameter variable">-v</span> 显示make工具的版本<span class="token parameter variable">-w</span> 在处理makefile之前和之后显示工作路径<span class="token parameter variable">-C</span> <span class="token function">dir</span> 读取makefile之前改变工作路径至dir目录<span class="token parameter variable">-n</span> 只打印要执行的命令但不执行<span class="token parameter variable">-s</span> 执行但不显示执行的命令<span class="token punctuation">[</span>targets<span class="token punctuation">]</span>:若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个规则指定了make工具要实现的目标，目标可以是一个或多个（多个目标用空格隔开）<span class="token function">make</span> test1 <span class="token parameter variable">-f</span> <span class="token number">1</span>.mk <span class="token comment">#就会执行目标为test1对应的语句。</span></code></pre><h3 id="Makefile示例"><a href="#Makefile示例" class="headerlink" title="Makefile示例"></a>Makefile示例</h3><p>测试程序：test.c add.c sub.c mul.c div.c add.h sub.h mul.h div.h</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#最简单的Makefile(首先vim Makefile)</span><span class="token target symbol">test</span><span class="token punctuation">:</span>test.c add.c sub.c mul.c div.cgcc test.c add.c sub.c mul.c div.c -o test</code></pre><p>缺点：效率低，修改一个文件，所有文件都要重新编译。</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">test</span><span class="token punctuation">:</span>test.o add.o sub.o mul.o div.o gcc test.o add.o sub.o mul.o div.o -o test<span class="token target symbol">add.o</span><span class="token punctuation">:</span>add.cgcc -c add.c -o add.o<span class="token target symbol">sub.o</span><span class="token punctuation">:</span>sub.cgcc -c sub.c -o sub.o<span class="token target symbol">mul.o</span><span class="token punctuation">:</span>mul.cgcc -c mul.c -o mul.o<span class="token target symbol">div.o</span><span class="token punctuation">:</span>div.cgcc -c div.c -o div.o<span class="token target symbol">test.o</span><span class="token punctuation">:</span>test.cgcc -c test.c -o test.o</code></pre><p>这样，下次编译，他只会编译你修改的文件，最后再链接，这样是比较高效的。</p><h3 id="Makefile中的变量"><a href="#Makefile中的变量" class="headerlink" title="Makefile中的变量"></a>Makefile中的变量</h3><p>在Makefile中使用变量有点类似c语言的宏定义，使用该变量相当于内容替换，使用变量可以使Makefile易于维护。如果.o文件很多，难道我们要一个一个打吗，这也未免太麻烦，还可能漏打。</p><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><p>定义变量：</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">变量名<span class="token operator">=</span>变量值</code></pre><p>引用变量：</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span>变量名<span class="token punctuation">)</span>或<span class="token variable">$</span><span class="token punctuation">&#123;</span>变量名<span class="token punctuation">&#125;</span></code></pre><p>makefile的变量名：</p><p>makefile变量名可以以数字开头。</p><p>变量是大小写敏感的。</p><p>变量一般在makefile的头部定义</p><p>变量几乎可在makefile的任何地方使用</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">OBJS <span class="token operator">=</span> test.o add.o sub.o mul.o div.o<span class="token target symbol">test</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> -o test<span class="token target symbol">add.o</span><span class="token punctuation">:</span>add.cgcc -c add.c -o add.o<span class="token target symbol">sub.o</span><span class="token punctuation">:</span>sub.cgcc -c sub.c -o sub.o<span class="token target symbol">mul.o</span><span class="token punctuation">:</span>mul.cgcc -c mul.c -o mul.o<span class="token target symbol">div.o</span><span class="token punctuation">:</span>div.cgcc -c div.c -o div.o<span class="token target symbol">test.o</span><span class="token punctuation">:</span>test.cgcc -c test.c -o test.o</code></pre><p>除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户使用，我们可以直接对其进行赋值。</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">CC<span class="token operator">=</span>gcc<span class="token target symbol">CPPFLAGS</span><span class="token punctuation">:</span><span class="token target symbol">CFLAGS</span><span class="token punctuation">:</span><span class="token target symbol">LDFLAGS</span><span class="token punctuation">:</span></code></pre><h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#这些变量不能单独使用 必须在命令中使用</span><span class="token comment"># $@ 表示目标</span><span class="token comment"># $^ 表示所有的依赖</span><span class="token comment"># $&lt; 表示第一个依赖</span></code></pre><pre class="language-makefile" data-language="makefile"><code class="language-makefile">OBJS <span class="token operator">=</span> test.o add.o sub.o mul.o div.oTARGET<span class="token operator">=</span>test<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>gcc <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token target symbol">add.o</span><span class="token punctuation">:</span>add.cgcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol">sub.o</span><span class="token punctuation">:</span>sub.cgcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol">mul.o</span><span class="token punctuation">:</span>mul.cgcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol">div.o</span><span class="token punctuation">:</span>div.cgcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol">test.o</span><span class="token punctuation">:</span>test.cgcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span></code></pre><h4 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h4><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#模式规则匹配示例</span><span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.c<span class="token variable">$</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span></code></pre><pre class="language-makefile" data-language="makefile"><code class="language-makefile">OBJS<span class="token operator">=</span>test.o add.o sub.o mul.o div.oTARGET<span class="token operator">=</span>test<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token comment">#模式匹配 所有的.o都依赖对应的.c</span><span class="token comment">#将所有的.c生成对应的.o</span><span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.cgcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span></code></pre><h3 id="Makefile的函数"><a href="#Makefile的函数" class="headerlink" title="Makefile的函数"></a>Makefile的函数</h3><p>常用的函数</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">wildcard <span class="token comment">#查找指定目录下的指定类型的文件</span>src<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.c<span class="token punctuation">)</span> <span class="token comment">#找到当前目录下所有后缀为.c的文件，赋值给src</span>patsubst <span class="token comment">#匹配替换</span>obj<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,<span class="token variable">$</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#把src变量里所有后缀为.c的文件替换成.o</span></code></pre><p>在makefile中所有的函数都是有返回值的。</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#获取当前目录下所有的.c文件</span>SRC<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> ./*.c<span class="token punctuation">)</span><span class="token comment">#将SRC中所有出现的.c的替换成.o</span>OBJS<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,<span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span class="token punctuation">)</span>TARGET<span class="token operator">=</span>test<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token comment">#模式匹配 所有的.o都依赖对应的.c</span><span class="token comment">#将所有的.c生成对应的.o</span><span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.cgcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token comment">#clean目标清除编译生成的中间文件</span><span class="token comment">#执行命令 make clean</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span></code></pre><h3 id="Makefile中的伪目标"><a href="#Makefile中的伪目标" class="headerlink" title="Makefile中的伪目标"></a>Makefile中的伪目标</h3><p>clean用途：清除编译生成的中间.o文件和最终目标文件</p><p>make clean 如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：</p><p>伪目标声明：.PHONY:clean 声明目标为伪目标之后，makefile将不会判断目标是否存在或者该目标是否需要更新。</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#获取当前目录下所有的.c文件</span>SRC<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> ./*.c<span class="token punctuation">)</span><span class="token comment">#将SRC中所有出现的.c的替换成.o</span>OBJS<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,<span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span class="token punctuation">)</span>TARGET<span class="token operator">=</span>test<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span><span class="token comment">#模式匹配 所有的.o都依赖对应的.c</span><span class="token comment">#将所有的.c生成对应的.o</span><span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.cgcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token comment">#clean目标清除编译生成的中间文件</span><span class="token comment">#执行命令 make clean</span><span class="token comment">#声明clean为伪目标</span><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>clean<span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span></code></pre><p>上面这个版本就是最终版。</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token operator">@</span>gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span> <span class="token comment">#在命令前加上@符号，表示不显示命令本身（默认显示），只显示结果</span>-gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span> <span class="token comment">#加上-符号，此条命令出错，make也会继续执行后续的命令。</span></code></pre><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用说的是操作系统提供给用户程序调用的一组”特殊”接口</p><h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h3><p>Linux下对文件操作有两种方式：系统调用和库函数调用</p><p>库函数调用有两类函数组成：</p><p>不需要系统调用：不需要切换到内核空间即可完成函数全部功能，并且结果反馈给应用程序，如strcpy,bzero等字符串操作函数。</p><p>需要调用系统调用：需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如printf,fread等。</p><p><img src="/2025/06/20/Linux-System%20Programming/4.png" alt="4" loading="lazy"></p><h3 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h3><p>errno是记录系统的最后一次错误代码，代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。</p><p>当Linux C api函数出现异常时，一般会将errno全局变量赋一个整数值。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> <span class="token comment">//fopen</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span> <span class="token comment">//errno</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span> <span class="token comment">//strerror(errno)</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    FILE <span class="token operator">*</span>fp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"xxxx"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fp<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//打印错误码</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把errno的数字转换为相应的文字</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fopen err"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印错误原因的字符串</span>        <span class="token comment">//perror和printf("%d\n",strerror(errno));实现效果相同。</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>每个进程都会分配虚拟地址空间，在32位机器上，该地址空间为4G。Linux每个运行的程序（进程），操作系统就会为其分配一个0<del>4G的地址空间（虚拟地址空间）。0</del>3G是用户区，3G~4G是内核区。在进程里平时所说的指针变量，保存的就是虚拟地址，当应用程序使用虚拟地址访问内存时，处理器会将其转换为物理地址（MMU）MMU将虚拟地址转换为物理地址。这样做的好处在于：进程隔离，更好的保护系统安全运行，屏蔽物理差异带来的麻烦，方便操作系统和编译器安排进程地址。</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>打开现存文件或新建文件时，系统内核会返回一个文件描述符，文件描述符用来指定已打开的的文件。这个文件描述符相当于已打开文件的标号，文件描述符是非负整数，是文件的标识，操作这个文件描述符相当于操作这个描述符所指定的文件。</p><p>程序运行起来后（每个进程）都有一张文件描述符的表，标准输入，标准输出，标准错误输出设备文件被打开，对应的文件描述符0，1，2记录在表中。程序运行起来后这三个文件描述符是默认打开的。</p><p>在程序运行起来后，打开其他文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中。</p><h4 id="最大打开的文件个数："><a href="#最大打开的文件个数：" class="headerlink" title="最大打开的文件个数："></a>最大打开的文件个数：</h4><p>​Linux中一个进程最多只能打开NR_OPEN_DEFAULT(即1024)个文件（当然这个数量的设定是可以修改的），故当文件不再使用时应该及时调用close()函数关闭文件。</p><h3 id="常用文件IO函数"><a href="#常用文件IO函数" class="headerlink" title="常用文件IO函数"></a>常用文件IO函数</h3><h4 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span><span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span><span class="token keyword">int</span> flags<span class="token punctuation">,</span><span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>功能：</p><p>​打开文件，如果文件不存在则可以选择创建。</p><h4 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span></code></pre><p>功能：</p><p>​关闭已打开的文件。</p><p>需要说明的是，当一个进程终止时，内核对该进程所有未关闭的文件描述符调用close关闭，所以即使用户程序不调用close,在终止时内核也会自动关闭它打开的文件。</p><p>但是对于一个常年累月的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量的文件描述符和系统资源。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/type.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h></span></span><span class="token comment">//打开和关闭文件</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//以只读的方式打开一个文件，如果文件不存在就报错。</span>    <span class="token comment">//fd=open("txt",O_RDONLY);</span>    <span class="token comment">//以只写的方式打开一个文件 如果文件存在就直接打开 如果文件不存在就新建一个文件。</span>    <span class="token comment">//fd=open("txt",O_WRONLY|O_CREAT,644);</span>    <span class="token comment">//以只写的方式打开一个文件，如果文件存在就报错，如果文件不存在就新建一个。</span>    <span class="token comment">//fd=open("txt",O_WRONLY|O_CREAT|O_EXCL,644);</span>    <span class="token comment">//以读写方式打开一个文件，如果文件存在就打开，如果文件不存在就新建一个文件。</span>    <span class="token comment">//fd=open("txt",O_RDWR|O_CREAT,644);</span>    <span class="token comment">//O_TRUNC 清空文件内容,如果文件存在，打开并清空，不存在就新建一个文件。</span>    <span class="token comment">//fd=open("txt",O_WRONLY|O_TRUNC|O_CREAT,644);</span>    <span class="token comment">//O_APPEND 追加的方式</span>    <span class="token comment">//以只写的方式和追加的方式打开一个文件 如果文件不存在会报错。</span>    fd<span class="token operator">=</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"txt"</span><span class="token punctuation">,</span>O_WRONLY<span class="token operator">|</span>O_APPEND<span class="token punctuation">)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fd<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//关闭文件</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span><span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：    把指定数目的数据写到文件（fd）参数：    fd<span class="token operator">:</span> 文件描述符    buf<span class="token operator">:</span>数据首地址    count<span class="token operator">:</span>写入数据的长度（字节）返回值：    成功：实际写入数据的字节个数    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><h4 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span><span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：    把指定数目的数据读到内存（缓冲区）参数：    fd<span class="token operator">:</span>文件描述符    buf<span class="token operator">:</span>内存首地址    count<span class="token operator">:</span>读取的字节个数返回值：    成功：实际读取的字节个数    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><h4 id="阻塞和非阻塞的概念"><a href="#阻塞和非阻塞的概念" class="headerlink" title="阻塞和非阻塞的概念"></a>阻塞和非阻塞的概念</h4><p>读常规文件是不会阻塞，不管读多少字节，read一定会在有限的时间内返回。</p><p>从终端设备或网络则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会堵塞，如果网络上没有接受到数据包，调用read从网络读就会，至于会阻塞多久也是不确定的，如果没有一直收到数据到达就一直阻塞在那里。</p><p>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</p><p>阻塞和非阻塞是对于文件而言，而不是指read,write等的属性。</p><h4 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token class-name">off_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token class-name">off_t</span> offset<span class="token punctuation">,</span><span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：    改变文件的偏移量参数：    fd<span class="token operator">:</span>文件描述符    offset<span class="token operator">:</span>根据whence来移动的位移数（偏移量），可以是正数，也可以是负数，如果正数，则相对于whence往右移动，如果是负数则相对于whence向左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。    whence<span class="token operator">:</span>其取值如下：        <span class="token constant">SEEK_SET</span><span class="token operator">:</span>从文件开头移动offset个字节        <span class="token constant">SEEK_CUR</span><span class="token operator">:</span>从当前位置移动offset个字节        <span class="token constant">SEEK_END</span><span class="token operator">:</span>从文件末尾移动offset个字节返回值：   若lseek成功执行，则返回新的偏移量    如果失败，返回<span class="token operator">-</span><span class="token number">1</span></code></pre><p>所有打开的文件都有一个当前文件偏移量（current file offset）以下简称为cfo。cfo通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。</p><p>读写操作通常开始cfo,并且使cfo变大，增量为读写的字节数。文件被打开时，cfo会被初始化为0，除非使用了O_APPEND。</p><p>如果把文件偏移量移到最后，使用read函数，将不会读出数据。要将文件描述符提前移到开头或者其他可以读到的位置。所以要注意文件描述符的位置。</p><h3 id="文件操作相关函数"><a href="#文件操作相关函数" class="headerlink" title="文件操作相关函数"></a>文件操作相关函数</h3><h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">lstat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> pathname<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：获取文件状态信息    stat和lstat的区别：    当文件是一个符号链接时<span class="token punctuation">,</span>lstat返回的是该符号链接本身的信息；    而stat返回的是该链接指向的文件的信息。参数：    path<span class="token operator">:</span>文件名    buf<span class="token operator">:</span>保存文件信息的结构体返回值<span class="token operator">:</span>成功：<span class="token number">0</span>    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><p>stat函数和命令stat 文件名的功能类似。</p><p>struct stat *buf结构体</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token punctuation">&#123;</span>           <span class="token class-name">dev_t</span>      st_dev<span class="token punctuation">;</span>      <span class="token comment">/* ID of device containing file */</span>           <span class="token class-name">ino_t</span>      st_ino<span class="token punctuation">;</span>      <span class="token comment">/* Inode number */</span>           <span class="token class-name">mode_t</span>     st_mode<span class="token punctuation">;</span>     <span class="token comment">/* File type and mode */</span>           <span class="token class-name">nlink_t</span>    st_nlink<span class="token punctuation">;</span>    <span class="token comment">/* Number of hard links */</span>           <span class="token class-name">uid_t</span>      st_uid<span class="token punctuation">;</span>      <span class="token comment">/* User ID of owner */</span>           <span class="token class-name">gid_t</span>      st_gid<span class="token punctuation">;</span>      <span class="token comment">/* Group ID of owner */</span>           <span class="token class-name">dev_t</span>      st_rdev<span class="token punctuation">;</span>     <span class="token comment">/* Device ID (if special file) */</span>           <span class="token class-name">off_t</span>      st_size<span class="token punctuation">;</span>     <span class="token comment">/* Total size, in bytes */</span>           <span class="token class-name">blksize_t</span>  st_blksize<span class="token punctuation">;</span>  <span class="token comment">/* Block size for filesystem I/O */</span>           <span class="token class-name">blkcnt_t</span>   st_blocks<span class="token punctuation">;</span>   <span class="token comment">/* Number of 512 B blocks allocated */</span>           <span class="token comment">/* Since POSIX.1-2008, this structure supports nanosecond              precision for the following timestamp fields.              For the details before POSIX.1-2008, see VERSIONS. */</span>           <span class="token keyword">struct</span> <span class="token class-name">timespec</span>  st_atim<span class="token punctuation">;</span>  <span class="token comment">/* Time of last access */</span>           <span class="token keyword">struct</span> <span class="token class-name">timespec</span>  st_mtim<span class="token punctuation">;</span>  <span class="token comment">/* Time of last modification */</span>           <span class="token keyword">struct</span> <span class="token class-name">timespec</span>  st_ctim<span class="token punctuation">;</span>  <span class="token comment">/* Time of last status change */</span>       <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">st_atime</span>  <span class="token expression">st_atim<span class="token punctuation">.</span>tv_sec  </span><span class="token comment">/* Backward compatibility */</span></span>       <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">st_mtime</span>  <span class="token expression">st_mtim<span class="token punctuation">.</span>tv_sec</span></span>       <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">st_ctime</span>  <span class="token expression">st_ctim<span class="token punctuation">.</span>tv_sec</span></span>       <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">stat</span> s<span class="token punctuation">;</span>        <span class="token comment">//获取指定文件信息</span>        ret<span class="token operator">=</span><span class="token function">stat</span><span class="token punctuation">(</span><span class="token string">"txt"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"stat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//文件属性信息</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"st_dev:%lu\n"</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span>st_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"st_ino:%ld\n"</span><span class="token punctuation">,</span>s<span class="token punctuation">.</span>st_ino<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p> st_mode;可以获取文件类型和文件三种用户的权限。</p><h4 id="access函数"><a href="#access函数" class="headerlink" title="access函数"></a>access函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">access</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> pathname<span class="token punctuation">,</span><span class="token keyword">int</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：测试指定文件是否具有某种属性参数：    pathname<span class="token operator">:</span>文件名    mode<span class="token operator">:</span>文件权限，<span class="token number">4</span>种权限（判断文件所属者）        R_OK<span class="token operator">:</span>是否有读权限        W_OK<span class="token operator">:</span>是否有写权限        X_OK<span class="token operator">:</span>是否有执行权限        F_OK<span class="token operator">:</span>测试文件是否存在返回值：     <span class="token number">0</span>：有某种权限，或者文件存在     <span class="token operator">-</span><span class="token number">1</span>：没有，或者文件不存在</code></pre><h4 id="chmod函数"><a href="#chmod函数" class="headerlink" title="chmod函数"></a>chmod函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token keyword">int</span> <span class="token function">chmod</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>pathname<span class="token punctuation">,</span><span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：修改文件权限参数：    pathname<span class="token operator">:</span>文件名    mode<span class="token operator">:</span>权限（<span class="token number">8</span>进制数）返回值：    成功：<span class="token number">0</span>    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><h4 id="chown函数"><a href="#chown函数" class="headerlink" title="chown函数"></a>chown函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">chown</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span><span class="token class-name">uid_t</span> owner<span class="token punctuation">,</span><span class="token class-name">gid_t</span> group<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：修改文件所有者和所属组参数：    pathname<span class="token operator">:</span>文件或目录名    owner<span class="token operator">:</span>文件所有者id，通过查看<span class="token operator">/</span>etc<span class="token operator">/</span>passwd得到所有者id    group；文件所属组id<span class="token punctuation">,</span>通过查看<span class="token operator">/</span>etc<span class="token operator">/</span>group得到用户组id返回值：    成功：<span class="token number">0</span>    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><h4 id="truncate函数"><a href="#truncate函数" class="headerlink" title="truncate函数"></a>truncate函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token keyword">int</span> <span class="token function">truncate</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span><span class="token class-name">off_t</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：修改文件大小参数：    path<span class="token operator">:</span>文件名字    length<span class="token operator">:</span>指定的文件大小        比原来小，删掉后边的部分        比原来大，向后拓展返回值：    成功：<span class="token number">0</span>    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><h4 id="link函数"><a href="#link函数" class="headerlink" title="link函数"></a>link函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">link</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> oldpath<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>newpath<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：创建一个硬链接参数：    oldpath<span class="token operator">:</span>源文件名字    newpath<span class="token operator">:</span>硬链接名字返回值：   成功：<span class="token number">0</span>    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><h4 id="symlink函数"><a href="#symlink函数" class="headerlink" title="symlink函数"></a>symlink函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">symlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> target<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> linkpath<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：创建一个软链接参数：    target：源文件名字    linKpath<span class="token operator">:</span>软链接名字返回值：    成功：<span class="token number">0</span>    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><p>剩下的还有<strong>readlink函数</strong>，<strong>unlink函数</strong>，<strong>rename函数</strong></p><h3 id="文件描述符复制"><a href="#文件描述符复制" class="headerlink" title="文件描述符复制"></a>文件描述符复制</h3><p>dup()和dup2()是两个非常有用的系统调用，都是用来复制一个文件的描述符，使新的文件描述符也标识旧的文件描述符所标识的文件</p><p>对比于dup(),dup2()也一样，通过原来的文件描述符复制出一个新的文件描述符，这样的话，原来的文件描述符和新的文件描述符都指向同一个文件，我们操作这两个文件描述符的任何一个，都能操作它所对应的文件。</p><h4 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldfd<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：    通过oldfd复制出一个新的文件描述符，新的文件描述符使调用进程文件描述符表中最小可用的文件描述符，最终oldfd和新的文件描述符都指向同一个文件。参数：    oldfd<span class="token operator">:</span>需要复制的文件描述符oldfd返回值：    成功：新文件描述符    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><p>函数示例：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token comment">//dup dup2</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> fd<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> newfd<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//1.打开文件</span>        fd<span class="token operator">=</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"txt"</span><span class="token punctuation">,</span>O_RDWR<span class="token operator">|</span>O_CREAT<span class="token punctuation">,</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fd<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>newfd<span class="token operator">=</span><span class="token function">dup</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">==</span>newfd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"dup"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"newfd=%d\n"</span><span class="token punctuation">,</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.操作</span>        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"ABCDEFG"</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//因为这两个文件描述符共享一张文件表，所以当前文件的偏移量是共享的，所以下次不会覆盖而是追加</span>        <span class="token comment">//使用另外一个文件描述符</span>        <span class="token function">write</span><span class="token punctuation">(</span>newfd<span class="token punctuation">,</span><span class="token string">"1234567"</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.关闭文件描述符</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="dup2函数"><a href="#dup2函数" class="headerlink" title="dup2函数"></a>dup2函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">dup2</span><span class="token punctuation">(</span><span class="token keyword">int</span> oldfd<span class="token punctuation">,</span><span class="token keyword">int</span> newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：    通过oldfd复制出一个新的文件描述符newfd<span class="token punctuation">,</span>如果成功，newfd和函数返回值是同一个返回值，最终oldfd和新的文件描述符newfd都指向同一个文件。参数：    oldfd<span class="token operator">:</span>需要复制的文件描述符    newfd<span class="token operator">:</span>新的文件描述符，这个描述符可以人为指定一个合法数字（<span class="token number">0</span><span class="token operator">-</span><span class="token number">1023</span>），如果指定的数字已经被占用，此函数会自动关闭<span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>断开这个数字和某个文件的关联，再来使用这个合法数字。返回值：    成功：返回newfd    失败；返回<span class="token operator">-</span><span class="token number">1</span>。</code></pre><p>注意：这里有个场景，我有两个程序都是要打开同一个文件并且向里面写东西，当然这就有两个open函数，那我先后打开该文件，前者写的会被后者写的覆盖掉吗，这是会的。因为每次open函数都会把文件偏移量的位置放回0。但是dup函数和dup2函数不会，因为复制的文件描述符共享一个文件描述符表项的。</p><h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h></span></span><span class="token keyword">int</span> <span class="token function">fcntl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">int</span> cmd<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/*arg */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>功能：改变已打开的文件性质，fcntl针对描述符提供控制。参数：    fd<span class="token operator">:</span>操作的文件描述符    cmd<span class="token operator">:</span>操作方式    arg<span class="token operator">:</span>针对cmd的值，fcntl能够接受第三个参数<span class="token keyword">int</span> arg。返回值：    成功：返回某个其他值    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h></span></span><span class="token comment">//fcntl复制文件描述符功能</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> newfd<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//1.打开文件</span>    fd<span class="token operator">=</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"txt"</span><span class="token punctuation">,</span>O_WRONLY<span class="token operator">|</span>O_CREAT<span class="token punctuation">,</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>fd<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fd=%d\n"</span><span class="token punctuation">,</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2.文件描述符复制</span>    <span class="token comment">//功能等价于dup函数</span>    <span class="token comment">//第三个参数0 表示返回一个最小的可用的文件描述符，并且大于或者等于0</span>    newfd<span class="token operator">=</span><span class="token function">fcntl</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span>F_DUPFD<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">==</span>newfd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fcntl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"newfd=%d\n"</span><span class="token punctuation">,</span>newfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//3.写操作</span>    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span><span class="token string">"123456789"</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span>newfd<span class="token punctuation">,</span><span class="token string">"ABCDEFGH"</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//4.关闭文件</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>newfd<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>fcntl函数还可以改变文件状态标记。</p><h3 id="目录相关操作"><a href="#目录相关操作" class="headerlink" title="目录相关操作"></a>目录相关操作</h3><h4 id="getcwd函数"><a href="#getcwd函数" class="headerlink" title="getcwd函数"></a>getcwd函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">getcwd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：获取当前进程的工作目录参数：    buf<span class="token operator">:</span>缓冲区，存储当前的工作目录    size<span class="token operator">:</span>缓冲区大小返回值：    成功：buf中保存当前进程工作目录位置    失败：<span class="token constant">NULL</span></code></pre><h4 id="chdir函数"><a href="#chdir函数" class="headerlink" title="chdir函数"></a>chdir函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">chdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：修改当前进程（应用程序）的路径参数：    path<span class="token operator">:</span>切换的路径返回值：    成功：<span class="token number">0</span>    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><h4 id="opendir函数"><a href="#opendir函数" class="headerlink" title="opendir函数"></a>opendir函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;dirent.h></span></span>DIR <span class="token operator">*</span><span class="token function">opendir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：打开一个目录参数：    name<span class="token operator">:</span>目录名返回值：    成功：返回指向该目录结构体指针    失败：<span class="token constant">NULL</span></code></pre><h4 id="closedir函数"><a href="#closedir函数" class="headerlink" title="closedir函数"></a>closedir函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;dirent.h></span></span><span class="token keyword">int</span> <span class="token function">closedir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：关闭目录参数：    dirp<span class="token operator">:</span>opendir返回指针返回值：    成功：<span class="token number">0</span>    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><h4 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;dirent.h></span></span><span class="token keyword">struct</span> <span class="token class-name">dirent</span><span class="token operator">*</span> <span class="token function">readdir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：读取目录参数：    dirp<span class="token operator">:</span>opendir的返回值返回值：    成功：目录结构体指针    失败：<span class="token constant">NULL</span></code></pre><p><strong>readdir函数要读取目录所有内容是要循环读取。</strong> </p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h3><p>我们平时写的C语言代码，通过编译器编译，最终它会成为一个可执行程序，当这个可执行程序运行起来后（没有结束前），他就成为了一个进程。程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建，调度和消亡。程序是静态的，进程是动态的。</p><p>在Linux系统中，操作系统是通过进程去完成一个一个的任务，<strong>进程是管理事务的基本单元</strong>。</p><p>进程拥有自己独立的处理环境（当前需要用到那些环境变量，程序运行的目录在哪里，当前是哪个用户在运行此程序）和系统资源（处理器cpu占用率，存储器，I&#x2F;O设备，数据，程序）。</p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并行：指在同一时刻，有多条指令在多个处理器上同时执行。</p><p>并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><h3 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h3><p>MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器，物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。</p><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><p>进程运行时，内核为进程每个进程分配一个PCB(进程控制块)，维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p><p>这个结构体的内部成员有很多，我们要知道的：</p><ol><li>进程id。系统中每个进程有唯一的id,在C语言中用pid_t类型表示，其实就是一个非负整数。</li><li>进程的状态，有就绪，运行，挂起，停止等状态。</li><li>进程切换时需要保存和恢复的一些CPU寄存器。</li><li>描述虚拟地址空间的信息。</li><li>描述控制终端的信息。</li><li>当前工作目录。</li><li>umask掩码</li><li>文件描述符表，包含很多指向file结构体的指针。</li><li>和信号相关的信息。</li><li>用户id和组id</li><li>会话（Session）和进程组。</li><li>进程可以使用的资源上限（Resource Limit）。</li></ol><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。</p><p>在三态模型中，进程状态分为三个基本状态，即运行态，就绪态，阻塞态。</p><p>在五态模型中，进程分为新建态，终止态，运行态，就绪态，阻塞态。</p><p><img src="/2025/06/20/Linux-System%20Programming/5.png" alt="5" loading="lazy"></p><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。</p><p>ps命令可以查看进程的详细情况，常用选项（选项可以不加”-“）。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示终端上的所有进程，包括其他用户的进程</td></tr><tr><td><code>-u</code></td><td>显示进程的详细状态&#96;</td></tr><tr><td><code>-x</code></td><td>显示无控制终端的进程</td></tr><tr><td><code>-r</code></td><td>只显示正在运行的进程</td></tr></tbody></table><p>ps aux</p><p>ps ef和aux等价</p><p>ps -a</p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>用来动态显示运行中的进程。</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>kill命令指定进程号的进程，需要配合ps使用。</p><p>使用格式：</p><p>kill [-signal] pid</p><p>信号值从0-15，其中9为绝对终止，可以处理一般信号无法终止的进程。</p><p>有些进程不能直接杀死，这时候我们需要加一个参数”-9”,”-9”代表强制结束。</p><h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><p>通过进程名字杀死进程,进程名字是可以重复的。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">killall</span> <span class="token parameter variable">-9</span> <span class="token function">sleep</span></code></pre><h3 id="进程号和相关函数"><a href="#进程号和相关函数" class="headerlink" title="进程号和相关函数"></a>进程号和相关函数</h3><p>每个进程都由一个进程号来标识，其类型为pid_t（整型），进程号的范围：0~32767（2的15次方-1）。进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用。</p><h4 id="三个不同的进程号"><a href="#三个不同的进程号" class="headerlink" title="三个不同的进程号"></a>三个不同的进程号</h4><p><strong>进程号（PID）</strong>:</p><p>标识进程的一个非负整型数。</p><p><strong>父进程号（PPID）</strong>:<br>任何进程（除init进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号成为父进程号（PPID）。如A进程创建了B进程，A的进程号就是B进程的父进程号。</p><p><strong>进程组号（PGID）</strong>:</p><p>进程组是一个或多个进程的集合，他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当作当前的进程组号。</p><h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a>getpid函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token class-name">pid_t</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>功能：    获取本进程号（PID）参数：无返回值：本进程号</code></pre><h4 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a>getppid函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token class-name">pid_t</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>功能：获取调用此函数的进程的父进程号参数：无返回值：调用此函数的进程的父进程号（PPID）    </code></pre><h4 id="getpgid函数"><a href="#getpgid函数" class="headerlink" title="getpgid函数"></a>getpgid函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token class-name">pid_t</span> <span class="token function">getpgid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：获取进程组号（PGID）参数：    pid<span class="token operator">:</span>进程号返回值：    参数为<span class="token number">0</span>时返回当前进程组号，否则返回参数指定的进程的进程组号。</code></pre><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>功能：    用于从一个已存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。参数：无返回值：    成功：子进程返回<span class="token number">0</span>，父进程中返回子进程ID，<span class="token class-name">pid_t</span>为整型。    失败：返回<span class="token operator">-</span><span class="token number">1</span>。    失败的两个主要原因<span class="token operator">:</span><span class="token number">1.</span>当前的进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN。        <span class="token number">2.</span>系统内存不足，这时errno的值被设置为ENOMEM。</code></pre><p>使用示例：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token comment">//创建一个子进程</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//创建子进程</span>    <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>这里的结果会输出两次hello world。这是为什么呢？</strong></p><p><strong>首先，fork函数创建子进程，子进程会将父进程的代码复制下来来执行了，当然这就有人说了，那么子进程执行fork函数，那就不是一直创建子进程了吗。这里涉及到了一个问题。当父进程调用fork函数，父进程会有一个pc指针指向fork函数调用后的代码，当然，子进程也把这个pc指针的值也继承了下来，所以子进程也是一样执行。</strong></p><h3 id="父子进程关系"><a href="#父子进程关系" class="headerlink" title="父子进程关系"></a>父子进程关系</h3><p>使用fork函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的的静态描述），进程堆栈，打开的文件描述符，信号控制设定，进程优先级，进程组号等。</p><p>子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用fork()函数的代价是很大的。</p><p>简单来说，一个进程调用fork函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值和原来的进程的值不同。相当于克隆了一个自己。</p><p><strong>实际上，Linux的fork函数使用是通过写时拷贝（copy-on-write）实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</strong></p><p><strong>fork之后父子进程共享文件，fork产生的子进程和父进程相同的文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</strong></p><h3 id="区分父子进程"><a href="#区分父子进程" class="headerlink" title="区分父子进程"></a>区分父子进程</h3><p>fork()函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是0，而父进程的返回值则是新子进程的进程ID。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token comment">//区分父子进程</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//创建一个子进程</span>    <span class="token comment">//fork函数在在子进程中返回0 在父进程中返回子进程的pid</span>    pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//子进程</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello pid:%d ppid:%d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token comment">//父进程</span>       <span class="token comment">//这里pid返回的就是新子进程的进程id</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world pid:%d cpid:%d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="父子进程堆空间"><a href="#父子进程堆空间" class="headerlink" title="父子进程堆空间"></a>父子进程堆空间</h3><p>当在创建子进程前在堆声明时，一定要对该指针指向区域释放两次。不然会出现内存泄露。</p><h3 id="如何检测内存是否泄露"><a href="#如何检测内存是否泄露" class="headerlink" title="如何检测内存是否泄露"></a>如何检测内存是否泄露</h3><pre class="language-bash" data-language="bash"><code class="language-bash">gcc zfork.cvalgrind ./a.out</code></pre><h3 id="GDB调试多进程"><a href="#GDB调试多进程" class="headerlink" title="GDB调试多进程"></a>GDB调试多进程</h3><p>使用GDB调试的时候，GDB只能跟踪一个进程。可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者跟踪子进程。默认跟踪父进程。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> follow-fork-mode child <span class="token comment">#设置gdb在fork之后跟踪子进程</span><span class="token builtin class-name">set</span> follow-fork-mode parent <span class="token comment">#设置跟踪父进程（默认）</span><span class="token comment">#注意，一定要在fork函数调用之前设置才有效。</span></code></pre><h3 id="进程退出函数"><a href="#进程退出函数" class="headerlink" title="进程退出函数"></a>进程退出函数</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span> <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：    结束调用此函数的进程参数：    status<span class="token operator">:</span>返回给父进程的参数（低<span class="token number">8</span>位有效），至于这个参数是多少根据需要来填写。返回值：    无</code></pre><p>exit()和_exit()函数功能和用法是一样的，无非是包含的头文件不一样，还有的区别就是：exit()属于标准库函数，_exit()属于系统调用函数。</p><p>_exit()函数不会关闭文件描述符和I刷新I&#x2F;O缓冲区。exit()函数会做这些。</p><h3 id="等待子进程退出函数"><a href="#等待子进程退出函数" class="headerlink" title="等待子进程退出函数"></a>等待子进程退出函数</h3><p>在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号，退出状态，运行时间）。</p><p>父进程可以调用wait或waitpid得到他的退出状态同时彻底清除掉这个进程。</p><p>wait()和waitpid函数的功能一样，区别在于wait()函数会堵塞，waitpid()可以设置不堵塞，waitpid()还可以指定等待那个子进程结束。</p><p>一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p><h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。参数：    status<span class="token operator">:</span>进程退出时的状态信息。返回值：    成功：已经结束子进程的进程号    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><p>调用wait函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒（相当于继续往下执行）。</p><p>若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。</p><p><strong>所以wait函数的主要功能为回收已经结束子进程的资源。如果参数status的值不是NULL,wait函数就会把子进程退出时的状态取出并且存入其中，这是一个整数值（int）,指出了子进程是正常退出还是被非正常结束的。这个退出信息在一个int中包含了多个字段，直接使用这个值是没有意义的，我们需要宏定义取出其中的每个字段。</strong></p><p>使用对应的宏函数如WIFEXITED(status)为非0表明进程正常结束。WEXITSTATUS(status)若WIFEXITED(status)值为真，获取进程退出状态（exit的参数）。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//属于正常退出</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"子进程退出状态码：%d\n"</span><span class="token punctuation">,</span><span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFSIGNALED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//在bash输入kill 子进程号</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"子进程被信号%d杀死了\n"</span><span class="token punctuation">,</span><span class="token function">WTERMSIG</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">WIFSTOPPED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//向指定进程发送暂停信号</span>    <span class="token comment">//kill -19 子进程号</span>    <span class="token comment">//唤醒指定暂停的进程</span>    <span class="token comment">//kill -18 子进程号</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"子进程被信号%d暂停\n"</span><span class="token punctuation">,</span><span class="token function">WSTOPSIG</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h></span></span><span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">,</span><span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>功能：    等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。参数：    pid<span class="token operator">:</span>参数pid的值有以下几种类型：        pid<span class="token operator">></span><span class="token number">0</span> 等待进程ID等于pid的子进程。        pid<span class="token operator">=</span><span class="token number">0</span> 等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会等待他。        pid<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span> 等待任一子进程，此时waitpid和wait作用一样。        pid<span class="token operator">&lt;</span><span class="token operator">-</span><span class="token number">1</span> 等待指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。    status<span class="token operator">:</span>进程退出时的状态信息。和<span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>用法一样。    options<span class="token operator">:</span>options提供了一些额外的选项来控制<span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>        <span class="token number">0</span><span class="token operator">:</span>同<span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>阻塞父进程，等待子进程退出。        WNOHANG<span class="token operator">:</span>没有任何已经结束的子进程，则立即返回        WUNTRACED<span class="token operator">:</span>如果子进程暂停了则此函数马上返回，并且不予理会子进程的结束状态。返回值：     当正常返回时，返回收集到的已经回收子进程的进程号     如果设置了选项WNOHANG<span class="token punctuation">,</span>而调用中<span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span>发现没有已经退出的子进程可等待，则返回<span class="token number">0</span><span class="token punctuation">;</span> 如果调用中出错，则返回<span class="token operator">-</span><span class="token number">1</span>，这是errno会被设置成相应的值以指示错误所在。</code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//等价于wait()</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>status<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第三个参数表示不阻塞</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>status<span class="token punctuation">,</span>WNOHANG<span class="token punctuation">)</span></code></pre><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p><strong>父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程。</strong></p><p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init,而init进程会循环wait()它的已经退出的子进程。所以init进程会处理孤儿进程的善后工作。</p><p><strong>孤儿进程并没有什么危害。</strong></p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p><strong>进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程。</strong>这样就导致了一个问题，如果进程不调用wait()或者waitpid（）的话，那么保留的那段信息就不会释放，其进程号就会一直被占用。如果产生大量的僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><h3 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h3><p>在Windows平台下，我们可以通过双击运行可执行程序，让这个可执行程序成为一个进程；而在Linux平台，我们可以通过.&#x2F;运行，让一个可执行程序成为一个进程。</p><p>但是，如果我们本来就运行着一个程序，我们如何在这个进程内部启动一个外部程序，由内核将这个外部程序读入内存，使其执行起来成为一个进程呢，我们通过exec函数族实现。</p><p>exec函数族是一组函数，在Linux并不存在exec函数。这组函数一共有6个。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>environ<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/*(char *) NULL*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/*(char *) NULL*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">/*,(char *) NULL,char * const envp[] */</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execvpe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中只有execve()是真正意义的系统调用，其他都是在此基础上经过包装的库函数。</p><p><strong>exec函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容。</strong></p><p><strong>进程在调用一种exec函数时，该进程完全由新程序替换，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后进程ID(当然还有父进程号，进程组号，当前工作目录)并未改变。exec只是用另一个新程序替换了当前进程的正文，数据，堆和栈段（进程替换）。</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//arg0 arg1 arg2 ... argn</span>    <span class="token comment">//arg0一般是可执行文件名 argn必须是NULL</span>    <span class="token comment">//execlp("ls","ls","-l","/home",NULL);</span>    <span class="token comment">//第一个参数是可执行文件的绝对路径或者相对路径</span>    <span class="token comment">//第二个参数一般是可执行文件的名字</span>    <span class="token comment">//中间的参数就是可执行文件的参数</span>    <span class="token comment">//最后一个参数是NULL</span>    <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"-l"</span><span class="token punctuation">,</span><span class="token string">"/home"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_GNU_SOURCE</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"-l"</span><span class="token punctuation">,</span><span class="token string">"/home"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"ADDR=BEIJING"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//第一个参数是可执行文件</span>    <span class="token comment">//第二个参数是指针数组 最后一定以NULL结束</span>    <span class="token comment">//execvp("ls",argv);</span>    <span class="token comment">//第一个参数是可执行文件</span>    <span class="token comment">//第二个参数是指针数组 最后一定以NULL结束</span>    <span class="token comment">//execv("/bin/ls",argv);</span>    <span class="token comment">//最后一个参数是环境变量指针数组</span>    <span class="token comment">//execle("/bin/ls","ls","-l","/home",NULL,envp);</span>    <span class="token comment">//第一个参数是可执行文件</span>    <span class="token comment">//第二个参数是参数列表 指针数组</span>    <span class="token comment">//第三个参数是环境变量列表 指针数组</span>    <span class="token function">execvpe</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span>argv<span class="token punctuation">,</span>envp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p><p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信。（IPC）</p><p><strong>进程间通信的目的：</strong></p><p><strong>数据传输：一个进程需要将它的数据发送给另一个进程。</strong></p><p><strong>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</strong></p><p><strong>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</strong></p><p><strong>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</strong></p><p><strong>Linux操作系统支持的主要进程间通信的通信机制：</strong></p><p><img src="/2025/06/20/Linux-System%20Programming/6.png" alt="6" loading="lazy"></p><h3 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h3><p>管道也叫无名管道，它是UNIX系统IPC(进程间通信)的最古老方式，所有的UNIX系统都支持这种通信机制。</p><p>管道有如下特点：</p><ol><li>半双工，数据在同一时刻只能在一个方向上流动。</li><li>数据只能从管道的一端写入，从另一端读出。</li><li>写入管道中的数据遵循先入先出的规则。</li><li>管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息。</li><li>管道不是普通文件，不属于某个文件系统，其只存在于<strong>内存</strong>中。</li><li>管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。</li><li><strong>从管道读数据是一次性操作</strong>，数据一旦被读走，他就从管道中被抛弃，释放空间以便写更多的数据。</li><li>管道没有名字，<strong>只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</strong></li></ol><p>管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。</p><p><img src="/2025/06/20/Linux-System%20Programming/7.png" alt="7" loading="lazy"></p><h4 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>功能：创建无名管道参数：    pipefd<span class="token operator">:</span>为<span class="token keyword">int</span>型数组的首地址，其存放了管道的文件描述符pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>。    当一个管道建立时，他会创建两个文件描述符fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>和fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>。其中fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>固定用于读管道，而fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>固定用于写管道。一般文件I<span class="token operator">/</span>O的函数都可以用来操作管道（<span class="token function">lseek</span><span class="token punctuation">(</span><span class="token punctuation">)</span>除外）。返回值：    成功：<span class="token number">0</span>    失败：<span class="token operator">-</span><span class="token number">1</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token comment">//用于创建无名管道</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//创建一个无名管道</span>    ret<span class="token operator">=</span><span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//fd[0]用于读 fd[1]用于写</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fd[0]:%d fd[1]:%d\n"</span><span class="token punctuation">,</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//关闭文件描述符</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="父子进程通过无名管道通信"><a href="#父子进程通过无名管道通信" class="headerlink" title="父子进程通过无名管道通信"></a>父子进程通过无名管道通信</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIZE</span> <span class="token expression"><span class="token number">64</span></span></span><span class="token comment">//父子进程使用无名管道进行通信</span><span class="token comment">//父进程写管道 子进程读管道</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span>SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> pid<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//1.创建无名管道</span>    ret<span class="token operator">=</span><span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">==</span>ret<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//2.创建子进程</span>    pid<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">==</span>pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//子进程 读管道</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//关闭写端</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        ret<span class="token operator">=</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span>SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"read"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child process buf :%s\n"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//关闭读端</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//父进程 写管道</span>    <span class="token comment">//关闭读端</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ret<span class="token operator">=</span><span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"ABCDE"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"write"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent process write: len:%d\n"</span><span class="token punctuation">,</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//关闭写端</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux常见目录&quot;&gt;&lt;a href=&quot;#Linux常见目录&quot; class=&quot;headerlink&quot; title=&quot;Linux常见目录&quot;&gt;&lt;/a&gt;Linux常见目录&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
</summary>
      
    
    
    
    <category term="计算机学习" scheme="http://yustonerain.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="http://yustonerain.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构100题</title>
    <link href="http://yustonerain.top/2025/06/03/data-structure-100.html"/>
    <id>http://yustonerain.top/2025/06/03/data-structure-100.html</id>
    <published>2025-06-03T00:02:57.000Z</published>
    <updated>2025-06-23T15:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">两数之和</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​ 给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1]</code></pre><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h3><h4 id="具体思路："><a href="#具体思路：" class="headerlink" title="具体思路："></a>具体思路：</h4><p>首先使用unordered_map，在遍历原数组时，边查边找。</p><p>如果没找到，就把当前值的值和下标存入unordered_map，以便下次寻找可以搜素以前的键值对，看是否有满足情况（target-nums[i]）的key,若有，取出对应的value(iter-&gt;second)和当前的数组下标一起返回。当然最坏的情况，遍历完了，也没有符合情况的出现。可以直接返回空。</p><h4 id="std-unordered-map的核心特性："><a href="#std-unordered-map的核心特性：" class="headerlink" title="std::unordered_map的核心特性："></a>std::unordered_map的核心特性：</h4><p><strong>1. 基于哈希表实现（Hash Table）</strong></p><ul><li><code>unordered_map</code> 通过哈希函数（<code>std::hash</code>）将键（key）映射到一个桶（bucket）中，实现<strong>常数时间复杂度（O(1)）</strong>的查找、插入和删除操作（平均情况）。</li><li>哈希冲突通过链表（或更优化的结构）解决。</li></ul><hr><ol start="2"><li><strong>键唯一（Key is Unique）</strong></li></ol><ul><li>每个键（key）在 <code>unordered_map</code> 中必须是唯一的，如果插入相同键，会覆盖原有值或插入失败（取决于操作方式）。</li></ul><hr><p><strong>3. 无序（Unordered）</strong></p><ul><li>元素的存储顺序<strong>不保证稳定性或有序性</strong>，与插入顺序无关。</li><li>如果需要有序容器，应使用 <code>std::map</code>。</li></ul><hr><p><strong>4. 自动扩容</strong></p><ul><li><code>unordered_map</code> 会根据负载因子（load factor）自动扩展桶的数量，以保持操作效率。</li><li>用户可以手动调整负载因子和桶数量（如 <code>rehash()</code> 或 <code>reserve()</code> 函数）。</li></ul><hr><p><strong>5. 允许自定义哈希函数与相等比较器</strong></p><ul><li>支持用户为自定义类型指定哈希函数（通过模板参数 <code>Hash</code> 和 <code>KeyEqual</code>）。</li></ul><pre class="language-none"><code class="language-none">cpp复制编辑std::unordered_map&lt;MyType, int, MyHash, MyEqual&gt;</code></pre><p> <strong>6. 快速访问接口</strong></p><ul><li><code>operator[]</code>：快速访问键对应的值，如果键不存在，则自动插入默认值。</li><li><code>find()</code>：返回一个迭代器，指向查找到的键值对，否则为 <code>end()</code>。</li></ul><hr><p><strong>7. 不支持排序算法</strong></p><ul><li>由于无序存储，标准排序算法（如 <code>sort</code>）不能直接应用于 <code>unordered_map</code>，但可以通过将其内容复制到 <code>vector&lt;pair&lt;&gt;&gt;</code> 后排序实现。</li></ul><hr><p><strong>8. 多线程下非线程安全</strong></p><ul><li>多线程环境下访问 <code>unordered_map</code> 必须加锁或使用线程安全容器。</li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> map<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">auto</span> iter <span class="token operator">=</span>map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>target<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>iter<span class="token operator">!=</span>map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span>iter<span class="token operator">-></span>second<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><ul><li>一次遍历 <code>nums</code> 数组，时间是 <code>O(n)</code>。</li><li>对于每个元素：<ul><li><code>map.find(...)</code> 查找操作的平均时间复杂度是 **O(1)**。</li><li><code>map.insert(...)</code> 插入操作的平均时间复杂度也是 **O(1)**。</li></ul></li></ul><p>因此，总体时间复杂度是：</p><p>**O(n)**（n 是数组中元素的数量）</p><h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>最多会向 <code>unordered_map</code> 中插入 <code>n</code> 个元素（每个 <code>nums[i]</code> 和其索引 <code>i</code>）。</li><li>所以空间复杂度与 <code>nums</code> 的大小成正比。</li></ul><p>**O(n)**（额外使用了哈希表来存储 n 个键值对）</p><h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: strs &#x3D; [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: strs &#x3D; [&quot;&quot;]输出: [[&quot;&quot;]]</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: strs &#x3D; [&quot;a&quot;]输出: [[&quot;a&quot;]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="具体思路：-1"><a href="#具体思路：-1" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​首先使用std::unordered_map结构，当然不用再介绍了。这个题的意思是把那些排序之后相同的单词放在一个组合。</p><p>所以我们可以先使用unordered_map&lt;string,vector<string>&gt;存储键值对，键就是排序之后的单词，毕竟排序之后都一样。</string></p><p>键对应的值就是对应的单词（排序相同的单词），最后再遍历这个unordered_map，输出结果。</p><h4 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//做这道题首先对于字母异位词 排序之后是相同的，所以可以用一个哈希表，键存储排序后的结果，值为结果集</span>        std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> record<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            string temp<span class="token operator">=</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>temp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            record<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>record<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>record<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>it<span class="token operator">-></span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>假设：</p><ul><li><code>n</code> 是字符串数组 <code>strs</code> 的长度。</li><li><code>k</code> 是每个字符串的平均长度。</li></ul><ol><li>遍历 <code>strs</code> 中的每个字符串，共 <code>n</code> 次。</li><li>对每个字符串排序：<code>O(k log k)</code></li><li>哈希表插入&#x2F;查找键值对：<code>O(1)</code> 平均时间。</li></ol><p>所以总时间复杂度为：</p><p><strong>O(n * k log k)</strong></p><h4 id="空间复杂度：-1"><a href="#空间复杂度：-1" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>哈希表 <code>record</code> 最多存 <code>n</code> 个键，每个键存一个 <code>vector&lt;string&gt;</code>，整体字符串内容不变，只是重新组织。</li><li>排序后的中间变量 <code>temp</code> 的开销为 <code>O(k)</code>，共用一次。</li><li>最终结果 <code>ans</code> 存储所有原字符串内容。</li></ul><p>所以额外空间主要包括：</p><ol><li>哈希表键（排序后的字符串）：最多 <code>n</code> 个，每个长度为 <code>k</code>：<code>O(n * k)</code></li><li>哈希表值（字符串集合）：整体还是输入的字符串，只是重新组织，<strong>不算重复存储</strong></li><li>排序的临时变量（重复使用）：忽略不计</li></ol><p>因此总空间复杂度为：</p><p><strong>O(n * k)</strong></p><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]输出：9</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,0,1,2]输出：3</code></pre><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-2"><a href="#具体思路：-2" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​首先将数组存入unordered_set中避免重复，为什么用unordered_set，因为找元素它是O(1)。</p><p>接下来遍历unordered_set，先判断当前元素有没有前一个连续的元素（例子：当前元素为5，查是否有4），有则跳过，没有则进行下一步，并且这个节点是作为开始节点。</p><p>然后先保存当前节点的值和连续序列的长度（这个时候为1），然后循环查找连续序列，最后获得连续序列的长度，再和历史最长连续序</p><p>列比较，更新历史最长连续序列。遍历完unordered_set，返回历史最长连续序列即可。</p><h4 id="std-unordered-set的特性："><a href="#std-unordered-set的特性：" class="headerlink" title="std::unordered_set的特性："></a>std::unordered_set的特性：</h4><p><code>std::unordered_set</code> 是 C++ 标准库中提供的 <strong>无序集合容器</strong>，它内部基于哈希表实现，主要用于快速判断一个元素是否存在，并确保元素唯一。下面是它的详细特性：</p><hr><p><strong>1. 元素唯一（Unique Elements）</strong></p><ul><li>它是一个 <strong>集合（set）</strong>，<strong>不允许重复元素</strong>。</li><li>插入相同元素将失败，已有的不会被替换。</li></ul><hr><p><strong>2. 基于哈希表（Hash Table）</strong></p><ul><li>内部使用哈希表存储元素。</li><li>插入、查找、删除的**平均时间复杂度是 O(1)**，非常高效。</li><li>如果发生大量哈希冲突，最坏情况会退化为 O(n)，但 STL 默认哈希函数表现良好，一般不会发生。</li></ul><hr><p><strong>3. 元素无序（Unordered）</strong></p><ul><li>和 <code>std::set</code>（基于红黑树，有序）不同，<code>unordered_set</code> 中的元素<strong>存储顺序不固定</strong>。</li><li>遍历时元素的顺序是哈希桶顺序，<strong>不可预测</strong>。</li></ul><hr><p><strong>4. 可自定义哈希函数（支持自定义类型）</strong></p><ul><li>可以为自定义类型提供哈希函数和等价比较函数。</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unordered_set<span class="token operator">&lt;</span>MyType<span class="token punctuation">,</span> MyHash<span class="token punctuation">,</span> MyEqual<span class="token operator">></span></code></pre><hr><p><strong>5. 常用操作和函数</strong></p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>insert(val)</code></td><td>插入元素，若已存在则不插入</td></tr><tr><td><code>erase(val)</code></td><td>删除元素</td></tr><tr><td><code>find(val)</code></td><td>查找元素，返回迭代器</td></tr><tr><td><code>count(val)</code></td><td>判断元素是否存在（返回 0 或 1）</td></tr><tr><td><code>size()</code></td><td>元素个数</td></tr><tr><td><code>empty()</code></td><td>是否为空</td></tr><tr><td><code>clear()</code></td><td>清空所有元素</td></tr><tr><td><code>begin()</code>, <code>end()</code></td><td>返回迭代器（可用于范围遍历）</td></tr></tbody></table><hr><p><strong>5.与 <code>std::set</code> 的区别</strong></p><table><thead><tr><th>特性</th><th><code>std::set</code>（有序）</th><th align="center"><code>std::unordered_set</code>（无序）</th></tr></thead><tbody><tr><td>底层结构</td><td>红黑树（平衡 BST）</td><td align="center">哈希表</td></tr><tr><td>元素是否有序</td><td>是</td><td align="center">否</td></tr><tr><td>查找&#x2F;插入效率</td><td><code>O(log n)</code></td><td align="center">平均 <code>O(1)</code></td></tr><tr><td>内存使用</td><td>较少</td><td align="center">较多（需额外存哈希结构）</td></tr><tr><td>自定义排序</td><td>支持</td><td align="center">不支持</td></tr></tbody></table><h4 id="代码块：-1"><a href="#代码块：-1" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> num_set<span class="token punctuation">;</span>        <span class="token comment">//使用unordered_set存储nums的所有值</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>num<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            num_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> longSum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>num<span class="token operator">:</span>num_set<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//上述遍历用nums和num_set有什么区别，在leetcode一个能过一个不能过</span>            <span class="token comment">//以遍历的每个元素为起点，满足才进行下一步操作</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>num_set<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>num<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//满足条件后，存储当前节点的信息</span>                <span class="token keyword">int</span> currentNum<span class="token operator">=</span>num<span class="token punctuation">;</span>                <span class="token keyword">int</span> currentSum<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">//寻找该节点的最长连续序列</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>num_set<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>currentNum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    currentNum<span class="token operator">=</span>currentNum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                    currentSum<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">//最后与longSum比较，更新历史最长连续序列</span>                longSum<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>currentSum<span class="token punctuation">,</span>longSum<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> longSum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="编写代码产生的问题："><a href="#编写代码产生的问题：" class="headerlink" title="编写代码产生的问题："></a>编写代码产生的问题：</h4><p>上述遍历用nums和num_set有什么区别，在leetcode一个能过一个不能过</p><p><strong>遍历 <code>num_set</code>：</strong></p><ul><li>每个元素最多只被作为“起点”处理一次。</li><li>例如：对于序列 <code>[100, 101, 102, 103]</code>，只有 <code>100</code> 会进入 while 循环处理。</li><li>其他如 <code>101</code>、<code>102</code> 在 <code>if (!num_set.count(num - 1))</code> 时会被跳过（因为 <code>100</code> 已经处理了它们）。</li><li>所以是 <strong>O(n)</strong> 时间复杂度。</li></ul><p><strong>遍历 <code>nums</code>：</strong></p><ul><li><code>nums</code> 可能包含重复值，也可能无序。</li><li>比如你在 <code>nums</code> 中遇到 <code>102</code>，它不是起点，但你仍会试图查找连续数字，造成<strong>重复计算</strong>。</li><li>重复调用 <code>count()</code>，浪费性能，导致 <strong>超时</strong> 或 <strong>错误结果</strong>（重复统计）。</li></ul><h4 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>设输入数组 <code>nums</code> 的长度为 <code>n</code>。</p><ol><li><code>unordered_set</code> 插入 <code>n</code> 个元素：**O(n)**（平均时间，插入是 O(1)）。</li><li>第二个循环遍历 <code>num_set</code> 中的每个元素，<strong>每个连续序列只处理一次</strong>。</li></ol><pre class="language-none"><code class="language-none">if (!num_set.count(num - 1))</code></pre><ul><li>这个判断确保每个序列的起点只会被处理一次。</li><li>例如序列 <code>[100, 101, 102, 103]</code> 只会从 <code>100</code> 开始处理一次，不会在遍历到 <code>101</code> 时重复处理。</li></ul><p>因此：</p><p>**总时间复杂度：O(n)**（哈希表操作均为 O(1) 平均时间）</p><h4 id="空间复杂度：-2"><a href="#空间复杂度：-2" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>使用了一个 <code>unordered_set</code> 存储 <code>n</code> 个整数，占用 O(n) 的空间。</li><li>其他变量如 <code>currentNum</code>, <code>currentSum</code> 等为常数空间。</li></ul><p>因此：</p><p><strong>总空间复杂度：O(n)</strong></p><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">移动零</a></h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [0]输出: [0]</code></pre><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-3"><a href="#具体思路：-3" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​我们可以采用双指针的方法，先left,right同时指向起始点，right到最后位置结束。当right找到非零节点，与left进行值交换，left只有交换结束才left++;这样最后非零节点都在前面，0都在末尾。</p><h4 id="代码块：-2"><a href="#代码块：-2" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><ul><li><code>right</code> 从 <code>0</code> 遍历到 <code>n-1</code>，每个元素访问一次。</li><li>最多发生 <code>n</code> 次 <code>swap</code> 操作（每个非零元素最多被交换一次）。</li><li>所以：</li></ul><p><strong>总时间复杂度：O(n)</strong></p><h4 id="空间复杂度：-3"><a href="#空间复杂度：-3" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>只使用了常量级别的辅助变量 <code>left</code> 和 <code>right</code>。</li><li>所有操作都在原数组上进行，<strong>原地修改</strong>，没有开辟额外数组。</li></ul><p><strong>总空间复杂度：O(1)</strong></p><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a></h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [1,1]输出：1</code></pre><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-4"><a href="#具体思路：-4" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​我们采用双指针的方式求解。这个题目的是求解柱子之间的最大面积。我们可以采用将两个指针放在两端，如果左边的柱子高度大于或等于右边的柱子高度，我们先算出容器对应的面积（高度以低柱子为准）。算出后更新历史最大面积。执行完，将右边的柱子向左移动。同时，还有一种情况，左边的柱子高度小于右边的柱子高度，先算出容器对应的面积（高度以低柱子为准）。算出后更新历史最大面积。执行完，将左边的柱子向右移动。直到当前的左柱子和右柱子重合。</p><h4 id="代码块：-3"><a href="#代码块：-3" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//采用双指针的方式求解</span>        <span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right<span class="token operator">=</span>height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">>=</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">*</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">*</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-4"><a href="#时间复杂度：-4" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>时间复杂度：<code>O(n)</code></p><ul><li>解释：使用的是<strong>双指针</strong>方法，从两端向中间遍历整个数组，每一次迭代都会<strong>移动左指针或右指针之一</strong>，因此总共最多移动 <code>n-1</code> 次。</li><li>所以时间复杂度是 **线性的 O(n)**，其中 <code>n</code> 是 <code>height</code> 数组的长度。</li></ul><h4 id="空间复杂度：-4"><a href="#空间复杂度：-4" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(1)</code></p><ul><li>解释：只使用了常数个额外变量（如 <code>ans</code>, <code>left</code>, <code>right</code>, <code>h</code>, <code>w</code>），不依赖于输入数据的大小。</li><li>因此空间复杂度是 **常数级 O(1)**。</li></ul><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode.cn/problems/3sum/">三数之和</a></h2><h3 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 </code></pre><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-5"><a href="#具体思路：-5" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​这题的目标是在在整数数组中，找到所有三个数满足和为零，最后结果不可以重复。这个题我们可以先定下一个值，剩下两个值用双指针法遍历，找到符合结果的。还有一些细节，还要考虑不能重复的问题，对于这个问题，我们可以先排序（升序）这个数组，从小到大定第一个值，首先如果这第一个值大于0，这个可以结束了，这个数组就不会存在符合条件的三元组。当然如果当前元素与上一个元素相同，也跳过，这样执行，首先我想的是定第一个元素，当当前元素和下一个元素相同直接跳过，后来发现，[-1,-1,2]这种情况没有考虑。当然那你为甚么还是要写当前元素与上一个元素相同，也跳过，我完全可以不管嘛，那不行，我的思路是当第一个元素是-1时，这一次直接找出所有符合第一个元素是-1的情况，要不然会十分混乱，所以我会说如果当前元素与上一个元素相同，也跳过。因为上一个元素已经找完了第一个元素为-1的三元组了，当避免找完-1还会再出现，我们用了排序。这样第一个元素的逻辑就结束了，接下来找剩下两个，用双指针，左指针指向当前元素的下一个元素，右指针指向末尾元素。我们是要找到所有符合情况，当三元组的值大于0，将右指针左移。当三元组的值小于0，将左指针右移。当三元组的值等于0，将三元组的值加入结果集。接下来再判断找到的左元素是否与后面的元素重复（因为是排序的，相同的元素就在身边）。跳过这些元素，找到的右元素是否与后面的元素重复（因为是排序的，相同的元素就在身边）。跳过这些元素。只要左指针和右指针没有重合，就一直找，找完符合情况的三元组。</p><h4 id="代码块：-4"><a href="#代码块：-4" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">threeSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token comment">//先升序排序</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//遍历排序后的数组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//先定第一个元素</span>            <span class="token comment">//第一个元素大于0,因为是升序排序，后面都大于零，那没有满足条件的结果了</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">//如果上一个元素相同，跳过当前，用下一个</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">//采用双指针定剩下两个</span>            <span class="token keyword">int</span> left<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> right<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> right<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> left<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//下面判断是否有相同的，避免重复</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>left<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>right<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token operator">--</span><span class="token punctuation">;</span>                    left<span class="token operator">++</span><span class="token punctuation">;</span>                    right<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-5"><a href="#时间复杂度：-5" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p> 时间复杂度：<code>O(n^2)</code></p><p>详细分析：</p><ol><li><p>外层循环遍历数组中的每个数作为固定值 <code>nums[i]</code>，这部分是 <code>O(n)</code>。</p></li><li><p>内层使用双指针 <code>left</code> 和 <code>right</code> 来查找另外两个数，最坏情况下每次都需要遍历一次剩余数组，即 <code>O(n)</code>。</p></li><li><p>所以总的时间复杂度是：</p><p>O(n^2)</p></li></ol><p>去重操作的影响：</p><ul><li>去重操作使用的是 <code>while(left &lt; right &amp;&amp; nums[left] == nums[left + 1])</code> 这类逻辑，在最坏情况下最多也只是跳过相同元素，不改变主导复杂度。</li></ul><h4 id="空间复杂度：-5"><a href="#空间复杂度：-5" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(1)</code>（不计输出）</p><p>解释：</p><ul><li>如果<strong>不考虑返回结果 <code>ans</code> 所占用的空间</strong>（即题目允许将返回值空间复杂度忽略），则使用的额外空间为：<ul><li>排序使用的可能是原地排序（如 <code>std::sort</code>），**空间复杂度为常数级 <code>O(1)</code>**。</li><li>其他仅使用了一些指针和变量，都是常数级空间。</li></ul></li><li>如果 <strong>将返回结果的空间也算入</strong>，最坏情况是 <code>O(k)</code>，其中 <code>k</code> 是满足条件的三元组个数。</li></ul><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></h2><h3 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [4,2,0,3,2,5]输出：9</code></pre><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-6"><a href="#具体思路：-6" class="headerlink" title="具体思路："></a>具体思路：</h4><p>这里采用的是动态规划解法，还有其他方法。动态规划解法，需要构造两个数组分别储存各个节点的左边最大高度和右边最大高度，便于计算当前节点所积水高度。问题在于左边和右边最大高度该如何获取。最左边的左边最大高度就是它自身，最右边的右边最大高度就是它自身，以这两个边界条件，左边最大高度就是当前节点的左边节点的左边最大高度和当前节点的高度的最大值，右边最大高度也是一样。求解出放入之前的两个数组中。已知这两个数组，可以遍历这两个数组，把当前节点的积水量算出，再累加一起，就是所求的雨水量。</p><h4 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//这题采用动态规划</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftMax</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rightMax</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        leftMax<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        rightMax<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>height<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            leftMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            rightMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>rightMax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token operator">+=</span><span class="token function">min</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>rightMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-6"><a href="#时间复杂度：-6" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>时间复杂度：<code>O(n)</code></p><ul><li><p>遍历了三次数组：</p><ol><li>构造 <code>leftMax</code>：<code>O(n)</code></li><li>构造 <code>rightMax</code>：<code>O(n)</code></li><li>遍历一次计算总雨水量：<code>O(n)</code></li></ol></li><li><p>所以总时间复杂度是：</p><p>O(n)</p></li></ul><h4 id="空间复杂度：-6"><a href="#空间复杂度：-6" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(n)</code></p><ul><li>使用了两个辅助数组：<ul><li><code>leftMax</code>：大小为 <code>n</code></li><li><code>rightMax</code>：大小为 <code>n</code></li></ul></li><li>所以额外空间是 <code>2n</code>，即 <strong><code>O(n)</code> 空间复杂度</strong>。</li></ul><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><h3 id="题目描述：-6"><a href="#题目描述：-6" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-7"><a href="#具体思路：-7" class="headerlink" title="具体思路："></a>具体思路：</h4><p>我们使用滑动窗口和哈希表实现这个题目。哈希表存储枚举值的下标，初始值为-1，j值在没有重合的情况下，会在每次循环+1，但是如果遇到重合，j值会跑到对应的下标位置之后的位置（下标位置存储在哈希表中）。只要有重合就调整窗口。</p><h4 id="代码块：-5"><a href="#代码块：-5" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//滑动窗口和哈希表</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pos</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//j为滑动窗口的起始节点</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            j<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>pos<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pos<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-7"><a href="#时间复杂度：-7" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>时间复杂度：<code>O(n)</code></p><ul><li>其中 <code>n</code> 是字符串 <code>s</code> 的长度。</li><li>每个字符最多访问两次（一次作为右指针扩展窗口，一次作为左指针缩小窗口）。</li><li>所以整体是线性时间复杂度 <code>O(n)</code>。</li></ul><h4 id="空间复杂度：-7"><a href="#空间复杂度：-7" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(1)</code></p><ul><li>使用了一个 <code>pos</code> 数组来记录 ASCII 字符上次出现的位置，长度是固定的 128（ASCII 字符集）。</li><li>即使改成 <code>256</code>（扩展 ASCII）或 <code>100,000</code>（Unicode 范围），只要是<strong>定长的字符集</strong>，空间复杂度都是 <strong><code>O(1)</code> 常数级</strong>。</li><li>如果字符集不固定，比如用 <code>unordered_map&lt;char, int&gt;</code>，那空间复杂度是 <code>O(k)</code>，其中 <code>k</code> 是字符集大小。</li></ul><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h2><h3 id="题目描述：-7"><a href="#题目描述：-7" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;cbaebabacd&quot;, p &#x3D; &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</code></pre><p> <strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;abab&quot;, p &#x3D; &quot;ab&quot;输出: [0,1,2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</code></pre><h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-8"><a href="#具体思路：-8" class="headerlink" title="具体思路："></a>具体思路：</h4><p>这道题的整体思路是让我找到对应字符串的所有异位词在一个陌生的字符串里。这里要解决两个问题，首先是异位词问题，找异位词可以通过枚举法，总共26个字母，我们通过数组存储使用字母的个数，最后对比，如果数组相等，就说明是异位词。还有一个问题：在陌生字符串找到所有的异位词，并且返回索引，找异位词是一个范围问题，所以我要使用流动窗口，大小就是对应字符串的大小。在陌生字符串扫描。最后返回结果。</p><h4 id="代码块：-6"><a href="#代码块：-6" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; findAnagrams(string s, string p) &#123;        &#x2F;&#x2F;首先记录两字符串的长度        int sLen&#x3D;s.size(),pLen&#x3D;p.size();        &#x2F;&#x2F;如果字符串s的长度还不比p字符串长        if(sLen&lt;pLen)&#123;            return vector&lt;int&gt;();        &#125;        &#x2F;&#x2F;记录结果        vector&lt;int&gt; ans;        &#x2F;&#x2F;记录s字符串和p字符串的字母对应的个数，枚举法        vector&lt;int&gt; sletter(26);        vector&lt;int&gt; pletter(26);        &#x2F;&#x2F;先试试索引为0的        for(int i&#x3D;0;i&lt;pLen;i++)&#123;            ++sletter[s[i]-&#39;a&#39;];            ++pletter[p[i]-&#39;a&#39;];        &#125;        &#x2F;&#x2F;如果符合，说明索引为0符合情况        if(sletter&#x3D;&#x3D;pletter)&#123;            ans.emplace_back(0);        &#125;        &#x2F;&#x2F;之后按照索引为1往后遍历，采取流动窗口,把前一次的流动窗口的第一个去掉，再往后补一个，形成新的流动窗口.        &#x2F;&#x2F;注意这里是按流动窗口为整体，上面的循环是为了形成流动窗口。        for(int i&#x3D;0;i&lt;sLen-pLen;i++)&#123;            --sletter[s[i]-&#39;a&#39;];            ++sletter[s[i+pLen]-&#39;a&#39;];            if(sletter&#x3D;&#x3D;pletter)&#123;            ans.emplace_back(i+1);        &#125;        &#125;                return ans;    &#125;&#125;;</code></pre><h4 id="时间复杂度：-8"><a href="#时间复杂度：-8" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><ul><li>初始化部分：O(p)</li><li>滑动窗口：O(n)</li></ul><p>由于通常 <code>p</code> 比 <code>n</code> 小，所以总时间复杂度是：O(n)</p><h4 id="空间复杂度：-8"><a href="#空间复杂度：-8" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>使用了两个长度为 26 的数组：<code>sletter</code>, <code>pletter</code>；</li><li>还使用了一个结果数组 <code>ans</code>，最坏情况下长度也是 O(n)；</li></ul><p>因此：</p><p>空间复杂度是 O(1) + O(k)，其中 k 是结果中异位词的数量，通常最多为 O(n)。</p><h2 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h2><h3 id="题目描述：-8"><a href="#题目描述：-8" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,1,1], k &#x3D; 2输出：2</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,2,3], k &#x3D; 3输出：2</code></pre><h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-9"><a href="#具体思路：-9" class="headerlink" title="具体思路："></a>具体思路：</h4><p>这里采取两个方法，第一种方法就是枚举法，暴力轮询。（为什莫要两种，因为我第一种leetcode超时了）。</p><p>方法二：首先通过前缀和这个点，定义 pre[i] 为 [0..i] 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：pre[i]&#x3D;pre[i−1]+nums[i]<br>那么[j..i] 这个子数组和为 k 这个条件我们可以转化为pre[i]−pre[j−1]&#x3D;&#x3D;k<br>简单移项可得符合条件的下标 j 需要满足pre[j−1]&#x3D;&#x3D;pre[i]−k<br>所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。建立以上条件，我们的问题就简化为寻找有多少个符合条件的pre[j]即可，我们建立哈希表，键是前缀和，值是前缀和重复的个数。在遍历的过程中，pre存储当前的前缀和，先不放进哈希表中，先在哈希表中查找是否有键pre-k,有的话，就取出对应的值加到count里，不管找没找到，都要将当前的前缀和存到哈希表中。这代码的逻辑是基于前缀和得出的只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。</p><h4 id="代码块：-7"><a href="#代码块：-7" class="headerlink" title="代码块："></a>代码块：</h4><p>方法一：枚举法</p><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        &#x2F;&#x2F;这题我们采用枚举法        int count&#x3D;0;&#x2F;&#x2F;返回的结果值        int n&#x3D;nums.size();        for(int start&#x3D;0;start&lt;n;++start)&#123;            int sum&#x3D;0;            for(int end&#x3D;start;end&lt;n;++end)&#123;                sum+&#x3D;nums[end];                if(sum&#x3D;&#x3D;k)&#123;                    count++;                &#125;            &#125;        &#125;        return count;    &#125;&#125;;</code></pre><p>方法二：前缀和+哈希表优化</p><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        &#x2F;&#x2F;前缀和+哈希表优化        unordered_map&lt;int,int&gt; mp;        mp[0]&#x3D;1;&#x2F;&#x2F;初始前缀和的个数为1        int count&#x3D;0,pre&#x3D;0;&#x2F;&#x2F;count是返回结果的，pre是前缀和        for(auto &amp;temp:nums)&#123;            pre+&#x3D;temp;            if(mp.find(pre-k)!&#x3D;mp.end())&#123;                count+&#x3D;mp[pre-k];            &#125;            mp[pre]++;        &#125;        return count;    &#125;&#125;;</code></pre><h4 id="时间复杂度：-9"><a href="#时间复杂度：-9" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>方法一：</p><p>时间复杂度：<strong>O(n²)</strong></p><p>方法二：</p><p>O(n) 时间</p><h4 id="空间复杂度：-9"><a href="#空间复杂度：-9" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>方法一：</p><p>空间复杂度：<strong>O(1)</strong></p><p>方法二：</p><p>**O(n)**（最坏情况下所有前缀和都不相同，哈希表大小为 n）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot;&gt;两数之和&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;</summary>
      
    
    
    
    <category term="计算机学习" scheme="http://yustonerain.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="data structure" scheme="http://yustonerain.top/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>c++实现集群聊天服务器</title>
    <link href="http://yustonerain.top/2025/06/02/C++-chatserver.html"/>
    <id>http://yustonerain.top/2025/06/02/C++-chatserver.html</id>
    <published>2025-06-02T15:57:52.000Z</published>
    <updated>2025-06-23T15:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="json学习"><a href="#json学习" class="headerlink" title="json学习"></a>json学习</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"json.hpp"</span></span><span class="token keyword">using</span> json<span class="token operator">=</span>nlohmann<span class="token double-colon punctuation">::</span>json<span class="token punctuation">;</span></code></pre><p>使用json,要包含json的头文件 ，方便使用可以重命名nlohmann::json为json。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//json序列化示例1</span>std<span class="token double-colon punctuation">::</span>string <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    json js<span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"msg_type"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"from"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"zhang san"</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"to"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"li si"</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"hello,what are you doing now"</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string sendBuf<span class="token operator">=</span>js<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>sendBuf<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> sendBuf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>js使用很像键值对。js.dump()是 nlohmann::json库中用于将 JSON 对象序列化（转为字符串）的方法，它会把一个 json类型的变量转换成 JSON 格式的字符串。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string recvBuf<span class="token operator">=</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）</span>   json jsbuf<span class="token operator">=</span>json<span class="token double-colon punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span>recvBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>jsbuf<span class="token punctuation">[</span><span class="token string">"msg_type"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>jsbuf<span class="token punctuation">[</span><span class="token string">"from"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>jsbuf<span class="token punctuation">[</span><span class="token string">"to"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>jsbuf<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></code></pre><p>这是main函数中执行。<code>json::parse()</code> 是 <code>nlohmann::json</code> 库中用来将 <strong>JSON 字符串 → JSON 对象</strong> 的函数，也就是实现<strong>反序列化</strong>。</p><p>转化为json对象后使用对应的键可以把对应的值取出来。结果：</p><pre class="language-none"><code class="language-none">&#123;&quot;from&quot;:&quot;zhang san&quot;,&quot;msg&quot;:&quot;hello,what are you doing now&quot;,&quot;msg_type&quot;:2,&quot;to&quot;:&quot;li si&quot;&#125;2&quot;zhang san&quot;&quot;li si&quot;&quot;hello,what are you doing now&quot;</code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//json序列化示例2</span>std<span class="token double-colon punctuation">::</span>string <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    json js<span class="token punctuation">;</span>    <span class="token comment">//添加数组</span>    js<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//添加key-value</span>    js<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"zhang san"</span><span class="token punctuation">;</span>    <span class="token comment">//添加对象</span>    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"zhang san"</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"liu shuo"</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"hello china"</span><span class="token punctuation">;</span>    <span class="token comment">//上面等同下面这句一次性添加数组对象</span>    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token string">"zhang san"</span><span class="token punctuation">,</span><span class="token string">"hello world"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token string">"liu shuo"</span><span class="token punctuation">,</span><span class="token string">"hello china"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>js<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> js<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>json还可以放数组，还可以嵌套json语句。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string recvBuf<span class="token operator">=</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）</span>    json jsbuf<span class="token operator">=</span>json<span class="token double-colon punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span>recvBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>jsbuf<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">auto</span> arr<span class="token operator">=</span>jsbuf<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">auto</span> msgjs<span class="token operator">=</span>jsbuf<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>msgjs<span class="token punctuation">[</span><span class="token string">"zhang san"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>msgjs<span class="token punctuation">[</span><span class="token string">"liu shuo"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></code></pre><p>“id”存储的是一个数组，取出来还可以作为数组使用。“msg”存储的值还可以是json语句，并且可以进入再取里面的值。</p><p>结果：</p><pre class="language-none"><code class="language-none">&#123;&quot;id&quot;:[1,2,3,4,5],&quot;msg&quot;:&#123;&quot;liu shuo&quot;:&quot;hello china&quot;,&quot;zhang san&quot;:&quot;hello world&quot;&#125;,&quot;name&quot;:&quot;zhang san&quot;&#125;[1,2,3,4,5]3&quot;hello world&quot;&quot;hello china&quot;</code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//json序列化示例3</span>std<span class="token double-colon punctuation">::</span>string <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    json js<span class="token punctuation">;</span>    <span class="token comment">//直接序列化一个vector容器</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"list"</span><span class="token punctuation">]</span><span class="token operator">=</span>vec<span class="token punctuation">;</span>    <span class="token comment">//直接序列化一个map容器</span>    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> m<span class="token punctuation">;</span>    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"黄山"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"华山"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"泰山"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"path"</span><span class="token punctuation">]</span> <span class="token operator">=</span>m<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string sendBuf <span class="token operator">=</span>js<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//json数据对象->序列化json字符串</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>sendBuf<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> sendBuf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>还可以序列化容器。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string recvBuf<span class="token operator">=</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）</span>    json jsbuf<span class="token operator">=</span>json<span class="token double-colon punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span>recvBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec <span class="token operator">=</span>jsbuf<span class="token punctuation">[</span><span class="token string">"list"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//js对象里面的数组类型，直接放入vector容器当中</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>v<span class="token operator">:</span>vec<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>v<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> mymap<span class="token operator">=</span>jsbuf<span class="token punctuation">[</span><span class="token string">"path"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>p<span class="token operator">:</span>mymap<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>p<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>p<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>结果：</p><pre class="language-none"><code class="language-none">&#123;&quot;list&quot;:[1,2,5],&quot;path&quot;:[[1,&quot;黄山&quot;],[2,&quot;华山&quot;],[3,&quot;泰山&quot;]]&#125;1 2 5 1 黄山2 华山3 泰山</code></pre><h2 id="muduo网络库学习"><a href="#muduo网络库学习" class="headerlink" title="muduo网络库学习"></a>muduo网络库学习</h2><p><strong>muduo</strong> 是一个现代 C++ 的非阻塞 I&#x2F;O 网络库，采用 <strong>Reactor 模式 + 多线程 + epoll + 定时器 + 高效缓冲区 + 智能指针设计</strong>，在性能和工程性方面都表现非常优秀。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*muduo网络库给用户提供了两个主要的类TcpServer :用于编写服务器程序的TcpClient :用于编写客户端程序的epoll+线程池好处：能够把网络I/O的代码和业务代码区分开了业务代码 :用户的连接和断开 用户的可读写事件*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;muduo/net/TcpServer.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;muduo/net/EventLoop.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> muduo<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> muduo<span class="token double-colon punctuation">::</span>net<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> placeholders<span class="token punctuation">;</span><span class="token comment">/*基于muduo网络库开发服务器程序1.组合TcpServer对象2.创建EventLoop事件循环对象的指针3.明确TcpServer构造函数需要什么参数，输出ChatServer的构造函数4.在当前服务器类的构造函数当中，注册处理连接的回调函数和处理读写事件的回调函数5.设置合适的服务端线程数量，muduo库会自己分配I/O线程和worker线程*/</span><span class="token keyword">class</span> <span class="token class-name">ChatServer</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ChatServer</span><span class="token punctuation">(</span>EventLoop<span class="token operator">*</span> loop<span class="token punctuation">,</span><span class="token comment">//事件循环</span>            <span class="token keyword">const</span> InetAddress<span class="token operator">&amp;</span> listenAddr<span class="token punctuation">,</span><span class="token comment">//ip+port</span>            <span class="token keyword">const</span> string<span class="token operator">&amp;</span> nameArg<span class="token punctuation">)</span><span class="token comment">//服务器的名字</span>        <span class="token operator">:</span><span class="token function">_server</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span>listenAddr<span class="token punctuation">,</span>nameArg<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">_loop</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//给服务器注册用户连接的创建和断开回调</span>            _server<span class="token punctuation">.</span><span class="token function">setConnectionCallback</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ChatServer<span class="token double-colon punctuation">::</span>onConnection<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//给服务器注册用户读写事件回调</span>            _server<span class="token punctuation">.</span><span class="token function">setMessageCallback</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ChatServer<span class="token double-colon punctuation">::</span>onMessage<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span>_1<span class="token punctuation">,</span>_2<span class="token punctuation">,</span>_3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//设置服务器端的线程数量 1个I/o线程 3个worker线程</span>            _server<span class="token punctuation">.</span><span class="token function">setThreadNum</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//开启事件循环</span>        <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            _server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">//专门处理用户的连接创建和断开</span>    <span class="token keyword">void</span> <span class="token function">onConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr<span class="token operator">&amp;</span>conn<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>conn<span class="token operator">-></span><span class="token function">connected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span>conn<span class="token operator">-></span><span class="token function">peerAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"->"</span><span class="token operator">&lt;&lt;</span>            conn<span class="token operator">-></span><span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"state:online"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//对方关闭连接或断开</span>            cout<span class="token operator">&lt;&lt;</span>conn<span class="token operator">-></span><span class="token function">peerAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"->"</span><span class="token operator">&lt;&lt;</span>            conn<span class="token operator">-></span><span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"state:offline"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            conn<span class="token operator">-></span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//close(fd)//关闭连接</span>            <span class="token comment">// _loop->quit();通常用于程序结束或手动控制关闭 Muduo</span>            <span class="token comment">//loop->quit() 使loop.loop()不再阻塞。</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//专门处理用户的读写事件</span>    <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr<span class="token operator">&amp;</span>conn<span class="token punctuation">,</span><span class="token comment">//连接</span>                            Buffer<span class="token operator">*</span> buffer<span class="token punctuation">,</span><span class="token comment">//缓冲区</span>                            Timestamp time<span class="token punctuation">)</span><span class="token comment">//接受数据的时间信息</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//是一个指向 muduo::net::Buffer 对象的指针，用于暂存客户端发送的数据。</span><span class="token comment">//Muduo 采用 非阻塞、事件驱动的方式，当客户端发送数据时，数据先被读入 Buffer 中，之后由用户注册的回调函数（例如 onMessage）来处理。</span>        <span class="token comment">//retrieveAllAsString()把缓冲区中的所有可读数据提取为一个 std::string，然后清空缓冲区。</span>        string buf<span class="token operator">=</span>buffer<span class="token operator">-></span><span class="token function">retrieveAllAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"recv data:"</span> <span class="token operator">&lt;&lt;</span>buf<span class="token operator">&lt;&lt;</span><span class="token string">"time:"</span><span class="token operator">&lt;&lt;</span>time<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        conn<span class="token operator">-></span><span class="token function">send</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原封不动发回去                        </span>    <span class="token punctuation">&#125;</span>    muduo<span class="token double-colon punctuation">::</span>net<span class="token double-colon punctuation">::</span>TcpServer _server<span class="token punctuation">;</span>    muduo<span class="token double-colon punctuation">::</span>net<span class="token double-colon punctuation">::</span>EventLoop <span class="token operator">*</span>_loop<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    EventLoop loop<span class="token punctuation">;</span><span class="token comment">//epoll</span>    InetAddress <span class="token function">addr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ChatServer <span class="token function">server</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token punctuation">,</span>addr<span class="token punctuation">,</span><span class="token string">"ChatServer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//listenfd epoll_ctl->epoll</span>    loop<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//epoll wait以阻塞方式等待新用户连接，已连接用户的读写事件等</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>先将bind函数讲清楚，</p><p>基本格式</p><pre class="language-none"><code class="language-none">std::bind(&amp;类名::成员函数, 对象指针, 占位符参数...)</code></pre><p>所以：</p><pre class="language-none"><code class="language-none">std::bind(&amp;ChatServer::onConnection, this, _1)</code></pre><p>意思是：</p><p>把当前对象（<code>this</code>）的 <code>onConnection</code> 成员函数绑定起来，形成一个可调用对象，并接受一个参数 <code>_1</code>。</p><p>分解解释</p><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><code>&amp;ChatServer::onConnection</code></td><td>指向 <code>ChatServer</code> 类的成员函数 <code>onConnection</code> 的指针</td></tr><tr><td><code>this</code></td><td>当前对象的指针，告诉 <code>bind</code> 这个函数是哪个对象的方法（即调用 this-&gt;onConnection）</td></tr><tr><td><code>_1</code></td><td>占位符，代表回调传入的第一个参数，实际调用时会被替换</td></tr><tr><td></td><td></td></tr></tbody></table><p>最终生成一个 <code>std::function&lt;void(const TcpConnectionPtr&amp;)&gt;</code> 类型的函数对象。</p><h2 id="CMakeList-txt学习"><a href="#CMakeList-txt学习" class="headerlink" title="CMakeList.txt学习"></a>CMakeList.txt学习</h2><p>主CMakeList.txt</p><pre class="language-none"><code class="language-none">cmake_minimum_required(VERSION 3.10)project(chat)#配置编译选项set(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)#配置最终的可执行文件输出的路径set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;bin)#配置头文件搜索路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include&#x2F;server)#加载子目录add_subdirectory(src)</code></pre><p>src文件夹下的CMakeList.txt</p><pre class="language-none"><code class="language-none">add_subdirectory(server)</code></pre><p>src文件夹下的server文件夹下的CMakeList.txt</p><pre class="language-none"><code class="language-none">#定义了SRC_LIST变量，包含了当前目录下的所有源文件aux_source_directory(. SRC_LIST) #获取当前目录下所有源文件#指定生成可执行文件add_executable(ChatServer $&#123;SRC_LIST&#125;)#指定可执行文件需要链接的库target_link_libraries(ChatServer muduo_net muduo_base pthread) #链接muduo库和pthread库</code></pre><h3 id="项目常见的cmake指令使用步骤"><a href="#项目常见的cmake指令使用步骤" class="headerlink" title="项目常见的cmake指令使用步骤"></a>项目常见的cmake指令使用步骤</h3><pre class="language-none"><code class="language-none">mkdir buildcd buildcmake ..make         # 如果你使用的是 Unix&#x2F;Linux&#x2F;macOS，或者是 MinGW</code></pre><p>解释：</p><ul><li><code>mkdir build</code>：创建构建目录（推荐 out-of-source build）</li><li><code>cd build</code>：进入构建目录</li><li><code>cmake ..</code>：执行 CMake，读取上一级目录的 <code>CMakeLists.txt</code>，生成构建系统（默认是 Makefile）</li><li><code>make</code>：使用生成的 Makefile 编译项目</li></ul><h2 id="集群聊天服务器"><a href="#集群聊天服务器" class="headerlink" title="集群聊天服务器"></a>集群聊天服务器</h2><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p><img src="/2025/06/02/C++-chatserver/1.png" alt="1" loading="lazy"></p><p>bin文件夹编译完成后的 <code>.exe</code>（Windows）或无扩展的可执行文件。</p><p>build文件夹通常用于存放 <strong>构建过程中产生的所有中间文件</strong>，它是整个编译流程的“临时工作区”。</p><p>include文件夹存放头文件（Header Files），src文件夹是 C++ 项目中最常见也最核心的目录之一，用于存放 <strong>源代码实现文件（source files）</strong>，主要是 <code>.cpp</code> 文件（也包括 <code>.c</code>, <code>.cc</code>, <code>.cxx</code> 等）。</p><p>test文件夹在 C++ 项目中用于存放<strong>测试代码</strong>，主要用于验证项目功能是否正确，确保每个模块在修改后仍然可以正常工作。</p><p>thirdparty文件夹在 C++ 项目中用于存放<strong>第三方依赖库的源码或接口文件</strong>。在这里存储了json.hpp文件。</p><h3 id="CMakeLists-txt文件存放和使用"><a href="#CMakeLists-txt文件存放和使用" class="headerlink" title="CMakeLists.txt文件存放和使用"></a>CMakeLists.txt文件存放和使用</h3><p>CMakeLists.txt文件放在了主目录，src文件夹里，src&#x2F;server文件夹里，接下来分别说明对应文件夹中CMakeLists.txt的作用。</p><p>主目录文件夹</p><pre class="language-none"><code class="language-none">cmake_minimum_required(VERSION 3.10)project(chat)#配置编译选项set(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)#配置最终的可执行文件输出的路径set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;bin)#配置头文件搜索路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include&#x2F;server)include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include&#x2F;server&#x2F;db)include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;thirdparty)#加载子目录add_subdirectory(src)</code></pre><p>主目录 <code>CMakeLists.txt</code> 的作用概括：</p><ol><li><strong>设置项目基本信息</strong>：指定 CMake 最低版本和项目名称。</li><li><strong>配置全局编译选项</strong>：例如添加调试信息（<code>-g</code>）以便调试。</li><li><strong>设置可执行文件输出路径</strong>：统一将程序输出到 <code>bin/</code> 目录。</li><li><strong>配置头文件搜索路径</strong>：包括项目头文件目录和第三方库目录，便于代码引用。</li><li><strong>组织子目录构建</strong>：通过 <code>add_subdirectory(src)</code> 加载 <code>src</code> 子目录，交由其继续组织源码编译。</li></ol><p>src文件夹</p><pre class="language-none"><code class="language-none">add_subdirectory(server)</code></pre><p><code>add_subdirectory(server)</code> 把 <code>server</code> 子目录纳入构建流程，交由其内部的 <code>CMakeLists.txt</code> 具体定义编译规则，是模块化项目管理的关键步骤。</p><p>src&#x2F;server文件夹</p><pre class="language-none"><code class="language-none">#定义了SRC_LIST变量，包含了当前目录下的所有源文件aux_source_directory(. SRC_LIST) #获取当前目录下所有源文件aux_source_directory(.&#x2F;db DB_LIST)#获取db文件下的所有源文件#指定生成可执行文件add_executable(ChatServer $&#123;SRC_LIST&#125; $&#123;DB_LIST&#125;)#指定可执行文件需要链接的库target_link_libraries(ChatServer muduo_net muduo_base mysqlclient pthread) #链接muduo库和pthread库</code></pre><p><code>src/server/CMakeLists.txt</code> 的作用概括：</p><ol><li><strong>收集源文件</strong>：自动获取当前目录和 <code>db</code> 子目录下的所有 <code>.cpp</code> 文件。</li><li><strong>生成可执行程序</strong>：将源文件编译为 <code>ChatServer</code> 可执行文件。</li><li><strong>链接依赖库</strong>：链接 Muduo 网络库、MySQL 客户端库和 pthread 线程库。</li></ol><h3 id="thirdparty文件夹（第三方库）json-hpp"><a href="#thirdparty文件夹（第三方库）json-hpp" class="headerlink" title="thirdparty文件夹（第三方库）json.hpp"></a>thirdparty文件夹（第三方库）json.hpp</h3><p>聊天服务器项目中，<code>json.hpp</code> 负责处理客户端与服务端之间的 JSON 数据格式，承担消息的 <strong>解析、构建与传输格式化</strong>，是通信协议的关键组件。</p><h3 id="include-server-chatserver-hpp-聊天服务器的主类"><a href="#include-server-chatserver-hpp-聊天服务器的主类" class="headerlink" title="include&#x2F;server&#x2F;chatserver.hpp 聊天服务器的主类"></a>include&#x2F;server&#x2F;chatserver.hpp 聊天服务器的主类</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CHATSERVER_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CHATSERVER_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;muduo/net/TcpServer.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;muduo/net/EventLoop.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> muduo<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> muduo<span class="token double-colon punctuation">::</span>net<span class="token punctuation">;</span><span class="token comment">//聊天服务器的主类</span><span class="token keyword">class</span> <span class="token class-name">ChatServer</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">//初始化聊天服务器队对象</span>    <span class="token function">ChatServer</span><span class="token punctuation">(</span>EventLoop<span class="token operator">*</span> loop<span class="token punctuation">,</span>            <span class="token keyword">const</span> InetAddress<span class="token operator">&amp;</span> listenAddr<span class="token punctuation">,</span>            <span class="token keyword">const</span> string<span class="token operator">&amp;</span> nameArg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//启动服务</span>    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">//上报连接相关信息的回调函数</span>    <span class="token keyword">void</span> <span class="token function">onConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr<span class="token operator">&amp;</span> conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//上报读写事件的回调函数</span>    <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr<span class="token operator">&amp;</span> conn<span class="token punctuation">,</span>            Buffer<span class="token operator">*</span> buffer<span class="token punctuation">,</span>            Timestamp time<span class="token punctuation">)</span><span class="token punctuation">;</span>    TcpServer _server<span class="token punctuation">;</span><span class="token comment">//组合的muduo库，实现服务器功能的类对象</span>    EventLoop <span class="token operator">*</span>_loop<span class="token punctuation">;</span><span class="token comment">//指向事件循环的指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre><p><code>ChatServer.h</code> 作用及结构概括</p><ol><li><strong>类功能</strong></li></ol><p>定义了聊天服务器的主类 <code>ChatServer</code>，负责网络服务的初始化、启动和事件处理。</p><ol start="2"><li><strong>成员变量</strong></li></ol><ul><li><code>_server</code>：<code>muduo::net::TcpServer</code> 对象，负责网络连接管理和服务端监听。</li><li><code>_loop</code>：<code>muduo::net::EventLoop</code> 指针，负责事件循环和调度。</li></ul><ol start="3"><li><strong>核心接口</strong></li></ol><ul><li>构造函数 <code>ChatServer(EventLoop*, const InetAddress&amp;, const string&amp;)</code>：初始化服务器监听地址、名称和事件循环。</li><li><code>start()</code>：启动服务器监听，进入事件循环。</li></ul><ol start="4"><li><strong>回调函数</strong>（私有）</li></ol><ul><li><code>onConnection()</code>：处理客户端连接和断开事件。</li><li><code>onMessage()</code>：处理客户端消息接收事件，进行消息读写。</li></ul><p><code>ChatServer</code> 类是整个聊天项目的网络核心，利用 Muduo 库提供的 TCP 服务器功能，封装了网络事件的注册与处理，负责服务器端的网络通信逻辑。</p><h3 id="src-server-chatserver-cpp"><a href="#src-server-chatserver-cpp" class="headerlink" title="src&#x2F;server&#x2F;chatserver.cpp"></a>src&#x2F;server&#x2F;chatserver.cpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;chatserver.hpp&quot;#include &lt;string&gt;#include &quot;chatservice.hpp&quot;#include &lt;functional&gt;#include &quot;json.hpp&quot;using json &#x3D;nlohmann::json;&#x2F;&#x2F;初始化聊天服务器队对象ChatServer::ChatServer(EventLoop* loop,            const InetAddress&amp; listenAddr,            const string&amp; nameArg)    : _server(loop, listenAddr, nameArg),      _loop(loop)&#123;    &#x2F;&#x2F;注册连接回调    _server.setConnectionCallback(        std::bind(&amp;ChatServer::onConnection, this, std::placeholders::_1));    &#x2F;&#x2F;注册消息回调    _server.setMessageCallback(        std::bind(&amp;ChatServer::onMessage, this, std::placeholders::_1,                  std::placeholders::_2, std::placeholders::_3));    &#x2F;&#x2F;设置线程数量    _server.setThreadNum(4);&#125;&#x2F;&#x2F;启动服务void ChatServer::start()&#123;    _server.start();&#125;&#x2F;&#x2F;上报连接相关信息的回调函数void ChatServer::onConnection(const TcpConnectionPtr&amp; conn)&#123;    &#x2F;&#x2F;客户端断开连接    if(!conn-&gt;connected())&#123;        conn-&gt;shutdown();    &#125;&#125;    &#x2F;&#x2F;上报读写事件的回调函数void ChatServer::onMessage(const TcpConnectionPtr&amp; conn,            Buffer* buffer,            Timestamp time)&#123;    string buf&#x3D;buffer-&gt;retrieveAllAsString();    &#x2F;&#x2F;数据的反序列化    json js&#x3D;json::parse(buf);    &#x2F;&#x2F;达到的目的:完全解耦网络模块的代码和业务模块的代码    &#x2F;&#x2F;通过js[&quot;msgid&quot;] 获取&#x3D;》业务handler&#x3D;&gt;conn js time    auto msgHandler&#x3D;ChatService::instance()-&gt;getHandler(js[&quot;msgid&quot;].get&lt;int&gt;());    &#x2F;&#x2F;回调消息绑定好的事件处理器，来执行相应的业务处理    msgHandler(conn,js,time);    &#125;</code></pre><p>ChatServer.cpp 作用与关键点概括</p><ol><li><strong>构造函数初始化</strong></li></ol><ul><li>初始化 Muduo 的 TCP 服务器对象 <code>_server</code> 和事件循环 <code>_loop</code>。</li><li>注册回调函数：<ul><li><code>onConnection</code> 处理连接建立与断开；</li><li><code>onMessage</code> 处理客户端消息。</li></ul></li><li>设置线程数为4，支持多线程处理网络事件。</li></ul><ol start="2"><li><strong>启动服务</strong></li></ol><ul><li><code>start()</code> 调用 Muduo 的 <code>_server.start()</code> 启动监听和事件循环。</li></ul><ol start="3"><li><strong>连接回调 <code>onConnection</code></strong></li></ol><ul><li>判断客户端是否断开连接，断开时调用 <code>conn-&gt;shutdown()</code> 关闭连接。</li></ul><ol start="4"><li><strong>消息回调 <code>onMessage</code></strong></li></ol><ul><li>将网络缓冲区中的数据读取为字符串。</li><li>使用 <code>json.hpp</code> 将字符串反序列化成 JSON 对象。</li><li>通过消息中的 <code>&quot;msgid&quot;</code> 字段，调用业务层 <code>ChatService</code> 获取对应的消息处理函数（回调）。</li><li>执行该消息处理函数，完成具体的业务逻辑处理。</li></ul><hr><p>作用总结</p><p>这段代码实现了聊天服务器的核心网络处理逻辑，做到：</p><ul><li><strong>网络层与业务层解耦</strong>：网络部分只负责收发和解析数据，业务处理由 <code>ChatService</code> 中注册的处理器完成。</li><li><strong>灵活消息分发</strong>：根据 JSON 中的 <code>msgid</code> 动态调用对应业务处理函数，实现消息驱动机制。</li><li><strong>高效异步处理</strong>：基于 Muduo 多线程事件循环模型，支持高并发网络请求。</li></ul><h3 id="include-server-chatservice-hpp-聊天服务器业务类"><a href="#include-server-chatservice-hpp-聊天服务器业务类" class="headerlink" title="include&#x2F;server&#x2F;chatservice.hpp 聊天服务器业务类"></a>include&#x2F;server&#x2F;chatservice.hpp 聊天服务器业务类</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef CHATSERVICE_H#define CHATSERVICE_H#include &lt;muduo&#x2F;net&#x2F;TcpConnection.h&gt;#include &lt;unordered_map&gt;#include &lt;functional&gt;#include &quot;json.hpp&quot;using namespace std;using namespace muduo;using namespace muduo::net;using json &#x3D;nlohmann::json;&#x2F;&#x2F;表示处理消息的事件回调方法类型using MsgHandler &#x3D; std::function&lt;void(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&gt;;&#x2F;&#x2F;聊天服务器业务类class ChatService&#123;public:    &#x2F;&#x2F;获取单例对象的接口函数    static ChatService * instance();    &#x2F;&#x2F;处理登录业务    void login(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);    &#x2F;&#x2F;处理注册业务    void reg(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);    &#x2F;&#x2F;获取消息对应的处理器    MsgHandler getHandler(int msgid);private:    ChatService();    &#x2F;&#x2F;存储消息id和其对应的业务处理方法    unordered_map&lt;int,MsgHandler&gt; _msgHandlerMap;&#125;;#endif</code></pre><p>ChatService.h 作用与结构概括</p><ol><li><strong>类功能</strong></li></ol><ul><li>负责处理聊天服务器的核心业务逻辑，如登录、注册等。</li><li>管理消息 ID 与对应的处理函数的映射，实现消息的动态分发。</li></ul><ol start="2"><li><strong>核心类型</strong></li></ol><ul><li><code>MsgHandler</code>：消息处理函数类型，参数包括 TCP 连接指针、JSON 消息对象和时间戳。</li></ul><ol start="3"><li><strong>接口函数</strong></li></ol><ul><li><code>static ChatService* instance()</code>：单例模式，获取业务服务唯一实例。</li><li><code>void login(...)</code>：处理登录业务逻辑。</li><li><code>void reg(...)</code>：处理注册业务逻辑。</li><li><code>MsgHandler getHandler(int msgid)</code>：根据消息 ID 获取对应的消息处理函数。</li></ul><ol start="4"><li><strong>成员变量</strong></li></ol><ul><li><code>_msgHandlerMap</code>：存储消息 ID 与处理函数的映射，支持根据消息类型快速调用相应业务处理器。</li></ul><h3 id="src-server-chatservice-cpp"><a href="#src-server-chatservice-cpp" class="headerlink" title="src&#x2F;server&#x2F;chatservice.cpp"></a>src&#x2F;server&#x2F;chatservice.cpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;chatservice.hpp&quot;#include &quot;public.hpp&quot;#include &lt;string&gt;#include &lt;muduo&#x2F;base&#x2F;Logging.h&gt;using namespace muduo;using namespace std;&#x2F;&#x2F;获取单例对象的接口函数&#x2F;&#x2F;在cpp文件就不需要写static了ChatService * ChatService::instance()&#123;    static ChatService service;    return &service;&#125;&#x2F;&#x2F;注册消息以及对应的Handler回调操作 ChatService::ChatService()&#123;    &#x2F;&#x2F;注册业务    _msgHandlerMap.insert(&#123;LOGIN_MSG,std::bind(&amp;ChatService::login,this,_1,_2,_3)&#125;);    _msgHandlerMap.insert(&#123;REG_MSG,std::bind(&amp;ChatService::reg,this,_1,_2,_3)&#125;); &#125;&#x2F;&#x2F;获取消息对应的处理器 MsgHandler ChatService::getHandler(int msgid)&#123;    &#x2F;&#x2F;记录错误日志，msgid没有对应的事件处理回调    auto it &#x3D;_msgHandlerMap.find(msgid);    if(it &#x3D;&#x3D;_msgHandlerMap.end())&#123;        &#x2F;&#x2F;返回一个默认的处理器，空操作        return [&#x3D;](const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;            LOG_ERROR&lt;&lt;&quot;msgid:&quot;&lt;&lt; msgid &lt;&lt;&quot;can not find handler!&quot;;        &#125;;    &#125;    else&#123;        return _msgHandlerMap[msgid];    &#125;&#125;&#x2F;&#x2F;处理登录业务void ChatService::login(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    LOG_INFO &lt;&lt;&quot;do login service!!!!&quot;;&#125;&#x2F;&#x2F;处理注册业务void ChatService::reg(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    LOG_INFO&lt;&lt;&quot;do reg service!!!&quot;;&#125;</code></pre><p>ChatService.cpp 作用和关键点</p><ol><li><strong>单例模式实现</strong></li></ol><ul><li><code>instance()</code> 函数内部静态变量实现线程安全的单例模式，保证 <code>ChatService</code> 只有一个实例。</li></ul><ol start="2"><li><strong>构造函数注册消息处理函数</strong></li></ol><ul><li>在构造函数中通过 <code>_msgHandlerMap.insert</code> 将消息 ID（<code>LOGIN_MSG</code>、<code>REG_MSG</code>）绑定到成员函数 <code>login</code> 和 <code>reg</code> 的回调。</li><li>使用 <code>std::bind</code> 绑定成员函数和 <code>this</code> 指针，方便后续调用。</li></ul><ol start="3"><li><strong>动态消息处理函数获取</strong></li></ol><ul><li><code>getHandler(int msgid)</code> 根据传入的消息 ID 返回对应的处理函数。</li><li>如果消息 ID 未注册，返回一个默认空操作的 lambda，同时写错误日志，保证系统健壮性。</li></ul><ol start="4"><li><strong>业务处理函数示例</strong></li></ol><ul><li><code>login()</code> 和 <code>reg()</code> 目前仅打印日志，代表登录和注册的业务处理接口，后续可以扩展具体业务逻辑。</li></ul><h3 id="include-public-hpp"><a href="#include-public-hpp" class="headerlink" title="include&#x2F;public.hpp"></a>include&#x2F;public.hpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef PUBLIC_H#define PUBLIC_H&#x2F;*server和client的公共文件*&#x2F;enum EnMsgType&#123;    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息    REG_MSG&#x2F;&#x2F;注册消息&#125;;#endif</code></pre><p>public.h 作用简述</p><ul><li><strong>共享消息类型定义</strong><ul><li>定义了枚举类型 <code>EnMsgType</code>，用于区分不同的消息类型。</li><li>目前包含两种消息：<ul><li><code>LOGIN_MSG = 1</code>：登录消息</li><li><code>REG_MSG</code>：注册消息</li></ul></li></ul></li><li><strong>作用</strong><ul><li>服务端和客户端都包含这个头文件，保证双方对消息类型有统一的理解和对应关系，方便通信协议的设计与实现。</li></ul></li></ul><h3 id="src-server-main-cpp"><a href="#src-server-main-cpp" class="headerlink" title="src&#x2F;server&#x2F;main.cpp"></a>src&#x2F;server&#x2F;main.cpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;chatserver.hpp&quot;#include &lt;iostream&gt;using namespace std;int main()&#123;    EventLoop loop;    InetAddress addr(&quot;127.0.0.1&quot;,6000);    ChatServer server(&amp;loop, addr, &quot;ChatServer&quot;);    server.start();    &#x2F;&#x2F;开启事件循环    loop.loop();    return 0;&#125;</code></pre><p><strong>启动聊天服务器</strong>：<br> 创建事件循环和服务器监听地址，初始化 <code>ChatServer</code> 对象，启动服务器后进入事件循环，开始接受和处理客户端连接与消息。</p><h3 id="include-server-db-db-h-数据库操作类"><a href="#include-server-db-db-h-数据库操作类" class="headerlink" title="include&#x2F;server&#x2F;db&#x2F;db.h 数据库操作类"></a>include&#x2F;server&#x2F;db&#x2F;db.h 数据库操作类</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef DB_H#define DB_H#include&lt;mysql&#x2F;mysql.h&gt;#include&lt;string&gt;using namespace std;&#x2F;&#x2F; 数据库操作类class MySQL &#123; public: &#x2F;&#x2F; 初始化数据库连接MySQL();&#x2F;&#x2F; 释放数据库连接资源~MySQL();&#x2F;&#x2F; 连接数据库bool connect();&#x2F;&#x2F; 更新操作bool update(string sql);&#x2F;&#x2F; 查询操作MYSQL_RES* query(string sql);&#x2F;&#x2F;获取连接MYSQL * getConnection();private:    MYSQL *_conn;&#125;;#endif</code></pre><p><strong>MySQL 数据库操作类说明</strong></p><p><strong>类功能</strong></p><p>封装对 MySQL 数据库的连接、查询和更新操作，方便上层业务调用。</p><p><strong>主要成员函数</strong></p><ul><li>**构造函数 <code>MySQL()</code>**：初始化数据库连接相关资源。</li><li>**析构函数 <code>~MySQL()</code>**：释放数据库连接资源。</li><li>**<code>bool connect()</code>**：连接数据库，返回连接是否成功。</li><li>**<code>bool update(string sql)</code>**：执行更新类 SQL 语句（如 INSERT、UPDATE、DELETE）。</li><li>**<code>MYSQL_RES* query(string sql)</code>**：执行查询类 SQL 语句，返回结果集指针。</li><li>**<code>MYSQL* getConnection()</code>**：获取底层 MySQL 连接对象，便于其他操作。</li></ul><p><strong>成员变量</strong></p><ul><li>**<code>MYSQL *_conn</code>**：指向 MySQL 连接句柄的指针。</li></ul><h3 id="src-server-db-db-cpp"><a href="#src-server-db-db-cpp" class="headerlink" title="src&#x2F;server&#x2F;db&#x2F;db.cpp"></a>src&#x2F;server&#x2F;db&#x2F;db.cpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;db.h&quot;#include &lt;muduo&#x2F;base&#x2F;Logging.h&gt;&#x2F;&#x2F; 数据库配置信息static string server &#x3D; &quot;127.0.0.1&quot;;static string user &#x3D; &quot;root&quot;;static string password &#x3D; &quot;123456&quot;;static string dbname &#x3D; &quot;chat&quot;;&#x2F;&#x2F; 初始化数据库连接MySQL::MySQL()&#123;    _conn &#x3D; mysql_init(nullptr);&#125;&#x2F;&#x2F; 释放数据库连接资源MySQL::~MySQL()&#123;    if (_conn !&#x3D; nullptr)    mysql_close(_conn);&#125;&#x2F;&#x2F; 连接数据库bool MySQL::connect()&#123;    MYSQL *p &#x3D; mysql_real_connect(_conn, server.c_str(), user.c_str(),password.c_str(), dbname.c_str(), 3306, nullptr, 0);    if (p !&#x3D; nullptr)    &#123;        &#x2F;&#x2F;C和C++代码默认的编码字符是ASCII,如果不设置，从MySQL上拉下来的中文显示？        mysql_query(_conn, &quot;set names gbk&quot;);        LOG_INFO &lt;&lt; &quot;connect mysql success!&quot;;    &#125;else&#123;        LOG_INFO &lt;&lt; &quot;connect mysql failed!&quot;;    &#125;    return p;&#125;&#x2F;&#x2F; 更新操作bool MySQL::update(string sql)&#123;    if (mysql_query(_conn, sql.c_str()))    &#123;        LOG_INFO &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;:&quot;                &lt;&lt; sql &lt;&lt; &quot;更新失败!&quot;;            return false;    &#125;    return true;&#125;&#x2F;&#x2F; 查询操作MYSQL_RES* MySQL::query(string sql)&#123;    if (mysql_query(_conn, sql.c_str()))        &#123;            LOG_INFO &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;:&quot;                &lt;&lt; sql &lt;&lt; &quot;查询失败!&quot;;            return nullptr;        &#125;    return mysql_use_result(_conn);&#125;&#x2F;&#x2F;获取连接MYSQL * MySQL::getConnection()&#123;    return _conn;&#125;</code></pre><p><strong>MySQL 类实现功能简述</strong></p><ol><li><strong>初始化连接</strong><ul><li>构造函数 <code>MySQL()</code> 调用 <code>mysql_init</code> 初始化 MySQL 连接对象。</li></ul></li><li><strong>释放连接资源</strong><ul><li>析构函数 <code>~MySQL()</code> 关闭数据库连接，释放资源。</li></ul></li><li><strong>连接数据库</strong><ul><li><code>connect()</code> 使用 <code>mysql_real_connect</code> 连接到数据库。</li><li>成功连接后设置字符集为 <code>gbk</code>，防止中文乱码。</li><li>通过日志打印连接成功或失败信息。</li></ul></li><li><strong>执行更新操作</strong><ul><li><code>update(string sql)</code> 执行 SQL 更新语句（如 INSERT、UPDATE、DELETE）。</li><li>失败时打印错误日志，返回 <code>false</code>。</li></ul></li><li><strong>执行查询操作</strong><ul><li><code>query(string sql)</code> 执行 SQL 查询语句。</li><li>返回查询结果指针，失败时返回 <code>nullptr</code>。</li></ul></li><li><strong>获取底层连接</strong><ul><li><code>getConnection()</code> 返回当前的 MySQL 连接指针，方便其他数据库操作调用。</li></ul></li></ol><h3 id="include-server-user-hpp-数据库中user表对应的类"><a href="#include-server-user-hpp-数据库中user表对应的类" class="headerlink" title="include&#x2F;server&#x2F;user.hpp 数据库中user表对应的类"></a>include&#x2F;server&#x2F;user.hpp 数据库中user表对应的类</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef USER_H#define USER_H#include&lt;string&gt;using namespace std;&#x2F;&#x2F;User表的ORM类class User&#123;    public:        User(int id&#x3D;1,string name&#x3D;&quot;&quot;,string pwd&#x3D;&quot;&quot;,string state&#x3D;&quot;offline&quot;)&#123;            this-&gt;id&#x3D;id;            this-&gt;name&#x3D;name;            this-&gt;password&#x3D;pwd;            this-&gt;state&#x3D;state;        &#125;        void setId(int id)&#123;this-&gt;id&#x3D;id;&#125;        void setName(string name)&#123;this-&gt;name&#x3D;name;&#125;        void setPwd(string pwd)&#123;this-&gt;password&#x3D;pwd;&#125;        void setState(string state)&#123;this-&gt;state&#x3D;state;&#125;        int getId()&#123;return this-&gt;id;&#125;        string getName()&#123;return this-&gt;name;&#125;        string getPwd()&#123;return this-&gt;password;&#125;        string getState()&#123;return this-&gt;state;&#125;    private:        int id;        string name;        string password;        string state;&#125;;#endif</code></pre><p><strong><code>User</code> 类作用概括：</strong></p><ol><li><strong>ORM 映射作用</strong></li></ol><ul><li>该类是对数据库 <code>User</code> 表的一个对象化表示（Object-Relational Mapping）。</li><li>将数据库中的一条用户记录封装成一个 C++ 对象，便于在程序中操作。</li></ul><ol start="2"><li><strong>属性封装</strong></li></ol><p>类中包含如下用户信息字段：</p><ul><li><code>id</code>: 用户编号</li><li><code>name</code>: 用户名</li><li><code>password</code>: 用户密码</li><li><code>state</code>: 用户状态（如 <code>&quot;online&quot;</code> &#x2F; <code>&quot;offline&quot;</code>）</li></ul><ol start="3"><li><strong>基本接口功能</strong></li></ol><p>提供了以下功能函数：</p><ul><li>构造函数（支持默认值）</li><li><code>setXXX()</code> 设置各字段值</li><li><code>getXXX()</code> 获取各字段值</li></ul><p><strong>项目中的实际用途</strong></p><p>基于 Muduo 的聊天服务器项目中：</p><ul><li>用户数据从数据库中查询出来后，可以封装成 <code>User</code> 类对象；</li><li>在业务逻辑中传递用户信息时，使用 <code>User</code> 类便于管理；</li><li>与数据库交互模块（如 DAO 类）进行数据传递、封装与解封装；</li><li>便于将用户信息序列化为 JSON 数据发送到客户端。</li></ul><h3 id="include-server-usermodel-hpp-user表的数据操作类"><a href="#include-server-usermodel-hpp-user表的数据操作类" class="headerlink" title="include&#x2F;server&#x2F;usermodel.hpp  user表的数据操作类"></a>include&#x2F;server&#x2F;usermodel.hpp  user表的数据操作类</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef USERMODEL_H#define USERMODEL_H#include &quot;user.hpp&quot;&#x2F;&#x2F;user表的数据操作类class UserModel&#123;public:    &#x2F;&#x2F;User表的增加方法    bool insert(User &amp;user);&#125;;#endif</code></pre><p><code>#ifndef/#define/#endif</code>：防止头文件重复包含（include guard）；</p><p><code>#include &quot;user.hpp&quot;</code>：引入用户实体类定义；</p><p><code>class UserModel</code>：封装了对 <code>User</code> 表的数据库操作；</p><p><code>bool insert(User &amp;user)</code>：定义了插入用户的方法，返回是否成功。</p><h3 id="src-server-usermodel-cpp"><a href="#src-server-usermodel-cpp" class="headerlink" title="src&#x2F;server&#x2F;usermodel.cpp"></a>src&#x2F;server&#x2F;usermodel.cpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;usermodel.hpp&quot;#include &quot;db.h&quot;#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;User表的增加方法bool UserModel::insert(User &amp;user)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;insert into User(name,password,state) values(&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;)&quot;,        user.getName().c_str(),user.getPwd().c_str(),user.getState().c_str());    MySQL mysql;    if(mysql.connect())&#123;        if(mysql.update(sql))&#123;            &#x2F;&#x2F;获取插入成功的用户数据生成的主键id            user.setId(mysql_insert_id(mysql.getConnection()));            return true;        &#125;    &#125;    return false;&#125;</code></pre><p><code>sprintf</code> 组装 SQL；</p><p><code>MySQL</code> 是你自定义的数据库操作类，封装了 <code>connect()</code> 和 <code>update()</code>；</p><p>插入成功后，用 <code>mysql_insert_id()</code> 获取刚插入的记录主键 ID。</p><h3 id="注册业务实现"><a href="#注册业务实现" class="headerlink" title="注册业务实现"></a>注册业务实现</h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>public.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">enum EnMsgType&#123;    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息    REG_MSG,&#x2F;&#x2F;注册消息    REG_MSG_ACK &#x2F;&#x2F;注册响应消息&#125;;</code></pre><p>再加上REG_MSG_ACK 注册响应消息，告诉客户端已经收到消息。</p><p>chatservice.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">private:    ChatService();    &#x2F;&#x2F;存储消息id和其对应的业务处理方法    unordered_map&lt;int,MsgHandler&gt; _msgHandlerMap;    &#x2F;&#x2F;数据操作类对象    UserModel _userModel;</code></pre><p>在private中加入数据操作类对象UserModel _userModel，这个是自定义的对象在usermodel.hpp</p><p>chatservice.cpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">void ChatService::reg(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    string name&#x3D;js[&quot;name&quot;];    string pwd&#x3D;js[&quot;password&quot;];    User user;    user.setName(name);    user.setPwd(pwd);    bool state&#x3D;_userModel.insert(user);    if(state)&#123;        &#x2F;&#x2F;注册成功        json response;        response[&quot;msgid&quot;]&#x3D; REG_MSG_ACK;        response[&quot;errno&quot;]&#x3D;0;        response[&quot;id&quot;]&#x3D;user.getId();        conn-&gt;send(response.dump());    &#125;else&#123;        &#x2F;&#x2F;注册失败        json response;        response[&quot;msgid&quot;]&#x3D; REG_MSG_ACK;        response[&quot;errno&quot;]&#x3D;1;        conn-&gt;send(response.dump());    &#125;&#125;</code></pre><p>在ChatService类的reg函数，负责处理注册业务的。js中存储的是我们的消息以json存储的。这里面的字段例如msgid,name,password都是服务端和客户端约定好的。首先将消息中的name,和password拿出来赋值给User类对象user,注册业务，把对应的值存入数据库chat中的User表中。当数据操作类对象_userModel插入成功时，返回消息给客户端，msgid是客户端和服务端规定的消息类型，消息REG_MSG_ACK注册后的回应消息。返回的消息有消息类型和是否注册成功的标志errno(0表示成功，1表示失败)，注册失败id也不会产生，所以不用发了。最后使用json的dump()函数转换为字符串通过conn的send函数再发出去。</p><h4 id="conn是TcpConnectionPtr类型"><a href="#conn是TcpConnectionPtr类型" class="headerlink" title="conn是TcpConnectionPtr类型"></a>conn是TcpConnectionPtr类型</h4><p><code>TcpConnectionPtr</code> 是 <strong>Muduo 网络库</strong> 中定义的一个智能指针类型，指向 <code>TcpConnection</code> 对象，通常用于表示一条活跃的 TCP 连接。</p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;</code></pre><p>它的生命周期由 <code>Muduo</code> 网络库自动管理。</p><p>常见成员函数（通过 <code>TcpConnectionPtr</code> 调用）</p><ul><li><code>conn-&gt;send(data)</code>：发送数据到客户端</li><li><code>conn-&gt;shutdown()</code>：关闭连接（半关闭）</li><li><code>conn-&gt;connected()</code>：是否仍保持连接</li><li><code>conn-&gt;peerAddress()</code>：对端地址</li><li><code>conn-&gt;localAddress()</code>：本地地址</li><li><code>conn-&gt;setContext()</code> &#x2F; <code>conn-&gt;getContext()</code>：绑定上下文（可保存登录信息、用户ID等）</li></ul><h4 id="实现注册业务时出现的问题"><a href="#实现注册业务时出现的问题" class="headerlink" title="实现注册业务时出现的问题"></a>实现注册业务时出现的问题</h4><p>实现注册业务时，使用vscod远程连接Linux出现了连接数据库不上的问题。</p><pre class="language-none"><code class="language-none">20250604 13:22:35.282815Z 18893 INFO  connect mysql failed!Access denied for user &#39;root&#39;@&#39;localhost&#39; - db.cpp:29</code></pre><p>数据库拒绝了 root 用户从 localhost 的访问请求。</p><p>解决方案</p><p>1.使用Linux root用户登录mysql</p><p>2.修改root用户认证方式为密码登录</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'root'</span><span class="token variable">@'localhost'</span> IDENTIFIED <span class="token keyword">WITH</span> mysql_native_password <span class="token keyword">BY</span> <span class="token string">'123456'</span><span class="token punctuation">;</span>FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span><span class="token keyword">EXIT</span><span class="token punctuation">;</span></code></pre><p>第一句ALTER USER修改存在的用户 ‘root‘@’localhost’用户名为root,本地连接。IDENTIFIED WITH mysql_native_password 设置认证插件为 <code>mysql_native_password</code>（密码方式）</p><p>第二句MySQL 会将用户和权限信息缓存在内存中，这条命令强制它 重新加载所有权限表。<code>ALTER USER</code> 做的更改立即生效，而不必重启 MySQL 服务</p><p>第三句对用户权限和密码的修改完成了，退出命令行界面即可。</p><p><code>auth_socket</code> 是 MySQL 默认的一种用户认证方式，<strong>主要用于本地登录</strong>，<strong>不使用密码，而是通过操作系统身份验证</strong>。MySQL 会验证：</p><ul><li>你是否是当前 Linux 系统的 <code>root</code> 用户；</li><li>如果是，允许登录；</li><li>否则，拒绝访问，即使你输入了正确的密码也没用。</li></ul><h3 id="登录业务实现"><a href="#登录业务实现" class="headerlink" title="登录业务实现"></a>登录业务实现</h3><h4 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h4><p>public.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">enum EnMsgType&#123;    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息    LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息    REG_MSG,&#x2F;&#x2F;注册消息    REG_MSG_ACK &#x2F;&#x2F;注册响应消息&#125;;</code></pre><p>加入LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息</p><p>usermodel.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;根据用户号码查询用户信息User query(int id);&#x2F;&#x2F;更新用户的状态信息bool updateState(User user);</code></pre><p>加入这两个函数，后面会在登录业务用到</p><p>usermodel.cpp 对应函数的具体实现</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;根据用户号码查询用户信息User UserModel::query(int id)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;select * from User where id&#x3D;%d&quot;,id);    MySQL mysql;    if(mysql.connect())&#123;        MYSQL_RES* res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;&#x2F;&#x2F;查询成功            MYSQL_ROW row&#x3D;mysql_fetch_row(res);&#x2F;&#x2F;查一行            if(row!&#x3D;nullptr)&#123;                User user;                user.setId(atoi(row[0]));&#x2F;&#x2F;转换id为int，从数据库取出的都是字符串                user.setName(row[1]);&#x2F;&#x2F;用户名                user.setPwd(row[2]);&#x2F;&#x2F;密码                user.setState(row[3]);&#x2F;&#x2F;状态，以上是根据查询出的结果集取得                mysql_free_result(res);&#x2F;&#x2F;释放结果集资源                return user;            &#125;        &#125;    &#125;    return User();&#125;&#x2F;&#x2F;更新用户的状态信息bool UserModel::updateState(User user)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;update User set state &#x3D; &#39;%s&#39; where id &#x3D; %d&quot;,user.getState().c_str(),user.getId());    MySQL mysql;    if(mysql.connect())&#123;        if(mysql.update(sql))&#123;            return true;        &#125;    &#125;    return false;&#125;</code></pre><p>chatservice.cpp</p><p>实现login函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;处理登录业务 id pwdvoid ChatService::login(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int id&#x3D;js[&quot;id&quot;];    string pwd&#x3D;js[&quot;password&quot;];    User user&#x3D;_userModel.query(id);    if(user.getId()&#x3D;&#x3D;id&amp;&amp;user.getPwd()&#x3D;&#x3D;pwd)&#123;        if(user.getState()&#x3D;&#x3D;&quot;online&quot;)&#123;            &#x2F;&#x2F;该用户已经登录，不允许重复登录            json response;            response[&quot;msgid&quot;]&#x3D; LOGIN_MSG_ACK;            response[&quot;errno&quot;]&#x3D;2;            response[&quot;errmsg&quot;]&#x3D;&quot;该账号已经登录，请输入新账号&quot;;            conn-&gt;send(response.dump());        &#125;else        &#123;            &#x2F;&#x2F;登录成功，更新用户状态信息 state offline&#x3D;&gt;online            user.setState(&quot;online&quot;);            _userModel.updateState(user);            json response;            response[&quot;msgid&quot;]&#x3D; LOGIN_MSG_ACK;            response[&quot;errno&quot;]&#x3D;0;            response[&quot;id&quot;]&#x3D;user.getId();            response[&quot;name&quot;]&#x3D;user.getName();            conn-&gt;send(response.dump());        &#125;                    &#125;else&#123;        &#x2F;&#x2F;该用户不存在，登陆失败        json response;        response[&quot;msgid&quot;]&#x3D; LOGIN_MSG_ACK;        response[&quot;errno&quot;]&#x3D;1;        response[&quot;errmsg&quot;]&#x3D;&quot;用户名或者密码错误&quot;;        conn-&gt;send(response.dump());    &#125;&#125;</code></pre><h3 id="记录用户的连接信息及线程安全性"><a href="#记录用户的连接信息及线程安全性" class="headerlink" title="记录用户的连接信息及线程安全性"></a>记录用户的连接信息及线程安全性</h3><p>因为要实现用户与用户之间的消息往来，所以要实现记录上线用户的连接信息和下线的删除。</p><p>chatservice.hpp private:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;存储在线用户的通信连接 注意线程安全    unordered_map&lt;int,TcpConnectionPtr&gt; _userConnMap;</code></pre><p>那么这个值在什么时候更新，首先在登录成功时，添加连接</p><p>chatservice.cpp login函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">_userConnMap.insert(&#123;id,conn&#125;);&#x2F;&#x2F;unordered_map容器没有线程安全需要添加线程互斥操作</code></pre><p>当然插入了还不够，多个用户连接服务器，_userConnMap这个是在多线程环境下，要保证线程互斥性。</p><p>大多数 <strong>C++ STL 容器本身</strong>（如 <code>vector</code>、<code>map</code>、<code>unordered_map</code> 等）<strong>不是线程安全的</strong>。</p><p>所以我们要在对这个插入数据加锁。</p><p>chatservice.hpp private:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;记得包含头文件#include &lt;mutex&gt;&#x2F;&#x2F;定义互斥锁，保证_userConnMap的线程安全    mutex _connMutex;</code></pre><p>chatservice.cpp login函数 </p><p>还是在登录成功那里</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#123;     &#x2F;&#x2F;登录成功，记录用户连接信息     lock_guard&lt;mutex&gt; lock(_connMutex);&#x2F;&#x2F;如果不析构，得得遇到&#125;为止，都是互斥，所以加个域     _userConnMap.insert(&#123;id,conn&#125;);&#x2F;&#x2F;unordered_map容器没有线程安全需要添加线程互斥操作&#125;</code></pre><p>有人会问为什么再加一个花括号，这是为了让lock_guard的生命周期结束，这个变量的特性是构造时加锁，析构时自动解锁。</p><h3 id="客户端异常退出业务"><a href="#客户端异常退出业务" class="headerlink" title="客户端异常退出业务"></a>客户端异常退出业务</h3><p>当客户端异常退出时，我们的数据库还没有修改当前状态时在线还是下线，所以要实现这个业务</p><p>chatservice.cpp 定义公共函数clientCloseException</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;处理客户端异常退出void clientCloseException(const TcpConnectionPtr &amp;conn);</code></pre><p>chatservice.cpp 对应函数实现</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;处理客户端异常退出void ChatService::clientCloseException(const TcpConnectionPtr &amp;conn)&#123;    User user;    &#123;        lock_guard&lt;mutex&gt; lock(_connMutex);&#x2F;&#x2F;如果不析构，得得遇到&#125;为止，都是互斥，所以加个域        for(auto it&#x3D;_userConnMap.begin();it!&#x3D;_userConnMap.end();++it)&#123;            if(it-&gt;second &#x3D;&#x3D; conn)&#123;                user.setId(it-&gt;first);                &#x2F;&#x2F;从map表删除用户的连接信息                _userConnMap.erase(it);                break;            &#125;        &#125;    &#125;    &#x2F;&#x2F;更新用户的状态信息    if(user.getId()!&#x3D;-1)&#123;        user.setState(&quot;offline&quot;);        _userModel.updateState(user);    &#125;&#125;</code></pre><p>chatserver.cpp  onConnection函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">if(!conn-&gt;connected())&#123;       &#x2F;&#x2F;处理异常退出业务，state更新为offline       ChatService::instance()-&gt;clientCloseException(conn);       conn-&gt;shutdown();   &#125;</code></pre><p>在确认断开后，使用clientCloseException将state更新为offline。</p><h3 id="一对一聊天业务：在线聊天实现"><a href="#一对一聊天业务：在线聊天实现" class="headerlink" title="一对一聊天业务：在线聊天实现"></a>一对一聊天业务：在线聊天实现</h3><p>public.hpp 加入聊天消息ONE_CHAT_MSG</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*server和client的公共文件*&#x2F;enum EnMsgType&#123;    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息    LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息    REG_MSG,&#x2F;&#x2F;注册消息    REG_MSG_ACK, &#x2F;&#x2F;注册响应消息    ONE_CHAT_MSG, &#x2F;&#x2F;聊天消息&#125;;</code></pre><p>既然注册了业务，所以还要在chatservice.cpp的构造函数，注册业务</p><pre class="language-c++" data-language="c++"><code class="language-c++">_msgHandlerMap.insert(&#123;ONE_CHAT_MSG,std::bind(&amp;ChatService::oneChat,this,_1,_2,_3)&#125;);</code></pre><p>chatservice.hpp 声明一对一聊天业务函数声明</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;一对一聊天业务    void oneChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);</code></pre><p>chatservice.cpp 声明一对一聊天业务函数声明</p><pre class="language-c++" data-language="c++"><code class="language-c++">void ChatService::oneChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int toid&#x3D;js[&quot;to&quot;];    &#123;        lock_guard&lt;mutex&gt; lock(_connMutex);        auto it&#x3D;_userConnMap.find(toid);        if(it!&#x3D;_userConnMap.end())&#123;            &#x2F;&#x2F;toid在线，转发消息            &#x2F;&#x2F;凡涉及_userConnMap注意线程安全性            &#x2F;&#x2F;服务器主动推送原消息给toid用户            it-&gt;second-&gt;send(js.dump());            return;        &#125;    &#125;    &#x2F;&#x2F;toid不在线，存储离线信息&#125;</code></pre><p>这里js里面的构成是</p><p>msgid &#x2F;&#x2F;消息类型<br>id发消息的id<br>from 发消息的name<br>to接受方的id<br>msg 要发送的消息</p><p>在线发送消息整体实现就是服务端接收到消息，之后查看接受用户是否在线，在线则调出服务端与接收端的连接，转发原消息。</p><h3 id="一对一聊天业务：离线消息"><a href="#一对一聊天业务：离线消息" class="headerlink" title="一对一聊天业务：离线消息"></a>一对一聊天业务：离线消息</h3><p>首先离线消息是存储在数据库的一张表里</p><p>这张表只有两个字段userid和message 这里就不用ORM映射构造一个类来保留，所以我们直接构造一个关于这张表的操作类OfflineMsgModel</p><p>offlinemessagemodel.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;string&gt;#include&lt;vector&gt;using namespace std;&#x2F;&#x2F;提供离线消息表的操作接口方法class OfflineMsgModel&#123;public:    &#x2F;&#x2F;存储用户的离线消息    void insert(int userid,string msg);    &#x2F;&#x2F;删除用户的离线消息    void remove(int userid);    &#x2F;&#x2F;查询用户的离线消息    vector&lt;string&gt; query(int userid);&#125;;</code></pre><p>offlinemessagemodel.cpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;offlinemessagemodel.hpp&quot;#include &quot;db.h&quot;&#x2F;&#x2F; 存储用户的离线消息void OfflineMsgModel::insert(int userid, string msg)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;insert into offlineMessage values(%d,&#39;%s&#39;)&quot;,userid,msg.c_str());    MySQL mysql;    if(mysql.connect())&#123;        mysql.update(sql);    &#125;&#125;&#x2F;&#x2F; 删除用户的离线消息void  OfflineMsgModel::remove(int userid)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;delete from offlineMessage where userid&#x3D;%d&quot;,userid);    MySQL mysql;    if(mysql.connect())&#123;        mysql.update(sql);    &#125;&#125;&#x2F;&#x2F; 查询用户的离线消息并返回对应id的消息数组vector&lt;string&gt;  OfflineMsgModel::query(int userid)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;select message from offlineMessage where userid&#x3D;%d&quot;,userid);    MySQL mysql;    vector&lt;string&gt; vec;       if(mysql.connect())&#123;        MYSQL_RES* res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;&#x2F;&#x2F;查询成功             &#x2F;&#x2F;把userid用户的所有离线消息放入vec中返回             &#x2F;&#x2F;查多行             MYSQL_ROW row;             while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;                vec.push_back(row[0]);             &#125;             mysql_free_result(res);             return vec;        &#125;    &#125;    return vec;&#125;</code></pre><p>构造好对应的数据操作类，要在chatservice类实现功能</p><p>chatservice.hpp 添加对应类的声明</p><pre class="language-c++" data-language="c++"><code class="language-c++">OfflineMsgModel _offlineMsgModel;</code></pre><p>chatservice.cpp</p><p>首先在用户登录成功后，要查看离线表中是否有属于它的离线消息，所以在login函数中登录成功板块还要添加</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;查询该用户是否有离线消息            vector&lt;string&gt; vec&#x3D;_offlineMsgModel.query(id);            if(!vec.empty())&#123;                response[&quot;offlinemsg&quot;]&#x3D;vec;                &#x2F;&#x2F;读取该用户的离线消息后，把该用户的所有离线消息删除掉                _offlineMsgModel.remove(id);            &#125;</code></pre><p>首先查询对应id是否有离线消息存在，存到vector数组中，如果不为空的话，response添加offlinemsg字段存储离线消息，并且在服务端删除属于接收端的离线消息，做完这些转发给接收端。</p><p>还有存储离线消息在onechat函数中对应的接收端不在线，存储离线消息在服务端。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;toid不在线，存储离线信息    _offlineMsgModel.insert(toid,js.dump());</code></pre><p>这样一对一的聊天业务就算实现了。</p><h3 id="服务器异常退出问题解决（ctrl-c退出）"><a href="#服务器异常退出问题解决（ctrl-c退出）" class="headerlink" title="服务器异常退出问题解决（ctrl+c退出）"></a>服务器异常退出问题解决（ctrl+c退出）</h3><p>这里遇到的问题是服务器异常退出，User表中用户们的在线状态并没有改变，所以我们要将其改变。</p><p>因为这里数据库的操作，所以在usermodel.cpp UserModel类实现resetState函数，记得在hpp文件声明</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;重置用户的状态信息void UserModel::resetState()&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&quot;update User set state &#x3D; &#39;offline&#39; where state &#x3D; &#39;online&#39;&quot;;    MySQL mysql;    if(mysql.connect())&#123;        mysql.update(sql);    &#125;&#125;</code></pre><p>这个函数就在chatservice.cpp中ChatService类的reset新函数调用</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;服务器异常，业务重置方法void ChatService::reset()&#123;    &#x2F;&#x2F;把online状态的用户，设置成offline    _userModel.resetState();&#125;</code></pre><p>最后在main.cpp实现这一功能</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;处理服务器ctrl+c结束后，重置user的状态信息void resetHandler(int)&#123;    ChatService::instance()-&gt;reset();    exit(0);&#125;</code></pre><p>在main函数添加对应的信号</p><pre class="language-c++" data-language="c++"><code class="language-c++">int main()&#123;    signal(SIGINT,resetHandler);    EventLoop loop;    InetAddress addr(&quot;127.0.0.1&quot;,6000);    ChatServer server(&amp;loop, addr, &quot;ChatServer&quot;);    server.start();    &#x2F;&#x2F;开启事件循环    loop.loop();    return 0;&#125;</code></pre><p>重点：signal(SIGINT,resetHandler);</p><p>注册信号处理函数</p><ul><li><strong><code>SIGINT</code></strong> 是一个信号，表示 <strong>中断信号</strong>，通常在终端按下 <code>Ctrl+C</code> 时触发。</li><li><strong><code>resetHandler</code></strong> 是你定义的函数，用来在收到这个信号时执行一些清理逻辑。它的参数类型必须是 <code>int</code>，因为它接受信号编号</li></ul><p>当然signal(SIGINT,resetHandler);这句话也不能随便放，得放在服务端启动前。</p><p>SIGINT 信号是：</p><p>Interrupt Signal（中断信号），编号是 2，表示用户希望中断（终止）正在运行的程序。</p><p>常见触发方式：</p><ul><li>当你在 终端&#x2F;命令行里运行一个程序时，按下 Ctrl + C，操作系统就会向该程序发送一个 SIGINT 信号。</li></ul><p>举个例子：</p><pre class="language-none"><code class="language-none">bash复制编辑$ .&#x2F;chat_server# 运行中...# 你按下 Ctrl+C</code></pre><p>这时，系统向 <code>chat_server</code> 进程发送 <code>SIGINT</code> 信号：</p><ul><li>如果你没处理这个信号，程序会<strong>直接终止</strong>；</li><li>如果你写了 <code>signal(SIGINT, resetHandler);</code>，就会先执行 <code>resetHandler()</code>，再退出。</li></ul><p>背后原理：</p><ul><li>Linux&#x2F;Unix 中，信号（signal）是一种<strong>异步通知机制</strong>，用于通知进程发生了某种事件。</li><li><code>SIGINT</code> 是一种 <strong>软件信号</strong>，由终端驱动程序发送给前台进程组。</li></ul><p>常见信号对比：</p><table><thead><tr><th>信号名</th><th>编号</th><th>含义</th><th>默认行为</th></tr></thead><tbody><tr><td><code>SIGINT</code></td><td>2</td><td>终端中断（Ctrl+C）</td><td>终止进程</td></tr><tr><td><code>SIGTERM</code></td><td>15</td><td>程序终止（系统或用户发送）</td><td>终止进程</td></tr><tr><td><code>SIGKILL</code></td><td>9</td><td>强制终止（不能捕获）</td><td>立即终止进程</td></tr><tr><td><code>SIGQUIT</code></td><td>3</td><td>退出（Ctrl+\）并生成 core dump</td><td>终止+生成转储文件</td></tr><tr><td><code>SIGSEGV</code></td><td>11</td><td>段错误（访问非法内存）</td><td>终止进程</td></tr></tbody></table><p>总结一句话：SIGINT 是终端用户通过 Ctrl+C 发出的“中断信号”，默认会终止程序，但你可以捕获它，在程序退出前做一些清理处理。</p><h3 id="添加好友业务代码"><a href="#添加好友业务代码" class="headerlink" title="添加好友业务代码"></a>添加好友业务代码</h3><p>public.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">enum EnMsgType&#123;    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息    LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息    REG_MSG,&#x2F;&#x2F;注册消息    REG_MSG_ACK, &#x2F;&#x2F;注册响应消息    ONE_CHAT_MSG, &#x2F;&#x2F;聊天消息    ADD_FRIEND_MSG,&#x2F;&#x2F;添加好友消息&#125;;</code></pre><p>添加ADD_FRIEND_MSG,&#x2F;&#x2F;添加好友消息</p><p>添加好友在数据库中对应的一张Friend表，其中字段是userid和friendid,所以我们实现一个操控Friend表的model类</p><p>friendmodel.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef FRIENDMODEL_H#define FRIENDMODEL_H#include &quot;user.hpp&quot;#include&lt;vector&gt;using namespace std;&#x2F;&#x2F;维护好友信息的操作接口方法class FriendModel&#123;public:    &#x2F;&#x2F;添加好友关系    void insert(int userid,int friendid);    &#x2F;&#x2F;返回用户好友列表 friendid    vector&lt;User&gt; query(int userid);&#125;;#endif</code></pre><p>friendmodel.cpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;friendmodel.hpp&quot;#include &quot;db.h&quot;&#x2F;&#x2F;添加好友关系void FriendModel::insert(int userid,int friendid)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;insert into Friend values(%d,%d)&quot;,userid,friendid);    MySQL mysql;    if(mysql.connect())&#123;        mysql.update(sql);    &#125;&#125;&#x2F;&#x2F;返回用户好友列表 friendidvector&lt;User&gt; FriendModel::query(int userid)&#123;     &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;select a.id,a.name,a.state from User a inner join Friend b on b.friendid&#x3D;a.id where b.userid&#x3D;%d&quot;,userid);    MySQL mysql;    vector&lt;User&gt; vec;       if(mysql.connect())&#123;        MYSQL_RES* res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;&#x2F;&#x2F;查询成功             &#x2F;&#x2F;把userid用户的所有离线消息放入vec中返回             &#x2F;&#x2F;查多行             MYSQL_ROW row;             while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;                User user;                user.setId(atoi(row[0]));                user.setName(row[1]);                user.setState(row[2]);                vec.push_back(user);             &#125;             mysql_free_result(res);             return vec;        &#125;    &#125;    return vec;&#125;</code></pre><p>insert函数实现的是将好友关系加到数据库中。query返回的是从数据库中返回的好友数据。</p><p>当然还有一个业务绑定</p><p>首先在chatservice.hpp声明一个FriendModel对象</p><pre class="language-c++" data-language="c++"><code class="language-c++">FriendModel _friendModel;</code></pre><p>在ChatService的构造函数实现绑定</p><pre class="language-c++" data-language="c++"><code class="language-c++">_msgHandlerMap.insert(&#123;ADD_FRIEND_MSG,std::bind(&amp;ChatService::addFriend,this,_1,_2,_3)&#125;);</code></pre><p>在chatservice.hpp声明一个addFriend的函数</p><p>addFriend函数实现:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;添加好友业务 msgid id friendidvoid ChatService::addFriend(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int userid&#x3D;js[&quot;id&quot;];    int friendid&#x3D;js[&quot;friendid&quot;];    &#x2F;&#x2F;存储好友信息    _friendModel.insert(userid,friendid);&#125;</code></pre><p>这里收到的json消息格式为</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span><span class="token property">"msgid"</span><span class="token operator">:</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token property">"friendid"</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">&#125;</span></code></pre><p>还有一个问题，在用户登录时，也要好友信息的显示，所以在用户登陆成功时，服务端也要把好友信息发给用户端。</p><p>所以在服务端登录的回复信息这里需要加上好友信息</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;查询该用户的好友信息并返回            vector&lt;User&gt; userVec&#x3D;_friendModel.query(id);            if(!userVec.empty())&#123;               vector&lt;string&gt; vec2;               for(User &amp;user:userVec)&#123;                json js;                js[&quot;id&quot;]&#x3D;user.getId();                js[&quot;name&quot;]&#x3D;user.getName();                js[&quot;state&quot;]&#x3D;user.getState();                vec2.push_back(js.dump());               &#125;               response[&quot;friends&quot;]&#x3D;vec2;            &#125;</code></pre><p>这里添加好友的业务就实现了。</p><h3 id="群组业务"><a href="#群组业务" class="headerlink" title="群组业务"></a>群组业务</h3><p>首先要实现群组业务，我在数据库有两张表实现群组业务AllGroup和GroupUser</p><p>AllGroup的数据结构：</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">-----------+--------------+------+-----+---------+----------------+</span><span class="token operator">|</span> Field     <span class="token operator">|</span> <span class="token keyword">Type</span>         <span class="token operator">|</span> <span class="token boolean">Null</span> <span class="token operator">|</span> <span class="token keyword">Key</span> <span class="token operator">|</span> <span class="token keyword">Default</span> <span class="token operator">|</span> Extra          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------+--------------+------+-----+---------+----------------+</span><span class="token operator">|</span> id        <span class="token operator">|</span> <span class="token keyword">int</span>          <span class="token operator">|</span> <span class="token keyword">NO</span>   <span class="token operator">|</span> PRI <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token keyword">auto_increment</span> <span class="token operator">|</span><span class="token operator">|</span> groupname <span class="token operator">|</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>  <span class="token operator">|</span> <span class="token keyword">NO</span>   <span class="token operator">|</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>                <span class="token operator">|</span><span class="token operator">|</span> groupdesc <span class="token operator">|</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span> <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span>         <span class="token operator">|</span>                <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------+--------------+------+-----+---------+----------------+</span></code></pre><p>GroupUSer的数据结构</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">------------+--------------------------+------+-----+---------+-------+</span><span class="token operator">|</span> Field      <span class="token operator">|</span> <span class="token keyword">Type</span>                     <span class="token operator">|</span> <span class="token boolean">Null</span> <span class="token operator">|</span> <span class="token keyword">Key</span> <span class="token operator">|</span> <span class="token keyword">Default</span> <span class="token operator">|</span> Extra <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------+--------------------------+------+-----+---------+-------+</span><span class="token operator">|</span> groupid    <span class="token operator">|</span> <span class="token keyword">int</span>                      <span class="token operator">|</span> <span class="token keyword">NO</span>   <span class="token operator">|</span> PRI <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">|</span> userid     <span class="token operator">|</span> <span class="token keyword">int</span>                      <span class="token operator">|</span> <span class="token keyword">NO</span>   <span class="token operator">|</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">|</span> groupprole <span class="token operator">|</span> <span class="token keyword">enum</span><span class="token punctuation">(</span><span class="token string">'creator'</span><span class="token punctuation">,</span><span class="token string">'normal'</span><span class="token punctuation">)</span> <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> normal  <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------+--------------------------+------+-----+---------+-------+</span></code></pre><p>groupuser.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef GROUPUSER_H#define GROUPUSER_H#include &quot;user.hpp&quot;&#x2F;&#x2F;群组用户，多了个role角色信息，从User类直接继承，复用User的其他信息&#x2F;&#x2F;对应的GroupUser表，但是光是这张表的不够，还要联表查询，所以继承User类。class GroupUser:public User&#123;public:    void setRole(string role)&#123;this-&gt;role&#x3D;role;&#125;    string getRole()&#123;return this-&gt;role;&#125;private:    string role;&#125;;#endif</code></pre><p>GroupUser类对象是记录关于组成员的详细信息的类，所以继承User。</p><p>group.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef GROUP_H#define GROUP_H#include&lt;vector&gt;#include&lt;string&gt;#include &quot;groupuser.hpp&quot;using namespace std;&#x2F;&#x2F;AllGroup表的ORM类但也不完全是还加了储存组用户的数组class Group&#123;public:    Group(int id&#x3D;-1,string name &#x3D;&quot;&quot;,string desc&#x3D;&quot;&quot;)&#123;        this-&gt;id&#x3D;id;        this-&gt;name&#x3D;name;        this-&gt;desc&#x3D;desc;    &#125;    void setId(int id)&#123;        this-&gt;id&#x3D;id;    &#125;    void setName(string name)&#123;        this-&gt;name&#x3D;name;    &#125;    void setDesc(string desc)&#123;this-&gt;desc&#x3D;desc;&#125;    int getId()&#123;        return this-&gt;id;    &#125;    string getName()&#123;        return this-&gt;name;    &#125;    string getDesc()&#123;        return this-&gt;desc;    &#125;    vector&lt;GroupUser&gt; &amp;getUsers() &#123;return this-&gt;users;&#125;private:    int id;&#x2F;&#x2F;组id    string name;&#x2F;&#x2F;组名    string desc;&#x2F;&#x2F;组功能描述    vector&lt;GroupUser&gt; users;&#x2F;&#x2F;组员的详细信息&#125;;#endif</code></pre><p>Group类对象是AllGroup表的ORM类，但也不完全，这个类还添加了存储组成员详细信息的结构vector<GroupUser> users;</GroupUser></p><p>因为这两张表的关联系很大，所以我们第一这个群组业务的数据操作接口。</p><p>groupmodel.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef GROUPMODEL_H#define GROUPMODEL_H#include &quot;group.hpp&quot;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;&#x2F;&#x2F;维护群组信息的操作接口方法class GroupModel&#123;public:    &#x2F;&#x2F;创建群组    bool createGroup(Group &amp;group);    &#x2F;&#x2F;加入群组    void addGroup(int userid,int groupid,string role);    &#x2F;&#x2F;查询用户所在群组消息    vector&lt;Group&gt; queryGroups(int userid);    &#x2F;&#x2F;根据指定的groupid查询群组用户id列表，除userid自己，主要用户群聊业务给群组其他成员群发消息。    vector&lt;int&gt; queryGroupUsers(int userid,int groupid);&#125;;#endif</code></pre><p>对应函数实现</p><p>创建群组createGroup函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 创建群组bool GroupModel::createGroup(Group &amp;group)&#123;    &#x2F;&#x2F;1.组装sql语句    char sql[1024]&#x3D;&#123;0&#125;;    sprintf(sql,&quot;insert into AllGroup(groupname,groupdesc) values(&#39;%s&#39;,&#39;%s&#39;)&quot;,group.getName().c_str(),group.getDesc().c_str());    MySQL mysql;    if(mysql.connect())&#123;        if(mysql.update(sql))&#123;            group.setId(mysql_insert_id(mysql.getConnection()));            return true;        &#125;    &#125;    return false;&#125;</code></pre><p>将组名和组介绍存到AllGroup表中。</p><p>加入群组addGroup函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 加入群组void GroupModel::addGroup(int userid, int groupid, string role)&#123;    &#x2F;&#x2F;1.组装sql语句    char sql[1024]&#x3D;&#123;0&#125;;    sprintf(sql,&quot;insert into GroupUser values(%d,%d,&#39;%s&#39;)&quot;,groupid,userid,role.c_str());    MySQL mysql;    if(mysql.connect())&#123;       mysql.update(sql);    &#125;&#125;</code></pre><p>&#x2F;&#x2F; 查询用户所在群组信息queryGroups</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 查询用户所在群组消息vector&lt;Group&gt; GroupModel::queryGroups(int userid)&#123;    &#x2F;&#x2F; 1.先根据userid在GroupUser表中查询该用户所属的群组消息    &#x2F;&#x2F; 2.再根据群组消息，查询属于该群组的所有用户的userid,并且和User表进行多表联合查询，查出用户的详细信息    char sql[1024]&#x3D;&#123;0&#125;;    sprintf(sql,&quot;select a.id,a.groupname,a.groupdesc from AllGroup a inner join GroupUser b on a.id&#x3D;b.groupid where b.userid&#x3D;%d&quot;,userid);    vector&lt;Group&gt; groupVec;    MySQL mysql;    if(mysql.connect())&#123;        MYSQL_RES *res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;            MYSQL_ROW row;            &#x2F;&#x2F;查出userid所有的群组消息            while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;                Group group;                group.setId(atoi(row[0]));                group.setName(row[1]);                group.setDesc(row[2]);                groupVec.push_back(group);            &#125;            mysql_free_result(res);        &#125;    &#125;    &#x2F;&#x2F;查询群组的用户信息    for(Group &amp;group:groupVec)&#123;        sprintf(sql,&quot;select a.id,a.name,a.state,b.grouprole from User a inner join GroupUser b on b.userid&#x3D;a.id where b.groupid&#x3D;%d&quot;,group.getId());        MYSQL_RES *res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;            MYSQL_ROW row;            while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;                GroupUser user;                user.setId(atoi(row[0]));                user.setName(row[1]);                user.setState(row[2]);                user.setRole(row[3]);                group.getUsers().push_back(user);            &#125;            mysql_free_result(res);        &#125;    &#125;    return groupVec;&#125;</code></pre><p>根据指定的groupid查询群组用户id列表，除userid自己。queryGroupUsers函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 根据指定的groupid查询群组用户id列表，除userid自己，主要用户群聊业务给群组其他成员群发消息。vector&lt;int&gt; GroupModel::queryGroupUsers(int userid, int groupid)&#123;    char sql[1024]&#x3D;&#123;0&#125;;    sprintf(sql,&quot;select userid from GroupUser where groupid&#x3D;%d and userid!&#x3D;%d&quot;,groupid,userid);    vector&lt;int&gt; idVec;    MySQL mysql;    if(mysql.connect())&#123;        MYSQL_RES *res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;            MYSQL_ROW row;            while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;                idVec.push_back(atoi(row[0]));            &#125;            mysql_free_result(res);        &#125;    &#125;    return idVec;&#125;</code></pre><p>完成这些在业务类使用这些功能</p><p>首先在public.hpp更新消息类型：</p><pre class="language-c++" data-language="c++"><code class="language-c++">CREATE_GROUP_MSG,&#x2F;&#x2F;创建群组    ADD_GROUP_MSG,&#x2F;&#x2F;加入群组    GROUP_CHAT_MSG,&#x2F;&#x2F;群聊天</code></pre><p>在业务类ChatService中添加对应的数据操作类对象：</p><pre class="language-c++" data-language="c++"><code class="language-c++">GroupModel _groupModel;</code></pre><p>加入功能实现函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建群组业务    void createGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);    &#x2F;&#x2F;加入群组业务    void addGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);    &#x2F;&#x2F;群组聊天业务    void groupChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);</code></pre><p>创建群组业务:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建群组业务void ChatService::createGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int userid&#x3D;js[&quot;id&quot;];    string name&#x3D;js[&quot;groupname&quot;];    string desc&#x3D;js[&quot;groupdesc&quot;];    &#x2F;&#x2F;存储新创建的群组消息    Group group(-1,name,desc);    if(_groupModel.createGroup(group))&#123;        &#x2F;&#x2F;存储群组创建人消息        _groupModel.addGroup(userid,group.getId(),&quot;creator&quot;);    &#125;&#125;</code></pre><p>加入群组业务:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;加入群组业务void ChatService::addGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int userid&#x3D;js[&quot;id&quot;];    int groupid&#x3D;js[&quot;groupid&quot;];    _groupModel.addGroup(userid,groupid,&quot;normal&quot;);&#125;</code></pre><p>群组聊天业务:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;群组聊天业务void ChatService::groupChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int userid&#x3D;js[&quot;id&quot;];    int groupid&#x3D;js[&quot;groupid&quot;];    vector&lt;int&gt; useridVec&#x3D;_groupModel.queryGroupUsers(userid,groupid);    lock_guard&lt;mutex&gt; lock(_connMutex);    for(int id:useridVec)&#123;                auto it&#x3D;_userConnMap.find(id);        if(it!&#x3D;_userConnMap.end())&#123;            &#x2F;&#x2F;转发群消息            it-&gt;second-&gt;send(js.dump());        &#125;else&#123;            &#x2F;&#x2F;存储离线群消息            _offlineMsgModel.insert(id,js.dump());        &#125;    &#125;&#125;</code></pre><p>还要在构造函数绑定消息对应函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;群组业务注册    _msgHandlerMap.insert(&#123;CREATE_GROUP_MSG,std::bind(&amp;ChatService::createGroup,this,_1,_2,_3)&#125;);    _msgHandlerMap.insert(&#123;ADD_GROUP_MSG,std::bind(&amp;ChatService::addGroup,this,_1,_2,_3)&#125;);    _msgHandlerMap.insert(&#123;GROUP_CHAT_MSG,std::bind(&amp;ChatService::groupChat,this,_1,_2,_3)&#125;);</code></pre><p>当然在用户登录成功时，还要把群组的信息发给客户端。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;查询用户的群组信息            vector&lt;Group&gt; groupuserVec&#x3D;_groupModel.queryGroups(id);            if(!groupuserVec.empty())&#123;                &#x2F;&#x2F;group:[&#123;groupid:[xxx,xxx,xxx,xxx]&#125;]                vector&lt;string&gt; groupV;                for(Group &amp;group:groupuserVec)&#123;                    json grpjson;                    grpjson[&quot;id&quot;]&#x3D;group.getId();                    grpjson[&quot;groupname&quot;]&#x3D;group.getName();                    grpjson[&quot;groupdesc&quot;]&#x3D;group.getDesc();                    vector&lt;string&gt; userV;                    for(GroupUser &amp;user:group.getUsers())&#123;                        json js;                        js[&quot;id&quot;]&#x3D;user.getId();                        js[&quot;name&quot;]&#x3D;user.getName();                        js[&quot;state&quot;]&#x3D;user.getState();                        js[&quot;role&quot;]&#x3D;user.getRole();                        userV.push_back(js.dump());                    &#125;                    grpjson[&quot;users&quot;]&#x3D;userV;                    groupV.push_back(grpjson.dump());                &#125;                response[&quot;groups&quot;]&#x3D;groupV;            &#125;</code></pre><p>群组业务就完成了。</p><h3 id="客户端开发-首页面开发"><a href="#客户端开发-首页面开发" class="headerlink" title="客户端开发-首页面开发"></a>客户端开发-首页面开发</h3><p>首先在src&#x2F;client编写CMakeLists.txt和main.cpp</p><p>CMakeLists.txt</p><pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#定义了一个SRC_LIST变量，包含了该目录下所有的源文件</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>. SRC_LIST<span class="token punctuation">)</span><span class="token comment">#指定生成可执行文件</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>ChatClient <span class="token punctuation">$&#123;</span>SRC_LIST<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">#指定可执行文件链接时所需要依赖的库文件</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>ChatClient pthread<span class="token punctuation">)</span></code></pre><p>main.cpp编写我们的客户端程序</p><p>首先保存的变量</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;记录当前系统登录的用户信息User g_currentUser;&#x2F;&#x2F;记录当前登录用户的好友列表信息vector&lt;User&gt; g_currentUserFriendList;&#x2F;&#x2F;记录当前登录用户的群组列表信息vector&lt;Group&gt; g_currentUserGroupList;</code></pre><p>目前的函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;显示当前登录成功用户的基本信息void showCurrentUserData();&#x2F;&#x2F;接受线程void readTaskHandler(int clientfd);&#x2F;&#x2F;获取系统时间(聊天信息需要添加时间信息)string getCurrentTime();&#x2F;&#x2F;主聊天页面程序void mainMenu();</code></pre><p>主线程main函数</p><p>int main(int argc,char **argv) </p><p>参数说明：</p><ul><li><code>int argc</code>：Argument Count，命令行参数的数量（包括程序本身的名称）。</li><li><code>char **argv</code>：Argument Vector，命令行参数的数组。<code>argv[0]</code> 是程序的名字，<code>argv[1]</code> 到 <code>argv[argc-1]</code> 是你在命令行中输入的其他参数。</li></ul><p>在命令行运行.&#x2F;ChatClient 127.0.0.1 6000即可运行</p><h4 id="客户端和服务端的连接"><a href="#客户端和服务端的连接" class="headerlink" title="客户端和服务端的连接"></a>客户端和服务端的连接</h4><p>首先客户端和服务端的连接代码：</p><pre class="language-c++" data-language="c++"><code class="language-c++">if(argc&lt;3)&#123;    cerr&lt;&lt;&quot;command invalid!example:.&#x2F;ChatClient 127.0.0.1 6000&quot;&lt;&lt;endl;    exit(-1);&#x2F;&#x2F;异常退出 exit(0)是正常退出&#125;&#x2F;&#x2F;解析通过命令行参数传递的ip和portchar *ip&#x3D;argv[1];uint16_t port&#x3D;atoi(argv[2]);&#x2F;&#x2F;创建client端的socketint clientfd&#x3D;socket(AF_INET,SOCK_STREAM,0);if(-1&#x3D;&#x3D;clientfd)&#123;    cerr&lt;&lt;&quot;socket create error&quot;&lt;&lt;endl;    exit(-1);&#125;&#x2F;&#x2F;填写client需要连接的server信息ip+portsockaddr_in server;memset(&amp;server,0,sizeof(sockaddr_in));server.sin_family&#x3D;AF_INET;server.sin_port&#x3D;htons(port);server.sin_addr.s_addr&#x3D;inet_addr(ip);&#x2F;&#x2F;client和server进行连接if(-1&#x3D;&#x3D;connect(clientfd,(sockaddr *)&amp;server,sizeof(sockaddr_in)))&#123;    cerr &lt;&lt;&quot;connect server error&quot;&lt;&lt;endl;    close(clientfd);    exit(-1);&#125;</code></pre><p>对其中的函数解释：</p><pre class="language-c++" data-language="c++"><code class="language-c++">int clientfd&#x3D;socket(AF_INET,SOCK_STREAM,0);</code></pre><p>socket函数功能：创建一个 TCP 套接字（socket）</p><p>其中的socket函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;sys&#x2F;socket.h&gt;</code></pre><p> 各个参数含义：</p><pre class="language-c++" data-language="c++"><code class="language-c++">socket(int domain, int type, int protocol)</code></pre><ol><li><code>AF_INET</code>（地址族）</li></ol><ul><li>指定使用 <strong>IPv4</strong> 地址（Internet Protocol version 4）。</li><li>如果是 <code>AF_INET6</code>，那就是 IPv6。</li></ul><ol start="2"><li><code>SOCK_STREAM</code>（套接字类型）</li></ol><ul><li>表示使用的是 <strong>面向连接的、可靠的、基于字节流</strong> 的通信方式。</li><li>通常对应 <strong>TCP</strong> 协议。</li></ul><ol start="3"><li><code>0</code>（协议编号）</li></ol><ul><li>填 <code>0</code> 表示让系统根据前两个参数自动选择合适的协议。</li><li>对于 <code>AF_INET + SOCK_STREAM</code>，系统会自动选择 <strong>TCP</strong> 协议。</li></ul><p>返回值：</p><ul><li>成功时返回一个非负整数（<strong>文件描述符</strong>，也就是 <code>clientfd</code>），用于后续的读写操作。</li><li>失败时返回 <code>-1</code>，常见原因包括：系统资源耗尽、参数错误等。</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">sockaddr_in server;</code></pre><p><code>sockaddr_in</code> 是 C&#x2F;C++ 中专门用来表示 <strong>IPv4 网络地址</strong> 的结构体。</p><p>对应的头文件：</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;netinet&#x2F;in.h&gt;</code></pre><pre class="language-c++" data-language="c++"><code class="language-c++">memset(&amp;server,0,sizeof(sockaddr_in));</code></pre><p>把 <code>server</code> 结构体从首地址开始，连续 <code>sizeof(server)</code> 个字节都设置为 <code>0</code>。</p><p>memset函数用法</p><pre class="language-c++" data-language="c++"><code class="language-c++">void *memset(void *ptr, int value, size_t num);</code></pre><p> 参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>ptr</code></td><td>指向要被设置的内存的指针</td></tr><tr><td><code>value</code></td><td>要设置的值（会被转换为 <code>unsigned char</code> 类型）</td></tr><tr><td><code>num</code></td><td>要设置的字节数</td></tr></tbody></table><pre class="language-c++" data-language="c++"><code class="language-c++">server.sin_family&#x3D;AF_INET;server.sin_port&#x3D;htons(port);server.sin_addr.s_addr&#x3D;inet_addr(ip);</code></pre><pre class="language-c++" data-language="c++"><code class="language-c++">server.sin_family &#x3D; AF_INET;</code></pre><ul><li>表示使用的地址类型是 <strong>IPv4</strong>。</li><li><code>AF_INET</code> 是 <strong>Address Family Internet</strong> 的缩写。</li><li>这是 <code>sockaddr_in</code> 中的 <code>sin_family</code> 字段，必须设置为 <code>AF_INET</code>，否则系统无法识别地址格式。</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">server.sin_port &#x3D; htons(port);</code></pre><ul><li>设置端口号，例如：6000。</li><li><code>htons()</code> 是 <strong>Host to Network Short</strong> 的缩写：h<ul><li>它把本地主机的字节序（可能是小端）转换为网络字节序（大端）。</li><li>因为 TCP&#x2F;IP 协议使用大端字节序进行数据传输。</li></ul></li><li><code>port</code> 是你从命令行传进来的端口号字符串转成的整数。</li></ul><p>htons函数头文件：</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;netinet&#x2F;in.h&gt;</code></pre><p> 端口必须转换成网络字节序，否则客户端连接服务器时会出错！</p><pre class="language-c++" data-language="c++"><code class="language-c++">server.sin_addr.s_addr &#x3D; inet_addr(ip);</code></pre><ul><li>设置 IP 地址。</li><li><code>inet_addr()</code> 函数把点分十进制的 IP 字符串（如 <code>&quot;127.0.0.1&quot;</code>）转换成 32 位的二进制整数。</li><li>转换后的结果赋值给 <code>sin_addr.s_addr</code>，用于 socket 连接。</li></ul><p>inet_addr函数头文件：</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;arpa&#x2F;inet.h&gt;</code></pre><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;client和server进行连接    if(-1&#x3D;&#x3D;connect(clientfd,(sockaddr *)&amp;server,sizeof(sockaddr_in)))&#123;        cerr &lt;&lt;&quot;connect server error&quot;&lt;&lt;endl;        close(clientfd);&#x2F;&#x2F;释放socket资源        exit(-1);    &#125;</code></pre><p><code>connect()</code> 函数详解：</p><pre class="language-c++" data-language="c++"><code class="language-c++">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>sockfd</code></td><td>用 <code>socket()</code> 创建的套接字文件描述符（即 <code>clientfd</code>）</td></tr><tr><td><code>addr</code></td><td>服务器地址结构指针（需要强转成 <code>sockaddr*</code> 类型）</td></tr><tr><td><code>addrlen</code></td><td><code>addr</code> 结构体的大小，通常是 <code>sizeof(sockaddr_in)</code></td></tr></tbody></table><h4 id="客户端业务实现"><a href="#客户端业务实现" class="headerlink" title="客户端业务实现"></a>客户端业务实现</h4><p>首先在一个死循环中实现循环选择：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;显示首页面菜单 登录,注册，退出       cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;       cout&lt;&lt;&quot;1. login&quot;&lt;&lt;endl;       cout&lt;&lt;&quot;2. register&quot;&lt;&lt;endl;       cout&lt;&lt;&quot;3. quit&quot;&lt;&lt;endl;       cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;       cout&lt;&lt; &quot;choice:&quot;;       int choice&#x3D;0;       cin&gt;&gt;choice;       cin.get();&#x2F;&#x2F;读掉缓冲区残留的回车</code></pre><p>使用switch语句实现不断选择。</p><h5 id="首先登录业务："><a href="#首先登录业务：" class="headerlink" title="首先登录业务："></a>首先登录业务：</h5><pre class="language-c++" data-language="c++"><code class="language-c++">case 1:&#x2F;&#x2F;login业务            &#123;                int id&#x3D;0;                char pwd[50]&#x3D;&#123;0&#125;;                cout&lt;&lt; &quot;userid:&quot;;                cin&gt;&gt; id;                cin.get();&#x2F;&#x2F;读掉缓冲区残留的回车                cout&lt;&lt;&quot;user password:&quot;;                cin.getline(pwd,50);                json js;                js[&quot;msgid&quot;]&#x3D;LOGIN_MSG;                js[&quot;id&quot;]&#x3D;id;                js[&quot;password&quot;]&#x3D;pwd;                string request &#x3D;js.dump();                int len&#x3D;send(clientfd,request.c_str(),strlen(request.c_str())+1,0);                if(len&#x3D;&#x3D;-1)&#123;                    cerr&lt;&lt;&quot;send login msg error:&quot;&lt;&lt;request&lt;&lt;endl;                &#125;else&#123;                    char buffer[1024]&#x3D;&#123;0&#125;;                    len&#x3D;recv(clientfd,buffer,1024,0);                    if(len&#x3D;&#x3D;-1)&#123;                        cerr &lt;&lt;&quot;recv login response error&quot;&lt;&lt;endl;                    &#125;else&#123;                        json responsejs&#x3D;json::parse(buffer);                        if(responsejs[&quot;errno&quot;]!&#x3D;0)&#123;                            cerr&lt;&lt;responsejs[&quot;errmsg&quot;]&lt;&lt;endl;                        &#125;                        else&#123;&#x2F;&#x2F;登录成功                            &#x2F;&#x2F;记录当前用户的id和name                            g_currentUser.setId(responsejs[&quot;id&quot;]);                            g_currentUser.setName(responsejs[&quot;name&quot;]);                            &#x2F;&#x2F;记录当前用户的好友列表信息                            if(responsejs.contains(&quot;friends&quot;))&#123;&#x2F;&#x2F;看是否包含friends这个键                                vector&lt;string&gt; vec&#x3D;responsejs[&quot;friends&quot;];                                for(string &amp;str:vec)&#123;                                    json js&#x3D;json::parse(str);                                    User user;                                    user.setId(js[&quot;id&quot;]);                                    user.setName(js[&quot;name&quot;]);                                    user.setState(js[&quot;state&quot;]);                                    g_currentUserFriendList.push_back(user);                                &#125;                            &#125;                            &#x2F;&#x2F;记录当前用户的群组列表信息                            if(responsejs.contains(&quot;groups&quot;))&#123;                                vector&lt;string&gt; vec1&#x3D;responsejs[&quot;groups&quot;];                                for(string &amp;groupstr:vec1)&#123;                                    json grpjs&#x3D;json::parse(groupstr);                                    Group group;                                    group.setId(grpjs[&quot;id&quot;]);                                    group.setName(grpjs[&quot;groupname&quot;]);                                    group.setDesc(grpjs[&quot;groupdesc&quot;]);                                    vector&lt;string&gt; vec2&#x3D;grpjs[&quot;users&quot;];                                    for(string &amp;userstr:vec2)&#123;                                        GroupUser user;                                        json js&#x3D;json::parse(userstr);                                        user.setId(js[&quot;id&quot;]);                                        user.setName(js[&quot;name&quot;]);                                        user.setState(js[&quot;state&quot;]);                                        user.setRole(js[&quot;role&quot;]);                                        group.getUsers().push_back(user);                                    &#125;                                    g_currentUserGroupList.push_back(group);                                &#125;                            &#125;                            &#x2F;&#x2F;显示登录用户的基本信息                            showCurrentUserData();                            &#x2F;&#x2F;显示当前用户的离线消息 个人聊天消息或者群组消息                            if(responsejs.contains(&quot;offlinemsg&quot;))&#123;                                vector&lt;string&gt; vec&#x3D;responsejs[&quot;offlinemsg&quot;];                                for(string &amp;str:vec)&#123;                                    json js&#x3D;json::parse(str);                                    &#x2F;&#x2F;time +[id]+name+&quot;said: &quot;+xxx                                    cout&lt;&lt;js[&quot;time&quot;]&lt;&lt;&quot;[&quot;&lt;&lt;js[&quot;id&quot;]&lt;&lt;&quot;]&quot;&lt;&lt;js[&quot;name&quot;]&lt;&lt;&quot; said &quot;&lt;&lt;js[&quot;msg&quot;]&lt;&lt;endl;                                &#125;                            &#125;                            &#x2F;&#x2F;登录成功，启动接受线程负责接受数据                            std::thread readTask(readTaskHandler,clientfd);                            readTask.detach();                            &#x2F;&#x2F;进入聊天主菜单页面                            mainMenu();                        &#125;                    &#125;                &#125;            &#125;            break;</code></pre><p>这里解释一些函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">int len&#x3D;send(clientfd,request.c_str(),strlen(request.c_str())+1,0);</code></pre><p>通过 <code>send()</code> 函数将字符串 <code>request</code> 的内容发送到套接字 <code>clientfd</code> 所代表的对端。</p><p>各参数详解：</p><pre class="language-c++" data-language="c++"><code class="language-c++">send(socket, buffer, length, flags)</code></pre><ul><li><code>clientfd</code>：套接字描述符，表示要发送数据的目标。</li><li><code>request.c_str()</code>：将 <code>std::string</code> 类型的 <code>request</code> 转为 C 风格的字符串（返回 <code>const char*</code> 指针）。c++</li><li><code>strlen(request.c_str()) + 1</code>：表示发送的数据长度，<code>+1</code> 是为了包括字符串末尾的 <code>\0</code>（空字符终止符），这是为了让接收方知道字符串结束。</li><li><code>0</code>：表示不使用额外的标志（默认行为）。</li></ul><p>关于返回值：</p><table><thead><tr><th>返回值 <code>len</code></th><th>意义说明</th></tr></thead><tbody><tr><td>&gt; 0</td><td>成功发送了 <code>len</code> 字节的数据</td></tr><tr><td>&#x3D;&#x3D; 0</td><td>TCP 连接被优雅关闭（几乎不会出现在 <code>send()</code>，常出现在 <code>recv()</code>）</td></tr><tr><td>&#x3D;&#x3D; -1</td><td>发送失败，需检查 <code>errno</code> 查看错误原因</td></tr></tbody></table><pre class="language-c++" data-language="c++"><code class="language-c++">len&#x3D;recv(clientfd,buffer,1024,0);</code></pre><p><strong>从 <code>clientfd</code> 套接字接收最多 1024 字节的数据，存入 <code>buffer</code> 缓冲区中</strong>。</p><p>各参数详解：</p><pre class="language-c++" data-language="c++"><code class="language-c++">recv(socket, buffer, length, flags)</code></pre><ul><li><code>clientfd</code>：连接的套接字描述符（已连接的对端）。</li><li><code>buffer</code>：用于存放接收数据的内存区域（<code>char buffer[1024];</code> 或 <code>char* buffer = new char[1024];</code>）。</li><li><code>1024</code>：最多接收 1024 字节（防止缓冲区溢出）。</li><li><code>0</code>：标志位，通常设置为 0（表示默认阻塞接收）。</li></ul><p>返回值说明（关键点）：</p><table><thead><tr><th>返回值 <code>len</code></th><th>意义说明</th></tr></thead><tbody><tr><td>&gt; 0</td><td>实际接收到的数据字节数（并不一定等于 1024）</td></tr><tr><td>&#x3D;&#x3D; 0</td><td><strong>连接已关闭</strong>（对方调用了 <code>close()</code>）</td></tr><tr><td>&#x3D;&#x3D; -1</td><td><strong>接收失败</strong>，可通过 <code>errno</code> 查看错误原因</td></tr></tbody></table><p>注意recv() 并不会自动在 buffer 的末尾添加 ‘\0‘</p><p>所以我们定义buffer:保证末尾有’\0‘</p><pre class="language-c++" data-language="c++"><code class="language-c++">char buffer[1024]&#x3D;&#123;0&#125;;</code></pre><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;登录成功，启动接受线程负责接受数据                            std::thread readTask(readTaskHandler,clientfd);                            readTask.detach();</code></pre><p>创建了一个<strong>新线程</strong>，并立刻将它<strong>分离（detach）</strong>，用来异步执行函数 <code>readTaskHandler(clientfd)</code>。</p><p>分析每一行作用：</p><ol><li><code>std::thread readTask(readTaskHandler, clientfd);</code></li></ol><ul><li>创建一个线程对象 <code>readTask</code>，该线程会立即开始运行 <code>readTaskHandler(clientfd)</code>。</li><li>通常用于处理客户端请求，比如接收数据、解析消息等。</li></ul><ol start="2"><li><code>readTask.detach();</code></li></ol><ul><li>将线程<strong>分离</strong>，让它独立运行。</li><li><strong>主线程不再管理这个子线程</strong>，也无法调用 <code>join()</code> 等待它。</li><li>线程资源会在线程函数执行完毕后由系统自动回收。</li></ul><p> detach 的 <strong>优点与风险</strong>：</p><p>优点：</p><ul><li>简单，<strong>不阻塞主线程</strong>，不需要显式 <code>join()</code>。</li><li>适合执行时间短、无需主线程等待的任务（比如客户端的消息监听）。</li></ul><p>风险：</p><ol><li><strong>无法再追踪或管理线程</strong>：你不能再 join 或获取其返回状态。</li><li><strong>容易引发悬空引用或资源泄漏问题</strong>：<ul><li>如果 <code>readTaskHandler()</code> 里访问了已经销毁的变量，会崩。</li><li>比如使用了传进来的 <code>clientfd</code> 后，主线程先关闭了它。</li></ul></li><li><strong>调试困难</strong>：detach 后的线程出错更难排查。</li></ol><h5 id="注册业务："><a href="#注册业务：" class="headerlink" title="注册业务："></a>注册业务：</h5><pre class="language-c++" data-language="c++"><code class="language-c++">case 2:&#x2F;&#x2F;register业务            &#123;                char name[50]&#x3D;&#123;0&#125;;                char pwd[50]&#x3D;&#123;0&#125;;                cout&lt;&lt; &quot;username:&quot;;                cin.getline(name,50);                cout&lt;&lt;&quot;user password:&quot;;                cin.getline(pwd,50);                json js;                js[&quot;msgid&quot;]&#x3D;REG_MSG;                js[&quot;name&quot;]&#x3D;name;                js[&quot;password&quot;]&#x3D;pwd;                string request&#x3D;js.dump();                int len&#x3D;send(clientfd,request.c_str(),strlen(request.c_str())+1,0);                if(len&#x3D;&#x3D;-1)&#123;                    cerr &lt;&lt;&quot;send reg msg error:&quot;&lt;&lt;request&lt;&lt;endl;                &#125;else&#123;                    char buffer[1024]&#x3D;&#123;0&#125;;                    len&#x3D;recv(clientfd,buffer,1024,0);                    if(len&#x3D;&#x3D;-1)&#123;                        cerr&lt;&lt;&quot;recv reg response error&quot;&lt;&lt;endl;                    &#125;else&#123;                        json responsejs&#x3D;json::parse(buffer);                        if(0!&#x3D;responsejs[&quot;errno&quot;])&#123;&#x2F;&#x2F;注册失败                            cerr&lt;&lt;name&lt;&lt;&quot;is already exist,register error!&quot;&lt;&lt;endl;                        &#125;else&#123;&#x2F;&#x2F;注册成功                            cout&lt;&lt;name&lt;&lt;&quot;register success,userid is &quot;&lt;&lt;responsejs[&quot;id&quot;]&lt;&lt;&quot;, do not forget it!&quot;&lt;&lt;endl;                        &#125;                    &#125;                &#125;            &#125;            break;</code></pre><h5 id="退出业务："><a href="#退出业务：" class="headerlink" title="退出业务："></a>退出业务：</h5><pre class="language-c++" data-language="c++"><code class="language-c++">case 3:&#x2F;&#x2F;quit 业务           &#123;               close(clientfd);&#x2F;&#x2F;释放连接，不要重复关闭               exit(0);           &#125;</code></pre><h5 id="聊天主界面业务："><a href="#聊天主界面业务：" class="headerlink" title="聊天主界面业务："></a>聊天主界面业务：</h5><p>首先在登录业务实现，登录成功又该何去何从，所以聊天主界面业务，首先在登录业务有几个函数，还没有实现，实现一下：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;显示登录用户的基本信息showCurrentUserData();</code></pre><p>具体实现：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;显示当前登录成功用户的基本信息void showCurrentUserData()&#123;    cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;login user&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;    cout&lt;&lt;&quot;current login user &#x3D;&gt;id:&quot;&lt;&lt;g_currentUser.getId()&lt;&lt;&quot;name:&quot;&lt;&lt;g_currentUser.getName()&lt;&lt;endl;    cout&lt;&lt;&quot;-------------------------friend list------------------------------&quot;&lt;&lt;endl;    if(!g_currentUserFriendList.empty())&#123;        for(User &amp;user:g_currentUserFriendList)&#123;            cout&lt;&lt;user.getId()&lt;&lt;&quot; &quot;&lt;&lt;user.getName()&lt;&lt;&quot; &quot;&lt;&lt;user.getState() &lt;&lt;endl;        &#125;    &#125;    cout&lt;&lt;&quot;--------------------------group list-------------------------------&quot;&lt;&lt;endl;    if(!g_currentUserGroupList.empty())&#123;        for(Group &amp;group:g_currentUserGroupList)&#123;            cout&lt;&lt;group.getId()&lt;&lt;&quot; &quot;&lt;&lt;group.getName()&lt;&lt;&quot; &quot;&lt;&lt;group.getDesc()&lt;&lt;endl;            for(GroupUser &amp;user:group.getUsers())&#123;                cout&lt;&lt;user.getId()&lt;&lt;&quot; &quot;&lt;&lt;user.getName()&lt;&lt;&quot; &quot;&lt;&lt;user.getState()&lt;&lt;user.getRole()&lt;&lt;endl;            &#125;        &#125;    &#125;    cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;&#125;</code></pre><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;登录成功，启动接受线程负责接受数据std::thread readTask(readTaskHandler,clientfd);readTask.detach();</code></pre><p>其中readTaskHandler的实现：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;接受线程void readTaskHandler(int clientfd)&#123;    for(;;)&#123;        char buffer[1024]&#x3D;&#123;0&#125;;        int len &#x3D;recv(clientfd,buffer,1024,0);        if(-1&#x3D;&#x3D;len||0&#x3D;&#x3D;len)&#123;            close(clientfd);            exit(-1);        &#125;        &#x2F;&#x2F;接收ChatServer转发的数据，反序列化生成json数据对象        json js&#x3D;json::parse(buffer);        if(ONE_CHAT_MSG&#x3D;&#x3D;js[&quot;msgid&quot;])&#123;            cout&lt;&lt;js[&quot;time&quot;].get&lt;string&gt;()&lt;&lt;&quot;[&quot;&lt;&lt;js[&quot;id&quot;]&lt;&lt;&quot;]&quot;&lt;&lt;js[&quot;name&quot;].get&lt;string&gt;()&lt;&lt; &quot; said: &quot;&lt;&lt;js[&quot;msg&quot;].get&lt;string&gt;()&lt;&lt;endl;            continue;        &#125;    &#125;&#125;</code></pre><p>这个函数是用来接受服务端发来的消息的。主线程是发消息的。但是当前就实现了关于一对一聊天的接受消息。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;进入聊天主菜单页面 mainMenu(clientfd);</code></pre><p>进入聊天主菜单页面实现具体的业务：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;主聊天页面程序void mainMenu(int clientfd)&#123;    help();    char buffer[1024]&#x3D;&#123;0&#125;;    for(;;)&#123;        cin.getline(buffer,1024);        string commandbuf(buffer);        string command;        int idx&#x3D;commandbuf.find(&quot;:&quot;);        if(idx&#x3D;&#x3D;-1)&#123;            command&#x3D;commandbuf;        &#125;        else&#123;            command&#x3D;commandbuf.substr(0,idx);        &#125;        auto it&#x3D;commandHandlerMap.find(command);        if(it&#x3D;&#x3D;commandHandlerMap.end())&#123;            cerr&lt;&lt; &quot;invalid input command!&quot;&lt;&lt;endl;            continue;        &#125;        &#x2F;&#x2F;调用相应命令的事件处理回调，mainMenu对修改封闭，添加新功能不需要修改该函数        it-&gt;second(clientfd,commandbuf.substr(idx+1,commandbuf.size()-idx));&#x2F;&#x2F;调用命令处理方法    &#125;&#125;</code></pre><p>这个函数实现进入主页面使用对应的指令使用对应的功能。接下来说说其中的变量commandHandlerMap。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;注册系统支持的客户端命令处理unordered_map&lt;string,function&lt;void(int,string)&gt;&gt;commandHandlerMap&#x3D;&#123;    &#123;&quot;help&quot;,help&#125;,    &#123;&quot;chat&quot;,chat&#125;,    &#123;&quot;addfriend&quot;,addfriend&#125;,    &#123;&quot;creategroup&quot;,creategroup&#125;,    &#123;&quot;addgroup&quot;,addgroup&#125;,    &#123;&quot;groupchat&quot;,groupchat&#125;,    &#123;&quot;loginout&quot;,loginout&#125;&#125;;</code></pre><p>通过哈希表绑定对应的字符串和对应函数的实现。</p><p>当然在实现这些功能时得要有一个文字说明，这就是help功能。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;help&quot; command handlervoid help(int fd,string str)&#123;    cout&lt;&lt; &quot;show command lists:&quot;&lt;&lt;endl;    for(auto&amp;p:commandMap)&#123;        cout&lt;&lt;p.first&lt;&lt;&quot; : &quot;&lt;&lt;p.second&lt;&lt;endl;    &#125;    cout&lt;&lt;endl;&#125;</code></pre><p>这有个细节，因为后续用户如果还想要再次使用help功能，所以把他放在commandHandlerMap中，但是help()函数不满足function&lt;void(int,string)&gt;,所以我们在声明的时候赋初始值，这样就可以直接help()实现了。在其中commandMap也是自己定义提示用户如何使用这些功能。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;系统支持的客户端命令列表unordered_map&lt;string,string&gt; commandMap&#x3D;&#123;    &#123;&quot;help&quot;,&quot;显示所有支持的命令，格式help&quot;&#125;,    &#123;&quot;chat&quot;,&quot;一对一聊天，格式chat:friendid:message&quot;&#125;,    &#123;&quot;addfriend&quot;,&quot;添加好友，格式addfriend:friendid&quot;&#125;,    &#123;&quot;creategroup&quot;,&quot;创建群组，格式creategroup:groupname:groupdesc&quot;&#125;,    &#123;&quot;addgroup&quot;,&quot;加入群组，格式addgroup:groupid&quot;&#125;,    &#123;&quot;groupchat&quot;,&quot;群聊，格式groupchat:groupid:message&quot;&#125;,    &#123;&quot;loginout&quot;,&quot;注销，格式loginout&quot;&#125;&#125;;</code></pre><p>由commandHandlerMap知道要实现的功能。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;调用相应命令的事件处理回调，mainMenu对修改封闭，添加新功能不需要修改该函数it-&gt;second(clientfd,commandbuf.substr(idx+1,commandbuf.size()-idx));&#x2F;&#x2F;调用命令处理方法</code></pre><p>这样就可以把具体实现的内容封装到每一个函数中，所以接下来聚集每个实现的函数。</p><h6 id="chat功能实现："><a href="#chat功能实现：" class="headerlink" title="chat功能实现："></a>chat功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;chat&quot; command handlervoid chat(int clientfd,string str)&#123;    int idx&#x3D;str.find(&quot;:&quot;);&#x2F;&#x2F;friendid:message    if(idx&#x3D;&#x3D;-1)&#123;        cerr&lt;&lt;&quot;chat command invalid!&quot;&lt;&lt;endl;        return;    &#125;    int friendid&#x3D;atoi(str.substr(0,idx).c_str());    string message&#x3D;str.substr(idx+1,str.size()-idx);    json js;    js[&quot;msgid&quot;]&#x3D;ONE_CHAT_MSG;    js[&quot;id&quot;]&#x3D;g_currentUser.getId();    js[&quot;name&quot;]&#x3D;g_currentUser.getName();    js[&quot;msg&quot;] &#x3D; message;    js[&quot;toid&quot;]&#x3D;friendid;    js[&quot;time&quot;]&#x3D;getCurrentTime();    string buffer&#x3D;js.dump();    int len&#x3D;send(clientfd,buffer.c_str(),strlen(buffer.c_str())+1,0);    if(len&#x3D;&#x3D;-1)&#123;        cerr&lt;&lt;&quot;send chat msg error:&quot;&lt;&lt;buffer&lt;&lt;endl;    &#125;&#125;</code></pre><p>还要实现getCurrentTime函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;获取系统时间(聊天信息需要添加时间信息)string getCurrentTime()&#123;    auto tt &#x3D; std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());    struct tm *ptm &#x3D; localtime(&amp;tt);    char date[60] &#x3D; &#123;0&#125;;    sprintf(date, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,            (int)ptm-&gt;tm_year + 1900, (int)ptm-&gt;tm_mon + 1, (int)ptm-&gt;tm_mday,            (int)ptm-&gt;tm_hour, (int)ptm-&gt;tm_min, (int)ptm-&gt;tm_sec);    return std::string(date);&#125;</code></pre><h6 id="addfriend功能实现："><a href="#addfriend功能实现：" class="headerlink" title="addfriend功能实现："></a>addfriend功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;addfriend&quot; command handlervoid addfriend(int clienfd,string str)&#123;    int friendid&#x3D;atoi(str.c_str());    json js;    js[&quot;msgid&quot;]&#x3D;ADD_FRIEND_MSG;    js[&quot;id&quot;]&#x3D;g_currentUser.getId();    js[&quot;friendid&quot;]&#x3D;friendid;    string buffer&#x3D;js.dump();    int len&#x3D;send(clienfd,buffer.c_str(),strlen(buffer.c_str())+1,0);    if(len&#x3D;&#x3D;-1)&#123;        cerr&lt;&lt;&quot;send addfriend msg error-&gt;&quot;&lt;&lt;buffer&lt;&lt;endl;    &#125;&#125;</code></pre><h6 id="creategroup功能实现："><a href="#creategroup功能实现：" class="headerlink" title="creategroup功能实现："></a>creategroup功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;creategroup&quot; command handlervoid creategroup(int clientfd, string str)&#123;    int idx &#x3D; str.find(&quot;:&quot;);    if (idx &#x3D;&#x3D; -1)    &#123;        cerr &lt;&lt; &quot;creategroup command invalid!&quot; &lt;&lt; endl;        return;    &#125;    string groupname &#x3D; str.substr(0, idx);    string groupdesc &#x3D; str.substr(idx + 1, str.size() - idx);    json js;    js[&quot;msgid&quot;] &#x3D; CREATE_GROUP_MSG;    js[&quot;id&quot;] &#x3D; g_currentUser.getId();    js[&quot;groupname&quot;] &#x3D; groupname;    js[&quot;groupdesc&quot;] &#x3D; groupdesc;    string buffer &#x3D; js.dump();    int len &#x3D; send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0);    if (len &#x3D;&#x3D; -1)    &#123;        cerr &lt;&lt; &quot;send creategroup msg error:&quot; &lt;&lt; buffer &lt;&lt; endl;    &#125;&#125;</code></pre><h6 id="addgroup功能实现："><a href="#addgroup功能实现：" class="headerlink" title="addgroup功能实现："></a>addgroup功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;addgroup&quot; command handlervoid addgroup(int clientfd, string str)&#123;    int groupid &#x3D; atoi(str.c_str());    json js;    js[&quot;msgid&quot;] &#x3D; ADD_GROUP_MSG;    js[&quot;id&quot;] &#x3D; g_currentUser.getId();    js[&quot;groupid&quot;] &#x3D; groupid;    string buffer &#x3D; js.dump();    int len &#x3D; send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0);    if (len &#x3D;&#x3D; -1)    &#123;        cerr &lt;&lt; &quot;send addgroup msg error:&quot; &lt;&lt; buffer &lt;&lt; endl;    &#125;&#125;</code></pre><h6 id="groupchat功能实现："><a href="#groupchat功能实现：" class="headerlink" title="groupchat功能实现："></a>groupchat功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;groupchat&quot; command handlervoid groupchat(int clientfd, string str)&#123;    int idx &#x3D; str.find(&quot;:&quot;);    if (idx &#x3D;&#x3D; -1)    &#123;        cerr &lt;&lt; &quot;groupchat command invalid!&quot; &lt;&lt; endl;        return;    &#125;    int groupid &#x3D; atoi(str.substr(0, idx).c_str());    string message &#x3D; str.substr(idx + 1, str.size() - idx);    json js;    js[&quot;msgid&quot;] &#x3D; GROUP_CHAT_MSG;    js[&quot;id&quot;] &#x3D; g_currentUser.getId();    js[&quot;name&quot;] &#x3D; g_currentUser.getName();    js[&quot;groupid&quot;] &#x3D; groupid;    js[&quot;msg&quot;] &#x3D; message;    js[&quot;time&quot;] &#x3D; getCurrentTime();    string buffer &#x3D; js.dump();    int len &#x3D; send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0);    if (len &#x3D;&#x3D; -1)    &#123;        cerr &lt;&lt; &quot;send groupchat msg error:&quot; &lt;&lt; buffer &lt;&lt; endl;    &#125;&#125;</code></pre><p>实现群聊功能后，需要在接受线程实现解析返回的信息，并且输出。服务端在这里是直接将消息转发。所以如下实现：</p><pre class="language-c++" data-language="c++"><code class="language-c++">if (GROUP_CHAT_MSG &#x3D;&#x3D; msgtype)&#123;cout &lt;&lt; &quot;群消息[&quot; &lt;&lt; js[&quot;groupid&quot;] &lt;&lt; &quot;]:&quot; &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;            continue; &#125;</code></pre><p>当然离线消息同时也要输出群组消息.</p><pre class="language-c++" data-language="c++"><code class="language-c++">if (ONE_CHAT_MSG &#x3D;&#x3D; js[&quot;msgid&quot;].get&lt;int&gt;())                                &#123;                                    cout &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;                                &#125;else&#123;                                    cout &lt;&lt; &quot;群消息[&quot; &lt;&lt; js[&quot;groupid&quot;] &lt;&lt; &quot;]:&quot; &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;                                &#125;</code></pre><p>else部分即为离线群组消息。</p><h6 id="loginout功能实现："><a href="#loginout功能实现：" class="headerlink" title="loginout功能实现："></a>loginout功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;login out&quot; command handlervoid loginout(int clientfd, string str)&#123;    json js;    js[&quot;msgid&quot;]&#x3D;LOGINOUT_MSG;    js[&quot;id&quot;]&#x3D;g_currentUser.getId();    string buffer&#x3D;js.dump();    int len&#x3D;send(clientfd,buffer.c_str(),strlen(buffer.c_str())+1,0);    if(len&#x3D;&#x3D;-1)&#123;        cerr&lt;&lt;&quot;send loginout msg error:&quot;&lt;&lt;buffer&lt;&lt;endl;    &#125;else&#123;        isMainMenuRunning&#x3D;false;    &#125;&#125;</code></pre><p>首先这个函数实现需要在public.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">LOGINOUT_MSG,&#x2F;&#x2F;注销消息</code></pre><p>在服务器端做出对应的函数：（记得在构造函数注册注销业务）</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;处理注销业务void ChatService::loginout(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int userid&#x3D;js[&quot;id&quot;];    &#123;        lock_guard&lt;mutex&gt; lock(_connMutex);        auto it&#x3D;_userConnMap.find(userid);        if(it!&#x3D;_userConnMap.end())&#123;            _userConnMap.erase(it);        &#125;    &#125;    &#x2F;&#x2F;更新用户的状态信息    User user(userid,&quot;&quot;,&quot;&quot;,&quot;offline&quot;);    _userModel.updateState(user);&#125;</code></pre><p>将_userConnMap对应的id的连接删去，并且更新用户的状态。</p><p>isMainMenuRunning是一个全局变量，用来确保loginout后会回到首页。所以默认值为false。当进入主菜单界面时，变为true。这样mainMenu函数就会退出循环，运行结束，进入首页的循环。</p><p>当然这里就出现了一个问题就是loginoutr退出但是程序没有退出，很多全局变量还保留着上一次的值，这就会在输出这些变量时会把上一次登录的用户信息都输出。所以在登录成功时，记得将对应变量初始化清空，再进行赋值。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 记录当前登录用户的好友列表信息vector&lt;User&gt; g_currentUserFriendList;&#x2F;&#x2F; 记录当前登录用户的群组列表信息vector&lt;Group&gt; g_currentUserGroupList;</code></pre><p>这两个变量在登录成功后，会进行赋值，记得在赋值前，初始化，清空。</p><p>这里还有一个问题，每次登录成功都会创造一个线程，当我在loginout后再次登录，又创造了一个新线程。所以要保证只有一个线程实现接受。所以在登录成功部分修改：</p><pre class="language-c++" data-language="c++"><code class="language-c++"> &#x2F;&#x2F; 登录成功，启动接受线程负责接受数据 ,该线程只启动一次static int readthreadnumber&#x3D;0;if(readthreadnumber&#x3D;&#x3D;0)&#123;std::thread readTask(readTaskHandler, clientfd); &#x2F;&#x2F; 在Linux pthread_createreadTask.detach();readthreadnumber++;                               &#x2F;&#x2F; Linux pthread_detach&#125;</code></pre><h3 id="引入负载均衡器："><a href="#引入负载均衡器：" class="headerlink" title="引入负载均衡器："></a>引入负载均衡器：</h3><p>以上我们基本完成了客户端和服务端的开发，由于是一个聊天服务器，要考虑一台服务器同时可以多少用户在线。我借用muduo模型创建 1个主线程（accept连接）+ 4个子线程（处理连接和事件）总共 5个线程，用于服务端 I&#x2F;O。主线程用于 accept 新连接4 个 <code>EventLoop</code> 子线程处理客户端连接的 I&#x2F;O 事件（读写、消息分发等）</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设置线程数量_server.setThreadNum(4);</code></pre><h4 id="操作系统的限制"><a href="#操作系统的限制" class="headerlink" title="操作系统的限制"></a><strong>操作系统的限制</strong></h4><p>操作系统对单个进程的文件描述符数量有限制，每个客户端连接通常占用一个文件描述符（socket）。</p><ul><li><strong>Linux默认值</strong>（可以用 <code>ulimit -n</code> 查看）：通常是 <strong>1024</strong>，也就是说一个进程默认最多只能同时处理约1000个客户端连接。</li></ul><h4 id="实际可支持的并发连接数（估算）："><a href="#实际可支持的并发连接数（估算）：" class="headerlink" title="实际可支持的并发连接数（估算）："></a>实际可支持的并发连接数（估算）：</h4><table><thead><tr><th>类型</th><th>数量</th></tr></thead><tbody><tr><td>Idle连接（不活跃）</td><td>40,000 ~ 100,000（受内核和 FD 限制）</td></tr><tr><td>活跃连接（频繁收发消息）</td><td>10,000 ~ 20,000（实际取决于业务逻辑复杂度）</td></tr></tbody></table><p>这是<strong>单进程、多线程、epoll</strong> 架构下的典型并发能力，非常高效。</p><h4 id="什么是-Idle连接（不活跃连接）？"><a href="#什么是-Idle连接（不活跃连接）？" class="headerlink" title="什么是 Idle连接（不活跃连接）？"></a>什么是 <strong>Idle连接（不活跃连接）</strong>？</h4><p><strong>Idle（空闲）连接</strong> 是指：</p><p>客户端虽然 <strong>已经建立了连接</strong>，但 <strong>长时间没有发送或接收任何数据</strong>，也就是说：</p><ul><li><strong>连接处于打开状态（TCP连接存在）</strong></li><li>但没有发生 <strong>读写事件</strong></li><li>占用资源极少（仅占用文件描述符、少量内存）</li></ul><h4 id="为什么要区分-Idle-与-活跃连接？"><a href="#为什么要区分-Idle-与-活跃连接？" class="headerlink" title="为什么要区分 Idle 与 活跃连接？"></a>为什么要区分 Idle 与 活跃连接？</h4><ol><li><strong>资源占用不同</strong></li></ol><ul><li>Idle 连接不产生消息，不触发回调，服务器处理负担极低</li><li>活跃连接需要处理消息、业务逻辑，负担高</li></ul><ol start="2"><li><strong>并发能力的评估</strong></li></ol><ul><li>很多高并发服务器说能支持“10万连接”，指的是 <strong>Idle连接数量</strong></li><li>真正活跃（消息频繁）的连接，一般几千~上万就会达到服务器上限</li></ul><ol start="3"><li><strong>是否需要清理 Idle连接</strong></li></ol><ul><li>有些服务器会设置 <strong>心跳&#x2F;超时机制</strong>，长时间不活跃的连接会被断开，防止资源泄漏或恶意占用</li></ul><p>我们还要提高并发量，就要引入<strong>负载均衡器</strong>的概念。</p><h4 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h4><p><strong>负载均衡器（Load Balancer）</strong> 是一个把大量客户端请求 <strong>均匀分发</strong> 给多个后端服务器的组件，以提高系统的 <strong>吞吐能力、稳定性和可用性</strong>。</p><h5 id="为什么需要它？"><a href="#为什么需要它？" class="headerlink" title="为什么需要它？"></a>为什么需要它？</h5><p>在高并发系统中，如果所有请求都打到一个服务器上，容易导致：</p><ul><li>响应慢</li><li>连接超时</li><li>服务宕机</li></ul><p>使用负载均衡器可以：</p><ul><li><strong>水平扩展</strong>服务器（多个 Muduo 实例）</li><li><strong>分担压力</strong></li><li>实现高可用（某个服务器挂了不影响整体）</li></ul><h5 id="按协议层划分（TCP-HTTP）"><a href="#按协议层划分（TCP-HTTP）" class="headerlink" title="按协议层划分（TCP&#x2F;HTTP）"></a>按协议层划分（TCP&#x2F;HTTP）</h5><table><thead><tr><th>类型</th><th>层级</th><th>说明</th><th>常用代表</th></tr></thead><tbody><tr><td><strong>四层负载均衡（L4）</strong></td><td>TCP&#x2F;UDP</td><td>基于 IP、端口、协议</td><td>LVS、HAProxy、Nginx Stream、Keepalived</td></tr><tr><td><strong>七层负载均衡（L7）</strong></td><td>HTTP、HTTPS</td><td>基于 URL、Header、Cookie</td><td>Nginx、HAProxy、Traefik、Envoy、Kong</td></tr></tbody></table><h5 id="常见软件负载均衡器对比"><a href="#常见软件负载均衡器对比" class="headerlink" title="常见软件负载均衡器对比"></a>常见软件负载均衡器对比</h5><table><thead><tr><th>名称</th><th>协议支持</th><th>类型</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td><strong>LVS</strong></td><td>L4 (TCP&#x2F;UDP)</td><td>内核模块</td><td>性能极高、稳定、复杂配置</td><td>超高并发、基础设施层</td></tr><tr><td><strong>HAProxy</strong></td><td>L4 + L7</td><td>用户态</td><td>灵活、高性能、支持健康检查、监控完备</td><td>Web、API 网关、数据库代理</td></tr><tr><td><strong>Nginx</strong></td><td>L7 (也支持 L4)</td><td>用户态</td><td>配置简单，静态资源支持好</td><td>Web服务器、轻量级反代</td></tr><tr><td><strong>Traefik</strong></td><td>L7</td><td>云原生</td><td>自动发现服务（K8s、Docker）、面向微服务</td><td>DevOps、容器化</td></tr><tr><td><strong>Envoy</strong></td><td>L4 + L7</td><td>云原生</td><td>微服务架构核心组件、支持 gRPC、动态配置</td><td>Istio、Service Mesh</td></tr><tr><td><strong>Kong</strong></td><td>L7 API网关</td><td>插件丰富</td><td>基于 Nginx，提供限流、安全等扩展能力</td><td>企业 API 管理</td></tr><tr><td><strong>Keepalived</strong></td><td>L4</td><td>高可用</td><td>常与 LVS 配合，提供主备切换</td><td>双主结构、高可用架构</td></tr><tr><td><strong>OpenResty</strong></td><td>L7</td><td>基于 Nginx</td><td>支持 Lua，适合做复杂业务逻辑</td><td>高定制需求</td></tr><tr><td><strong>Caddy</strong></td><td>L7</td><td>自动 TLS</td><td>HTTPS 自动配置简单</td><td>个人、低门槛网站部署</td></tr></tbody></table><p>我们这里要使用的是Nginx 的 TCP 负载均衡模块（即 stream 模块）</p><p><img src="/2025/06/02/C++-chatserver/2.png" alt="2" loading="lazy"></p><p>这是负载均衡器在本项目发挥的作用图。</p><p>Nginx 默认是 HTTP 层负载均衡（七层），但它的 <strong><code>stream</code> 模块</strong> 支持四层（TCP&#x2F;UDP）负载均衡，非常适合。</p><p>说白了，通过多台后台服务器提高并发量。但也面临着如何处理跨服务器通信的问题。</p><h3 id="引入服务器中间件（redis）"><a href="#引入服务器中间件（redis）" class="headerlink" title="引入服务器中间件（redis）"></a>引入服务器中间件（redis）</h3><p><strong>Redis（Remote Dictionary Server）</strong> 是一个<strong>开源</strong>的、基于内存的<strong>键值对存储（Key-Value Store）数据库</strong>，支持丰富的数据结构，<strong>读写极快</strong>，非常适合用作缓存、中间件、消息队列等。</p><p>引入redis是要解决如果一个用户要和另一个用户通信，但是另一个用户在另一台服务器上，我们能从数据库中看到他在线，但是我们不能获取他的连接，所以引入中间件。这样就可以解决跨服务器通信的问题。</p><p>这里是redis在本项目的作用图：</p><p><img src="/2025/06/02/C++-chatserver/3.png" alt="3" loading="lazy"></p><h3 id="nginx项目配置"><a href="#nginx项目配置" class="headerlink" title="nginx项目配置"></a>nginx项目配置</h3><p>nginx配置编译好后，去修改&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf中修改nginx.conf文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#nginx tcp loadbalance config</span>stream <span class="token punctuation">&#123;</span>        upstream MyServer <span class="token punctuation">&#123;</span>                server <span class="token number">127.0</span>.0.1:6000 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">max_fails</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span>30s<span class="token punctuation">;</span>                server <span class="token number">127.0</span>.0.1:6002 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">max_fails</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span>30s<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        server <span class="token punctuation">&#123;</span>                proxy_connect_timeout 1s<span class="token punctuation">;</span>                <span class="token comment">#proxy_timeout 3s; # 可以根据需要开启，控制代理的读写超时</span>                listen <span class="token number">8000</span><span class="token punctuation">;</span>                proxy_pass MyServer<span class="token punctuation">;</span>                tcp_nodelay on<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span></code></pre><p>在events和http领域之间加入上述代码。这一段代码就是加入**<code>stream</code> 模块** 。</p><p>说明</p><ul><li>**stream{}**：用于 TCP&#x2F;UDP 负载均衡。</li><li><strong>upstream MyServer</strong>：定义了两个后端服务器，权重相等。</li><li><strong>max_fails&#x3D;3 fail_timeout&#x3D;30s</strong>：3次失败后，30秒内认为该节点不可用。</li><li><strong>listen 8000</strong>：监听本机 8000 端口。</li><li><strong>proxy_connect_timeout 1s</strong>：连接超时时间为1秒。</li><li><strong>proxy_pass MyServer</strong>：请求转发到 MyServer 负载均衡组。</li><li><strong>tcp_nodelay on</strong>：开启 TCP_NODELAY，减少延迟。</li></ul><p>这样就实现了多个客户端只需要向一个ip+port就可以。通过nginx对多台服务器管理，这样就增加了聊天服务器的并发量。当然跨服务器通信这一问题还没有解决。</p><h3 id="Redis项目配置"><a href="#Redis项目配置" class="headerlink" title="Redis项目配置"></a>Redis项目配置</h3><p>首先在include和src建立redis文件夹，在对应的文件夹添加redis.hpp和redis.cpp。记得更新CMakeLists.txt文件。这里调用了hiredis库。hiredis是c++使用redis封装的库。</p><p>redis.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef REDIS_H#define REDIS_H#include &lt;hiredis&#x2F;hiredis.h&gt;#include &lt;thread&gt;#include &lt;functional&gt;using namespace std;class Redis&#123;    public:        Redis();        ~Redis();        &#x2F;&#x2F;连接redis服务器        bool connect();        &#x2F;&#x2F;向redis指定的通道channel发布消息        bool publish(int channel,string message);        &#x2F;&#x2F;向redis指定的通道subscribe订阅消息        bool subscribe(int channel);        &#x2F;&#x2F;向redis指定的通道unsubscribe取消订阅消息        bool unsubscribe(int channel);        &#x2F;&#x2F;在独立线程中接受订阅通道中的消息        void observer_channel_message();        &#x2F;&#x2F;初始化向业务层上报通道消息的回调对象        void init_notify_handler(function&lt;void(int,string)&gt; fn);    private:        &#x2F;&#x2F;hiredis同步上下文对象，负责publish消息        redisContext *_publish_context;        &#x2F;&#x2F;hiredis同步上下文对象，负责subscribe消息        redisContext * _subscribe_context;        &#x2F;&#x2F;回调操作，收到订阅的消息，给service层上报        function&lt;void (int,string)&gt; _notify_message_handler;&#125;;#endif</code></pre><p>redis.cpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&quot;redis.hpp&quot;#include&lt;iostream&gt;using namespace std;Redis::Redis():_publish_context(nullptr),_subscribe_context(nullptr)&#123;&#125;Redis::~Redis()&#123;    if(_publish_context!&#x3D;nullptr)&#123;        redisFree(_publish_context);    &#125;    if(_subscribe_context!&#x3D;nullptr)&#123;        redisFree(_subscribe_context);    &#125;&#125;bool Redis::connect()&#123;    &#x2F;&#x2F;负责publish发布消息的上下文连接    _publish_context&#x3D;redisConnect(&quot;127.0.0.1&quot;,6379);    if(_publish_context&#x3D;&#x3D;nullptr)&#123;        cerr&lt;&lt; &quot;connect redis failed!&quot;&lt;&lt;endl;        return false;    &#125;    &#x2F;&#x2F;负责subscribe订阅消息的上下文连接    _subscribe_context&#x3D;redisConnect(&quot;127.0.0.1&quot;,6379);    if(_subscribe_context&#x3D;&#x3D;nullptr)&#123;        cerr&lt;&lt; &quot;connect redis failed!&quot;&lt;&lt;endl;        return false;    &#125;    &#x2F;&#x2F;在单独的线程中，监听通道上的事件，有消息给业务层进行上报    thread t([&amp;]()&#123;        observer_channel_message();    &#125;);    t.detach();    cout&lt;&lt;&quot;connect redis_server success!&quot;&lt;&lt;endl;    return true;&#125;&#x2F;&#x2F;向redis指定的通道channel发布消息bool Redis::publish(int channel,string message)&#123;    redisReply *reply&#x3D;(redisReply*)redisCommand(_publish_context,&quot;PUBLISH %d %s&quot;,channel,message.c_str());    if(reply&#x3D;&#x3D;nullptr)&#123;        cerr&lt;&lt;&quot;publish command failed&quot;&lt;&lt;endl;        return false;    &#125;    freeReplyObject(reply);    return true;&#125;&#x2F;&#x2F;向redis指定的通道subscribe订阅消息bool Redis::subscribe(int channel)&#123;    &#x2F;&#x2F;subscribe命令本身会造成线程阻塞等待通道里面发生消息，这里只做订阅通道，不接受消息    &#x2F;&#x2F;通道消息的接受专门在observer_channel_message函数中的独立线程中进行    &#x2F;&#x2F;只负责发送命令，不阻塞接受redis server响应消息，否则和notifyMsg线程抢占响应资源。    if(REDIS_ERR&#x3D;&#x3D;redisAppendCommand(this-&gt;_subscribe_context,&quot;SUBSCRIBE %d&quot;,channel))&#123;        cerr&lt;&lt;&quot;subscribe command failed!&quot;&lt;&lt;endl;        return false;    &#125;    &#x2F;&#x2F;redisBufferWrite 可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1）    int done&#x3D;0;    while(!done)&#123;        if(REDIS_ERR&#x3D;&#x3D;redisBufferWrite(this-&gt;_subscribe_context,&amp;done))&#123;            cerr&lt;&lt;&quot;subscribe command failed!&quot;&lt;&lt;endl;            return false;        &#125;    &#125;    &#x2F;&#x2F;redisGetReply不执行    return true;&#125;&#x2F;&#x2F;向redis指定的通道unsubscribe取消订阅消息bool Redis::unsubscribe(int channel)&#123;    if(REDIS_ERR&#x3D;&#x3D;redisAppendCommand(this-&gt;_subscribe_context,&quot;UNSUBSCRIBE %d&quot;,channel))&#123;        cerr&lt;&lt;&quot;unsubscribe command failed!&quot;&lt;&lt;endl;        return false;    &#125;    &#x2F;&#x2F;redisBufferWrite 可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1）    int done&#x3D;0;    while(!done)&#123;        if(REDIS_ERR&#x3D;&#x3D;redisBufferWrite(this-&gt;_subscribe_context,&amp;done))&#123;            cerr&lt;&lt;&quot;unsubscribe command failed!&quot;&lt;&lt;endl;            return false;        &#125;    &#125;    return true;&#125;&#x2F;&#x2F;在独立线程中接受订阅通道中的消息void Redis::observer_channel_message()&#123;    redisReply *reply&#x3D;nullptr;    while(REDIS_OK&#x3D;&#x3D;redisGetReply(this-&gt;_subscribe_context,(void**)&amp;reply))&#123;        &#x2F;&#x2F;订阅收到的消息是一个带三元组的数组        if(reply!&#x3D;nullptr&amp;&amp;reply-&gt;element[2]!&#x3D;nullptr&amp;&amp;reply-&gt;element[2]-&gt;str!&#x3D;nullptr)&#123;            &#x2F;&#x2F;给业务层上报通道上发生的消息            _notify_message_handler(atoi(reply-&gt;element[1]-&gt;str),reply-&gt;element[2]-&gt;str);        &#125;        freeReplyObject(reply);    &#125;    cerr&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;observer_channel_message quit &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;&#125;&#x2F;&#x2F;初始化向业务层上报通道消息的回调对象void Redis::init_notify_handler(function&lt;void(int,string)&gt; fn)&#123;    this-&gt;_notify_message_handler&#x3D;fn;&#125;</code></pre><p>这里需要注意的点就是关于订阅和发布，发布publish直接用redisCommand函数即可，因为这个命令直接执行本身不会堵塞（服务器会很快给出回复）。但是subscribe不一样，他直接执行会卡在那里，一直等待消息进入通道里（服务器不会很快回复）。所以我们这里使用redisAppendCommand<code>+</code>redisBufferWrite这两个函数一起，不用再等待响应。所以我们单开一个线程来接受通道里的消息。</p><p>总结对比</p><table><thead><tr><th>功能</th><th><code>redisCommand</code></th><th><code>redisAppendCommand</code> + <code>redisBufferWrite</code></th></tr></thead><tbody><tr><td>用法</td><td>直接发送+等待响应</td><td>仅发送命令到 Redis，不等待响应</td></tr><tr><td>是否阻塞</td><td>会阻塞直到响应</td><td>不会阻塞</td></tr><tr><td>适用场景</td><td>普通命令（GET&#x2F;SET）</td><td>发布订阅等需要后台线程响应的命令</td></tr></tbody></table><p>所以我们把监听逻辑放到线程里。</p><p>注意：</p><p>Redis 的订阅-发布机制设计：</p><ul><li><strong>订阅连接会被阻塞监听消息，不允许执行其他命令。</strong></li><li>如果同一个连接既用来订阅又用来发布，订阅时会阻塞导致发布失败或延迟。</li><li>所以一般建议<strong>发布和订阅使用独立的连接</strong>，保证各自的流畅性和响应效率。</li></ul><h3 id="解决跨服务器通信问题"><a href="#解决跨服务器通信问题" class="headerlink" title="解决跨服务器通信问题"></a>解决跨服务器通信问题</h3><p>我们已经配置好redis,并且封装了对应的redis类。接下来在业务类实现加入redis。</p><p>在对应的ChatService类声明私有变量。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;redis操作对象 Redis _redis;</code></pre><p>在ChatService类的构造函数，实现redis连接并且加入回调函数。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;连接redis服务器if(_redis.connect())&#123;&#x2F;&#x2F;设置上报消息的回调_redis.init_notify_handler(std::bind(&amp;ChatService::handleRedisSubscribeMessage,this,_1,_2));&#125;</code></pre><p>handleRedisSubscribeMessage函数是从redis消息队列中获取订阅的消息（在另一个线程执行）</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;从redis消息队列中获取订阅的消息void ChatService::handleRedisSubscribeMessage(int userid,string msg)&#123;    lock_guard&lt;mutex&gt; lock(_connMutex);    auto it&#x3D;_userConnMap.find(userid);    if(it!&#x3D;_userConnMap.end())&#123;        it-&gt;second-&gt;send(msg);        return;    &#125;    &#x2F;&#x2F;存储该用户的离线消息    _offlineMsgModel.insert(userid,msg);&#125;</code></pre><p>从redis返回的userid和message是当前服务器订阅的通道返回的消息，所以当前userid一定在当前服务器的_userConnMap中，当然也存在一种情况，发消息给redis时，还在线，redis传给对应的服务器时，该用户下线了，所以也要存储该用户的离线消息。</p><p>接着还要在登录功能和注销功能做修改</p><p>在登录成功后：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;id用户登录成功后，向redis订阅channel(id)_redis.subscribe(id);</code></pre><p>要向redis订阅消息，有向当前用户发送的消息会向在redis通道存储，之后会向当前用户输送。</p><p>在注销（退出）后：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;用户注销，相当于下线，在redis中取消订阅通道_redis.unsubscribe(userid);</code></pre><p>关闭掉订阅通道。当然还有客户端异常退出时，也要关闭订阅</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;客户端关闭，相当于下线，在redis中取消订阅通道_redis.unsubscribe(user.getId());</code></pre><p>最后对一对一聊天和群聊功能做修改。</p><p>一对一聊天，当查到目标用户没有在_userConnMap中，说明目标用户不在当前服务器上或者不在线，所以接下来去数据库查看目标用户是否在线，若在线，则向redis对应的通道发布消息。不在线则存储连线消息。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;查询toid是否在线（可能在其他服务器上）User user&#x3D;_userModel.query(toid);if(user.getState()&#x3D;&#x3D;&quot;online&quot;)&#123;_redis.publish(toid,js.dump());return;&#125;</code></pre><p>群聊，当查到目标用户没有在_userConnMap中，说明目标用户不在当前服务器上或者不在线，所以接下来去数据库查看目标用户是否在线，若在线，则向redis对应的通道发布消息。不在线则存储连线消息。</p><pre class="language-c++" data-language="c++"><code class="language-c++">auto it&#x3D;_userConnMap.find(id);if(it!&#x3D;_userConnMap.end())&#123;            &#x2F;&#x2F;转发群消息            it-&gt;second-&gt;send(js.dump());        &#125;else&#123;            &#x2F;&#x2F;查询id是否在线            User user&#x3D;_userModel.query(id);            if(user.getState()&#x3D;&#x3D;&quot;online&quot;)&#123;                _redis.publish(id,js.dump());            &#125;else&#123;                &#x2F;&#x2F;存储离线群消息                _offlineMsgModel.insert(id,js.dump());            &#125;                    &#125;</code></pre><p>至此解决跨服务器通信问题。</p><h3 id="解决登录注销后再次登录会阻塞的问题"><a href="#解决登录注销后再次登录会阻塞的问题" class="headerlink" title="解决登录注销后再次登录会阻塞的问题"></a>解决登录注销后再次登录会阻塞的问题</h3><p>在登录后注销退出后，在进行登录会一直卡住，没有关于用户的信息展示和指令展示，核查发现是主线程在执行recv,接受线程也在recv同一个socket,所以这里我们引入</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 用于读写线程的通信sem_t rwem;&#x2F;&#x2F; 记录登录状态atomic_bool g_isLoginSuccess&#123;false&#125;;</code></pre><p><code>sem_t</code> 是 POSIX 信号量类型（semaphore），用于线程之间同步或通信。</p><p><code>tomic_bool</code> 是 C++ 的原子变量类型之一，用于线程安全地读写布尔值，防止并发条件竞争。</p><p>一、信号量 <code>sem_t</code> 的初始化</p><p>在使用前，<strong>必须初始化</strong>。常用的是 <code>sem_init</code>：</p><pre class="language-c++" data-language="c++"><code class="language-c++">sem_t rwem;sem_init(&amp;rwem, 0, 0);</code></pre><p>参数解释：</p><pre class="language-c++" data-language="c++"><code class="language-c++">int sem_init(sem_t *sem, int pshared, unsigned int value);</code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>sem</code></td><td>指向信号量的指针</td></tr><tr><td><code>pshared=0</code></td><td>表示是线程之间使用（同一进程）</td></tr><tr><td><code>value=0</code></td><td>初始值为 0（表示“没有资源”）</td></tr></tbody></table><p> 通常设为 0，表示线程必须等待 <code>sem_post()</code> 才能继续。</p><p>二、sem_post 和 sem_wait 的配合逻辑</p><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td><code>sem_post(&amp;rwem)</code></td><td>给信号量加1，表示“有资源了”或“可以继续了”</td></tr><tr><td><code>sem_wait(&amp;rwem)</code></td><td>阻塞等待信号量值&gt;0，然后减1，表示“我来用这个资源”</td></tr></tbody></table><p>总体步骤：</p><table><thead><tr><th>步骤</th><th>函数</th><th>示例</th></tr></thead><tbody><tr><td>初始化</td><td><code>sem_init(&amp;rwem, 0, 0);</code></td><td>启动阶段</td></tr><tr><td>发送信号（通知）</td><td><code>sem_post(&amp;rwem);</code></td><td>接收线程收到数据时</td></tr><tr><td>等待信号</td><td><code>sem_wait(&amp;rwem);</code></td><td>处理线程等待数据</td></tr><tr><td>销毁</td><td><code>sem_destroy(&amp;rwem);</code></td><td>程序结束或退出登录时</td></tr></tbody></table><p>由于登录成功和注册成功的消息的收取是在主线程进行的，其他信息的收取是在另一个进程中，所以我要修改代码，把登录和注册的回复消息由接受进程收取。</p><p>首先在客户端main函数中连接服务器端成功后，插入</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 初始化读写线程通信用的信号量sem_init(&amp;rwem, 0, 0);&#x2F;&#x2F; 连接服务器成功，启动接受线程std::thread readTask(readTaskHandler, clientfd); &#x2F;&#x2F; 在Linux pthread_createreadTask.detach();</code></pre><p>在登录时向服务端发送登录消息后，插入</p><pre class="language-c++" data-language="c++"><code class="language-c++">sem_wait(&amp;rwem); &#x2F;&#x2F; 等待信号量，由子线程处理完登录的响应消息后，通知这里g_isLoginSuccess &#x3D; false;</code></pre><p>sem_wait(&amp;rwem); 是为了<strong>接受线程</strong>消息处理好后会sem_post(&amp;rewm)，主线程接受到信号进行往下走。</p><p>g_isLoginSuccess时为了确认登录是否成功，如不成功，就进入首页面，成功进主菜单页面。</p><pre class="language-c++" data-language="c++"><code class="language-c++">if (g_isLoginSuccess)            &#123;                &#x2F;&#x2F; 进入聊天主菜单页面                isMainMenuRunning &#x3D; true;                mainMenu(clientfd);            &#125;</code></pre><p>注册就只需要等待信号就可以了</p><pre class="language-c++" data-language="c++"><code class="language-c++">sem_wait(&amp;rwem); &#x2F;&#x2F; 等待信号量，由子线程处理完注册的响应消息后，通知这里</code></pre><p>在退出业务记得把信号回收</p><pre class="language-c++" data-language="c++"><code class="language-c++">sem_destroy(&amp;rwem);</code></pre><p>在接受线程里</p><pre class="language-c++" data-language="c++"><code class="language-c++">if (LOGIN_MSG_ACK &#x3D;&#x3D; msgtype)        &#123;            doLoginResponse(js); &#x2F;&#x2F; 处理登录响应的业务逻辑            sem_post(&amp;rwem);     &#x2F;&#x2F; 通知主线程，登录结果处理完成            continue;        &#125;        if (REG_MSG_ACK &#x3D;&#x3D; msgtype)        &#123;            doRegResponse(js);            sem_post(&amp;rwem); &#x2F;&#x2F; 通知主线程，注册结果处理完成            continue;        &#125;</code></pre><p>当收到对应业务的消息，就执行对应逻辑。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 处理登录响应的业务void doLoginResponse(json &amp;responsejs)&#123;    if (responsejs[&quot;errno&quot;] !&#x3D; 0)    &#123;        cerr &lt;&lt; responsejs[&quot;errmsg&quot;] &lt;&lt; endl;        g_isLoginSuccess &#x3D; false;    &#125;    else    &#123; &#x2F;&#x2F; 登录成功        &#x2F;&#x2F; 记录当前用户的id和name        g_currentUser.setId(responsejs[&quot;id&quot;]);        g_currentUser.setName(responsejs[&quot;name&quot;]);        &#x2F;&#x2F; 记录当前用户的好友列表信息        if (responsejs.contains(&quot;friends&quot;))        &#123;            &#x2F;&#x2F; 初始化            g_currentUserFriendList.clear();            &#x2F;&#x2F; 看是否包含friends这个键            vector&lt;string&gt; vec &#x3D; responsejs[&quot;friends&quot;];            for (string &amp;str : vec)            &#123;                json js &#x3D; json::parse(str);                User user;                user.setId(js[&quot;id&quot;]);                user.setName(js[&quot;name&quot;]);                user.setState(js[&quot;state&quot;]);                g_currentUserFriendList.push_back(user);            &#125;        &#125;        &#x2F;&#x2F; 记录当前用户的群组列表信息        if (responsejs.contains(&quot;groups&quot;))        &#123;            &#x2F;&#x2F; 初始化            g_currentUserGroupList.clear();            vector&lt;string&gt; vec1 &#x3D; responsejs[&quot;groups&quot;];            for (string &amp;groupstr : vec1)            &#123;                json grpjs &#x3D; json::parse(groupstr);                Group group;                group.setId(grpjs[&quot;id&quot;]);                group.setName(grpjs[&quot;groupname&quot;]);                group.setDesc(grpjs[&quot;groupdesc&quot;]);                vector&lt;string&gt; vec2 &#x3D; grpjs[&quot;users&quot;];                for (string &amp;userstr : vec2)                &#123;                    GroupUser user;                    json js &#x3D; json::parse(userstr);                    user.setId(js[&quot;id&quot;]);                    user.setName(js[&quot;name&quot;]);                    user.setState(js[&quot;state&quot;]);                    user.setRole(js[&quot;role&quot;]);                    group.getUsers().push_back(user);                &#125;                g_currentUserGroupList.push_back(group);            &#125;        &#125;        &#x2F;&#x2F; 显示登录用户的基本信息        showCurrentUserData();        &#x2F;&#x2F; 显示当前用户的离线消息 个人聊天消息或者群组消息        if (responsejs.contains(&quot;offlinemsg&quot;))        &#123;            vector&lt;string&gt; vec &#x3D; responsejs[&quot;offlinemsg&quot;];            for (string &amp;str : vec)            &#123;                json js &#x3D; json::parse(str);                &#x2F;&#x2F; time +[id]+name+&quot;said: &quot;+xxx                if (ONE_CHAT_MSG &#x3D;&#x3D; js[&quot;msgid&quot;].get&lt;int&gt;())                &#123;                    cout &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;                &#125;                else                &#123;                    cout &lt;&lt; &quot;群消息[&quot; &lt;&lt; js[&quot;groupid&quot;] &lt;&lt; &quot;]:&quot; &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;                &#125;            &#125;        &#125;        g_isLoginSuccess &#x3D; true;    &#125;&#125;</code></pre><p>当然，在登陆成功后记得把g_isLoginSuccess置为true。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 处理注册响应的业务void doRegResponse(json &amp;responsejs)&#123;    if (0 !&#x3D; responsejs[&quot;errno&quot;])    &#123; &#x2F;&#x2F; 注册失败        cerr &lt;&lt;&quot;name is already exist,register error!&quot; &lt;&lt; endl;    &#125;    else    &#123; &#x2F;&#x2F; 注册成功        cout &lt;&lt;&quot;name register success,userid is &quot; &lt;&lt; responsejs[&quot;id&quot;] &lt;&lt; &quot;, do not forget it!&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><p>这样就把这个问题解决了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;json学习&quot;&gt;&lt;a href=&quot;#json学习&quot; class=&quot;headerlink&quot; title=&quot;json学习&quot;&gt;&lt;/a&gt;json学习&lt;/h2&gt;&lt;pre class=&quot;language-cpp&quot; data-language=&quot;cpp&quot;&gt;&lt;code class</summary>
      
    
    
    
    <category term="项目" scheme="http://yustonerain.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="C++" scheme="http://yustonerain.top/tags/C/"/>
    
  </entry>
  
</feed>
