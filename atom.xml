<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YuStone</title>
  
  
  <link href="http://yustonerain.top/atom.xml" rel="self"/>
  
  <link href="http://yustonerain.top/"/>
  <updated>2025-07-25T13:26:16.000Z</updated>
  <id>http://yustonerain.top/</id>
  
  <author>
    <name>YuStone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MYSQL learning</title>
    <link href="http://yustonerain.top/2025/07/25/MYSQLlearning/"/>
    <id>http://yustonerain.top/2025/07/25/MYSQLlearning/</id>
    <published>2025-07-25T07:46:07.000Z</published>
    <updated>2025-07-25T13:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><h3 id="MySQL介绍"><a href="#MySQL介绍" class="headerlink" title="MySQL介绍"></a>MySQL介绍</h3><ol><li>关系型数据库(<strong>有行有列</strong>) <strong>SQLite(进程内的db)</strong>  NOSQL(<strong>非关系数据库)键值对</strong>（key-value）:redis leveldb rocksdb 大数据分析列式数据库 Hbase</li><li>大家熟悉的关系型数据库还有SQL Server,Oracle,MySQL,MariaDB,DB2</li><li>MySQL区别于其他关系型数据库最大的一个特点就是<strong>支持插件式的存储引擎</strong>，支持如<strong>InnoDB,MyISAM,Memory</strong>等</li><li>MySQL设计成<strong>C&#x2F;S模型</strong></li><li>MySQL的服务器模型采用的是<strong>I&#x2F;O复用+可伸缩的线程池</strong>，是实现网络服务器的经典模型。用的是<strong>select+线程池。</strong>这里为什么不设计成epoll+线程池，或者更高效的模型，<strong>用select,因为网络I&#x2F;O快，但是MySQL还需要把数据存储到磁盘，磁盘I&#x2F;O速度是比较慢的，所以速度匹配即可，没必要做那么快</strong>。</li></ol><p><img src="/2025/07/25/MYSQLlearning/1.png" alt="1"></p><p><strong>Windows下MySQL安装目录中有一个my.ini文件，可以做一些配置调优。在data文件夹中，每建立一个数据库会有一个文件夹与其对应。</strong></p><p><strong>Linux下mysql的配置文件 &#x2F;etc&#x2F;my.cnf，没有可以自己创建</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在root用户下</span></span><br><span class="line">netstat -tanp <span class="comment">#查看mysql是否启动,这个命令主要显示当前系统的所有 TCP 连接及其状态，并显示对应的进程信息。</span></span><br><span class="line">service mysql start <span class="comment">#启动mysql</span></span><br></pre></td></tr></table></figure><h3 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h3><p><strong>MySQL数据类型定义了数据的大小范围，因此使用时选择合适的类型，不仅会降低表占用的磁盘空间，间接减少了磁盘I&#x2F;O的次数，提高了表的访问效率，而且索引的效率也和数据的类型息息相关。</strong></p><h4 id="整数类型（Integer-Types）"><a href="#整数类型（Integer-Types）" class="headerlink" title="整数类型（Integer Types）"></a><strong>整数类型（Integer Types）</strong></h4><table><thead><tr><th>类型</th><th>大小（字节）</th><th>范围（有符号）</th><th>范围（无符号）</th><th>描述</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1</td><td>-128 到 127</td><td>0 到 255</td><td>很小的整数</td></tr><tr><td><code>SMALLINT</code></td><td>2</td><td>-32,768 到 32,767</td><td>0 到 65,535</td><td>小整数</td></tr><tr><td><code>MEDIUMINT</code></td><td>3</td><td>-8,388,608 到 8,388,607</td><td>0 到 16,777,215</td><td>中等大小的整数</td></tr><tr><td><code>INT</code> 或 <code>INTEGER</code></td><td>4</td><td>-2,147,483,648 到 2,147,483,647</td><td>0 到 4,294,967,295</td><td>常用整数类型</td></tr><tr><td><code>BIGINT</code></td><td>8</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td>0 到 18,446,744,073,709,551,615</td><td>大整数</td></tr></tbody></table><p>可加上 <code>UNSIGNED</code> 修饰符来存储更大的非负整数</p><p>age INT(9)：整型占用内存的大小是固定的，和具体的类型是强相关的。(M)只是代表整数显示的宽度</p><h4 id="浮点与定点类型（Floating-Point-and-Fixed-Point-Types）"><a href="#浮点与定点类型（Floating-Point-and-Fixed-Point-Types）" class="headerlink" title="浮点与定点类型（Floating-Point and Fixed-Point Types）"></a><strong>浮点与定点类型（Floating-Point and Fixed-Point Types）</strong></h4><p><strong>推荐DECIMAL,FLOAT和DOUBLE数据越界不会报错，DECIMAL会报错</strong></p><table><thead><tr><th>类型</th><th>描述</th><th>范围和精度</th></tr></thead><tbody><tr><td><code>FLOAT(M,D)</code></td><td>单精度浮点数</td><td>近似值，4字节，M是总位数，D是小数位数 7位精度</td></tr><tr><td><code>DOUBLE(M,D)</code> 或 <code>REAL(M,D)</code></td><td>双精度浮点数</td><td>近似值，8字节，M是总位数，D是小数位数  15位精度</td></tr><tr><td><code>DECIMAL(M,D)</code> 或 <code>NUMERIC(M,D)</code></td><td>定点数</td><td>精确值，适合存储货币等对精度要求高的场景</td></tr></tbody></table><ul><li><code>M</code>: 精度（总位数），<code>D</code>: 小数位数</li><li><code>DECIMAL</code> 使用字符串进行存储，防止浮点误差</li><li>如果 <code>M</code> 和 <code>D</code> 不指定，MySQL 默认为 <code>DECIMAL(10,0)</code></li></ul><h4 id="字符型类型"><a href="#字符型类型" class="headerlink" title="字符型类型"></a><strong>字符型类型</strong></h4><table><thead><tr><th>类型</th><th>最大长度</th><th>是否定长</th><th>是否可设默认值</th><th>特点说明</th><th>典型用途</th></tr></thead><tbody><tr><td><code>CHAR(M)</code></td><td>最多 255 字符</td><td>✅</td><td>✅</td><td>固定长度，右侧自动补空格</td><td>固定长度：手机号、身份证</td></tr><tr><td><code>VARCHAR(M)</code></td><td>取决于字符集（如 utf8mb4 最多 21844）</td><td>❌</td><td>✅</td><td>变长字符串，节省空间，需额外1-2字节</td><td>姓名、标题、备注</td></tr><tr><td><code>TINYTEXT</code></td><td>255 字节</td><td>❌</td><td>❌</td><td>极短文本，不能设默认值</td><td>简短评论、小段文字</td></tr><tr><td><code>TEXT</code></td><td>64 KB</td><td>❌</td><td>❌</td><td>常用文本类型，不能设默认值</td><td>文章正文、用户简介</td></tr><tr><td><code>MEDIUMTEXT</code></td><td>16 MB</td><td>❌</td><td>❌</td><td>中大型文本</td><td>博文、报告内容</td></tr><tr><td><code>LONGTEXT</code></td><td>4 GB</td><td>❌</td><td>❌</td><td>超大文本</td><td>大文档、日志</td></tr></tbody></table><table><thead><tr><th>类型</th><th>最大长度</th><th>特点说明</th><th>用途举例</th></tr></thead><tbody><tr><td><code>BINARY(M)</code></td><td>最多 255 字节</td><td>类似 <code>CHAR</code>，存储二进制数据，定长</td><td>加密哈希、固定密钥存储</td></tr><tr><td><code>VARBINARY(M)</code></td><td>最多 65535 字节</td><td>类似 <code>VARCHAR</code>，变长二进制字符串</td><td>二进制令牌、签名</td></tr><tr><td><code>TINYBLOB</code></td><td>255 字节</td><td>与 <code>TINYTEXT</code> 类似，但用于二进制数据</td><td>小图标、缩略图</td></tr><tr><td><code>BLOB</code></td><td>64 KB</td><td>与 <code>TEXT</code> 类似，用于二进制内容</td><td>图像、音频、文件</td></tr><tr><td><code>MEDIUMBLOB</code></td><td>16 MB</td><td>中等大小二进制对象</td><td>视频、音频中等资源</td></tr><tr><td><code>LONGBLOB</code></td><td>4 GB</td><td>超大二进制对象</td><td>文件存储、大附件</td></tr></tbody></table><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a><strong>日期和时间类型</strong></h4><table><thead><tr><th>类型</th><th>占用空间</th><th>范围&#x2F;格式</th><th>精度</th><th>用途示例</th></tr></thead><tbody><tr><td><code>DATE</code></td><td>3 字节</td><td><code>1000-01-01</code> 到 <code>9999-12-31</code></td><td>到“日”</td><td>出生日期、订单日期</td></tr><tr><td><code>TIME</code></td><td>3 字节</td><td><code>-838:59:59</code> 到 <code>838:59:59</code></td><td>到“秒”</td><td>持续时间、工时</td></tr><tr><td><code>DATETIME</code></td><td>8 字节</td><td><code>1000-01-01 00:00:00</code> 到 <code>9999-12-31 23:59:59</code></td><td>到“秒”</td><td>记录某一精确时刻</td></tr><tr><td><code>TIMESTAMP</code></td><td>4 字节</td><td><code>1970-01-01 00:00:01</code> UTC 到 <code>2038-01-19 03:14:07</code></td><td>到“秒”</td><td>创建时间、修改时间</td></tr><tr><td><code>YEAR</code></td><td>1 字节</td><td><code>1901</code> 到 <code>2155</code></td><td>到“年”</td><td>出厂年份、学年</td></tr></tbody></table><h4 id="枚举与集合类型（可存储预定义字符串）"><a href="#枚举与集合类型（可存储预定义字符串）" class="headerlink" title="枚举与集合类型（可存储预定义字符串）"></a>枚举与集合类型（可存储预定义字符串）</h4><table><thead><tr><th>类型</th><th>特点说明</th><th>示例用途</th></tr></thead><tbody><tr><td><code>ENUM(...)</code></td><td>从固定字符串列表中选一个值，实际存储为整数索引（1字节）</td><td>性别、状态（如 <code>&#39;男&#39;,&#39;女&#39;</code>、<code>&#39;启用&#39;,&#39;禁用&#39;</code>）</td></tr><tr><td><code>SET(...)</code></td><td>可多选，存储为位图（1~8字节），最多支持 64 个选项</td><td>标签、用户权限、兴趣爱好</td></tr></tbody></table><h3 id="MySQL运算符"><a href="#MySQL运算符" class="headerlink" title="MySQL运算符"></a>MySQL运算符</h3><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法</td><td><code>5 + 3</code></td><td><code>8</code></td></tr><tr><td><code>-</code></td><td>减法</td><td><code>5 - 3</code></td><td><code>2</code></td></tr><tr><td><code>*</code></td><td>乘法</td><td><code>5 * 3</code></td><td><code>15</code></td></tr><tr><td><code>/</code></td><td>除法</td><td><code>5 / 2</code></td><td><code>2.5</code></td></tr><tr><td><code>DIV</code></td><td>整除</td><td><code>5 DIV 2</code></td><td><code>2</code></td></tr><tr><td><code>%</code></td><td>取模（余数）</td><td><code>5 % 2</code> 或 <code>5 MOD 2</code></td><td><code>1</code></td></tr><tr><td><code>MOD</code></td><td>同 <code>%</code></td><td><code>5 MOD 3</code></td><td><code>2</code></td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th>运算符</th><th>名称</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>AND</code></td><td>逻辑与</td><td><code>age &gt; 18 AND gender = &#39;M&#39;</code></td><td>两个条件都为真，结果才为真</td></tr><tr><td><code>OR</code></td><td>逻辑或</td><td><code>score &gt; 90 OR grade = &#39;A&#39;</code></td><td>至少一个条件为真，结果为真</td></tr><tr><td><code>NOT</code></td><td>逻辑非</td><td><code>NOT (age &lt; 18)</code></td><td>取反，原来为真变为假，反之亦然</td></tr><tr><td><code>XOR</code></td><td>逻辑异或</td><td><code>TRUE XOR FALSE</code></td><td>仅当两个值不同，结果才为真</td></tr><tr><td><code>!</code></td><td>逻辑非（简写）</td><td><code>!is_deleted</code></td><td>等价于 <code>NOT is_deleted</code></td></tr><tr><td><code>&amp;&amp;</code></td><td>与（MySQL兼容）</td><td><code>a &gt; 5 &amp;&amp; b &lt; 10</code></td><td>等价于 <code>AND</code></td></tr><tr><td>&#96;</td><td></td><td>&#96;</td><td>逻辑或</td></tr></tbody></table><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>=</code></td><td>等于</td><td><code>age = 18</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>!=</code> 或 <code>&lt;&gt;</code></td><td>不等于</td><td><code>name != &#39;Tom&#39;</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code>score &gt; 60</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>&lt;</code></td><td>小于</td><td><code>score &lt; 60</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>score &gt;= 90</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td><code>score &lt;= 100</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>&lt;=&gt;</code></td><td>安全等于（支持 NULL）</td><td><code>a &lt;=&gt; NULL</code></td><td><code>true</code> if both NULL</td></tr><tr><td><code>IS NULL</code></td><td>判断是否为 NULL</td><td><code>birthday IS NULL</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>IS NOT NULL</code></td><td>非 NULL</td><td><code>email IS NOT NULL</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>BETWEEN ... AND ...</code></td><td>在区间内</td><td><code>score BETWEEN 60 AND 90</code></td><td>含头尾：<code>60 ≤ score ≤ 90</code></td></tr><tr><td><code>NOT BETWEEN ... AND ...</code></td><td>不在区间</td><td><code>age NOT BETWEEN 18 AND 25</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>IN (...)</code></td><td>属于集合</td><td><code>city IN (&#39;Beijing&#39;, &#39;Shanghai&#39;)</code></td><td>是否存在于集合中</td></tr><tr><td><code>NOT IN (...)</code></td><td>不属于集合</td><td><code>status NOT IN (&#39;A&#39;, &#39;B&#39;)</code></td><td><code>true</code> 或 <code>false</code></td></tr><tr><td><code>LIKE</code></td><td>模糊匹配（单行）</td><td><code>name LIKE &#39;J%&#39;</code></td><td><code>J</code>开头的字符串</td></tr><tr><td><code>NOT LIKE</code></td><td>非匹配</td><td><code>email NOT LIKE &#39;%.com&#39;</code></td><td>不以<code>.com</code>结尾</td></tr><tr><td><code>REGEXP</code> 或 <code>RLIKE</code></td><td>正则匹配</td><td><code>name REGEXP &#39;^A.*&#39;</code></td><td>匹配正则表达式</td></tr></tbody></table><h3 id="MySQL常用函数"><a href="#MySQL常用函数" class="headerlink" title="MySQL常用函数"></a>MySQL常用函数</h3><table><thead><tr><th>分类</th><th>函数名</th><th>功能描述</th><th>示例</th><th>示例结果</th></tr></thead><tbody><tr><td>字符串函数</td><td><code>CONCAT(str1, str2, ...)</code></td><td>字符串连接</td><td><code>CONCAT(&#39;Hello&#39;, &#39;World&#39;)</code></td><td><code>&#39;HelloWorld&#39;</code></td></tr><tr><td></td><td><code>LENGTH(str)</code></td><td>字节长度（utf8中一个汉字3字节）</td><td><code>LENGTH(&#39;abc&#39;)</code></td><td><code>3</code></td></tr><tr><td></td><td><code>CHAR_LENGTH(str)</code></td><td>字符长度（汉字算1个字符）</td><td><code>CHAR_LENGTH(&#39;你好&#39;)</code></td><td><code>2</code></td></tr><tr><td></td><td><code>UPPER(str)</code></td><td>转大写</td><td><code>UPPER(&#39;abc&#39;)</code></td><td><code>&#39;ABC&#39;</code></td></tr><tr><td></td><td><code>LOWER(str)</code></td><td>转小写</td><td><code>LOWER(&#39;ABC&#39;)</code></td><td><code>&#39;abc&#39;</code></td></tr><tr><td></td><td><code>REPLACE(str, from_str, to_str)</code></td><td>字符串替换</td><td><code>REPLACE(&#39;abcabc&#39;, &#39;a&#39;, &#39;x&#39;)</code></td><td><code>&#39;xbcxbc&#39;</code></td></tr><tr><td></td><td><code>SUBSTRING(str, pos, len)</code></td><td>截取字符串</td><td><code>SUBSTRING(&#39;abcdef&#39;, 2, 3)</code></td><td><code>&#39;bcd&#39;</code></td></tr><tr><td></td><td><code>TRIM(str)</code></td><td>去除字符串首尾空格</td><td><code>TRIM(&#39;  abc &#39;)</code></td><td><code>&#39;abc&#39;</code></td></tr><tr><td>数值函数</td><td><code>ABS(n)</code></td><td>绝对值</td><td><code>ABS(-10)</code></td><td><code>10</code></td></tr><tr><td></td><td><code>ROUND(n, d)</code></td><td>四舍五入到小数点后 d 位</td><td><code>ROUND(3.14159, 2)</code></td><td><code>3.14</code></td></tr><tr><td></td><td><code>CEIL(n)</code></td><td>向上取整</td><td><code>CEIL(2.3)</code></td><td><code>3</code></td></tr><tr><td></td><td><code>FLOOR(n)</code></td><td>向下取整</td><td><code>FLOOR(2.7)</code></td><td><code>2</code></td></tr><tr><td></td><td><code>MOD(a, b)</code></td><td>取模</td><td><code>MOD(10, 3)</code></td><td><code>1</code></td></tr><tr><td></td><td><code>RAND()</code></td><td>生成0到1之间随机数</td><td><code>RAND()</code></td><td><code>0.123456789</code>（示例）</td></tr><tr><td></td><td><code>TRUNCATE(n, d)</code></td><td>截断数字到小数点后 d 位</td><td><code>TRUNCATE(3.4567, 2)</code></td><td><code>3.45</code></td></tr><tr><td>日期时间函数</td><td><code>NOW()</code></td><td>当前日期时间</td><td><code>NOW()</code></td><td><code>&#39;2025-07-25 20:30:00&#39;</code></td></tr><tr><td></td><td><code>CURDATE()</code></td><td>当前日期</td><td><code>CURDATE()</code></td><td><code>&#39;2025-07-25&#39;</code></td></tr><tr><td></td><td><code>CURTIME()</code></td><td>当前时间</td><td><code>CURTIME()</code></td><td><code>&#39;20:30:00&#39;</code></td></tr><tr><td></td><td><code>DATE_FORMAT(date, fmt)</code></td><td>格式化日期</td><td><code>DATE_FORMAT(NOW(), &#39;%Y-%m-%d&#39;)</code></td><td><code>&#39;2025-07-25&#39;</code></td></tr><tr><td></td><td><code>DATEDIFF(a, b)</code></td><td>计算日期差（a - b）天数</td><td><code>DATEDIFF(&#39;2025-08-01&#39;, &#39;2025-07-25&#39;)</code></td><td><code>7</code></td></tr><tr><td></td><td><code>TIMESTAMPDIFF(unit, a, b)</code></td><td>计算两时间差，单位可选</td><td><code>TIMESTAMPDIFF(DAY, &#39;2025-07-25&#39;, &#39;2025-08-01&#39;)</code></td><td><code>7</code></td></tr><tr><td></td><td><code>ADDDATE(date, n)</code></td><td>日期加n天</td><td><code>ADDDATE(&#39;2025-07-25&#39;, 5)</code></td><td><code>&#39;2025-07-30&#39;</code></td></tr><tr><td></td><td><code>SUBDATE(date, n)</code></td><td>日期减n天</td><td><code>SUBDATE(&#39;2025-07-25&#39;, 5)</code></td><td><code>&#39;2025-07-20&#39;</code></td></tr><tr><td>聚合函数</td><td><code>COUNT(*)</code></td><td>统计行数</td><td><code>SELECT COUNT(*) FROM users</code></td><td><code>100</code></td></tr><tr><td></td><td><code>SUM(col)</code></td><td>求和</td><td><code>SUM(price)</code></td><td><code>12345.67</code></td></tr><tr><td></td><td><code>AVG(col)</code></td><td>平均值</td><td><code>AVG(score)</code></td><td><code>87.5</code></td></tr><tr><td></td><td><code>MAX(col)</code></td><td>最大值</td><td><code>MAX(age)</code></td><td><code>60</code></td></tr><tr><td></td><td><code>MIN(col)</code></td><td>最小值</td><td><code>MIN(created_at)</code></td><td><code>&#39;2020-01-01&#39;</code></td></tr><tr><td>条件判断函数</td><td><code>IF(expr, a, b)</code></td><td>条件判断，类似三元运算符</td><td><code>IF(score &gt; 60, &#39;及格&#39;, &#39;不及格&#39;)</code></td><td><code>&#39;及格&#39;</code></td></tr><tr><td></td><td><code>IFNULL(expr, val)</code></td><td>如果 expr 为 NULL，返回 val</td><td><code>IFNULL(name, &#39;未知&#39;)</code></td><td><code>&#39;未知&#39;</code></td></tr><tr><td></td><td><code>NULLIF(a, b)</code></td><td>若 a &#x3D; b，则返回 NULL，否则 a</td><td><code>NULLIF(1,1)</code> → <code>NULL</code></td><td><code>NULL</code></td></tr><tr><td></td><td><code>CASE WHEN ... THEN ... ELSE ... END</code></td><td>多条件判断</td><td>参见下方示例</td><td></td></tr></tbody></table><h3 id="MySQL完整性约束"><a href="#MySQL完整性约束" class="headerlink" title="MySQL完整性约束"></a>MySQL完整性约束</h3><h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><p><strong>primary key</strong>(<strong>唯一且不为空</strong>)</p><h4 id="自增键约束"><a href="#自增键约束" class="headerlink" title="自增键约束"></a>自增键约束</h4><p><strong>auto_increment(整型自增)</strong></p><h4 id="唯一键约束"><a href="#唯一键约束" class="headerlink" title="唯一键约束"></a>唯一键约束</h4><p><strong>unique(不可以重复但是可以为空)</strong></p><h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><p><strong>not null</strong></p><h4 id="默认值约束"><a href="#默认值约束" class="headerlink" title="默认值约束"></a>默认值约束</h4><p><strong>default</strong></p><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p><strong>foreign key</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line">id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;用户的主键id&#x27;,</span><br><span class="line">nickname varchar(50) UNIQUE NOT NULL COMMENT &#x27;用户的昵称&#x27;,</span><br><span class="line">age TINYINT UNSIGNED NOT NULL DEFAULT 18,</span><br><span class="line">sex ENUM(&#x27;male&#x27;,&#x27;female&#x27;));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+----------+-----------------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type                  | Null | Key | Default | Extra          |</span><br><span class="line">+----------+-----------------------+------+-----+---------+----------------+</span><br><span class="line">| id       | int unsigned          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| nickname | varchar(50)           | NO   | UNI | NULL    |                |</span><br><span class="line">| age      | tinyint unsigned      | NO   |     | 18      |                |</span><br><span class="line">| sex      | enum(&#x27;male&#x27;,&#x27;female&#x27;) | YES  |     | NULL    |                |</span><br><span class="line">+----------+-----------------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><h3 id="关系型数据库表设计"><a href="#关系型数据库表设计" class="headerlink" title="关系型数据库表设计"></a>关系型数据库表设计</h3><p>好的设计减少数据冗余。</p><h4 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h4><p><strong>在子表中增加一列，关联父表的主键</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用户User表：父表</span><br><span class="line">uid name agesex</span><br><span class="line">1000zhang20M</span><br><span class="line">1020liu21 W</span><br><span class="line">2010 Wang22M</span><br><span class="line">身份信息Info 子表</span><br><span class="line">uid cardidaddrinfo</span><br><span class="line">1020    112233aaa</span><br><span class="line">2010    334455bbb</span><br><span class="line">1000556677ccc</span><br></pre></td></tr></table></figure><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p><strong>在子表中增加一列，关联父表的主键</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">电商系统：</span><br><span class="line">用户User,商品Product,订单Order</span><br><span class="line">用户和商品：没有关系</span><br><span class="line">用户和订单：一对多的关系 User为父表 Order为子表 在子表中增加一列，关联父表的主键</span><br><span class="line">商品和订单：多对多的关系</span><br><span class="line">User: </span><br><span class="line">uid name agesex</span><br><span class="line">1000zhang20M</span><br><span class="line">1020liu21 W</span><br><span class="line">2010 Wang22M</span><br><span class="line">Product:</span><br><span class="line">pidpnamepriceamount</span><br><span class="line">1手机600100</span><br><span class="line">2笔记本200050</span><br><span class="line">3电池10200</span><br><span class="line">Order:</span><br><span class="line">orderiduidpidnumbermoneytotalpriceaddrinfo</span><br><span class="line">O10001000116004640海定区</span><br><span class="line">O100010002240004640海定区</span><br><span class="line">O1000100035404640海定区</span><br><span class="line">O200020102120002000平谷区</span><br></pre></td></tr></table></figure><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p><strong>增加一个中间表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">电商系统：</span><br><span class="line">用户User,商品Product,订单Order</span><br><span class="line">用户和商品：没有关系</span><br><span class="line">用户和订单：一对多的关系 User为父表 Order为子表 在子表中增加一列，关联父表的主键</span><br><span class="line">商品和订单：多对多的关系 </span><br><span class="line">User: </span><br><span class="line">uid name agesex</span><br><span class="line">1000zhang20M</span><br><span class="line">1020liu21 W</span><br><span class="line">2010 Wang22M</span><br><span class="line">Product:</span><br><span class="line">pidpnamepriceamount</span><br><span class="line">1手机600100</span><br><span class="line">2笔记本200050</span><br><span class="line">3电池10200</span><br><span class="line">Order:</span><br><span class="line">orderiduidpidnumbermoneytotalpriceaddrinfo</span><br><span class="line">O10001000116004640海定区</span><br><span class="line">O100010002240004640海定区</span><br><span class="line">O1000100035404640海定区</span><br><span class="line">O200020102120002000平谷区</span><br><span class="line">商品和订单：多对多的关系 </span><br><span class="line">发现Order表太过冗余了，所以增加一个中间表</span><br><span class="line">订单内容表</span><br><span class="line">OrderList:</span><br><span class="line">orderidpidnumbermoney</span><br><span class="line">O100011600</span><br><span class="line">O1000224000</span><br><span class="line">O10003440</span><br><span class="line">O2000  212000</span><br><span class="line">这里中间表可以orderid,pid为联合主键。</span><br><span class="line">所以Order表改变</span><br><span class="line">Order:</span><br><span class="line">orderiduidtotalpriceaddrinfo</span><br><span class="line">O100010004640海定区</span><br><span class="line">O200020102000平谷区</span><br></pre></td></tr></table></figure><h3 id="关系型数据库范式"><a href="#关系型数据库范式" class="headerlink" title="关系型数据库范式"></a>关系型数据库范式</h3><p><strong>应用数据库范式可以带来许多好处，最重要的到处归结为三点：</strong></p><ol><li><strong>减少数据冗余(这是最主要的好处，其他好处都是由此而附带的)</strong></li><li><strong>消除异常(插入异常，更新异常，删除异常)</strong></li><li><strong>让数据组织的更加和谐</strong></li></ol><p><strong>但是数据库范式绝对不是越高越好，范式越高，意味着表越多，多表联合查询的机率就越大，SQL的效率就越低。</strong></p><h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p><strong>每一列保持原子特性</strong></p><p>列都是基本数据项，不能够再进行分割，否则设计成一对多的实体关系。例如表中的地址字段，可以再细分为省，市，区等不可再分割的字段。<strong>不符合第一范式不能称作关系型数据库。</strong></p><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p><strong>属性完全依赖于主键，主要针对联合主键</strong></p><p>非主属性完全依赖于主关键字，如果不是完全依赖主键，应该拆分成新的实体，设计成一对多的实体关系。</p><p>例如：选课关系表为SelectCourse(学号，姓名，年龄，课程名称，成绩，学分),(学号，课程名称)是联合主键，但是学分字段只和课程名称有关，和学号无关，相当于只依赖联合主键的其中一个字段，不符合第二范式。姓名，年龄不符合第二范式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">所以这里需要拆分</span><br><span class="line">学生表</span><br><span class="line">学号姓名年龄</span><br><span class="line"></span><br><span class="line">课程表</span><br><span class="line">课程id课程名称学分</span><br><span class="line"></span><br><span class="line">中间表：选课情况</span><br><span class="line">学号 课程id 成绩</span><br></pre></td></tr></table></figure><h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p><strong>属性不依赖于其他非主属性</strong></p><p>示例：学生关系表为Student(学号，姓名，年龄，所在学院，学院地点，学院电话)，学号是主键，但是学院电话只依赖于所在学院，并不依赖于主键学号，所以不符合第三范式，应该把学院专门设计成一张表，学生表和学院表，两个是一对多的关系。</p><p><strong>一般关系型数据库满足第三范式就可以了。</strong></p><h4 id="BC范式（BCNF）"><a href="#BC范式（BCNF）" class="headerlink" title="BC范式（BCNF）"></a>BC范式（BCNF）</h4><p><strong>每个表中只有一个候选键</strong></p><h4 id="第四范式（4NF）"><a href="#第四范式（4NF）" class="headerlink" title="第四范式（4NF）"></a>第四范式（4NF）</h4><p><strong>消除表中的多值依赖</strong></p><h2 id="MySQL核心SQL"><a href="#MySQL核心SQL" class="headerlink" title="MySQL核心SQL"></a>MySQL核心SQL</h2><h3 id="结构化查询语句SQL"><a href="#结构化查询语句SQL" class="headerlink" title="结构化查询语句SQL"></a>结构化查询语句SQL</h3><p>SQL是结构化查询语言，它是关系型数据库的通用语言。</p><p>SQL主要可以划分三个类别：</p><ol><li>DDL语句：数据定义语言，这些语句定义了不同的数据库，表，列，索引等数据库对象的定义。通常的语句关键字主要包括<strong>create,drop,alter</strong>等。</li><li>DML语句：数据操纵语句，用于添加，删除，更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括<strong>insert,delete,update和select</strong>等。</li><li>DCL语句：数据控制语句，用于控制不同的许可和访问级别的语句。这些语句定义了数据库，表，字段，用户的访问权限和安全级别。主要的语句关键字包括<strong>grant,revoke</strong>等。</li></ol><h3 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询数据库</span><br><span class="line">show databases;</span><br><span class="line">#创建数据库</span><br><span class="line">create database ChatDB;</span><br><span class="line">#删除数据库</span><br><span class="line">drop database ChatDB;</span><br><span class="line">#选择数据库</span><br><span class="line">use ChatDB;</span><br></pre></td></tr></table></figure><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p>查看表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><p>创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">    id int unsigned primary key not null auto_increment,</span><br><span class="line">    name varchar(50) unique not null,</span><br><span class="line">    age tinyint not null,</span><br><span class="line">    sex enum(&#x27;M&#x27;,&#x27;W&#x27;) not null)engine=INNODB default charset=utf8;</span><br></pre></td></tr></table></figure><p>查看表结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc user;</span><br></pre></td></tr></table></figure><p>查看建表sql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table user\G</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table user;</span><br></pre></td></tr></table></figure><h3 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h3><h4 id="insert增加"><a href="#insert增加" class="headerlink" title="insert增加"></a>insert增加</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into user(nickname,name,age,sex) values(&#x27;fixbug&#x27;,&#x27;zhangsan&#x27;,22,&#x27;M&#x27;);</span><br><span class="line">insert into user(nickname,name,age,sex) values(&#x27;666&#x27;,&#x27;li si&#x27;,21,&#x27;W&#x27;),(&#x27;888&#x27;,&#x27;gao yang&#x27;,20,&#x27;M&#x27;);</span><br></pre></td></tr></table></figure><p><strong>这里有个问题：就是一次全插入和多次插入最后结果都是相同的，那么他们有什么区别。</strong></p><p><img src="/2025/07/25/MYSQLlearning/2.png" alt="2"></p><p><strong>由上图，多次插入会导致tcp连接次数增多，消耗资源。</strong></p><h4 id="update修改"><a href="#update修改" class="headerlink" title="update修改"></a>update修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update user set age=23 where name=&#x27;zhangsan&#x27;;</span><br><span class="line">update user set age=age+1 where id=3;</span><br></pre></td></tr></table></figure><h4 id="delete删除"><a href="#delete删除" class="headerlink" title="delete删除"></a>delete删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from user where age=23;</span><br><span class="line">delete from user where age between 20 and 22;</span><br><span class="line">delete from user;</span><br></pre></td></tr></table></figure><h4 id="select查询"><a href="#select查询" class="headerlink" title="select查询"></a>select查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br><span class="line">select id,nickname,name,age,sex from user;</span><br><span class="line">select id,name from user;</span><br><span class="line">select id,nickname,name,age,sex from user where sex=&#x27;M&#x27; and age&gt;=20 and age&lt;=25;</span><br><span class="line">select id,nickname,name,age,sex from user where sex=&#x27;M&#x27; and age between 20 and 25;</span><br><span class="line">select id,nickname,name,age,sex from user where sex=&#x27;W&#x27; or age&gt;=22;</span><br></pre></td></tr></table></figure><p><strong>去重distinct</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct name from user;</span><br></pre></td></tr></table></figure><p><strong>空值查询</strong></p><p><strong>is [not] null</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name is null;</span><br></pre></td></tr></table></figure><p><strong>union合并查询</strong></p><p><strong>把两个结果合并起来，union默认去重，不用修饰distinct，all表示显示所有重复值。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select country from websites union all select country from apps order by country;</span><br></pre></td></tr></table></figure><p><strong>带in子查询</strong></p><p><strong>[不]包含这些元素</strong></p><p><strong>[not] in(元素1，元素2，…，元素3)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id in(10,20,30,40,50);</span><br><span class="line">select * from user where id not in(10,20,30,40,50);</span><br><span class="line">select * from user where id in(select stu_id from grade where average&gt;=60.0);</span><br></pre></td></tr></table></figure><p><strong>分页查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,nickname,name,age,sex from user limit 10;</span><br><span class="line">select id,nickname,name,age,sex from user limit 2000,10#偏移2000，再取10个</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from user where name=&#x27;zhangsan&#x27;;</span><br><span class="line">explain:查看SQL语句的执行计划(但是MySQL的自身优化检测不到，可能体现的数据不对)，主键会注册主键索引，唯一键会注册索引，通过索引查询，直接查到（查一次），不需要遍历去查。如果通过没有注册索引的字段去查询的话，就可能变成整表查询（查很多次）。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">select id,nickname,name,age,sex from user limit 10;#没有设计limit 10，它是查完整表返回结果，设计了limit 10 查到10个符合条件的数据就返回。</span><br><span class="line">所以这就可以利用这个特性</span><br><span class="line">在通过一些非注册索引的字段查找时，可以通过limit,提高查询速度。</span><br><span class="line">select * from t_user where email =&#x27;1000001@fixbug.com&#x27;;</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| id      | email              | password |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| 1000001 | 1000001@fixbug.com | 1000001  |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">1 row in set (0.66 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user where email =&#x27;1000001@fixbug.com&#x27; limit 1;</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| id      | email              | password |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| 1000001 | 1000001@fixbug.com | 1000001  |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">1 row in set (0.33 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">分页查询优化</span><br><span class="line">select * from t_user limit 1000000,20;</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| id      | email              | password |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| 1000001 | 1000001@fixbug.com | 1000001  |</span><br><span class="line">| 1000002 | 1000002@fixbug.com | 1000002  |</span><br><span class="line">| 1000003 | 1000003@fixbug.com | 1000003  |</span><br><span class="line">| 1000004 | 1000004@fixbug.com | 1000004  |</span><br><span class="line">| 1000005 | 1000005@fixbug.com | 1000005  |</span><br><span class="line">| 1000006 | 1000006@fixbug.com | 1000006  |</span><br><span class="line">| 1000007 | 1000007@fixbug.com | 1000007  |</span><br><span class="line">| 1000008 | 1000008@fixbug.com | 1000008  |</span><br><span class="line">| 1000009 | 1000009@fixbug.com | 1000009  |</span><br><span class="line">| 1000010 | 1000010@fixbug.com | 1000010  |</span><br><span class="line">| 1000011 | 1000011@fixbug.com | 1000011  |</span><br><span class="line">| 1000012 | 1000012@fixbug.com | 1000012  |</span><br><span class="line">| 1000013 | 1000013@fixbug.com | 1000013  |</span><br><span class="line">| 1000014 | 1000014@fixbug.com | 1000014  |</span><br><span class="line">| 1000015 | 1000015@fixbug.com | 1000015  |</span><br><span class="line">| 1000016 | 1000016@fixbug.com | 1000016  |</span><br><span class="line">| 1000017 | 1000017@fixbug.com | 1000017  |</span><br><span class="line">| 1000018 | 1000018@fixbug.com | 1000018  |</span><br><span class="line">| 1000019 | 1000019@fixbug.com | 1000019  |</span><br><span class="line">| 1000020 | 1000020@fixbug.com | 1000020  |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">20 rows in set (0.27 sec)</span><br><span class="line">select * from t_user where id&gt;1000000 limit 20;</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| id      | email              | password |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| 1000001 | 1000001@fixbug.com | 1000001  |</span><br><span class="line">| 1000002 | 1000002@fixbug.com | 1000002  |</span><br><span class="line">| 1000003 | 1000003@fixbug.com | 1000003  |</span><br><span class="line">| 1000004 | 1000004@fixbug.com | 1000004  |</span><br><span class="line">| 1000005 | 1000005@fixbug.com | 1000005  |</span><br><span class="line">| 1000006 | 1000006@fixbug.com | 1000006  |</span><br><span class="line">| 1000007 | 1000007@fixbug.com | 1000007  |</span><br><span class="line">| 1000008 | 1000008@fixbug.com | 1000008  |</span><br><span class="line">| 1000009 | 1000009@fixbug.com | 1000009  |</span><br><span class="line">| 1000010 | 1000010@fixbug.com | 1000010  |</span><br><span class="line">| 1000011 | 1000011@fixbug.com | 1000011  |</span><br><span class="line">| 1000012 | 1000012@fixbug.com | 1000012  |</span><br><span class="line">| 1000013 | 1000013@fixbug.com | 1000013  |</span><br><span class="line">| 1000014 | 1000014@fixbug.com | 1000014  |</span><br><span class="line">| 1000015 | 1000015@fixbug.com | 1000015  |</span><br><span class="line">| 1000016 | 1000016@fixbug.com | 1000016  |</span><br><span class="line">| 1000017 | 1000017@fixbug.com | 1000017  |</span><br><span class="line">| 1000018 | 1000018@fixbug.com | 1000018  |</span><br><span class="line">| 1000019 | 1000019@fixbug.com | 1000019  |</span><br><span class="line">| 1000020 | 1000020@fixbug.com | 1000020  |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">20 rows in set (0.00 sec)</span><br><span class="line">可以看出明显的效率不同</span><br><span class="line">select * from t_user limit 1000000,20;通过limit偏移，是会扫表的，所以耗费效率，所以我们要通过有索引的字段来约束条件，他就不会扫前面的，因为索引。这样效率也提高了</span><br><span class="line">select * from t_user where id&gt;1000000 limit 20;id&gt;的取值一般为上一页最后一条数据的id值</span><br></pre></td></tr></table></figure><p><strong>排序order by</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id,nickname,name,age,sex from user where sex=&#x27;M&#x27; and age&gt;=20 and age&lt;=25 order by age asc;(默认为升序)</span><br><span class="line">select id,nickname,name,age,sex from user where sex=&#x27;M&#x27; and age&gt;=20 and age&lt;=25 order by age desc;(降序)</span><br><span class="line">select id,nickname,name,age,sex from user where sex=&#x27;M&#x27; and age&gt;=20 and age&lt;=25 order by name,age asc;(先按name升序，当name相同时，再按age升序)</span><br></pre></td></tr></table></figure><p><strong>分组group by</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select sex from user group by sex;</span><br><span class="line">select count(id) as number,sex from user group by sex;</span><br><span class="line">select count(id),age from user group by age having age&gt;20;</span><br><span class="line">select age,sex,count(*) from user group by age,sex;</span><br></pre></td></tr></table></figure><p><strong>group by后面再筛选就不能用where,要使用having。</strong></p><p><strong>在使用 ORDER BY 和 GROUP BY 时，建议对相关字段建立索引。</strong></p><p><strong>如果排序或分组字段没有索引，MySQL 在执行过程中通常会采用 filesort 或创建临时表，这会导致性能下降。通过 EXPLAIN 分析语句时，可以在 Extra 字段看到 Using filesort，这意味着：</strong></p><ul><li><strong>MySQL 首先会读取满足条件的数据；</strong></li><li><strong>将其加载到内存或临时表中；</strong></li><li><strong>然后在内存或磁盘上进行排序；</strong></li><li><strong>最终返回排序后的结果。</strong></li></ul><p><strong>由于这涉及额外的 CPU 和磁盘 I&#x2F;O 操作，效率会显著降低，尤其是在数据量较大时。因此，在 ORDER BY 或 GROUP BY 中应尽量使用已经建立索引的字段，以提升查询性能。</strong></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p><img src="/2025/07/25/MYSQLlearning/3.png" alt="3"></p><h4 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#on a.uid=c.uid 区分大表和小表，按照（where过滤后）数据量来区分，小表永远是整表扫描，然后去大表搜索。所以大表建索引才是最有效的</span><br><span class="line">#从student小表中取出所有的a.uid，然后拿着这些uid去exame大表搜素。</span><br><span class="line">#对于inner join内连接，过滤条件写在where的后面和on连接条件里面(会优化成where去过滤)，效果一样的。</span><br><span class="line">select a.uid,a.name,a.age,a.sex,c.score from student a </span><br><span class="line">inner join exame c </span><br><span class="line">on a.uid=c.uid </span><br><span class="line">where c.uid=1 and c.cid=2;</span><br><span class="line"></span><br><span class="line">select a.uid,a.name,a.age,a.sex,b.cid,b.cname,b.credit,c.score from exame c</span><br><span class="line">inner join student a on c.uid=a.uid</span><br><span class="line">inner join course b on c.cid=b.cid</span><br><span class="line">where c.uid=1 and c.cid=2;</span><br></pre></td></tr></table></figure><p><strong>内连接查询解决单张表的limit分页偏移量的消耗，这个问题可以采用有索引的字段来约束条件来使分页偏移量的消耗消失。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where id&gt;1000000 limit 20;</span><br></pre></td></tr></table></figure><p><strong>可是如果我们不知道这个id的值要取多少，偏移量必须写。又该如何提升效率。可以利用临时表存储所需信息的id，再通过这张表和原表inner join进而查出更多的信息。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">select id,email,password from t_user limit 1500000,10;</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| id      | email              | password |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| 1500001 | 1500001@fixbug.com | 1500001  |</span><br><span class="line">| 1500002 | 1500002@fixbug.com | 1500002  |</span><br><span class="line">| 1500003 | 1500003@fixbug.com | 1500003  |</span><br><span class="line">| 1500004 | 1500004@fixbug.com | 1500004  |</span><br><span class="line">| 1500005 | 1500005@fixbug.com | 1500005  |</span><br><span class="line">| 1500006 | 1500006@fixbug.com | 1500006  |</span><br><span class="line">| 1500007 | 1500007@fixbug.com | 1500007  |</span><br><span class="line">| 1500008 | 1500008@fixbug.com | 1500008  |</span><br><span class="line">| 1500009 | 1500009@fixbug.com | 1500009  |</span><br><span class="line">| 1500010 | 1500010@fixbug.com | 1500010  |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">10 rows in set (0.71 sec)</span><br><span class="line">这是正常查的</span><br><span class="line">select id from t_user limit 1500000,10;</span><br><span class="line">+---------+</span><br><span class="line">| id      |</span><br><span class="line">+---------+</span><br><span class="line">| 1500001 |</span><br><span class="line">| 1500002 |</span><br><span class="line">| 1500003 |</span><br><span class="line">| 1500004 |</span><br><span class="line">| 1500005 |</span><br><span class="line">| 1500006 |</span><br><span class="line">| 1500007 |</span><br><span class="line">| 1500008 |</span><br><span class="line">| 1500009 |</span><br><span class="line">| 1500010 |</span><br><span class="line">+---------+</span><br><span class="line">10 rows in set (0.20 sec)</span><br><span class="line">#我们发现查单个字段效率会提高</span><br><span class="line">#所以我们建立临时表（小表）存储带索引的字段，再通过inner join查出相同的结果</span><br><span class="line">select a.id,a.email,a.password from t_user a inner join (select id from t_user limit 1500000,10) b on a.id=b.id;</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| id      | email              | password |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">| 1500001 | 1500001@fixbug.com | 1500001  |</span><br><span class="line">| 1500002 | 1500002@fixbug.com | 1500002  |</span><br><span class="line">| 1500003 | 1500003@fixbug.com | 1500003  |</span><br><span class="line">| 1500004 | 1500004@fixbug.com | 1500004  |</span><br><span class="line">| 1500005 | 1500005@fixbug.com | 1500005  |</span><br><span class="line">| 1500006 | 1500006@fixbug.com | 1500006  |</span><br><span class="line">| 1500007 | 1500007@fixbug.com | 1500007  |</span><br><span class="line">| 1500008 | 1500008@fixbug.com | 1500008  |</span><br><span class="line">| 1500009 | 1500009@fixbug.com | 1500009  |</span><br><span class="line">| 1500010 | 1500010@fixbug.com | 1500010  |</span><br><span class="line">+---------+--------------------+----------+</span><br><span class="line">10 rows in set (0.18 sec)</span><br><span class="line">#肉眼可见的效率提高了。</span><br></pre></td></tr></table></figure><h4 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h4><p><strong>左连接查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#把left这边的表所有的数据显示出来，在右表中不存在相应数据，则显示NULL，这里就不存在大小表的区分了，左表整表扫描。</span><br><span class="line">select a.* from User a left join orderlist b on a.uid=b.uid where a.orderid is null;</span><br></pre></td></tr></table></figure><p><strong>右连接查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#把right这边的表所有的数据显示出来，在左表中不存在相应数据，则显示NULL，这里就不存在大小表的区分了，右表整表扫描。</span><br><span class="line">select a.* from User a right join orderlist b on a.uid=b.uid where b.orderid is null;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#外连接经常用于查找某个用户没有，不存在</span><br><span class="line">#查找没有考试的学生</span><br><span class="line">select * from student where uid not in (select distinct uid from exame);</span><br><span class="line">#select distinct uid from exame 会产生一张中间表存储结果供外面的sql来查询</span><br><span class="line">#not in对于索引的命中并不高</span><br><span class="line">#可以看出用上述方法效率不是很高</span><br><span class="line">select a.* from student a left join exame b on a.uid=b.uid where b.cid is null;</span><br><span class="line">#这样也可以实现效果</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select a.* from student a left join exame b on a.uid=b.uid where b.cid=3;</span><br><span class="line">select a.* from student a inner join exame b on a.uid=b.uid where b.cid=3;</span><br><span class="line">#上述两句效果是一样的，为什么呢，这时候我们用explain查看左连接，先查b表，再查a表，这就和左连接的查表顺序不符，和内连接相符。</span><br><span class="line">#原因在于where筛选数据后b为小表，所以又成了内连接了。所以在外连接查找时，where不要跟具体的筛选，放在on后，where后跟判断null.</span><br><span class="line">select a.* from student a left join exame b on a.uid=b.uid and b.cid=3 where b.cid is null;</span><br><span class="line">#带有一定条件的查询某个用户没有做什么要像上述写的。</span><br></pre></td></tr></table></figure><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一张表，MySQL一般如何存储</span><br><span class="line">表的结构，数据，索引</span><br><span class="line">存储引擎直接影响上面内容的存储方式</span><br></pre></td></tr></table></figure><p><strong>MyISAM不支持事务，也不支持外键，索引采用非聚集索引，其优势是访问的速度快，对事务完整性没有要求，以select,insert为主的应用基本上都可以使用这个引擎来创建表。MyISAM的表在磁盘上存储三个文件，其文件名都和表名相同，扩展名分别是：</strong></p><p><strong>.frm(存储表定义)</strong></p><p><strong>.MYD(MYData，存储数据)</strong></p><p><strong>.MYI(MYIndex，存储索引)</strong></p><p><strong>InnoDB存储引擎提供了具有提交，回滚和崩溃恢复能力的事务安全，支持自动增长列，外键等功能，索引采用聚集索引，索引和数据存储在同一个文件，所以InnoDB的表在磁盘上有两个文件，其文件名都和表名相同，扩展名分别是：</strong></p><p><strong>.frm(存储表定义)</strong></p><p><strong>.ibd(存储数据和索引)</strong></p><p><strong>MEMORY存储引擎使用存在内存中的内容创建表。每个MEMORY表实际只对应一个磁盘文件，格式是.frm(表结构定义)。MEMORY类型的表访问非常快，因为它的数据是放在内存中的，并且默认使用HASH索引（不适合做范围查询），但是一旦服务关闭，表中的数据就会丢失掉。</strong></p><h3 id="各存储引擎区别"><a href="#各存储引擎区别" class="headerlink" title="各存储引擎区别"></a>各存储引擎区别</h3><h3 id="MySQL-存储引擎对比"><a href="#MySQL-存储引擎对比" class="headerlink" title="MySQL 存储引擎对比"></a>MySQL 存储引擎对比</h3><table><thead><tr><th>特性&#x2F;存储引擎</th><th><strong>InnoDB</strong></th><th><strong>MyISAM</strong></th><th><strong>Memory</strong></th></tr></thead><tbody><tr><td>🔒 锁机制</td><td>✅ 行级锁 + 表级锁混合（默认行锁，支持多版本并发控制 MVCC）</td><td>❌ 仅支持表级锁，写入或更新时整个表被锁定</td><td>❌ 仅支持表级锁</td></tr><tr><td>🌳 B-树索引</td><td>✅ 支持，<strong>聚簇索引（主键）</strong>存储数据，辅助索引存主键</td><td>✅ 支持，<strong>非聚簇索引</strong>，索引与数据分离</td><td>✅ 支持（基于哈希或 B-Tree，可设置）</td></tr><tr><td>🔗 哈希索引</td><td>⚠️ 不支持（只有 Adaptive Hash Index，InnoDB 内部使用）</td><td>❌ 不支持</td><td>✅ 默认使用哈希索引，<strong>也支持 BTree（可配置）</strong></td></tr><tr><td>🔐 外键支持</td><td>✅ 支持（定义级联删除、更新等外键约束）</td><td>❌ 不支持</td><td>❌ 不支持</td></tr><tr><td>🔁 事务支持</td><td>✅ 支持完整事务（ACID），回滚、提交、一致性恢复</td><td>❌ 不支持事务机制</td><td>❌ 不支持事务</td></tr><tr><td>📚 索引缓存</td><td>✅ 支持（通过 Buffer Pool 缓存索引和数据）</td><td>✅ 支持（<strong>只缓存索引，不缓存数据</strong>）</td><td>❌ 不缓存索引（数据在内存中，系统重启即失）</td></tr><tr><td>💾 数据缓存</td><td>✅ 支持（Buffer Pool 中同时缓存数据和索引）</td><td>❌ 不支持数据缓存（每次查询都需从磁盘读取数据）</td><td>✅ 所有数据在内存中，速度极快</td></tr></tbody></table><p><strong>锁机制：表示数据库在并发请求访问的时候，多个事务在操作时，并发操作的粒度。</strong></p><p><strong>B-树索引和哈希索引：主要是加速SQL的查询速度。</strong></p><p><strong>外键：子表的字段依赖父表的主键，设置两张表的依赖关系。</strong></p><p><strong>事务：多个SQL语句，保证他们共同执行的原子操作，要么成功，要么失败，不能只成功一部分，失败需回滚事务。</strong></p><p><strong>索引缓存和数据缓存：和MySQL Server的查询缓存相关，在没有对数据和索引做修改之前，重复查询可以不用进行磁盘I&#x2F;O(数据库的性能提升，目的是为了减少磁盘I&#x2F;O操作来提升数据库访问效率)，读取上一次内存中查询的缓存即可。</strong></p><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><p><strong>当表中的数据量到达几十万甚至上百万的时候，SQL查询所花费的时间会很长，导致业务超时出错，此时就需要用索引来加速SQL查询。</strong></p><p><strong>由于索引也是需要存储索引文件的，因此对索引的使用也会涉及磁盘I&#x2F;O操作。如果索引创建过多，使用不当，会造成SQL查询时，进行大量无用的磁盘I&#x2F;O操作，降低了SQL的查询效率，适得其反，所以掌握良好得索引创建原则非常重要。</strong></p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><strong>索引是创建在表上的，是对数据库表一列或者多列的值进行排序的一种结果。索引的核心是提高查询的速度。</strong></p><p><strong>物理上(聚集索引&amp;非聚集索引)&#x2F;逻辑上(以下六种)</strong></p><p><strong>索引的优点：提高查询效率</strong></p><p><strong>索引的缺点：索引并非越多越好，过多的索引会导致CPU使用率居高不下，由于数据的改变，会造成索引文件的改动，过多的磁盘I&#x2F;O造成CPU负荷太重。</strong></p><ol><li><strong>普通索引：没有任何限制条件，可以给任何类型的字段创建普通索引。(创建新表&amp;已创建表，数量是不限的，一张表的一次sql查询只能用一个索引 where a&#x3D;1 and b&#x3D;’M’只用其中一个)</strong></li><li><strong>唯一性索引：使用UNIQUE修饰的字段，值不能够重复，主键索引就隶属于唯一性索引。</strong></li><li><strong>主键索引：使用Primary Key修饰的字段会自动创建索引。</strong></li><li><strong>单列索引：在一个字段上创建索引</strong></li><li><strong>多列索引：在表的多个字段上创建索引（多列索引必须使用到第一个列，才能使用到多列索引，否则索引用不上）</strong></li><li><strong>全文索引：使用FULLTEXT参数可以设置全文索引，只支持CHAR,VARCHAR和TEXT类型的字段上，常用于数据量较大的字符串类型上，可以提高查询速度。(线上项目支持专门的搜索功能，给后台服务器增加专门的搜索引擎支持快速高效的搜索 elasticsearch简称es C++开源的搜索引擎 搜狗的workflow,所以最好不要部署到mysql里)</strong></li></ol><h3 id="索引创建和删除"><a href="#索引创建和删除" class="headerlink" title="索引创建和删除"></a>索引创建和删除</h3><p><strong>注意：</strong></p><ol><li><strong>经常作为where条件过滤的字段考虑添加索引</strong></li><li><strong>字符串创建索引时，尽量规定索引的长度，而不能让索引值的长度key_len过长</strong></li><li><strong>索引字段涉及类型强转，mysql函数调用，表达式计算等，索引就用不上了（索引失效）。</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where password=&#x27;1000000&#x27;;</span><br><span class="line">select * from t_user where password=1000000;</span><br><span class="line">password是个varchar类型，加了索引，上面两句的耗时量不同。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建表的时候指定索引字段：</span><br><span class="line">CREATE TABLE index1(id INT,</span><br><span class="line">                    name VARCHAR(20),</span><br><span class="line">                    sex ENUM(&#x27;male&#x27;,&#x27;female&#x27;),</span><br><span class="line">                   INDEX(id));</span><br><span class="line">#在已经创建的表上添加索引：添加索引。后续用这个字段查，索引一定会用到吗，不一定，如果使用索引所消耗的数据量和扫表的数据量差不多的话，会优化成直接扫表。不用索引</span><br><span class="line">CREATE [UNIQUE]INDEX 索引名 ON 表名（属性名（length）[ASC|DESC]）;length为索引的长度,一般在给字符串字段加索引时写明长度</span><br><span class="line">create index pwdidx on t_user(password);</span><br><span class="line">#删除索引</span><br><span class="line">DROP INDEX 索引名 ON 表名;</span><br></pre></td></tr></table></figure><h3 id="索引的执行过程"><a href="#索引的执行过程" class="headerlink" title="索引的执行过程"></a>索引的执行过程</h3><h4 id="explain查看执行计划"><a href="#explain查看执行计划" class="headerlink" title="explain查看执行计划"></a>explain查看执行计划</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM user WHERE id = 1;</span><br></pre></td></tr></table></figure><p><strong>EXPLAIN 关键字段详细说明表格</strong></p><table><thead><tr><th>字段名</th><th>详细解释</th></tr></thead><tbody><tr><td><strong>id</strong></td><td>表示查询中每个 SELECT 子句的唯一标识符。 数值越大，优先级越高，越早执行。常见于子查询和联合查询中。</td></tr><tr><td><strong>select_type</strong></td><td>表示查询的类型（即 SELECT 的种类）： 🔹 <code>SIMPLE</code>：简单查询，没有子查询或 UNION 🔹 <code>PRIMARY</code>：最外层的主查询 🔹 <code>SUBQUERY</code>：SELECT 在 WHERE 中嵌套 🔹 <code>DERIVED</code>：FROM 子句中的子查询（派生表）🔹<code>UNION</code>：UNION 中的第二个及以后查询 🔹 <code>DEPENDENT SUBQUERY</code>：依赖外层查询结果的子查询</td></tr><tr><td><strong>table</strong></td><td>当前访问的表名或别名，若为临时表，则会显示 <code>derivedN</code> 或 <code>unionN</code></td></tr><tr><td><strong>partitions</strong></td><td>如果使用了分区表，显示所访问的分区。无分区则为 NULL</td></tr><tr><td><strong>type（访问类型）</strong></td><td>🔥 评估索引使用效率的核心字段，从优到劣如下： 1. <code>system</code>（表只有一行） 2. <code>const</code>（通过主键或唯一索引查询常量） 3. <code>eq_ref</code>（唯一索引 + 连接） 4. <code>ref</code>（普通索引 + 连接） 5. <code>range</code>（范围查询，如 <code>&gt;</code>、<code>BETWEEN</code>） 6. <code>index</code>（全索引扫描） 7. <code>ALL</code>（全表扫描 ⚠️ 需优化）</td></tr><tr><td><strong>possible_keys</strong></td><td>显示可能用于查询的索引列表。 不一定表示最终用到了。 如果是 <code>NULL</code>，说明没有可用索引。</td></tr><tr><td><strong>key</strong></td><td>实际使用的索引名称。 为 <code>NULL</code> 则表示未使用任何索引。</td></tr><tr><td><strong>key_len</strong></td><td>实际使用的索引长度（单位是字节）， 由字段类型、字符集等决定。 ⚠️ 并不等于整个索引长度，仅表示此次查询使用了其中多少部分。</td></tr><tr><td><strong>ref</strong></td><td>显示哪个字段或常量被用来与索引中的列进行比较： 如：<code>const</code>（常量）、<code>func</code>（函数）、<code>table.column</code>（表字段）等</td></tr><tr><td><strong>rows</strong></td><td>MySQL 预计需要读取的记录行数（不是返回行数），越少越好。 是估算值，不一定准确。</td></tr><tr><td><strong>filtered</strong></td><td>表示通过 WHERE 条件过滤后，预估保留的记录百分比。 值为百分比形式，100 表示全部通过。</td></tr><tr><td><strong>Extra</strong></td><td>显示额外的执行细节，非常重要： 🔹 <code>Using index</code>：覆盖索引，无需回表 🔹 <code>Using where</code>：使用了 WHERE 过滤条件 🔹 <code>Using temporary</code>：使用了临时表（如GROUP BY） 🔹 <code>Using filesort</code>：需要额外排序（ORDER BY） 🔹 <code>Using index condition</code>：使用了 Index Condition Pushdown（ICP） 🔹 <code>Impossible WHERE</code>：WHERE 条件永远不成立</td></tr></tbody></table><h3 id="索引的底层实现原理"><a href="#索引的底层实现原理" class="headerlink" title="索引的底层实现原理"></a>索引的底层实现原理</h3><p><strong>数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘块（对应索引树的节点），索引树越低，越矮胖，磁盘IO次数就少。</strong></p><p><strong>MySQL支持两种索引，一种是B-树索引，一种是哈希索引，大家知道，B-树和哈希表在查询时的效率是非常高的。</strong></p><p><strong>这里主要讨论MySQL InnoDB的存储引擎，基于B-树(但实际上MySQL采用的是B+树结构)的索引结构。</strong></p><p><strong>B-树是一种m阶平衡树，叶子节点都在同一层，由于每个节点存储的数据量比较大，索引整个B-树的层数是非常低的，基本不超过三层。</strong></p><p><strong>由于磁盘的读取也是按照block块操作的(内存是按page页面操作的)，因此B-树的节点大小一般设置为和磁盘块大小一致，这样一个B-树节点，就可以通过一次磁盘I&#x2F;O把一个磁盘块的数据全部存储下来，所以当使用B-树存储索引的时候，磁盘I&#x2F;O的操作次数是最少的(MySQL的读写效率，主要集中在磁盘I&#x2F;O)。</strong></p><p><img src="/2025/07/25/MYSQLlearning/4.png" alt="4"></p><p><strong>为什么MySQL(MyISAM和InnoDB)索引底层选择B+树而不是B树呢？</strong></p><ol><li><strong>索引+数据内容分散在不同的节点上，离根节点近，搜索就快；离根节点远，搜索就慢！花费的磁盘IO次数不平均，每一行数据花费的时间也不平均。</strong></li><li><strong>每一个非叶子节点，不仅仅要存储索引(key),还要存储索引值所在的那一行的data数据。一个节点所能存放的索引key值的个数，比只能存储key值的节点的个数要少的多！！！</strong></li><li><strong>这棵树不方便做范围搜索，整表遍历看起来也不方便。</strong></li></ol><p><strong>有上面的三个原因，由B+树来构建索引。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.每一个非叶子节点，只存放key,不存储data!</span><br><span class="line">好处就是一个节点存放的key值更多，B+树在理论上来说，层数会更低一些，搜索的效率会更好一些。</span><br><span class="line">2.叶子节点上存储了所有的索引值+数据data:搜索每一个索引对应的值data,都需要跑到叶子节点上，这样每一行记录搜索的时间是非常平均的。</span><br><span class="line">3.叶子节点被串在一个链表当中，形成了一个有序的链表，如果要进行索引树的搜索&amp;整表搜索，直接遍历叶子节点的有序链表即可！或者做范围查询的时候，直接遍历叶子节点的有序链表即可！</span><br></pre></td></tr></table></figure><h4 id="InnoDB的主键和二级索引树"><a href="#InnoDB的主键和二级索引树" class="headerlink" title="InnoDB的主键和二级索引树"></a>InnoDB的主键和二级索引树</h4><p><img src="/2025/07/25/MYSQLlearning/5.png" alt="5"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from student where age=20 order by name;</span><br><span class="line">如果只给age添加索引，行不行？还有什么没考虑到吗？</span><br><span class="line">如果只给age加索引，oder by name 会触发using filesort十分消耗资源，order by可以在name上加索引，但是一次sql,只能使用一次索引。</span><br><span class="line">所以我们这里要使用联合索引(多列索引)</span><br><span class="line">key:age+name 在B+树的链表中先按age排序，再按name排序；age相同，按name进行排序！！！</span><br><span class="line">多列索引必须使用到第一个列，才能使用到多列索引，否则索引用不上</span><br></pre></td></tr></table></figure><h4 id="MyISAM的主键和二级索引树"><a href="#MyISAM的主键和二级索引树" class="headerlink" title="MyISAM的主键和二级索引树"></a>MyISAM的主键和二级索引树</h4><p><img src="/2025/07/25/MYSQLlearning/6.png" alt="6"></p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p><img src="/2025/07/25/MYSQLlearning/7.png" alt="7"></p><h4 id="InnoDB自适应哈希索引"><a href="#InnoDB自适应哈希索引" class="headerlink" title="InnoDB自适应哈希索引"></a>InnoDB自适应哈希索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这个数据结构和哈希索引的数据结构是一样的。</span><br><span class="line">InnoDB存储引擎检测到同样的二级索引不断被使用，有回表，(使用等值搜索)，那么底层会根据这个二级索引优化，在内存上根据二级索引树（B+树）上的二级索引值，在内存上构建一个哈希索引，来加强搜索。毕竟等值查询的效率是O(1);</span><br><span class="line">但是自适应哈希索引本身的数据维护也是需要耗费性能的，并不是说自适应哈希索引在任何情况下都会提升二级索引的查询性能！根据参数指标，来具体分析是否打开或者关闭自适应哈希索引。</span><br><span class="line">show engine innodb status\G 能看到两个比较重要的信息：</span><br><span class="line">1.RW_latch等到的线程数量(自适应哈希索引默认分配8个分区)，同一个分区等待的线程数量过多，会造成自适应哈希索引搜索的效率低可以关闭自适应哈希索引</span><br><span class="line">2.走自适应哈希索引搜索的效率（低）和二级索引树搜索的效率（高）可以关闭自适应哈希索引</span><br></pre></td></tr></table></figure><p><strong>SQL和索引的优化问题，如何切入？</strong></p><p><strong>explain 分析sql</strong></p><p><strong>项目&#x3D;》很多业务&#x3D;》各种各样的sql 千条，万条</strong></p><p><strong>流程：从什么地方能够获取哪些运行时间长，耗性能的sql;然后再用explain去使用它。</strong></p><p><strong>1.可以使用慢查询日志slow_query_log，设置合理的，业务可以接受的慢查询时间！！</strong></p><p><strong>2.压测执行各种业务。</strong></p><p><strong>3.查看慢查询日志，找出所有执行耗时的sql。</strong></p><p><strong>4.用explain分析这些耗时的sql</strong></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a><strong>慢查询日志</strong></h3><p><strong>MySQL可以设置慢查询日志，当SQL执行的时间超过我们设定的时间，那么这些SQL就会被记录在慢查询日志当中，然后我们通过查看日志，用explain分析这些SQL的执行计划，来判断为什么效率低下，是没有使用到索引？还是索引本身创建的有问题？或者是索引使用到了，但是由于表的数据量太大，花费的时间就是很长，那么此时我们可以把表分为n个小表，比如订单表按年份分成多个小表。</strong></p><p>慢查询日志相关参数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%slow_query%&#x27;;</span><br><span class="line">+---------------------+---------------------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                                   |</span><br><span class="line">+---------------------+---------------------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                                     |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/yustone-VMware-Virtual-Platform-slow.log |</span><br><span class="line">+---------------------+---------------------------------------------------------+</span><br><span class="line">2 rows in set (0.27 sec)</span><br></pre></td></tr></table></figure><p>打开慢查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log=ON;</span><br></pre></td></tr></table></figure><p>慢查询日志记录了包含所以执行时间超过参数long_query_time(单位：秒)所设置值的SQL语句的日志，在MySQL上用命令可以查看。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;long%&#x27;;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>这个值是可以修改的，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set long_query_time=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>修改完成后，执行sql后可以去对应文件&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;yustone-VMware-Virtual-Platform-slow.log查看。</p><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h3 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h3><p><strong>一个事务是由一条或者多条对数据库操作的SQL语句所组成的一个不可分割的单元，只有当事务中的所有操作都正常执行完了，整个事务才会被提交到数据库；如果有部分事务处理失败，那么事务就要回退到最初的状态，因此，事务要么全部执行成功要么全部失败。</strong></p><ol><li><strong>事务是一组SQL语句的执行，要么全部成功，要么全部失败，不能出现部分成功，部分失败的结果。保证事务执行的原子操作。</strong></li><li><strong>事务的所有SQL语句全部执行成功，才能提交(commit)事务，把结果写回磁盘。</strong></li><li><strong>事务执行过程中，有的SQL出现错误，那么事务必须要回滚(rollback)到最初的状态。</strong></li></ol><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><p><strong>每一个事务必须满足下面的4个特性：</strong></p><p><strong>事务的原子性(Atomic):</strong></p><p><strong>事务是一个不可分割的整体，事务必须具有原子特性，及当数据修改时，要么全执行，要么全不执行，即不允许事务部分的完成。</strong></p><p><strong>事务的一致性(Consistency):</strong></p><p><strong>一个事务执行之前和执行之后，数据库数据必须保持一致性状态。数据库的一致性状态必须由用户来负责，由并发控制机制实现。就拿网上购物来说，你只有让商品出库，又让商品进入顾客的购物车才能构成一个完整的事务。</strong></p><p><strong>事务的隔离性(Isolation):</strong></p><p><strong>当两个或者多个事务并发执行时，为了保证数据的安全性，将一个事务内部的操作与其他事务的操作隔离起来，不被其他正在执行的事务所看到，使得并发执行的各个事务之间不能互相影响。</strong></p><p><strong>事务的持久性(Durability):</strong></p><p><strong>事务完成(commit)以后，DBMS保证它对数据库中的数据的修改是永久性的(可能出现内存把数据写回磁盘时出现断电)，即使数据库因为故障出错，也应该能够恢复数据！（利用redo log:重做日志 保证数据库的永久性）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事务的ACID特性：</span><br><span class="line">ACD:是由mysql的redo log和undo log机制来保证的。</span><br><span class="line">I:隔离性，是由mysql事务的锁机制来实现保证的。</span><br></pre></td></tr></table></figure><h3 id="事务并发存在的问题"><a href="#事务并发存在的问题" class="headerlink" title="事务并发存在的问题"></a>事务并发存在的问题</h3><p>事务处理不经隔离，并发执行事务时通常会发生以下的问题：</p><p><strong>脏读（Dirty Read）:一个事务读取了另一个事务未提交的数据。例如当事务A和事务B并发执行时，当事务A更新后，事务B查询读取到A尚未提交的数据，此时事务A回滚，则事务B读到的数据就是无效的脏数据。（事务B读取了事务A尚未提交的数据）。</strong>（杜绝）</p><p><strong>不可重复读（NonRepeatable Read）:一个事务的操作导致另一个事务前后两次读到不同的数据。例如当事务A和事务B并发执行时，当事务B查询读取数据后，事务A更新操作更改事务B查询到的数据，此时事务B再次去读该数据，发现前后两次读的数据不一样。（事务B读取了事务A已提交的数据）</strong>（看业务能不能接受）</p><p><strong>虚读(Phantom Read) 幻读：一个事务的操作导致另一个事务前后查询的结果数据量不同。例如当事务A和事务B并发执行时，当事务B查询读取数据后，事务A新增或者删除了一条满足事务B查询条件的记录，此时事务B再去查询，发现查询到前一次不存在的记录。或者前一次查询的一些记录不见了。（事务B读取了事务A(已提交)新增加的数据或者读不到事务A删除的数据）。</strong>（看业务能不能接受）</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>MySQL支持的四种隔离级别是：</p><ol><li><strong>TRANSACTION_READ_UNCOMMITTED。未提交读。说明在提交前一个事务可以看到另一个事务的变化。这样读脏数据，不可重复读和虚读都是被允许的。</strong></li><li><strong>TRANSACTION_READ_COMMITTED。已提交读。说明读取未提交的数据是不允许的。这个级别仍然允许不可重复读和虚读产生。</strong></li><li><strong>TRANSACTION_REPEATABLE_READ。可重复读。说明事务保证能够再次读取相同的数据而不会失败，都是相同的数据，但虚读仍然会出现。可以解决一部分的幻读（insert&#x2F;delete）,但是解决不了update造成的幻读。</strong></li><li><strong>TRANSACTION_SERIALIZABLE。串行化。是最高的事务级别，他防止读脏数据，不可重复读和虚读。</strong></li></ol><p><strong>MySQL默认隔离级别：可重复读,oracle的默认隔离级别：已提交读。</strong></p><h3 id="MySQL的事务处理命令"><a href="#MySQL的事务处理命令" class="headerlink" title="MySQL的事务处理命令"></a>MySQL的事务处理命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select @@autocommit;#查看事务是自动(1)还是手动(0)</span><br><span class="line"></span><br><span class="line">set autocommit=0;#设置事务为手动(在当前会话生效)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#MyISAM:不支持事务的！</span><br><span class="line">#InnoDB:最大的特点：支持事务，支持行锁</span><br><span class="line">try&#123;</span><br><span class="line">begin;#开始一个事务</span><br><span class="line">SQL语句</span><br><span class="line"></span><br><span class="line">commit;#提交一个事务</span><br><span class="line">&#125;catch(... err)&#123;</span><br><span class="line">rollback;#回滚一个事务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT point1;设置一个名字为point1的保存点</span><br><span class="line">ROLLBACK TO point1;事务回滚到保存点point1,而不是回滚到初始状态</span><br><span class="line">SET SESSION transaction_isolation = &#x27;REPEATABLE-READ&#x27;;设置事务的隔离级别</span><br><span class="line">SELECT @@transaction_isolation;查询事务的隔离级别</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@transaction_isolation;</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+-------------------------+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure><h2 id="MySQL的锁机制"><a href="#MySQL的锁机制" class="headerlink" title="MySQL的锁机制"></a>MySQL的锁机制</h2><p><img src="/2025/07/25/MYSQLlearning/8.png" alt="8"></p><h3 id="表级锁-行级锁"><a href="#表级锁-行级锁" class="headerlink" title="表级锁&amp;行级锁"></a>表级锁&amp;行级锁</h3><p><strong>表级锁：对整张表加锁。开销小，加锁快，不会出现死锁；锁粒度大，发生锁冲突的概率高，并发读低。</strong></p><p><strong>行级锁：对某行记录加锁。开销大，加锁慢，会出现死锁；锁粒度最小，发生锁冲突的概率最低，并发度高。</strong></p><h3 id="排它锁和共享锁"><a href="#排它锁和共享锁" class="headerlink" title="排它锁和共享锁"></a>排它锁和共享锁</h3><p><strong>排它锁（Exclusive）,又称为X锁，写锁。</strong></p><p><strong>共享锁（Shared）,又称为S锁，读锁。</strong></p><p><strong>X锁和S锁之间有以下关系： SS可以兼容，XS,SX,XX之间是互斥的</strong></p><ol><li><strong>一个事务对数据对象O加了S锁，可以对O进行读取操作但不能进行更新操作。加锁期间其他事务能对O加S锁但不能加X锁。</strong></li><li><strong>一个事务对数据对象O加了X锁，就可以对O进行读取和更新。加锁期间其他事务不能对O加任何锁。</strong></li><li><strong>手动加锁：select…lock in share mode强制获取共享锁，select…for update获取排它锁</strong></li></ol><h3 id="InnoDB行级锁"><a href="#InnoDB行级锁" class="headerlink" title="InnoDB行级锁"></a>InnoDB行级锁</h3><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p><strong>InnoDB存储引擎支持事务处理，表支持行级锁定，并发能力更好。</strong></p><ol><li><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的，而不是给表的行记录加锁实现的，这就意味着只有通过索引数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。</strong></li><li><strong>由于InnoDB的行锁实现是针对索引字段添加的锁，不是针对行记录加的锁，因此虽然访问的是InnoDB引擎下表的不同行，但是如果使用相同的索引字段值作为过滤条件，依然会发生锁冲突，只能串行进行，不能并发进行。</strong></li><li><strong>即使SQL中使用了索引，但是经历MySQL的优化器后，如果认为全表扫描比使用索引效率更高，此时会放弃使用索引，因此不会使用行锁，而是使用表锁，比如对一些很小的表，MySQL就不会去使用索引。</strong></li></ol><h4 id="间隙锁-gap-lock"><a href="#间隙锁-gap-lock" class="headerlink" title="间隙锁(gap lock)"></a>间隙锁(gap lock)</h4><p><img src="/2025/07/25/MYSQLlearning/9.png" alt="9"></p><p><strong>当我们用范围条件而不是相等条件检索数据，并请求共享或排它锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做间隙，InnoDB也会对这个间隙加锁，这个锁机制就是所谓的间隙锁。举例来说，假如user表中只有101条记录，其userid的值分别为1，2，100，101，下面的SQL:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where userid&gt;100 for update;</span><br></pre></td></tr></table></figure><p><strong>是一个范围条件的检索，InnoDB不仅会对符合条件的userid值为101的记录加锁，也会对userid大于101(但是这些记录不存在)的间隙加锁，防止其他事务在表的末尾增加数据。</strong></p><p><strong>InnoDB使用间隙锁的目的，为了防止幻读，以满足串行化隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了userid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读。</strong></p><p><img src="/2025/07/25/MYSQLlearning/10.png" alt="10"></p><h3 id="InnoDB表级锁"><a href="#InnoDB表级锁" class="headerlink" title="InnoDB表级锁"></a>InnoDB表级锁</h3><p>在绝大部分情况下都应该使用行锁，因为事务和行锁往往是选择InnoDB的理由，但个别情况下也使用表级锁；</p><ol><li>事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间等待和锁冲突；</li><li>事务涉及多个表，比较复杂，很可能造成死锁，造成大量事务回滚。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE user READ;读锁锁表</span><br><span class="line">LOCK TABLE user WRITE;写锁锁表</span><br><span class="line">事务执行。。。</span><br><span class="line">COMMIT/ROLLBACK;事务提交/回滚</span><br><span class="line">UNLOCK TABLES;本身自带提交事务，释放线程占用的所有表锁。</span><br></pre></td></tr></table></figure><h4 id="意向共享锁和意向排他锁"><a href="#意向共享锁和意向排他锁" class="headerlink" title="意向共享锁和意向排他锁"></a>意向共享锁和意向排他锁</h4><p><strong>意向共享锁（IS锁）:事务计划给记录加行共享锁，事务在给一行记录加共享锁前，必须先取得该表的IS锁。</strong></p><p><strong>意向排他锁（IX锁）:事务计划给记录加行排他锁，事务在给一行记录加排他锁前，必须先取得该表的IX锁</strong></p><p><strong>IS和IX之间是兼容的，没有互斥</strong></p><p><img src="/2025/07/25/MYSQLlearning/13.png" alt="13"></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>MyISAM表锁是deadlock free的，这是因为MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，即锁的粒度比较小，这就决定了在InnoDB中发生死锁是可能的。</strong></p><p><img src="/2025/07/25/MYSQLlearning/14.png" alt="14"></p><p><strong>死锁问题一般都是我们自己的应用造成的，和多线程编程的死锁情况相似，大部分都是由于我们多个线程在获取多个锁资源的时候，获取的顺序不同而导致的死锁问题。因此我们应用在对数据库的多个表作更新的时候，不同的代码段，应对这些表按相同的顺序进行更新操作，以防止锁冲突导致死锁问题。</strong></p><h3 id="锁的优化建议"><a href="#锁的优化建议" class="headerlink" title="锁的优化建议"></a>锁的优化建议</h3><ol><li><strong>尽量使用较低的隔离级别</strong></li><li><strong>设计合理的索引并尽量使用索引访问数据，使加锁更加准确，减少锁冲突的机会提高并发能力</strong></li><li><strong>选择合理的事务大小，小事务发生锁冲突的概率小</strong></li><li><strong>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表；对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</strong></li><li><strong>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</strong></li><li><strong>不要申请超过实际需要的锁级别</strong></li><li><strong>除非必须，查询时不要显式加锁</strong></li></ol><h3 id="redo-log和undo-log"><a href="#redo-log和undo-log" class="headerlink" title="redo log和undo log"></a>redo log和undo log</h3><p><strong>统称为事务日志。区别于binlog是MySQL Server层的日志，这两个属于存储引擎层的日志。</strong></p><p><strong>redo log：重做日志。</strong></p><p><strong>undo log: 回滚日志</strong></p><p><strong>redo log:用于记录事务操作的变化，确保事务的持久性。redo log是在事务开始后就开始记录，不管事务是否提交都会记录下来，在异常发生时（如数据持久化过程中掉电），InnoDB会使用redo log恢复到掉电前的时刻，保证数据的完整性。</strong></p><p><strong>innodb_log_buffer_size默认是16M,就是redo log缓冲区的大小，它随着事务开始，就开始写redo log,如果事务比较大，为了避免事务执行过程中花费过多磁盘IO,可以设置比较大的redo log缓存，节省磁盘IO。</strong></p><p><strong>InnoDB修改操作数据，不是直接修改磁盘上的数据，实际只是修改Buffer Pool的数据。InnoDB总是先把Buffer Pool中的数据改变记录到redo log中，用来进行崩溃后的数据恢复。优先记录redo log,然后再慢慢的将Buffer Pool的脏数据刷新到磁盘上。</strong></p><p><strong>innodb_log_group_home_dir指定的目录下的两个文件：ib_logfile0,ib_logfile1,该文件被称作重做日志。</strong></p><p><strong>buffer pool缓存池：</strong></p><p><strong>作用：加速读和加速写，直接操作data page,写redo log修改就算完成，有专门的线程去做把buffer pool的dirty page写入磁盘。</strong></p><p><img src="/2025/07/25/MYSQLlearning/15.png" alt="15"></p><p><strong>undo log:保存了事务发生之前的数据的一个版本，用于事务执行时的回滚操作，同时也是实现多版本并发控制（MVCC）下读操作的关键技术。</strong></p><p><strong>在创建表时，除了自己设定的字段，mysql会自动加一些字段，其中DB_TRX_ID：事务ID  DB_ROLL_PTR：回滚指针</strong></p><p> <strong>DB_ROLL_PTR：回滚指针指向修改前的数据，修改前的数据在undo log中，当然当前数据库里的数据是最新的。回滚的话，直接从undo log调就可以。</strong></p><p><img src="/2025/07/25/MYSQLlearning/11.png" alt="11"></p><h3 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h3><p><strong>MVCC是多版本并发控制，是MySQL中基于乐观锁理论实现隔离级别的方式，用于实现已提交读和可重复读隔离级别的实现，也经常称为多版本数据库。MVCC机制会生成一个数据请求时间点的一致性数据快照（Snapshot）,并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本（系统版本号和事务版本号）。</strong></p><p><strong>MVCC多版本并发控制中，读操作可以分为两类：</strong></p><p><strong>1.快照读（Snapshot read）</strong></p><p>​<strong>读的是记录的可见版本，不用加锁，如select。</strong></p><p><strong>2.当前读（current read）</strong></p><p>​<strong>读取的是记录的最新版本，并且当前读返回的记录。如insert,delete,update,select…lock in share mode&#x2F;for update</strong></p><p>​<strong>MVCC:每一行记录实际上有多个版本，每个版本的记录除了数据本身之外，增加了其他字段</strong></p><p>​<strong>DB_TRX_ID:记录当前的事务ID。</strong></p><p>​<strong>DB_ROLL_PTR:指向undo log日志上数据的指针。</strong></p><p><strong>逻辑上来看，MVCC 就是为每个事务“搞出了一张表的快照”，但这张“表”并不是实际复制的，而是通过行级的历史版本 + 可见性判断规则拼出来的。</strong></p><p><strong>已提交读：每次执行语句的时候都重新生成一次快照（Read View）,每次select查询时。</strong></p><p><strong>可重复读：同一个事务开始的时候生成一个当前事务全局性的快照（Read View）,第一次select查询时。</strong></p><p><strong>快照内容读取原则：</strong></p><ol><li><strong>版本未提交无法读取生成快照</strong></li><li><strong>版本已提交，但是在快照创建后提交的，无法读取</strong></li><li><strong>版本已提交，但是在快照创建前提交的，可以读取</strong></li><li><strong>当前事务内自己的更新，可以读到。</strong></li></ol><p><img src="/2025/07/25/MYSQLlearning/12.png" alt="12"></p><h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2><p><img src="/2025/07/25/MYSQLlearning/16.png" alt="16"></p><h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;log_%&#x27;; #全局变量设置&amp;状态show variables &amp; show status</span><br><span class="line">+----------------------------------------+----------------------------------------+</span><br><span class="line">| Variable_name                          | Value                                  |</span><br><span class="line">+----------------------------------------+----------------------------------------+</span><br><span class="line">| log_bin                                | ON                                     |</span><br><span class="line">| log_bin_basename                       | /var/lib/mysql/binlog                  |</span><br><span class="line">| log_bin_index                          | /var/lib/mysql/binlog.index            |</span><br><span class="line">| log_bin_trust_function_creators        | OFF                                    |</span><br><span class="line">| log_bin_use_v1_row_events              | OFF                                    |</span><br><span class="line">| log_error                              | /var/log/mysql/error.log               |</span><br><span class="line">| log_error_services                     | log_filter_internal; log_sink_internal |</span><br><span class="line">| log_error_suppression_list             |                                        |</span><br><span class="line">| log_error_verbosity                    | 2                                      |</span><br><span class="line">| log_output                             | FILE                                   |</span><br><span class="line">| log_queries_not_using_indexes          | OFF                                    |</span><br><span class="line">| log_raw                                | OFF                                    |</span><br><span class="line">| log_replica_updates                    | ON                                     |</span><br><span class="line">| log_slave_updates                      | ON                                     |</span><br><span class="line">| log_slow_admin_statements              | OFF                                    |</span><br><span class="line">| log_slow_extra                         | OFF                                    |</span><br><span class="line">| log_slow_replica_statements            | OFF                                    |</span><br><span class="line">| log_slow_slave_statements              | OFF                                    |</span><br><span class="line">| log_statements_unsafe_for_binlog       | ON                                     |</span><br><span class="line">| log_throttle_queries_not_using_indexes | 0                                      |</span><br><span class="line">| log_timestamps                         | UTC                                    |</span><br><span class="line">+----------------------------------------+----------------------------------------+</span><br><span class="line">21 rows in set (0.06 sec)</span><br></pre></td></tr></table></figure><p>关于日志的配置需要到my.cnf去添加。</p><p><img src="/2025/07/25/MYSQLlearning/17.png" alt="17"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL基础&quot;&gt;&lt;a href=&quot;#MySQL基础&quot; class=&quot;headerlink&quot; title=&quot;MySQL基础&quot;&gt;&lt;/a&gt;MySQL基础&lt;/h2&gt;&lt;h3 id=&quot;MySQL介绍&quot;&gt;&lt;a href=&quot;#MySQL介绍&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="MYSQL learning" scheme="http://yustonerain.top/categories/MYSQL-learning/"/>
    
    
    <category term="MYSQL learning" scheme="http://yustonerain.top/tags/MYSQL-learning/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="http://yustonerain.top/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yustonerain.top/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2025-07-16T14:54:16.000Z</published>
    <updated>2025-07-24T13:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="mac地址（6个字节-48位）"><a href="#mac地址（6个字节-48位）" class="headerlink" title="mac地址（6个字节 48位）"></a><strong>mac地址</strong>（6个字节 48位）</h3><p>标记网卡的id,；理论上这个id全球唯一</p><p><strong>mac地址一般用来标识主机的id,这个id是物理地址，不会改变。</strong></p><h3 id="ip地址，ipv4-4个字节，32位-，ipv6-16个字节，128位"><a href="#ip地址，ipv4-4个字节，32位-，ipv6-16个字节，128位" class="headerlink" title="ip地址，ipv4(4个字节，32位)，ipv6(16个字节，128位)"></a><strong>ip地址，ipv4(4个字节，32位)，ipv6(16个字节，128位)</strong></h3><p>IP地址是标识主机的id,这个id是虚拟的，会改变。</p><p>一个IP将其分为子网id和主机id</p><p><strong>子网id和主机id需要和子网掩码一起来看，</strong></p><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png" alt="1"></p><p>ping命令用来测试两台主机的网络联通性（windows和Linux都适用）。</p><p>Linux下设置ip命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 192.168.131.133 netmask 255.255.255.0</span><br></pre></td></tr></table></figure><h3 id="桥接模式（Bridged-Networking）"><a href="#桥接模式（Bridged-Networking）" class="headerlink" title="桥接模式（Bridged Networking）"></a><strong>桥接模式（Bridged Networking）</strong></h3><p>桥接模式是将虚拟机&#x2F;容器的网络<strong>桥接到物理网卡</strong>上，使其就像是局域网中的一台独立主机。</p><p>工作原理：</p><p>虚拟机通过虚拟网桥（Bridge）连接到宿主机的物理网卡，相当于直接插入交换机，与宿主机处于<strong>同一物理局域网</strong>中。</p><p>网络特点：</p><ul><li>虚拟机可获得<strong>与宿主机同网段的IP地址</strong>（例如通过 DHCP）</li><li>可以被局域网中其他设备访问（可 ping 通）</li><li>能访问局域网和外网</li></ul><p>优点：</p><ul><li>网络透明，虚拟机像一台真实的独立主机</li><li>易于与其他局域网设备通信</li></ul><p>缺点：</p><ul><li>需要宿主网络支持（如局域网允许多个 IP）</li><li>有可能增加网络冲突和安全风险</li></ul><h3 id="NAT-模式（网络地址转换）"><a href="#NAT-模式（网络地址转换）" class="headerlink" title="NAT 模式（网络地址转换）"></a><strong>NAT 模式（网络地址转换）</strong></h3><p>NAT 模式是虚拟机&#x2F;容器通过宿主机的网络连接上网，<strong>共享宿主机的 IP</strong>。</p><p>工作原理：</p><p>宿主机充当“路由器”，将虚拟机的私有 IP 转换为宿主的公网 IP，进行地址转换。</p><p>网络特点：</p><ul><li>虚拟机使用<strong>私有 IP 地址（如 192.168.xx.xx）</strong></li><li>能访问外网，但外部主机<strong>无法主动访问虚拟机</strong></li><li>类似家庭内的多台设备通过路由器上网</li></ul><p>优点：</p><ul><li>设置简单，几乎无须额外配置</li><li>安全性高，外部无法直接访问虚拟机</li></ul><p>缺点：</p><ul><li>虚拟机不能被外部主机主动访问（除非端口转发）</li><li>网络透明度低，不适合复杂网络测试</li></ul><h3 id="端口（port）"><a href="#端口（port）" class="headerlink" title="端口（port）"></a>端口（port）</h3><p><strong>作用：用来标识应用程序（进程）</strong></p><p><strong>port:两个字节 0-65535</strong></p><p><strong>0-1023 知名端口</strong></p><p><strong>自定义端口1024-65535（避免冲突）</strong></p><p><strong>一个应用可以有多个端口，一个端口只能有一个应用程序。</strong></p><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>为了使各种不同的计算机之间可以互联，ARPANet指定了一套计算机通信协议，即TCP&#x2F;IP协议（族）；</p><p>为了减少协议设计的复杂性，大多数网络模型均采用分层的方式来组织。</p><p>每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽。</p><p><strong>物理层：双绞线（网线）接口类型，光纤的传输速率等等</strong></p><p><strong>数据链路层：mac 负责收发数据</strong></p><p><strong>网络层：ip 给两台主机提供路径选择。</strong></p><p><strong>传输层：port 区分数据递送到那个应用程序。</strong></p><p><strong>会话层：建立连接</strong></p><p><strong>表示层：解码</strong></p><p><strong>应用层：应用程序</strong></p><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2.png" alt="2"></p><h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h3><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3.png" alt="3"></p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><strong>规定了数据传输的方式和格式</strong></p><p><strong>这里主要按照TCP&#x2F;IP四层模型有的协议。</strong></p><p><strong>应用层协议：</strong></p><p><strong>FTP:文件传输协议</strong></p><p><strong>HTTP:超文本传输协议</strong></p><p><strong>NFS:网络文件系统</strong></p><p><strong>传输层协议：</strong></p><p><strong>TCP:传输控制协议</strong> 头部20个字节</p><p><strong>UDP:用户数据报协议</strong> 头部8个字节</p><p><strong>网络层：</strong></p><p><strong>IP:英特网互联协议</strong> 头部20个字节</p><p><strong>ICMP:英特网控制报文协议 ping命令就是这个协议</strong><br><strong>IGMP：英特网组管理协议</strong></p><p><strong>链路层：</strong></p><p><strong>ARP:地址解析协议 通过ip找mac地址</strong></p><p><strong>RARP:反向地址解析协议 通过mac找ip</strong></p><p><strong>硬件接口：mac头</strong> 头部14个字节</p><p>目的mac地址为ff:ff:ff:ff:ff:ff 局域网内其他主机无条件接受。（常在ARP协议上使用）</p><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4.png" alt="4"></p><h3 id="网络设计模式"><a href="#网络设计模式" class="headerlink" title="网络设计模式"></a>网络设计模式</h3><p><strong>B&#x2F;S browser&#x2F;server</strong></p><p><strong>C&#x2F;S client&#x2F;server</strong></p><p>C&#x2F;S 性能较好 客户端容易篡改数据 开发周期较长</p><p>B&#x2F;S 性能低 客户端安全 开发周期短</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>tcp建立连接的过程 <strong>SYN是请求建立连接的标识，ACK就是确认。</strong></p><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.png" alt="9"></p><p><strong>mss:最大报文长度，一般出现在三次握手的前两次，用来告知对方传送数据的最大长度。</strong></p><p><strong>MTU:最大传输单元 由网卡限制</strong></p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>tcp断开连接，这个哪一方发起断开都可以，就以客户端申请断开为例子，三次握手一定是客户端发起。</p><p>就是两端的某一段调用了close函数。</p><p><strong>FIN是请求断开连接的标识</strong></p><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/10.png" alt="10"></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><strong>TCP报头上有一个窗口尺寸的标识，这个是说接收方告知发送方：我的接收缓冲区还能接收多少字节。</strong></p><p><strong>在ACK标识回复时会带有win剩余多少空间。</strong></p><p><strong>这样发送方就会发送以避免拥堵，因为知道接收方还剩下多少空间，接收方是把当前接收缓冲区的一块数据提取出来，才会回复给发送方ACK携带当前缓冲区大小告知对方。</strong></p><h3 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h3><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11.png" alt="11"></p><p>如果想要查看TCP应用的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp | grep 8000(端口)</span><br></pre></td></tr></table></figure><h3 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h3><p><strong>主动方在FIN_WAIT_2状态之后，主动方不可以在应用层发送数据了，但是应用层还可以接受数据，这个状态叫半关闭。</strong></p><p><strong>有人就有疑惑了，那为什么在TIME_WAIT状态还能发，因为它发的是ACK,主动方不可以在应用层发送数据了，指的是应用层的协议不可以接受了，但是在底层，传输层TCP协议还是可以发出，所以ACK是可以发的</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span>;</span><br><span class="line">参数：</span><br><span class="line">    sockfd:需要关闭的socket的描述符</span><br><span class="line">    how:允许为shutdown操作选择以下几种方式：</span><br><span class="line">        SHUT_RD(<span class="number">0</span>):关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被丢弃。</span><br><span class="line">        SHUT_WR(<span class="number">1</span>):关闭sockfd上的写功能，此选项将不允许sockfd进行写操作。进程不能再对此套接字发出写操作</span><br><span class="line">        SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是SHUT_RD,然后是SHUT_WR。</span><br></pre></td></tr></table></figure><h3 id="TCP异常断开"><a href="#TCP异常断开" class="headerlink" title="TCP异常断开"></a>TCP异常断开</h3><h4 id="心跳包-TCP-的-keepalive-机制"><a href="#心跳包-TCP-的-keepalive-机制" class="headerlink" title="心跳包(TCP 的 keepalive 机制)"></a>心跳包(TCP 的 keepalive 机制)</h4><p><strong>SO_KEEPALIVE保持连接检测对方主机是否崩溃，避免服务器永远阻塞于TCP连接的输入。设置该选项后，如果两小时内在此套接口的任一方向都没有数据交换，TCP会自动给对方发一个保持存活探测分节，这是一个对方必须响应的TCP分节。他会导致以下三种情况：</strong></p><ol><li><strong>对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个。</strong></li><li><strong>对方已崩溃且已重新启动：以RST响应。套接口的待处理错误设置为ECONNRESET,套接口本身被关闭。</strong></li><li><strong>对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT,套接口本身就关闭。若ICMP错误是host unreachable(主机不可达),说明对方主机没有崩溃，但是不可达，这种情况下待处理错误设置为EHOSTUNREACH.</strong></li></ol><p><strong>所以我们可以设置SO_KEEPALIVE属性使得我们在两小时后发现对方的TCP连接是否依然存在。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keepAlive=<span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd,SOL_SOCKET,SO_KEEPALIVE,(<span class="type">void</span> *)&amp;keepAlive,<span class="keyword">sizeof</span>(keepAlive));</span><br></pre></td></tr></table></figure><p><strong>但是说真的，这个函数两小时检测一次，对于现在来说，有点太长了，所以可以自己在应用层写对应的心跳包。</strong></p><p>心跳包：最小粒度，携带的数据部分一定要少。</p><p>乒乓包：携带比较多的数据的心跳包。</p><h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><p>端口重新启用，谁最后启用的端口谁用。前面启用的作废，用不了了。为什莫需要端口复用呢，在server的TCP连接没有完全断开之前不允许重新监听。比如我强制退出server,再启动就不会说端口被占用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在server代码的socket()和bind()调用之间插入如下代码：</span><br><span class="line"><span class="type">int</span> opt=<span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p><strong>TCP:传输控制协议 安全可靠 丢包重传 面向连接(电话模型)</strong></p><p><strong>UDP:用户数据报协议 不安全不可靠 丢包不重传 快 不面向连接(邮件模型)</strong></p><p><strong>tcp通信流程：</strong><br><strong>服务器：创建流式套接字 绑定 监听 提取 读写 关闭</strong></p><p><strong>客户端：创建流式套接字 连接 读写 关闭</strong></p><p><strong>收发数据：</strong></p><p><strong>read recv</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> buf[.len], <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> flags)</span>;</span><br><span class="line">flags==MSG_PEEK 读数据不会删除缓冲区的数据 一般填<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>write send</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">void</span> buf[.len], <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;<span class="comment">//flags=1表示紧急数据 一般填0</span></span><br></pre></td></tr></table></figure><p><strong>udp通信流程：</strong></p><p><strong>服务器：创建报式套接字 绑定 读写 关闭</strong></p><p><strong>客户端：创建报式套接字 读写 关闭</strong></p><p><strong>发数据：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">void</span> buf[.len], <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr * dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">dest_addr:目的地的地址信息</span><br><span class="line">addrlen:结构体大小</span><br></pre></td></tr></table></figure><p><strong>收数据：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> buf[<span class="keyword">restrict</span>.len], <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> sockaddr * _Nullable <span class="keyword">restrict</span> src_addr,</span></span><br><span class="line"><span class="params">  <span class="type">socklen_t</span> * _Nullable <span class="keyword">restrict</span> addrlen)</span>;</span><br><span class="line">src_addr：对方的地址信息</span><br><span class="line">addrlen：结构体大小地址    </span><br></pre></td></tr></table></figure><p>创建报式套接字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocol)</span>;</span><br><span class="line">参数：</span><br><span class="line">    domain:AF_INET</span><br><span class="line">    type:SOCK_DGRAM</span><br><span class="line">    protocol:<span class="number">0</span></span><br></pre></td></tr></table></figure><p>UDP一般是一对一的。一个套接字服务一个客户端，不像TCP,后来可以分配套接字。</p><h3 id="UDP服务器和客户端代码实现"><a href="#UDP服务器和客户端代码实现" class="headerlink" title="UDP服务器和客户端代码实现"></a>UDP服务器和客户端代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">myaddr</span>;</span></span><br><span class="line">    myaddr.sin_family=AF_INET;</span><br><span class="line">    myaddr.sin_port=htons(<span class="number">8000</span>);</span><br><span class="line">    myaddr.sin_addr.s_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret=bind(fd,(<span class="keyword">struct</span> sockaddr*)&amp;myaddr,<span class="keyword">sizeof</span>(myaddr));</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> n=recvfrom(fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">            sendto(fd,buf,n,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -u 127.0.0.1 8000 <span class="comment">#这里连接服务器加上-u 表示连接的是udp</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">myaddr</span>;</span></span><br><span class="line">    myaddr.sin_family=AF_INET;</span><br><span class="line">    myaddr.sin_port=htons(<span class="number">9000</span>);</span><br><span class="line">    myaddr.sin_addr.s_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret=bind(fd,(<span class="keyword">struct</span> sockaddr*)&amp;myaddr,<span class="keyword">sizeof</span>(myaddr));</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dstaddr</span>;</span></span><br><span class="line">    dstaddr.sin_family=AF_INET;</span><br><span class="line">    dstaddr.sin_port=htons(<span class="number">8000</span>);</span><br><span class="line">    dstaddr.sin_addr.s_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        n=read(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        sendto(fd,buf,n,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;dstaddr,<span class="keyword">sizeof</span>(dstaddr));</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> n=recvfrom(fd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">hhhhh</span><br><span class="line">hhhhh</span><br><span class="line"></span><br><span class="line">woshinidia</span><br><span class="line">woshinidia</span><br></pre></td></tr></table></figure><h3 id="本地套接字通信"><a href="#本地套接字通信" class="headerlink" title="本地套接字通信"></a>本地套接字通信</h3><p><strong>unix domain socket又是一个新的IPC方式，</strong>“本地套接字”通常指的是 <strong>Unix 域套接字（Unix Domain Socket，UDS）</strong>，是一种用于<strong>同一台主机内部进程间通信（IPC）</strong>的套接字，与 TCP&#x2F;IP 套接字相比，它不经过网络协议栈，速度更快、效率更高。</p><p><strong>全双工</strong></p><p><strong>套接字用文件来标识，这个文件在绑定之前是不能存在的。</strong></p><p><strong>作用</strong>：实现本地进程间通信，替代管道、共享内存等传统 IPC 手段。</p><p><strong>协议族</strong>：使用 <code>AF_UNIX</code> 或 <code>AF_LOCAL</code> 而不是 <code>AF_INET</code>。</p><p><strong>通信方式</strong>：支持 <code>SOCK_STREAM</code>（类似 TCP）和 <code>SOCK_DGRAM</code>（类似 UDP）。</p><p><strong>地址类型</strong>：使用文件系统中的路径名作为标识（如 <code>/tmp/mysock</code>）。</p><p>本地套接字实现tcp通信</p><ol><li>创建本地套接字</li><li>绑定</li><li>监听</li><li>提取</li><li>读写</li><li>关闭</li></ol><p>创建本地套接字用于tcp通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocol)</span>;</span><br><span class="line">参数：</span><br><span class="line">    domain:AF_UNIX</span><br><span class="line">    type:SOCK_STREAM</span><br><span class="line">    protocol:<span class="number">0</span></span><br></pre></td></tr></table></figure><p>绑定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> sockaddr * addr,</span></span><br><span class="line"><span class="params">    <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">参数:</span><br><span class="line">sockfd：本地套接字</span><br><span class="line">    addr：本地套接字结构体地址</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sun_family; <span class="comment">/* AF_UNIX */</span></span><br><span class="line">  <span class="type">char</span> sun_path[<span class="number">108</span>]; <span class="comment">/* Pathname */</span></span><br><span class="line">&#125;;   </span><br><span class="line">addrlen:sockaddr_un大小</span><br></pre></td></tr></table></figure><p>提取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr * _Nullable <span class="keyword">restrict</span> addr,</span></span><br><span class="line"><span class="params">  <span class="type">socklen_t</span> * _Nullable <span class="keyword">restrict</span> addrlen)</span>;</span><br><span class="line">addr:<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>结构体来接</span></span><br></pre></td></tr></table></figure><h3 id="本地套接字实现tcp服务器和客户端代码实现"><a href="#本地套接字实现tcp服务器和客户端代码实现" class="headerlink" title="本地套接字实现tcp服务器和客户端代码实现"></a>本地套接字实现tcp服务器和客户端代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="comment">//删除文件，文件如果先前存在会通信不了</span></span><br><span class="line">    unlink(<span class="string">&quot;sock.s&quot;</span>);</span><br><span class="line">    <span class="comment">//创建unix流式套接</span></span><br><span class="line">    <span class="type">int</span> lfd=socket(AF_UNIX,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">myaddr</span>;</span></span><br><span class="line">    myaddr.sun_family=AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(myaddr.sun_path,<span class="string">&quot;sock.s&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bind(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;myaddr,<span class="keyword">sizeof</span>(myaddr));</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//提取</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd=accept(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new client file=%s\n&quot;</span>,cliaddr.sun_path);</span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> n=recv(cfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">            send(cfd,buf,n,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new client file=</span><br><span class="line">hellop</span><br><span class="line"><span class="comment">#使用nc连接服务器</span></span><br><span class="line"> nc -U sock.s</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    unlink(<span class="string">&quot;sock.c&quot;</span>);</span><br><span class="line">    <span class="comment">//创建unix流式套接字</span></span><br><span class="line">    <span class="type">int</span> cfd=socket(AF_UNIX,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果不绑定就会隐式绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">myaddr</span>;</span></span><br><span class="line">    myaddr.sun_family=AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(myaddr.sun_path,<span class="string">&quot;sock.c&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(bind(cfd,(<span class="keyword">struct</span> sockaddr*)&amp;myaddr,<span class="keyword">sizeof</span>(myaddr))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sun_family=AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(seraddr.sun_path,<span class="string">&quot;sock.s&quot;</span>);</span><br><span class="line">    connect(cfd,(<span class="keyword">struct</span> sockaddr *)&amp;seraddr,<span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1500</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> n=read(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        send(cfd,buf,n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        n=recv(cfd,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">我是你弟</span><br><span class="line">我是你弟</span><br></pre></td></tr></table></figure><h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><p>无名管道，命名管道，文件，信号，消息队列，共享内存只能用于本机的进程间通信。</p><p><strong>不同主机间进程通信方法：socket</strong></p><p>socket是一个伪文件。</p><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5.png" alt="5"></p><p><strong>socket必须成对出现。</strong></p><h3 id="大小端："><a href="#大小端：" class="headerlink" title="大小端："></a><strong>大小端：</strong></h3><p><strong>小端：低位存低地址，高位存高地址</strong></p><p><strong>大端：高位存低地址，低位存高地址</strong></p><p><strong>网络上走的数据都是大端的，主机的主机字节序是未知的，需要转换。</strong></p><ul><li><strong>协议头部：如 TCP&#x2F;IP 头、DNS 头等 → 这些字段是标准协议的，必须按规定的大端（网络字节序）</strong></li><li><strong>数据部分（Payload）：完全由你应用程序自己定义</strong></li></ul><p>网络字节序和主机字节序的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;<span class="comment">//主机字节序转网络字节序（4个字节）转ip</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;<span class="comment">//主机字节序转网络字节序（2个字节）转port</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br></pre></td></tr></table></figure><p>示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>]=&#123;<span class="number">192</span>,<span class="number">168</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num=*(<span class="type">int</span> *)buf;</span><br><span class="line">    <span class="type">int</span> sum=htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p=&amp;sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p+<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a=<span class="number">0x0102</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b=htons(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 1 168 192</span><br><span class="line">201</span><br></pre></td></tr></table></figure><p>说明我的电脑是小端。</p><h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af,<span class="type">const</span> <span class="type">char</span> *src,<span class="type">void</span> *dst)</span>;</span><br><span class="line">功能：将点分十进制串转成<span class="number">32</span>位网络大端的数据</span><br><span class="line">参数：af:</span><br><span class="line">AF_INET IPV4</span><br><span class="line">        AF_INET6 IPV6</span><br><span class="line">    src：点分十进制串的首地址</span><br><span class="line">    dst:<span class="number">32</span>位网络数据的首地址</span><br><span class="line">返回值：</span><br><span class="line">     成功：返回<span class="number">1</span></span><br><span class="line">     失败：返回<span class="number">0</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af,<span class="type">const</span> <span class="type">void</span> *src,<span class="type">char</span> *dst,<span class="type">socklen_t</span> size)</span>;</span><br><span class="line">功能：将<span class="number">32</span>位大端的网络数据转成点分十进制串</span><br><span class="line">参数：af:</span><br><span class="line">AF_INET IPV4</span><br><span class="line">        AF_INET6 IPV6</span><br><span class="line">    src：<span class="number">32</span>位网络数据的首地址</span><br><span class="line">    dst: 点分十进制串的首地址</span><br><span class="line">     size:存储点分制串数组的大小 通常写<span class="number">16</span></span><br><span class="line">返回值：</span><br><span class="line">     存储点分制串数组的首地址。</span><br><span class="line">支持IPV4和IPV6。</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[]=<span class="string">&quot;192.168.1.4&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    inet_pton(AF_INET,buf,&amp;num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p=(<span class="type">unsigned</span> <span class="type">char</span> *)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,*p,*(p+<span class="number">1</span>),*(p+<span class="number">2</span>),*(p+<span class="number">3</span>));</span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    inet_ntop(AF_INET,&amp;num,ip,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192 168 1 4</span><br><span class="line">192.168.1.4</span><br></pre></td></tr></table></figure><h3 id="ipv4套接字结构体"><a href="#ipv4套接字结构体" class="headerlink" title="ipv4套接字结构体"></a>ipv4套接字结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sin_family; <span class="comment">/* address family: AF_INET */</span> 对应的协议（ipv4）</span><br><span class="line">  <span class="type">in_port_t</span> sin_port; <span class="comment">/* port in network byte order */</span> 端口</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* internet address */</span> ip地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> s_addr; <span class="comment">/* address in network byte order */</span> ip地址</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ipv6套接字结构体太多了，这里不展示</strong></p><p>因为有这两种套接字结构体，所以我们要统一，方便函数编写。</p><p><strong>通用套接字结构体</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family; <span class="comment">/* address family,AF_xxx*/</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/*14 bytes of protocol address*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h3><p>tcp  特点：出错重传 每次发送数据，对方都会回ACK 可靠</p><h4 id="网络通信流程"><a href="#网络通信流程" class="headerlink" title="网络通信流程"></a>网络通信流程</h4><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6.png" alt="6"></p><h4 id="创建套接字函数socket"><a href="#创建套接字函数socket" class="headerlink" title="创建套接字函数socket()"></a>创建套接字函数socket()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain,<span class="type">int</span> type,<span class="type">int</span> protocol)</span>;</span><br><span class="line">功能：创建套接字</span><br><span class="line">参数：domain:AF_INET</span><br><span class="line">     type:SOCK_STREAM 流式套接字 用于TCP通信</span><br><span class="line">     protocol:<span class="number">0</span></span><br><span class="line">返回值：</span><br><span class="line">     成功：返回文件描述符</span><br><span class="line">     失败：返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="连接服务器函数connect"><a href="#连接服务器函数connect" class="headerlink" title="连接服务器函数connect()"></a>连接服务器函数connect()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> sockaddr * addr,</span></span><br><span class="line"><span class="params">    <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：连接服务器</span><br><span class="line">参数：</span><br><span class="line">    sockfd:socket套接字</span><br><span class="line">    addr:ipv4套接字结构体地址</span><br><span class="line">    addrlen:ipv4套接字结构体的长度</span><br></pre></td></tr></table></figure><h4 id="tcp客户端代码"><a href="#tcp客户端代码" class="headerlink" title="tcp客户端代码"></a>tcp客户端代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="type">int</span> sock_fd;</span><br><span class="line">    sock_fd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock_fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family=AF_INET;</span><br><span class="line">    addr.sin_port=htons(<span class="number">8000</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>,&amp;addr.sin_addr.s_addr);  </span><br><span class="line">    connect(sock_fd,(<span class="keyword">struct</span> sockaddr *)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">//读写数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> n=read(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(sock_fd,buf,n);<span class="comment">//发送数据给服务器</span></span><br><span class="line">        n=read(sock_fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO,buf,n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    close(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcp服务器通信流程"><a href="#tcp服务器通信流程" class="headerlink" title="tcp服务器通信流程"></a>tcp服务器通信流程</h4><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7.png" alt="7"></p><p>对于得到一个新的连接套接字（提取连接部分），服务器是要接受多个客户端连接的，所以先连接上，再分配新的连接和客户端通信。</p><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/8.png" alt="8"></p><h4 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h4><p>给套接字绑定固定的端口和ip</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> sockaddr * addr,</span></span><br><span class="line"><span class="params">    <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">功能：给套接字绑定固定的端口和ip</span><br><span class="line">参数：</span><br><span class="line">    sockfd:套接字</span><br><span class="line">    addr:ipv4套接字结构体地址</span><br><span class="line">    addrlen:ipv4结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回<span class="number">0</span></span><br><span class="line">    失败：返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line">功能：</span><br><span class="line">    监听套接字</span><br><span class="line">参数：</span><br><span class="line">    sockfd:套接字</span><br><span class="line">    backlog:已完成连接队列和未完成连接队列之和的最大值 一般写<span class="number">128</span></span><br></pre></td></tr></table></figure><h4 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr * _Nullable <span class="keyword">restrict</span> addr,</span></span><br><span class="line"><span class="params">  <span class="type">socklen_t</span> * _Nullable <span class="keyword">restrict</span> addrlen)</span>;</span><br><span class="line">功能：</span><br><span class="line">    从已完成连接队列提取新的连接，如果没有新的连接，accept会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    sockfd:套接字</span><br><span class="line">    addr:获取的客户端的ip和端口信息 ipv4套接字结构体</span><br><span class="line">    addrlen:ipv4套接字结构体的大小的地址</span><br><span class="line">返回值：</span><br><span class="line">    新的已连接套接字的文件描述符</span><br></pre></td></tr></table></figure><h4 id="tcp服务器代码"><a href="#tcp服务器代码" class="headerlink" title="tcp服务器代码"></a>tcp服务器代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="type">int</span> lfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family=AF_INET;</span><br><span class="line">    addr.sin_port=htons(<span class="number">8000</span>);</span><br><span class="line">    <span class="comment">//addr.sin_addr.s_addr=INADDR_ANY;//绑定的是通配地址，当前主机的所有ip</span></span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>,&amp;addr.sin_addr.s_addr);</span><br><span class="line">    <span class="type">int</span> ret=bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//提取</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd=accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new client ip=%s port=%d\n&quot;</span>,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,<span class="number">16</span>),ntohs(cliaddr.sin_port));</span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> n=read(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(cfd,buf,n);</span><br><span class="line">        <span class="type">int</span> readn=read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(readn==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端关闭&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc 127.0.0.1 8000 <span class="comment">#可以实现一个客户端，简易聊天</span></span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new client ip=127.0.0.1 port=52486</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><h3 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_process</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pid=waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(pid&lt;=<span class="number">0</span>)&#123;<span class="comment">//小于0 子进程全部退出 =0没有子进程退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child pid =%d&quot;</span>,pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = tcp4bind(<span class="number">8000</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    Listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 提取</span></span><br><span class="line">    <span class="comment">// 回射</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 提取连接</span></span><br><span class="line">        <span class="type">int</span> cfd = Accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;new client ip=%s port=%d\n&quot;</span>, inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="number">16</span>), ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="comment">// fork创建子进程</span></span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork:&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 关闭lfd</span></span><br><span class="line">            close(lfd);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">int</span> n = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read:&quot;</span>);</span><br><span class="line">                    close(cfd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                &#123; <span class="comment">// 对方关闭</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client close\n&quot;</span>);</span><br><span class="line">                    close(cfd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">                    write(cfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// 父进程</span></span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="comment">// 回收</span></span><br><span class="line">            <span class="comment">//注册信号回调</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">            act.sa_flags=<span class="number">0</span>;</span><br><span class="line">            act.sa_handler=free_process;</span><br><span class="line">            sigemptyset(&amp;act.sa_mask);</span><br><span class="line">            sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">            sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里不知道为什么在子进程结束后回调函数没有触发。</p><h3 id="多线程实现并发服务器"><a href="#多线程实现并发服务器" class="headerlink" title="多线程实现并发服务器"></a>多线程实现并发服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">c_info</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> cfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">&#125;CINFO;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">client_fun</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argc&lt;2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果使用pthread_join或pthread_detach()回收资源要具体的线程id,太繁琐，</span></span><br><span class="line">    <span class="comment">//所以在创建线程时赋予detach属性</span></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="type">short</span> port=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> lfd=tcp4bind(port,<span class="literal">NULL</span>);<span class="comment">//创建套接字 绑定</span></span><br><span class="line">    Listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    CINFO *info;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> cfd=Accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;len);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//printf(&quot;new client ip=%s port=%d\n&quot;,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,buf,16),ntohs(cliaddr.sin_port));</span></span><br><span class="line">        <span class="type">pthread_t</span> pthid;</span><br><span class="line">        <span class="comment">//这里如果CINFO info来用是不可以的，在多线程环境下，可能info里面的信息被覆盖，就不是原来的信息，所以放在堆区。</span></span><br><span class="line">        info=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CINFO));</span><br><span class="line">        info-&gt;cfd=cfd;</span><br><span class="line">        info-&gt;cliaddr=cliaddr;</span><br><span class="line">        pthread_create(&amp;pthid,<span class="literal">NULL</span>,client_fun,info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">client_fun</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    CINFO *info=(CINFO *)arg;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new client ip=%s port=%d\n&quot;</span>,inet_ntop(AF_INET,&amp;(info-&gt;cliaddr.sin_addr.s_addr),buf,<span class="number">16</span>),ntohs(info-&gt;cliaddr.sin_port));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        count=read(info-&gt;cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read:&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client close\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">            write(info-&gt;cfd,buf,count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(info-&gt;cfd);</span><br><span class="line">    <span class="built_in">free</span>(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高并发服务器"><a href="#高并发服务器" class="headerlink" title="高并发服务器"></a>高并发服务器</h2><p>为了实现更好的并发：以下由三种方法</p><ol><li>阻塞等待：消耗资源，效率不高</li><li>非阻塞忙轮询：消耗cpu</li><li><strong>多路IO转接(多路IO复用)：这种较为理想，epoll，select，poll都是 依赖 Linux 内核事件机制 实现的 I&#x2F;O 多路复用模型，他们可以监听到任意socket的读写缓冲区发生了变化，应用层进而去处理。这样实现高并发。</strong></li></ol><p><strong>多路IO转接服务器也叫做多任务IO服务器，该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，而是由内核替应用程序监视</strong></p><p><strong>windows 使用select select跨平台</strong></p><p><strong>poll 用的较少</strong></p><p><strong>epoll linux</strong></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ol><li>select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数。</li><li>解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，<strong>select采用的是轮询模型</strong>，会大大降低服务器响应效率，不应在select上投入更多精力。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="comment">/* ... */</span> fd_set;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set * _Nullable <span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">  fd_set * _Nullable <span class="keyword">restrict</span> writefds,</span></span><br><span class="line"><span class="params">  fd_set * _Nullable <span class="keyword">restrict</span> exceptfds,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> timeval * _Nullable <span class="keyword">restrict</span> timeout)</span>;</span><br><span class="line">功能：监听多个文件描述符的属性变化（读，写，异常）</span><br><span class="line">参数：nfds:最大文件描述符+<span class="number">1</span></span><br><span class="line">    readfds:需要监听的读的文件描述符存放集合</span><br><span class="line">    writefds:需要监听的写的文件描述符存放集合 <span class="literal">NULL</span></span><br><span class="line">    exceptfds:需要监听的异常的文件描述符存放集合 <span class="literal">NULL</span></span><br><span class="line">    timeout：多长时间监听一次 固定的时间，限时等待 <span class="literal">NULL</span> 永久监听</span><br><span class="line">返回值：返回的是变化的文件描述符的个数，变化的文件描述符会在readfds保存，但是没有变化的文件描述符会被删掉。</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="type">time_t</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="type">suseconds_t</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set * <span class="built_in">set</span>)</span>;<span class="comment">//从集合删除指定文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set * <span class="built_in">set</span>)</span>;<span class="comment">//文件描述符是否在集合，在就返回1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set * <span class="built_in">set</span>)</span>;<span class="comment">//向集合添加文件描述符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set * <span class="built_in">set</span>)</span>;<span class="comment">//清空文件描述符集</span></span><br></pre></td></tr></table></figure><h3 id="基于select的并发服务器"><a href="#基于select的并发服务器" class="headerlink" title="基于select的并发服务器"></a>基于select的并发服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8888</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字，绑定</span></span><br><span class="line">    <span class="type">int</span> lfd=tcp4bind(PORT,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    Listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="type">int</span> maxfd=lfd;<span class="comment">//最大的文件描述符</span></span><br><span class="line">    fd_set oldset,rset;</span><br><span class="line">    <span class="comment">//清空集合</span></span><br><span class="line">    FD_ZERO(&amp;oldset);</span><br><span class="line">    FD_ZERO(&amp;rset);</span><br><span class="line">    <span class="comment">//将lfd添加到oldset集合中</span></span><br><span class="line">    FD_SET(lfd,&amp;oldset);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        rset=oldset;</span><br><span class="line">        <span class="type">int</span> n=select(maxfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;select:&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//监听到了文件描述符的变化</span></span><br><span class="line">            <span class="comment">//lfd 代表有新的连接到来</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(lfd,&amp;rset))&#123;</span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="comment">//提取新的连接</span></span><br><span class="line">                <span class="type">int</span> cfd=Accept(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;new client ip=%s port=%d\n&quot;</span>,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,<span class="number">16</span>),ntohs(cliaddr.sin_port));</span><br><span class="line">                <span class="comment">//将cfd添加至oldset集合中，以下次监听</span></span><br><span class="line">                FD_SET(cfd,&amp;oldset);</span><br><span class="line">                <span class="comment">//更新maxfd</span></span><br><span class="line">                <span class="keyword">if</span>(cfd&gt;maxfd)&#123;</span><br><span class="line">                    maxfd=cfd;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果只有lfd变化，continue</span></span><br><span class="line">                <span class="keyword">if</span>(--n==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cfd  遍历lfd之后的文件描述符是否在rset集合中，如果在则cfd变化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=lfd+<span class="number">1</span>;i&lt;=maxfd;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(i,&amp;rset))&#123;</span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1500</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="type">int</span> ret=Read(i,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;<span class="comment">//出错，将cfd关闭，从oldset删除cfd;</span></span><br><span class="line">                        perror(<span class="string">&quot;Read&quot;</span>);</span><br><span class="line">                        close(i);</span><br><span class="line">                        FD_CLR(i,&amp;oldset);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client close\n&quot;</span>);</span><br><span class="line">                        close(i);</span><br><span class="line">                        FD_CLR(i,&amp;oldset);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">                        Write(i,buf,ret);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new client ip=127.0.0.1 port=54938</span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">client close</span><br></pre></td></tr></table></figure><p><strong>select的优缺点：</strong></p><p><strong>优点：跨平台</strong></p><p><strong>缺点：</strong></p><p><strong>文件描述符1024的限制 由于FD_SETSIZE的限制。只是返回变化的文件描述符的个数，具体是哪些变化，需要遍历。</strong></p><p><strong>每次都需要将需要监听的文件描述符集合由应用层拷贝到内核，也比较费时间。</strong></p><p><strong>当大量并发，少量活跃，select效率低。</strong></p><p><strong>假设现在4-1023个文件描述符需要监听，但是5-1000这些文件描述符关闭了？</strong></p><p><strong>列一个数组存储监听的文件描述符列表，文件描述符关闭就把他的值从数组覆盖掉，再确认那些文件描述符读或写，直接遍历这个数组，效率高些，但是还是很一般。</strong></p><p><strong>其实我们可以在文件描述符表把后面的文件描述符提前，让文件描述符更紧凑，这样效率更高，我们可以使用dup2函数把前面空余的文件描述符复制后面的，再把后面的关掉。</strong></p><p><strong>假设4-1023个文件描述符需要监听，但是只有5，1002发来消息：无解</strong></p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd * fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line">功能：监听多个文件描述符的属性变化</span><br><span class="line">参数:</span><br><span class="line">fds:监听的数组首元素地址</span><br><span class="line">    nfds:数组有效元素的最大下标+<span class="number">1</span></span><br><span class="line">    timeout:超时时间 <span class="number">-1</span>是永久监听 &gt;=<span class="number">0</span>限时等待</span><br><span class="line">数组元素：<span class="keyword">struct</span> pollfd</span><br><span class="line"><span class="keyword">struct</span> pollfd &#123;</span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span> 需要监听的文件描述符</span><br><span class="line">  <span class="type">short</span> events; <span class="comment">/* requested events */</span> 需要监听的文件描述符什么事件 POLLIN 读事件 POLLOUT 写事件</span><br><span class="line">  <span class="type">short</span> revents; <span class="comment">/* returned events */</span> 返回监听到的事件</span><br><span class="line">&#125;;        </span><br></pre></td></tr></table></figure><p><strong>poll相对于select的优缺点：</strong></p><p><strong>优点：</strong></p><p><strong>没有文件描述符1024的限制</strong></p><p><strong>请求和返回是分离的</strong></p><p><strong>缺点和select一样：</strong></p><p><strong>每次都需要将需要监听的文件描述符从应用层拷贝到内核</strong></p><p><strong>每次都需要将数组的元素遍历一遍才知道那一个文件描述符变化了</strong></p><p><strong>大量并发，少量活跃，效率低。</strong></p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/12.png" alt="12"></p><p><strong>红黑树的节点不只是文件描述符。</strong></p><p><strong>epoll API</strong></p><p><strong>1.创建红黑树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">参数：</span><br><span class="line">    size:监听的文件描述符上限，<span class="number">2.6</span>版本之后写<span class="number">1</span>即可会自动扩展</span><br><span class="line">返回值：</span><br><span class="line">    返回树的句柄</span><br></pre></td></tr></table></figure><p><strong>2.上树 下树 修改节点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> epoll_event * _Nullable event)</span>;</span><br><span class="line">参数：</span><br><span class="line">    epfd:树的句柄</span><br><span class="line">    op:选项：EPOLL_CTL_ADD 上树 EPOLL_CTL_MOD 修改节点 EPOLL_CTL_DEL 下树</span><br><span class="line">    fd:上树下树的文件描述符</span><br><span class="line">    event:上树的节点</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">   <span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span> 需要监听的事件 EPOLLIN　读事件　EPOLLOUT 写事件</span><br><span class="line">   <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span> 需要监听的文件描述符</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">   <span class="type">void</span> * ptr;</span><br><span class="line">   <span class="type">int</span> fd;</span><br><span class="line">   <span class="type">uint32_t</span> u32;</span><br><span class="line">   <span class="type">uint64_t</span> u64;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> <span class="title">epoll_data_t</span>;</span></span><br></pre></td></tr></table></figure><p><strong>3.监听</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line">功能：监听树上文件描述符的变化</span><br><span class="line">参数：</span><br><span class="line">epfd:树的句柄</span><br><span class="line">    events：接收变化节点的数组的首地址</span><br><span class="line">    maxevents：数组元素的个数</span><br><span class="line">    timeout：<span class="number">-1</span> 永久监听 大于等于<span class="number">0</span>限时等待</span><br><span class="line">返回值：</span><br><span class="line">    返回的是变化的文件描述符个数</span><br></pre></td></tr></table></figure><p>示例代码：父子进程通过管道通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">        <span class="type">char</span> ch=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="built_in">memset</span>(buf,ch++,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">            write(fd[<span class="number">1</span>],buf,<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//创建树</span></span><br><span class="line">        <span class="type">int</span> epfd=epoll_create(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//上树</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>,<span class="title">evs</span>[1];</span></span><br><span class="line">        ev.data.fd=fd[<span class="number">0</span>];</span><br><span class="line">        ev.events=EPOLLIN;</span><br><span class="line">        epoll_ctl(epfd,EPOLL_CTL_ADD,fd[<span class="number">0</span>],&amp;ev);</span><br><span class="line">        <span class="comment">//监听</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> n=epoll_wait(epfd,evs,<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">128</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">int</span> ret=read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    close(fd[<span class="number">0</span>]);</span><br><span class="line">                    epoll_ctl(epfd,EPOLL_CTL_DEL,fd[<span class="number">0</span>],&amp;ev);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">bbbbb</span><br><span class="line">ccccc</span><br><span class="line">ddddd</span><br><span class="line">eeeee</span><br><span class="line">fffff</span><br><span class="line">ggggg</span><br><span class="line">hhhhh</span><br></pre></td></tr></table></figure><h3 id="基于epoll的高并发服务器"><a href="#基于epoll的高并发服务器" class="headerlink" title="基于epoll的高并发服务器"></a>基于epoll的高并发服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字 绑定</span></span><br><span class="line">    <span class="type">int</span> lfd=tcp4bind(<span class="number">8000</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    Listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//创建树</span></span><br><span class="line">    <span class="type">int</span> epfd=epoll_create(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将lfd上树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>,<span class="title">evs</span>[1024];</span></span><br><span class="line">    ev.data.fd=lfd;</span><br><span class="line">    ev.events=EPOLLIN;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev);</span><br><span class="line">    <span class="comment">//while监听</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> nready=epoll_wait(epfd,evs,<span class="number">1024</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nready&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait:&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nready==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nready;i++)&#123;</span><br><span class="line">                <span class="comment">//判断lfd变化，并且是读事件变化</span></span><br><span class="line">                <span class="keyword">if</span>(evs[i].data.fd==lfd&amp;&amp;evs[i].events &amp; EPOLLIN)&#123;</span><br><span class="line">                    <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                    <span class="type">char</span> ip[<span class="number">16</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="type">socklen_t</span> len=<span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                    <span class="comment">//提取新的连接</span></span><br><span class="line">                    <span class="type">int</span> cfd=Accept(lfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;new client ip=%s port=%d\n&quot;</span>,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,<span class="number">16</span>),ntohs(cliaddr.sin_port));</span><br><span class="line">                    <span class="comment">//将cfd上树</span></span><br><span class="line">                    ev.data.fd=cfd;</span><br><span class="line">                    ev.events=EPOLLIN;</span><br><span class="line">                    epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(evs[i].events &amp; EPOLLIN)<span class="comment">//cfd变化,而且是读事件变化</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="type">int</span> n=read(evs[i].data.fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;read:&quot;</span>);</span><br><span class="line">                        epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&amp;evs[i]);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;<span class="comment">//客户端关闭</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client close&quot;</span>);</span><br><span class="line">                        close(evs[i].data.fd);</span><br><span class="line">                        epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&amp;evs[i]);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">                        write(evs[i].data.fd,buf,n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new client ip=127.0.0.1 port=56746</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="epoll的两种工作方式"><a href="#epoll的两种工作方式" class="headerlink" title="epoll的两种工作方式"></a>epoll的两种工作方式</h3><p><strong>在电路中，存在高电平和低电平，水平触发：持续的高电平或者低电平。边沿触发：电平有高到低的一个变化 或者由低到高的变化。对于epoll_wait的水平触发 LT，边沿触发 ET,对于读缓冲区使用水平触发，epoll_wait(系统调用)触发很频繁，所以使用边沿触发。写缓冲区一般用边沿触发</strong></p><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/13.png" alt="13"></p><p><strong>如何使用边沿触发呢，读缓冲区默认是水平触发。我们可以在上树时，需要设置需要监听的事件，再加上个EPOLLET</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ev.events=EPOLLIN | EPOLLET</span><br></pre></td></tr></table></figure><h3 id="基于epoll的高并发服务器-加入边沿触发和优化代码"><a href="#基于epoll的高并发服务器-加入边沿触发和优化代码" class="headerlink" title="基于epoll的高并发服务器(加入边沿触发和优化代码)"></a>基于epoll的高并发服务器(加入边沿触发和优化代码)</h3><p>将cfd设置边沿触发。设置边沿触发就要非阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建套接字 绑定</span></span><br><span class="line">    <span class="type">int</span> lfd = tcp4bind(<span class="number">8000</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    Listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 创建树</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将lfd上树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">evs</span>[1024];</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="comment">// while监听</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nready = epoll_wait(epfd, evs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;epoll_wait .........................\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait:\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nready == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nready; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断lfd变化，并且是读事件变化</span></span><br><span class="line">                <span class="keyword">if</span> (evs[i].data.fd == lfd &amp;&amp; evs[i].events &amp; EPOLLIN)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                    <span class="comment">// 提取新的连接</span></span><br><span class="line">                    <span class="type">int</span> cfd = Accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;new client ip=%s port=%d\n&quot;</span>, inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="number">16</span>), ntohs(cliaddr.sin_port));</span><br><span class="line">                    <span class="comment">// 设置cfd为非阻塞</span></span><br><span class="line">                    <span class="type">int</span> flags = fcntl(cfd, F_GETFL); <span class="comment">// 获取cfd的标志位</span></span><br><span class="line">                    flags |= O_NONBLOCK;</span><br><span class="line">                    fcntl(cfd, F_SETFL, flags);</span><br><span class="line">                    <span class="comment">// 将cfd上树</span></span><br><span class="line">                    ev.data.fd = cfd;</span><br><span class="line">                    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (evs[i].events &amp; EPOLLIN) <span class="comment">// cfd变化,而且是读事件变化</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                    &#123;   <span class="comment">//使用循环读，因为cfd采用的边沿模式读，一次可能读不完需要循环读保证读完</span></span><br><span class="line">                        <span class="comment">//但是read循环读的话会产生阻塞，这个程序就无法监听了，所以设置cfd为非阻塞</span></span><br><span class="line">                        <span class="type">char</span> buf[<span class="number">4</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="comment">//如果读一个缓冲区，缓冲区没有数据，如果是带阻塞，就阻塞等待</span></span><br><span class="line">                        <span class="comment">//如果是非阻塞，返回值就等于-1,并且会将errno的值置为EAGAIN</span></span><br><span class="line">                        <span class="comment">//所以在非阻塞这里就出现问题了，n&lt;0,可能是出错或者没有数据，没有数据不必下树，退出循环读。出错下树</span></span><br><span class="line">                        <span class="type">int</span> n = read(evs[i].data.fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//缓冲区读干净了，跳出读循环</span></span><br><span class="line">                            <span class="keyword">if</span>(errno==EAGAIN)&#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//普通错误</span></span><br><span class="line">                            perror(<span class="string">&quot;read:&quot;</span>);</span><br><span class="line">                            epoll_ctl(epfd, EPOLL_CTL_DEL, evs[i].data.fd, &amp;evs[i]);</span><br><span class="line">                            close(evs[i].data.fd);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                        &#123; <span class="comment">// 客户端关闭</span></span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;client close&quot;</span>);</span><br><span class="line">                            close(evs[i].data.fd);</span><br><span class="line">                            epoll_ctl(epfd, EPOLL_CTL_DEL, evs[i].data.fd, &amp;evs[i]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//这里为什么不用printf了呢，因为printf输出字符串时，会去找字符串结束的\0但是网络传输收到的是没有\0(需要主动方手动添加)</span></span><br><span class="line">                            <span class="comment">//没有\0,printf就会出错，但是使用write函数就不会</span></span><br><span class="line">                            write(STDOUT_FILENO,buf,n);</span><br><span class="line">                            write(evs[i].data.fd, buf, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll反应堆Reactor"><a href="#epoll反应堆Reactor" class="headerlink" title="epoll反应堆Reactor"></a>epoll反应堆Reactor</h3><p><strong>epoll反应堆就是把这三个东西：文件描述符 事件 回调函数封装在一起。</strong></p><p><strong>结构体来封装。</strong></p><p>反应堆模式（Reactor Pattern）是一种事件驱动的设计模式，用于处理并发 I&#x2F;O 操作。核心思想：</p><ul><li><strong>事件驱动</strong>：等待多个事件（如网络连接的读写事件）发生；</li><li><strong>事件分发</strong>：事件就绪时，分发给相应的处理器执行；</li><li><strong>非阻塞 I&#x2F;O</strong>：避免线程阻塞，提高资源利用率。</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>线程池，事先创建几个线程，不停取任务，如果没有任务休眠，省去了不停的创建线程销毁线程的事件和资源</strong></p><p><strong>注意：线程池 处理的单个任务所需要处理的时间必须很短。</strong></p><p><strong>一个锁</strong></p><p><strong>两个条件变量</strong></p><p><strong>循环队列</strong></p><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/14.png" alt="14"></p><h2 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h2><p><code>libevent</code> 是一个 <strong>高性能事件通知库</strong>，用于在不同平台上进行 <strong>异步事件驱动编程</strong>，特别适合开发网络服务（如 HTTP 服务器、聊天服务等）。它封装了底层的 <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code> 等系统调用，提供了统一、跨平台的接口。</p><h3 id="libevent事件触发流程"><a href="#libevent事件触发流程" class="headerlink" title="libevent事件触发流程"></a>libevent事件触发流程</h3><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.png" alt="15"></p><h3 id="libevent的使用"><a href="#libevent的使用" class="headerlink" title="libevent的使用"></a>libevent的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建event_base根节点</span><br><span class="line"><span class="keyword">struct</span> event_base *<span class="title function_">event_base_new</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">返回值就是event_base根节点，因为libevent底层默认使用epoll,所以定义了一个自己封装的节点</span><br><span class="line">释放根节点</span><br><span class="line"><span class="type">void</span> <span class="title function_">event_base_free</span><span class="params">(<span class="keyword">struct</span> event_base *)</span>;</span><br><span class="line">循环监听</span><br><span class="line"><span class="type">int</span> <span class="title function_">event_base_dispatch</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span>;</span><br><span class="line">相当于<span class="keyword">while</span>(<span class="number">1</span>)&#123;epoll_wait()&#125;<span class="comment">//循环监听</span></span><br><span class="line">退出循环监听</span><br><span class="line"><span class="type">int</span> <span class="title function_">event_base_loopexit</span><span class="params">(<span class="keyword">struct</span> event_base *base,<span class="type">const</span> <span class="keyword">struct</span> timeval*tv)</span>;<span class="comment">//等待固定时间退出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">event_base_loopbreak</span><span class="params">(<span class="keyword">struct</span> event_base *base)</span>;<span class="comment">//立即退出</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始化上树节点</span><br><span class="line"><span class="keyword">struct</span> event*<span class="title function_">event_new</span><span class="params">(<span class="keyword">struct</span> event_base *base,<span class="type">evutil_socket_t</span> fd,</span></span><br><span class="line"><span class="params">                       <span class="type">short</span> events,event_callback_fn cb,<span class="type">void</span> *arg)</span>;</span><br><span class="line">参数：</span><br><span class="line">    base:event_base根节点</span><br><span class="line">    fd:上树的文件描述符</span><br><span class="line">    events:监听的事件 EV_TIMEOUT 超时事件 EV_READ 读事件 EV_WRITE 写事件 EV_SIGNAL 信号事件 EV_PERSIST 周期性触发</span><br><span class="line">   cb:回调函数</span><br><span class="line">       <span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*event_callback_fn)</span><span class="params">(<span class="type">evutil_socket_t</span> fd,<span class="type">short</span> events,<span class="type">void</span> *arg)</span>;</span><br><span class="line">返回值:初始化好的节点的地址        </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">节点上树</span><br><span class="line"><span class="type">int</span> <span class="title function_">event_add</span><span class="params">(<span class="keyword">struct</span> event*ev,<span class="type">const</span> <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line">参数:</span><br><span class="line">ev:上树节点的地址</span><br><span class="line">    timeout:<span class="literal">NULL</span> 永久监听 固定时间 限时等待</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">节点下树</span><br><span class="line"><span class="type">int</span> <span class="title function_">event_del</span><span class="params">(<span class="keyword">struct</span> event *ev)</span>;</span><br><span class="line">参数：</span><br><span class="line">    ev:下树节点的地址</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">释放节点</span><br><span class="line"><span class="type">void</span> <span class="title function_">event_free</span><span class="params">(<span class="keyword">struct</span> event *ev)</span>;</span><br></pre></td></tr></table></figure><h3 id="libevent编写tcp服务器代码"><a href="#libevent编写tcp服务器代码" class="headerlink" title="libevent编写tcp服务器代码"></a>libevent编写tcp服务器代码</h3><p>创建套接字</p><p>绑定</p><p>监听</p><p>创建event_base根节点</p><p>初始上树节点 lfd</p><p>上树</p><p>循环监听</p><p>收尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cfdcb</span><span class="params">(<span class="type">int</span> cfd,<span class="type">short</span> event,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n=Read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;err or close&quot;</span>);</span><br><span class="line">       <span class="comment">// event_del()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">        Write(cfd,buf,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lfdcb</span><span class="params">(<span class="type">int</span> lfd,<span class="type">short</span> event,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>=</span>(<span class="keyword">struct</span> event_base *)arg;</span><br><span class="line">    <span class="comment">//提取新的cfd</span></span><br><span class="line">    <span class="type">int</span> cfd=Accept(lfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//cfd初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>=</span>event_new(base,cfd,EV_READ|EV_PERSIST,cfdcb,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//cfd上树</span></span><br><span class="line">    event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="comment">//邦定</span></span><br><span class="line">    <span class="type">int</span> lfd=tcp4bind(<span class="number">8000</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    Listen(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//创建event_base根节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>=</span>event_base_new();</span><br><span class="line">    <span class="comment">//初始化lfd上树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span>=</span>event_new(base,lfd,EV_READ|EV_PERSIST,lfdcb,base);</span><br><span class="line">    <span class="comment">//上树</span></span><br><span class="line">    event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    event_base_dispatch(base);<span class="comment">//阻塞</span></span><br><span class="line">    <span class="comment">//收尾</span></span><br><span class="line">    event_free(ev);</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>在下树的时候有问题，下树时需要所属的struct event <em>ev，但是回调函数也是在event_new函数执行后注册，但是那个时候ev还没有生成，所以不能依靠传参，所以我们要定义一个全局数组，数组成员是自定义结构体包含fd和ev,ev生成后放进数组里，执行读回调后，通过fd查找对应得ev下树。</em></em></p><p><strong>还有一种就是不用定义数组，直接自定义结构体包含fd和ev传过去。结构体在传之前先malloc,直接定义会因为函数结束而被释放。之前是因为修改的是ev,传的也是ev冲突了，这下改成传的是结构体指针，改的结构体的ev,这不冲突，所以可行。</strong></p><h3 id="bufferevent事件"><a href="#bufferevent事件" class="headerlink" title="bufferevent事件"></a>bufferevent事件</h3><p><strong>普通的event事件  文件描述符  事件(底层缓冲区的读事件或者写事件)触发  回调</strong></p><p><strong>高级的event事件 bufferevent事件</strong></p><p><strong>bufferevent &#x3D; 封装好的一套“异步读写 + 自动缓冲 + 错误处理 + 回调触发 + 高并发”解决方案，是 libevent 最推荐用的通信组件。</strong></p><p>不同点</p><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/16.png" alt="16"></p><p>核心：一个文件描述符 两个缓冲区 三个回调</p><h3 id="bufferevent监听流程"><a href="#bufferevent监听流程" class="headerlink" title="bufferevent监听流程"></a>bufferevent监听流程</h3><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/17.png" alt="17"></p><h3 id="bufferevent-API"><a href="#bufferevent-API" class="headerlink" title="bufferevent API"></a>bufferevent API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建新的节点</span><br><span class="line"><span class="keyword">struct</span> bufferevent *<span class="title function_">bufferevent_socket_new</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">    <span class="type">evutil_socket_t</span> fd,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> options</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">参数：</span><br><span class="line">    base:event_base 根节点</span><br><span class="line">    fd:要初始化上树的文件描述符</span><br><span class="line">    options:BEV_OPT_CLOSE_ON_FREE在 bufferevent_free() 时自动关闭 socket（常用）</span><br><span class="line">        BEV_OPT_THREADSAFE让 bufferevent 在多线程中线程安全</span><br><span class="line">返回值：新建节点的地址</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">设置节点的回调</span><br><span class="line"><span class="type">void</span> <span class="title function_">bufferevent_setcb</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> bufferevent *bev,</span></span><br><span class="line"><span class="params">    bufferevent_data_cb readcb,</span></span><br><span class="line"><span class="params">    bufferevent_data_cb writecb,</span></span><br><span class="line"><span class="params">    bufferevent_event_cb eventcb,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *cbarg</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">参数:</span><br><span class="line">bev:新建的节点的地址</span><br><span class="line">    readcb:读回调</span><br><span class="line">    writecb:写回调</span><br><span class="line">    eventcb：异常回调</span><br><span class="line">    cbarg：传给回调函数的参数</span><br><span class="line">    回调函数：</span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*bufferevent_data_cb)</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *ctx)</span>;<span class="comment">//读写回调</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*bufferevent_event_cb)</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> events, <span class="type">void</span> *ctx)</span>;<span class="comment">//事件回调</span></span><br><span class="line">事件回调 events会写明触发回调的原因</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">让事件使能</span><br><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_enable</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> events)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_disable</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> events)</span>;</span><br><span class="line">参数：</span><br><span class="line">    bev:新建的节点的地址</span><br><span class="line">    events:使生效或使失效的事件 EV_READ EV_WRITE</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发送数据</span><br><span class="line">将数据写入 bufferevent 的输出缓冲区，异步发送（不会立即写到 socket 上）发送后会触发回调</span><br><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_write</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">接受数据</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">bufferevent_read</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *data, <span class="type">size_t</span> size)</span>;</span><br><span class="line">将从 bev 的读缓冲区中读取最多 size 字节的数据，复制到 data。同时将读到的数据从bufferevent的读缓冲区清除</span><br><span class="line">返回实际读取的字节数。    </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">连接侦听器</span><br><span class="line">创建套接字 绑定 监听 提取</span><br><span class="line"><span class="keyword">struct</span> evconnlistener *<span class="title function_">evconnlistener_new_bind</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">    evconnlistener_cb cb,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *ctx,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> backlog,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> socklen</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">参数：</span><br><span class="line">    base：根节点</span><br><span class="line">    cb:提取套接字cfd（连接到来）调用的回调</span><br><span class="line">        回调函数：</span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">evconnlistener_cb</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> evconnlistener *listener,</span></span><br><span class="line"><span class="params">            <span class="type">evutil_socket_t</span> fd,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> socklen,</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *ctx</span></span><br><span class="line"><span class="params">        )</span>;</span><br><span class="line">参数：</span><br><span class="line">            listener：连接侦听器的地址</span><br><span class="line">            fd：提取后的新文件描述符cfd</span><br><span class="line">            addr:客户端的地址信息</span><br><span class="line">            socklen：addr的大小</span><br><span class="line">            ctx：evconnlistener_new_bind传给回调函数的参数</span><br><span class="line">    ctx:传给回调函数的参数</span><br><span class="line">    flags:</span><br><span class="line">        LEV_OPT_CLOSE_ON_FREE关闭时自动释放（推荐）</span><br><span class="line">        LEV_OPT_REUSEABLE设置 SO_REUSEADDR 端口复用（推荐）</span><br><span class="line">        LEV_OPT_THREADSAFE线程安全</span><br><span class="line">        LEV_OPT_LEAVE_SOCKETS_BLOCKING  文件描述符为阻塞的</span><br><span class="line">    backlog:<span class="number">-1</span> 监听队列长度自动填充</span><br><span class="line">    sa：绑定的地址信息</span><br><span class="line">    socklen：sa的大小     </span><br><span class="line">返回值：连接侦听器的地址</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">这个是用来写tcp客户端的</span><br><span class="line">创建套接字 连接服务器</span><br><span class="line">但是要先有节点</span><br><span class="line"><span class="keyword">struct</span> bufferevent *<span class="title function_">bufferevent_socket_new</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">    <span class="type">evutil_socket_t</span> fd,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> options</span></span><br><span class="line"><span class="params">)</span>;这里fd为<span class="number">-1.</span>    </span><br><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_socket_connect</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> bufferevent *bev,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *address,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> addrlen</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line">参数：</span><br><span class="line">    bev:新建的节点</span><br><span class="line">    address:服务器的地址信息</span><br><span class="line">    addrlen：address长度</span><br></pre></td></tr></table></figure><h3 id="基于hello-world-c的服务端代码"><a href="#基于hello-world-c的服务端代码" class="headerlink" title="基于hello-world.c的服务端代码"></a>基于hello-world.c的服务端代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This example program provides a trivial server program that listens for TCP</span></span><br><span class="line"><span class="comment">  connections on port 9995.  When they arrive, it writes a short message to</span></span><br><span class="line"><span class="comment">  each client connection, and closes each connection once it is flushed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Where possible, it exits cleanly in response to a SIGINT (ctrl-c).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _XOPEN_SOURCE_EXTENDED</span></span><br><span class="line"><span class="meta">#  <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> MESSAGE[] = <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> PORT = <span class="number">9995</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">listener_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *, <span class="type">evutil_socket_t</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> sockaddr *, <span class="type">int</span> socklen, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">conn_writecb</span><span class="params">(<span class="keyword">struct</span> bufferevent *, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">conn_eventcb</span><span class="params">(<span class="keyword">struct</span> bufferevent *, <span class="type">short</span>, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">conn_readcb</span><span class="params">(<span class="keyword">struct</span> bufferevent *, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">signal_cb</span><span class="params">(<span class="type">evutil_socket_t</span>, <span class="type">short</span>, <span class="type">void</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span><span class="comment">//创建根节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">signal_event</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">WSADATA wsa_data;</span><br><span class="line">WSAStartup(<span class="number">0x0201</span>, &amp;wsa_data);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">base = event_base_new();</span><br><span class="line"><span class="keyword">if</span> (!base) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not initialize libevent!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接侦听器</span></span><br><span class="line">listener = evconnlistener_new_bind(base, listener_cb, (<span class="type">void</span> *)base,</span><br><span class="line">    LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, <span class="number">-1</span>,</span><br><span class="line">    (<span class="keyword">struct</span> sockaddr*)&amp;<span class="built_in">sin</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!listener) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not create a listener!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建信号触发的节点</span></span><br><span class="line">signal_event = evsignal_new(base, SIGINT, signal_cb, (<span class="type">void</span> *)base);</span><br><span class="line"><span class="comment">//将信号节点上树</span></span><br><span class="line"><span class="keyword">if</span> (!signal_event || event_add(signal_event, <span class="literal">NULL</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not create/add a signal event!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event_base_dispatch(base);<span class="comment">//循环监听</span></span><br><span class="line"></span><br><span class="line">evconnlistener_free(listener);<span class="comment">//释放连接侦听器</span></span><br><span class="line">event_free(signal_event);<span class="comment">//释放信号节点</span></span><br><span class="line">event_base_free(base);<span class="comment">//释放event_base根节点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">listener_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener, <span class="type">evutil_socket_t</span> fd,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> sockaddr *sa, <span class="type">int</span> socklen, <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> user_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line"><span class="comment">//将fd上树</span></span><br><span class="line"><span class="comment">//新建一个bufferevent节点</span></span><br><span class="line">bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"><span class="keyword">if</span> (!bev) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error constructing bufferevent!&quot;</span>);</span><br><span class="line">event_base_loopbreak(base);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置回调</span></span><br><span class="line">bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, <span class="literal">NULL</span>);</span><br><span class="line">bufferevent_enable(bev, EV_WRITE | EV_READ);<span class="comment">//设置读写事件使能</span></span><br><span class="line"><span class="comment">//bufferevent_disable(bev, EV_READ);//设置读事件非使能</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bufferevent_write(bev, MESSAGE, strlen(MESSAGE));//给cfd发送消息 hello world</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">conn_readcb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *user_data)</span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1500</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> n=bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="comment">//不用担心出错，出错会触发事件回调</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">bufferevent_write(bev, buf,n);<span class="comment">//给cfd发送消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">conn_writecb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">output</span> =</span> bufferevent_get_output(bev);<span class="comment">//获取缓冲区类型</span></span><br><span class="line"><span class="keyword">if</span> (evbuffer_get_length(output) == <span class="number">0</span>) &#123;<span class="comment">//判断==0则应用层缓冲区为空，发送完毕</span></span><br><span class="line"><span class="comment">//printf(&quot;flushed answer\n&quot;);</span></span><br><span class="line"><span class="comment">//bufferevent_free(bev);//释放节点 自动关闭连接</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">conn_eventcb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> events, <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (events &amp; BEV_EVENT_EOF) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Connection closed.\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Got an error on the connection: %s\n&quot;</span>,</span><br><span class="line">    strerror(errno));<span class="comment">/*XXX win32*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* None of the other events can happen here, since we haven&#x27;t enabled</span></span><br><span class="line"><span class="comment"> * timeouts */</span></span><br><span class="line">bufferevent_free(bev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">signal_cb</span><span class="params">(<span class="type">evutil_socket_t</span> sig, <span class="type">short</span> events, <span class="type">void</span> *user_data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> user_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span> =</span> &#123; <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Caught an interrupt signal; exiting cleanly in two seconds.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">event_base_loopexit(base, &amp;delay);<span class="comment">//退出循环监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webserver服务器流程"><a href="#webserver服务器流程" class="headerlink" title="webserver服务器流程"></a>webserver服务器流程</h2><p><img src="/2025/07/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/18.png" alt="18"></p><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><p>html 超文本标签语句(超文本标记语言)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>我是一个html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&#x27;7&#x27;</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&#x27;7&#x27;</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>http请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请求行：GET /demo.html HTTP/1.1\r\n</span><br><span class="line"></span><br><span class="line">请求方式  /请求的内容   版本\r\n</span><br><span class="line"></span><br><span class="line">请求头</span><br><span class="line">空行\r\n</span><br><span class="line">数据</span><br></pre></td></tr></table></figure><table><thead><tr><th>部分</th><th>内容示例</th></tr></thead><tbody><tr><td><strong>请求行</strong></td><td><code>GET /index.html HTTP/1.1</code>包含：方法、请求目标路径、HTTP版本号</td></tr><tr><td><strong>请求头</strong></td><td>一组键值对，每行一个，例如：<code>Host: www.example.com``User-Agent: curl/7.81.0</code></td></tr><tr><td><strong>空行</strong></td><td>请求头与请求体之间必须有一个空行</td></tr><tr><td><strong>请求体</strong></td><td>（可选）提交的数据，比如表单、JSON、文件上传等</td></tr></tbody></table><p>http应答</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">状态行：HTTP/1.1 200 OK\r\n</span><br><span class="line">版本    状态码 状态信息\r\n</span><br><span class="line">消息报头：</span><br><span class="line">文件类型（必填的）</span><br><span class="line">文件的长度（可填可不填，填了要求一定对）</span><br><span class="line">空行\r\n</span><br><span class="line">发送文件</span><br></pre></td></tr></table></figure><table><thead><tr><th>部分</th><th>示例与说明</th></tr></thead><tbody><tr><td><strong>状态行</strong></td><td><code>HTTP/1.1 200 OK</code>包含：协议版本、状态码、状态短语</td></tr><tr><td><strong>响应头</strong></td><td>键值对形式，如：<code>Content-Type: text/html``Content-Length: 123</code></td></tr><tr><td><strong>空行</strong></td><td>用于分隔响应头和响应体</td></tr><tr><td><strong>响应体</strong></td><td>实际返回的内容，如网页HTML、JSON数据、图片等（可选）</td></tr></tbody></table><p>状态码</p><table><thead><tr><th>状态码</th><th>名称</th><th>含义描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功，服务器正常返回了请求的数据。</td></tr><tr><td>301</td><td>Moved Permanently</td><td>资源已永久移动到新位置，浏览器会自动跳转，搜索引擎会更新索引。</td></tr><tr><td>302</td><td>Found</td><td>资源临时移动，原 URL 仍然有效，浏览器会自动跳转。</td></tr><tr><td>400</td><td>Bad Request</td><td>请求语法错误或参数无效，服务器无法理解请求。</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求需要身份认证（未登录或 token 无效）。</td></tr><tr><td>403</td><td>Forbidden</td><td>已认证但没有权限访问该资源。</td></tr><tr><td>404</td><td>Not Found</td><td>请求的资源不存在，可能是 URL 错误或资源已删除。</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，可能是代码异常或服务器故障。</td></tr></tbody></table><p>读取目录下的所有文件名</p><p>以前用readdir函数，还有一个scandir</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  <span class="type">ino_t</span> d_ino; <span class="comment">/* Inode number */</span></span><br><span class="line">  <span class="type">off_t</span> d_off; <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* Length of this record */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> d_type;</span><br><span class="line">  <span class="comment">/* Type of file; not supported</span></span><br><span class="line"><span class="comment">                                          by all filesystem types */</span></span><br><span class="line">  <span class="type">char</span> d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">mylist</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">scandir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> dirp,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> dirent ** * <span class="keyword">restrict</span> namelist,</span></span><br><span class="line"><span class="params">  <span class="type">int</span>( * filter)(<span class="type">const</span> <span class="keyword">struct</span> dirent * ),</span></span><br><span class="line"><span class="params">  <span class="type">int</span>( * compar)(<span class="type">const</span> <span class="keyword">struct</span> dirent ** ,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> dirent ** ))</span>;</span><br><span class="line">参数:</span><br><span class="line">dirp：目录下的路径名</span><br><span class="line">    namelist：mylist地址</span><br><span class="line">    filter：过滤的函数入口地址</span><br><span class="line">    compar：排序函数入口地址 alphasort(字母排序)  </span><br><span class="line">返回值：读取文件的个数</span><br></pre></td></tr></table></figure><h3 id="webserver代码（基于epoll）"><a href="#webserver代码（基于epoll）" class="headerlink" title="webserver代码（基于epoll）"></a>webserver代码（基于epoll）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8889</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_header</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> code, <span class="type">char</span> *info, <span class="type">char</span> *filetype, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 发送状态行</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, code, info);</span><br><span class="line">    send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 发送消息头</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type:%s\r\n&quot;</span>, filetype);</span><br><span class="line">    send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Length:%d\r\n&quot;</span>, length);</span><br><span class="line">        send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 空行</span></span><br><span class="line">    send(cfd, <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_file</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span> *path, <span class="keyword">struct</span> epoll_event *ev, <span class="type">int</span> epfd, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//这里发送大文件时会出现无法播放的问题，写缓冲区可能满，写不进去，</span></span><br><span class="line">            <span class="comment">//写不进去，监听EPOLLOUT,将没有发送的数据保存，等写事件触发，写出去</span></span><br><span class="line">            <span class="comment">//消息存储未发送的数据 </span></span><br><span class="line">            <span class="comment">//libevent库的bufferevent可以解决</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">// 关闭cfd,下树</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(cfd);</span><br><span class="line">        epoll_ctl(epfd, EPOLL_CTL_DEL, cfd, ev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_client_request</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *ev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 读取请求（先读取一行，在把其他行读取，扔掉）</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">1024</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> n = Readline(ev-&gt;data.fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;close or err\n&quot;</span>);</span><br><span class="line">        epoll_ctl(epfd, EPOLL_CTL_DEL, ev-&gt;data.fd, ev);</span><br><span class="line">        close(ev-&gt;data.fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ret = Readline(ev-&gt;data.fd, tmp, <span class="keyword">sizeof</span>(tmp))) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;read ok\n&quot;);</span></span><br><span class="line">    <span class="comment">// 解析请求行 GET /a.txt HTTP/1.1\r\n</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> content[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> protocol[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%[^ ] %[^ ] %[^ \r\n]&quot;</span>, method, content, protocol);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s] [%s] [%s]\n&quot;</span>, method, content, protocol);</span><br><span class="line">    <span class="comment">// 判断是否为get请求，get请求才处理</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;get&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">// 这个函数比较忽略大小写</span></span><br><span class="line">        <span class="type">char</span> *strfile = content + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//在请求阶段注意如果传过来的是中文，中文是一堆十六进制（URL编码），需要转换才能使用</span></span><br><span class="line">        <span class="comment">//传过来后必须把按十六进制转换成十进制，一个字节一个字节的转，最后拼在一起放在字符串中即可使用</span></span><br><span class="line">        <span class="comment">// 如果没有请求文件，默认请求工作目录</span></span><br><span class="line">        <span class="comment">// 得到浏览器请求的文件 如果对方没有请求文件 默认请求 ./</span></span><br><span class="line">        <span class="keyword">if</span> (*strfile == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            strfile = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断请求的文件在不在</span></span><br><span class="line">        <span class="comment">// 判断文件是否存在,如果存在（发送普通文件，目录）</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (stat(strfile, &amp;s) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">// 文件不存在</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;file not found\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 先发送 报头(状态行 消息头 空行)</span></span><br><span class="line">            send_header(ev-&gt;data.fd, <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>, <span class="string">&quot;/text/html&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 发送文件 发送error.html</span></span><br><span class="line">            send_file(ev-&gt;data.fd, <span class="string">&quot;client.c&quot;</span>, ev, epfd,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 请求的是一个普通文件</span></span><br><span class="line">            <span class="keyword">if</span> (S_ISREG(s.st_mode))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;file\n&quot;</span>);</span><br><span class="line">                <span class="comment">// 先发送 报头(状态行 消息头 空行)</span></span><br><span class="line">                send_header(ev-&gt;data.fd, <span class="number">200</span>, <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;/text/html&quot;</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 发送文件</span></span><br><span class="line">                send_file(ev-&gt;data.fd, strfile, ev, epfd,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(s.st_mode))</span><br><span class="line">            &#123; <span class="comment">// 请求的是一个目录</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;dir\n&quot;</span>);</span><br><span class="line">                <span class="comment">// 发送一个列表 网页</span></span><br><span class="line">                <span class="comment">// 先发送 报头(状态行 消息头 空行)</span></span><br><span class="line">                send_header(ev-&gt;data.fd, <span class="number">200</span>, <span class="string">&quot;ok&quot;</span>, <span class="string">&quot;/text/html&quot;</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 发送header.html</span></span><br><span class="line">                send_file(ev-&gt;data.fd, <span class="string">&quot;dir_header.html&quot;</span>, ev, epfd,<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//发送列表</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> **<span class="title">mylist</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">                <span class="type">int</span> n=scandir(strfile,&amp;mylist,<span class="literal">NULL</span>,alphasort);</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,mylist[i]-&gt;d_name);</span><br><span class="line">                    <span class="keyword">if</span>(mylist[i]-&gt;d_type==DT_DIR)&#123;</span><br><span class="line">                        len=<span class="built_in">sprintf</span>(buf,<span class="string">&quot;&lt;li&gt;&lt;a href=%s/ &gt;%s&lt;/a&gt;&lt;li&gt;&quot;</span>,mylist[i]-&gt;d_name,mylist[i]-&gt;d_name);</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        len=<span class="built_in">sprintf</span>(buf,<span class="string">&quot;&lt;li&gt;&lt;a href=%s&gt;%s&lt;/a&gt;&lt;li&gt;&quot;</span>,mylist[i]-&gt;d_name,mylist[i]-&gt;d_name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    send(ev-&gt;data.fd,buf,len,<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">free</span>(mylist[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">free</span>(mylist);</span><br><span class="line"></span><br><span class="line">                send_file(ev-&gt;data.fd, <span class="string">&quot;dir_tail.html&quot;</span>, ev, epfd,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//忽略这个信号，为了解决在浏览器请求大文件，服务器有时会关闭的问题，</span></span><br><span class="line">    <span class="comment">//因为有的浏览器会把读端关闭，导致服务端无法写</span></span><br><span class="line">    signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    <span class="comment">// 切换工作目录</span></span><br><span class="line">    <span class="comment">// 获取当前目录的工作路径</span></span><br><span class="line">    <span class="type">char</span> pwd_path[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *path = getenv(<span class="string">&quot;PWD&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(pwd_path, path);</span><br><span class="line">    <span class="built_in">strcat</span>(pwd_path, <span class="string">&quot;/web-http&quot;</span>);</span><br><span class="line">    <span class="comment">// 切换工作目录</span></span><br><span class="line">    chdir(pwd_path);</span><br><span class="line">    <span class="comment">// 创建套接字 绑定</span></span><br><span class="line">    <span class="type">int</span> lfd = tcp4bind(PORT, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    Listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">// 创建树</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将lfd上树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">evs</span>[1024];</span></span><br><span class="line">    ev.data.fd = lfd;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="comment">// 循环监听</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nready = epoll_wait(epfd, evs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nready &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nready; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断是否是lfd</span></span><br><span class="line">                <span class="keyword">if</span> (evs[i].data.fd == lfd &amp;&amp; evs[i].events &amp; EPOLLIN)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                    <span class="type">int</span> cfd = Accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;new client ip=%s port=%d\n&quot;</span>, inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="number">16</span>), ntohs(cliaddr.sin_port));</span><br><span class="line">                    <span class="comment">// 设置cfd为非阻塞</span></span><br><span class="line">                    <span class="type">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                    flag |= O_NONBLOCK;</span><br><span class="line">                    fcntl(cfd, F_SETFL, flag);</span><br><span class="line">                    <span class="comment">// 上树</span></span><br><span class="line">                    ev.data.fd = cfd;</span><br><span class="line">                    ev.events = EPOLLIN;</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (evs[i].events &amp; EPOLLIN) <span class="comment">// cfd变化</span></span><br><span class="line">                &#123;</span><br><span class="line">                    read_client_request(epfd, &amp;evs[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个代码还有URL转码，函数没有实现。发送大文件，无法传输的问题，已写明解决方法（基于bufferevent）。</strong></p><p><strong>为什么服务端 <code>send()</code> 写不进去，错误是“写缓冲区满”，难道不是因为“客户端浏览器的读缓冲区满”吗？</strong></p><p>正确解释如下：send() 写的是 <strong>内核发送缓冲区</strong></p><p>当你调用 <code>send(fd, buf, len, 0)</code> 时：</p><ul><li>数据不是直接“发到浏览器”，而是先写入 <strong>服务端内核的 socket 发送缓冲区</strong>；</li><li><strong>只有写进这个缓冲区成功，<code>send()</code> 才会返回你“写成功了”；</strong></li><li>如果这个缓冲区满了，<code>send()</code> 就会返回 <code>-1</code>，并设置 <code>errno = EAGAIN</code>。</li></ul><p>这就是“写缓冲区满”的真正含义 —— 是<strong>你本地操作系统的内核缓冲区满了</strong>，跟浏览器还没关系。</p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络基础&quot;&gt;&lt;a href=&quot;#网络基础&quot; class=&quot;headerlink&quot; title=&quot;网络基础&quot;&gt;&lt;/a&gt;网络基础&lt;/h2&gt;&lt;h3 id=&quot;mac地址（6个字节-48位）&quot;&gt;&lt;a href=&quot;#mac地址（6个字节-48位）&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Linux Network Programming" scheme="http://yustonerain.top/categories/Linux-Network-Programming/"/>
    
    
    <category term="Linux Network Programming" scheme="http://yustonerain.top/tags/Linux-Network-Programming/"/>
    
  </entry>
  
  <entry>
    <title>mysql连接池</title>
    <link href="http://yustonerain.top/2025/07/03/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://yustonerain.top/2025/07/03/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/</id>
    <published>2025-07-03T12:48:36.000Z</published>
    <updated>2025-07-04T13:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目目的"><a href="#项目目的" class="headerlink" title="项目目的"></a>项目目的</h2><p>为了提高MySQL数据库(基于C&#x2F;S设计)的访问瓶颈，除了在服务端增加缓存服务器缓存常用的数据之外，还可增加连接池，来提高MySQL Server的访问效率，在高并发情况下，大量的TCP三次握手，MySQL Server连接认证，MySQL Server关闭连接回收资源和TCP四次挥手所耗费的性能时间也是很明显的，增加连接池就是为了减少这一部分的损耗。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目目的&quot;&gt;&lt;a href=&quot;#项目目的&quot; class=&quot;headerlink&quot; title=&quot;项目目的&quot;&gt;&lt;/a&gt;项目目的&lt;/h2&gt;&lt;p&gt;为了提高MySQL数据库(基于C&amp;#x2F;S设计)的访问瓶颈，除了在服务端增加缓存服务器缓存常用的数据之外，还可增加连接池</summary>
      
    
    
    
    <category term="mysql连接池" scheme="http://yustonerain.top/categories/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
    
    <category term="mysql连接池" scheme="http://yustonerain.top/tags/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程</title>
    <link href="http://yustonerain.top/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <id>http://yustonerain.top/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</id>
    <published>2025-06-20T13:26:00.000Z</published>
    <updated>2025-07-16T13:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux常见目录"><a href="#Linux常见目录" class="headerlink" title="Linux常见目录"></a>Linux常见目录</h2><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td><code>/</code></td><td>根目录，所有目录的起点，Linux 文件系统的顶级目录</td></tr><tr><td><code>/bin</code></td><td>存放常用的二进制可执行文件（如 <code>ls</code>、<code>cp</code>、<code>mv</code> 等），普通用户和系统都可使用</td></tr><tr><td><code>/sbin</code></td><td>系统管理命令，只有 root 用户可用（如 <code>reboot</code>、<code>ifconfig</code>）</td></tr><tr><td><code>/etc</code></td><td>配置文件目录（如 <code>/etc/passwd</code>、<code>/etc/fstab</code>、<code>/etc/ssh/sshd_config</code>）</td></tr><tr><td><code>/home</code></td><td>普通用户的家目录（如 <code>/home/user1</code>）</td></tr><tr><td><code>/root</code></td><td>超级用户（root）的家目录</td></tr><tr><td><code>/lib</code></td><td>核心共享库和驱动模块，供 <code>/bin</code> 和 <code>/sbin</code> 下的程序使用</td></tr><tr><td><code>/usr</code></td><td>存放用户应用程序和文件，子目录中包括 <code>/usr/bin</code>、<code>/usr/lib</code> 等</td></tr><tr><td><code>/usr/bin</code></td><td>普通用户使用的应用程序（非基本命令）</td></tr><tr><td><code>/usr/sbin</code></td><td>非系统引导时使用的系统管理员命令</td></tr><tr><td><code>/var</code></td><td>可变数据，如日志文件 <code>/var/log</code>、邮件、缓存、锁等</td></tr><tr><td><code>/tmp</code></td><td>临时文件，系统重启后可能会被清空</td></tr><tr><td><code>/opt</code></td><td>第三方软件安装目录（如 Chrome、VMware 等）</td></tr><tr><td><code>/dev</code></td><td>设备文件（如硬盘 <code>/dev/sda</code>，终端 <code>/dev/tty</code>）</td></tr><tr><td><code>/proc</code></td><td>虚拟文件系统，内核和进程信息（如 <code>/proc/cpuinfo</code>、<code>/proc/meminfo</code>）</td></tr><tr><td><code>/sys</code></td><td>另一种虚拟文件系统，提供与内核、设备驱动的交互接口</td></tr><tr><td><code>/boot</code></td><td>存放启动相关文件，如内核、grub 等（如 <code>/boot/vmlinuz-*</code>）</td></tr><tr><td><code>/media</code></td><td>可移动媒体挂载点（如 U 盘、光盘）</td></tr><tr><td><code>/mnt</code></td><td>临时挂载点，一般管理员手动挂载文件系统用</td></tr><tr><td><code>/run</code></td><td>系统运行时临时文件（如 PID、Socket）</td></tr><tr><td><code>/srv</code></td><td>提供服务的数据目录（如 Web 服务、FTP 服务的数据）</td></tr></tbody></table><h2 id="Bash解析器常用快捷键"><a href="#Bash解析器常用快捷键" class="headerlink" title="Bash解析器常用快捷键"></a>Bash解析器常用快捷键</h2><p>1.tap键</p><p>补齐命令，补齐路径，显示当前目录下的所有目录</p><p>2.清屏 clear</p><p>3.中断进程 ctrl+c</p><p>4 遍历输入的历史命令箭头上（ctrl+p）箭头下(ctrl+n)</p><p>5 光标相关操作</p><p>光标左移： ctrl+b（箭头左）</p><p>光标右移： ctrl+f(箭头右)</p><p>移动到头部: ctrl+a(home键)</p><p>移动到尾部：ctrl+e(end键)</p><p>6字符删除</p><p>删除光标前面的字符：ctrl+h(Backspace)</p><p>删除光标后面的字符：ctrl+d</p><p>光标后面的字符即光标覆盖的字符</p><p>删除光标前的所有内容：ctrl+u</p><p>删除光标后的所有内容：ctrl+k</p><h2 id="终端相关快捷键"><a href="#终端相关快捷键" class="headerlink" title="终端相关快捷键"></a>终端相关快捷键</h2><p>（终端一定要选中）</p><p>ctrl+shift+N 新建一个终端</p><p>ctrl+shift+T 在终端里新建一个标签</p><p>ctrl+D 关闭当前一个终端</p><h2 id="内建命令和外部命令对比"><a href="#内建命令和外部命令对比" class="headerlink" title="内建命令和外部命令对比"></a>内建命令和外部命令对比</h2><p>内建命令 vs 外部命令 对比总结</p><table><thead><tr><th>比较项</th><th>内建命令（Builtin Command）</th><th>外部命令（External Command）</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>由 Shell 内部直接实现的命令</td><td>是文件系统中的可执行程序（如 <code>/bin/ls</code>）</td></tr><tr><td><strong>执行速度</strong></td><td>快（不需新建进程）</td><td>较慢（需 fork 子进程执行）</td></tr><tr><td><strong>资源消耗</strong></td><td>少，执行在当前 Shell 进程中</td><td>多，执行时创建子进程</td></tr><tr><td><strong>路径查找</strong></td><td>不需要依赖 <code>PATH</code> 环境变量</td><td>需要从 <code>PATH</code> 中查找可执行文件</td></tr><tr><td><strong>是否可以替换</strong></td><td>一般不推荐重定义</td><td>可以覆盖、替换或删改（如 alias 覆盖）</td></tr><tr><td><strong>是否常驻内存</strong></td><td>是，Shell 启动时加载</td><td>否，执行时加载，执行完释放</td></tr><tr><td><strong>例子</strong></td><td><code>cd</code>, <code>echo</code>, <code>exit</code>, <code>pwd</code>, <code>type</code></td><td><code>ls</code>, <code>cp</code>, <code>gcc</code>, <code>vim</code>, <code>python</code></td></tr><tr><td><strong>查看方法</strong></td><td><code>type cd</code> → builtin</td><td><code>type ls</code> → file</td></tr></tbody></table><p>命令类型查看方法</p><p>使用type命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> [选项] 命令名</span><br></pre></td></tr></table></figure><p>使用 -a 显示所有同名命令（包括 alias、builtin、文件）</p><p>使用 -t 显示类型（简洁）</p><h2 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 [选项] [参数]</span><br></pre></td></tr></table></figure><table><thead><tr><th>部分</th><th>说明</th></tr></thead><tbody><tr><td><strong>命令</strong></td><td>要执行的操作，如 <code>ls</code>、<code>cp</code>、<code>mkdir</code> 等</td></tr><tr><td><strong>选项</strong></td><td>用于控制命令行为的开关，通常以 <code>-</code> 或 <code>--</code> 开头，例如 <code>-l</code>、<code>--help</code></td></tr><tr><td><strong>参数</strong></td><td>命令作用的对象，通常是文件名、目录名、用户名等</td></tr></tbody></table><p>选项类型说明</p><table><thead><tr><th>类型</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>短选项</td><td><code>-l</code></td><td>通常是一个字母，多个可组合（如 <code>-al</code>）</td></tr><tr><td>长选项</td><td><code>--help</code></td><td>更易读，通常不可组合</td></tr><tr><td>组合选项</td><td><code>-avz</code></td><td>相当于 <code>-a -v -z</code></td></tr></tbody></table><h2 id="帮助文档查看方法"><a href="#帮助文档查看方法" class="headerlink" title="帮助文档查看方法"></a>帮助文档查看方法</h2><p>如果是内建命令（可以通过之前的type命令查看）使用 help +内建命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> <span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p>如果是外部命令 对应命令名 –help</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><code>man</code> 是 Linux 中最常用的命令之一，全称是 <strong>manual（手册）</strong>，用于查看各种命令、函数、配置文件的使用说明。它是学习和查找 Linux 命令最权威的工具。</p><p><code>man</code> 命令基本语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man [选项] [命令名或函数名]</span><br></pre></td></tr></table></figure><p> man 手册的 9 个部分（章节）</p><table><thead><tr><th>章节号</th><th>内容</th><th>示例</th></tr></thead><tbody><tr><td>1</td><td>用户命令（常见终端命令）</td><td><code>man ls</code></td></tr><tr><td>2</td><td>系统调用（内核提供的函数）</td><td><code>man 2 open</code></td></tr><tr><td>3</td><td>C 库函数</td><td><code>man 3 printf</code></td></tr><tr><td>4</td><td>设备文件和特殊文件</td><td><code>man 4 tty</code></td></tr><tr><td>5</td><td>配置文件格式</td><td><code>man 5 crontab</code></td></tr><tr><td>6</td><td>游戏与趣味（极少）</td><td></td></tr><tr><td>7</td><td>杂项（宏定义、协议、约定等）</td><td><code>man 7 signal</code></td></tr><tr><td>8</td><td>系统管理员命令（只能 root 执行）</td><td><code>man 8 ifconfig</code></td></tr><tr><td>9</td><td>内核开发接口（不常见）</td><td></td></tr></tbody></table><p>常用选项</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><code>-k 关键词</code></td><td>搜索相关命令（相当于 <code>apropos</code>）</td></tr><tr><td><code>-f 命令名</code></td><td>显示命令属于哪个章节（相当于 <code>whatis</code>）</td></tr><tr><td><code>-a</code></td><td>显示所有章节中匹配的 man 页</td></tr><tr><td><code>-M</code></td><td>指定手册路径</td></tr><tr><td><code>--help</code></td><td>查看 man 自身帮助信息</td></tr></tbody></table><h2 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h2><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>用于显示当前终端所在的<strong>工作目录</strong>（即当前绝对路径）。</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [目录路径]</span><br></pre></td></tr></table></figure><p>常见用法示例</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>cd /home/user</code></td><td>切换到绝对路径 <code>/home/user</code> 目录</td></tr><tr><td><code>cd ..</code></td><td>切换到上一级目录</td></tr><tr><td><code>cd</code> 或 <code>cd ~</code></td><td>切换到当前用户的主目录</td></tr><tr><td><code>cd -</code></td><td>切换到上一次所在的目录（切换目录的“切换”）</td></tr><tr><td><code>cd ./folder</code></td><td>切换到当前目录下的子目录 <code>folder</code></td></tr></tbody></table><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>用于<strong>创建新目录</strong>的命令，创建不了已存在目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [选项] 目录名</span><br></pre></td></tr></table></figure><p>mkdir test 在当前目录下创建test文件夹</p><p>mkdir &#x2F;tmp&#x2F;test</p><p>mkdir file{1..100}在当前目录创建100个文件夹，file1,file2,file3…file100</p><p>mkdir “file{1..100}”在当前目录创建file{1..100}文件夹，只会创建一个。</p><p>mkdir “a b” 在当前目录创建a b一个文件夹。</p><p>mkdir a b 在当前目录创建a b两个文件夹。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code></td><td>递归创建目录（父目录不存在时自动创建）</td></tr><tr><td><code>-m MODE</code></td><td>设置新建目录的权限，如 <code>-m 755</code></td></tr><tr><td><code>-v</code></td><td>显示详细创建过程（verbose）</td></tr></tbody></table><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>用法和mkdir相同</p><p>用于<strong>删除空目录</strong>的命令</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>rmdir testdir</code></td><td>删除当前目录下的 <code>testdir</code>（需为空）</td></tr><tr><td><code>rmdir -p a/b/c</code></td><td>递归删除空目录链：先删 <code>c</code>，再删 <code>b</code>，再删 <code>a</code></td></tr><tr><td><code>rmdir ./mydir/</code></td><td>删除当前目录中的 <code>mydir</code>（需为空）</td></tr></tbody></table><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code></td><td>递归删除路径中的所有空目录（从子到父）</td></tr><tr><td><code>--ignore-fail-on-non-empty</code></td><td>删除目录时忽略非空目录导致的错误</td></tr></tbody></table><h2 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h2><p>常用的文件类型有七种：普通文件，目录文件，设备文件，管道文件，链接文件和套接字。</p><p><img src="/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/1.png" alt="1"></p><p><strong>普通文件</strong> 是 Linux 中最常见的一类文件，主要用于存储用户数据。包括：</p><ul><li>文本文件（如 <code>.txt</code>, <code>.c</code>, <code>.py</code>）</li><li>二进制文件（如 可执行程序、图片、音频等）</li><li>脚本文件（如 <code>.sh</code>, <code>.py</code>，可以被解释执行）</li></ul><p>在 Linux 中，<strong>目录文件（Directory File）</strong> 是一种特殊的文件类型，用来组织和存放文件和其他目录（子目录）。<br> 它本质上是一个<strong>保存了文件名和 inode 编号之间映射关系</strong>的文件。</p><p><strong>设备文件</strong>（Device File）是 Linux 中用于访问硬件设备的接口，本质上就是一种特殊的文件，程序通过它来与硬件设备通信。</p><p>设备文件通常位于 <code>/dev</code> 目录中。</p><p>常见设备文件举例</p><table><thead><tr><th>路径</th><th>类型</th><th>功能描述</th></tr></thead><tbody><tr><td><code>/dev/sda</code></td><td>块设备</td><td>第一块硬盘</td></tr><tr><td><code>/dev/tty</code></td><td>字符设备</td><td>当前终端</td></tr><tr><td><code>/dev/null</code></td><td>字符设备</td><td>写入数据会被丢弃</td></tr><tr><td><code>/dev/zero</code></td><td>字符设备</td><td>会源源不断输出 0</td></tr><tr><td><code>/dev/random</code></td><td>字符设备</td><td>伪随机数生成器</td></tr></tbody></table><p><strong>管道文件</strong>（或称命名管道，FIFO &#x3D; First In First Out）是一种特殊文件，用于<strong>在不同进程之间传输数据</strong>。<br> 写入管道的数据会按顺序被读取，类似“排队喝水”的水管，先进先出。</p><p>管道文件与匿名管道不同之处在于它有名字，存在于文件系统中（通常创建在某个路径下），因此<strong>不同进程不必有父子关系</strong>也能通信。</p><p><strong>链接文件</strong> 是指向另一个文件的引用，常用于：</p><ul><li>创建多个路径指向同一个文件（节省空间）</li><li>为长路径或常用文件创建别名（提高效率）</li><li>实现共享与替代功能</li></ul><table><thead><tr><th>类型</th><th>描述</th><th><code>ls -l</code> 标识</th></tr></thead><tbody><tr><td><strong>软链接</strong>（符号链接）</td><td>类似 Windows 快捷方式，是一个指向目标路径的独立文件</td><td><code>l</code></td></tr><tr><td><strong>硬链接</strong></td><td>直接指向目标文件的 inode，本质上是同一个文件的另一个名字</td><td><code>-</code></td></tr></tbody></table><p>在 Linux 中，你可以使用 <code>ls -l</code> 命令来区分各种文件类型。<code>ls -l</code> 输出的每一行开头的第一个字符表示文件类型。下面是 <strong>七种常见文件类型及其 <code>ls -l</code> 显示符号</strong>：</p><p>七种常见文件类型及其标识</p><table><thead><tr><th>文件类型</th><th><code>ls -l</code> 类型字符</th><th>示例路径</th><th>含义说明</th></tr></thead><tbody><tr><td><strong>普通文件</strong></td><td><code>-</code></td><td><code>-rw-r--r-- file.txt</code></td><td>常见的文本、二进制、可执行文件等</td></tr><tr><td><strong>目录文件</strong></td><td><code>d</code></td><td><code>drwxr-xr-x dir/</code></td><td>存储文件的容器</td></tr><tr><td><strong>字符设备文件</strong></td><td><code>c</code></td><td><code>crw------- /dev/tty</code></td><td>逐字符访问设备，如终端、串口等</td></tr><tr><td><strong>块设备文件</strong></td><td><code>b</code></td><td><code>brw-rw---- /dev/sda</code></td><td>按块访问设备，如硬盘、U 盘等</td></tr><tr><td><strong>管道文件</strong></td><td><code>p</code></td><td><code>prw-r--r-- mypipe</code></td><td>用于进程间通信的 FIFO 管道</td></tr><tr><td><strong>链接文件</strong></td><td><code>l</code></td><td><code>lrwxrwxrwx link -&gt; target</code></td><td>指向其他文件的软链接</td></tr><tr><td><strong>套接字文件</strong></td><td><code>s</code></td><td><code>srwxrwxrwx socket</code></td><td>进程间网络通信接口，如 <code>/tmp/.X11-unix/X0</code></td></tr></tbody></table><h2 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h2><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>ls</code></td><td>简单列出当前目录内容</td></tr><tr><td><code>ls -a</code></td><td>显示所有文件，包括隐藏文件（以<code>.</code>开头）</td></tr><tr><td><code>ls -l</code></td><td>以长格式列出，显示权限、类型、时间等</td></tr><tr><td><code>ls -lh</code></td><td>长格式 + 人类可读大小（如 KB, MB）</td></tr><tr><td><code>ls -lt</code></td><td>按修改时间排序，最新的在前</td></tr><tr><td><code>ls -r</code></td><td>反向排序</td></tr><tr><td><code>ls -R</code></td><td>递归列出子目录</td></tr><tr><td><code>ls -d */</code></td><td>只列出目录 ls -d只显示一个.</td></tr></tbody></table><p>ls -l命令会输出长格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">权限       硬链接数 拥有者 所属组  大小    修改日期      文件名</span><br><span class="line">drwxr-xr-x   2    user   user  4096   Jun 21 13:00  mydir</span><br></pre></td></tr></table></figure><p>对权限部分说明一下权限部分总共10个字符</p><table><thead><tr><th>位置</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>文件类型标识</td></tr><tr><td>2-4</td><td><strong>拥有者（user）</strong>权限</td></tr><tr><td>5-7</td><td><strong>同组用户（group）</strong>权限</td></tr><tr><td>8-10</td><td><strong>其他用户（others）</strong>权限</td></tr></tbody></table><p>文件类型标识（第1个字符）</p><table><thead><tr><th>字符</th><th>类型</th></tr></thead><tbody><tr><td><code>-</code></td><td>普通文件</td></tr><tr><td><code>d</code></td><td>目录</td></tr><tr><td><code>l</code></td><td>软链接</td></tr><tr><td><code>c</code></td><td>字符设备文件</td></tr><tr><td><code>b</code></td><td>块设备文件</td></tr><tr><td><code>p</code></td><td>管道（FIFO）</td></tr><tr><td><code>s</code></td><td>套接字</td></tr></tbody></table><p>权限字符说明（2-10位置）</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>r</code></td><td>读权限 (read)</td></tr><tr><td><code>w</code></td><td>写权限 (write)</td></tr><tr><td><code>x</code></td><td>执行权限 (execute)</td></tr><tr><td><code>-</code></td><td>无该权限</td></tr><tr><td><code>s</code></td><td>setuid&#x2F;setgid 位（特殊执行权限）</td></tr><tr><td><code>t</code></td><td>粘滞位（sticky bit）</td></tr></tbody></table><p>三组权限详解</p><table><thead><tr><th>组别</th><th>位置</th><th>含义</th></tr></thead><tbody><tr><td><strong>拥有者</strong></td><td>2~4 字符</td><td>拥有该文件&#x2F;目录的用户权限</td></tr><tr><td><strong>组用户</strong></td><td>5~7 字符</td><td>属于该文件组的用户权限</td></tr><tr><td><strong>其他用户</strong></td><td>8~10 字符</td><td>系统中除拥有者和组以外的所有用户权限</td></tr></tbody></table><h3 id="什么是通配符？"><a href="#什么是通配符？" class="headerlink" title="什么是通配符？"></a>什么是通配符？</h3><p>通配符是一种简化文件名匹配的符号，用于在命令中匹配多个文件或目录。它可以让你不用输入完整文件名，就能选中符合规则的文件。</p><p>常用的通配符类型</p><table><thead><tr><th>通配符</th><th>作用</th><th>例子</th><th>匹配结果示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意数量的任意字符（包括0个）</td><td><code>ls *.txt</code></td><td>匹配所有以 <code>.txt</code> 结尾的文件</td></tr><tr><td><code>?</code></td><td>匹配任意一个单字符</td><td><code>ls file?.txt</code></td><td>匹配 <code>file1.txt</code>、<code>fileA.txt</code>，但不匹配 <code>file10.txt</code></td></tr><tr><td><code>[abc]</code></td><td>匹配括号内的任意一个字符</td><td><code>ls file[123].txt</code></td><td>匹配 <code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code></td></tr><tr><td><code>[a-z]</code></td><td>匹配指定范围内的任意一个字符</td><td><code>ls file[a-c].txt</code></td><td>匹配 <code>filea.txt</code>、<code>fileb.txt</code>、<code>filec.txt</code></td></tr><tr><td><code>[!abc]</code></td><td>匹配不在括号内的任意一个字符</td><td><code>ls file[!123].txt</code></td><td>匹配除 <code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code> 以外的文件</td></tr></tbody></table><h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p><code>touch</code> 是用来 <strong>创建空文件</strong> 或 <strong>更新已有文件的时间戳</strong> 的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> file.txt</span><br></pre></td></tr></table></figure><p>如果 <code>file.txt</code> 不存在，会被创建为空文件；如果存在，文件时间被更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> file1.txt file2.txt file3.txt</span><br></pre></td></tr></table></figure><p>一次创建或更新多个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> file&#123;2,3,4&#125;#同时创建file2,file3,file4三个空文件和<span class="built_in">mkdir</span> file&#123;1..100&#125;用法是一样的。</span><br><span class="line"><span class="built_in">touch</span> <span class="string">&quot;file&#123;2,3,4&#125;&quot;</span>#创建file&#123;2,3,4&#125;这一个文件。</span><br></pre></td></tr></table></figure><h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p><code>cp</code> 是 Linux 中用于 <strong>复制文件或目录</strong> 的命令。</p><table><thead><tr><th>任务</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td>复制文件</td><td><code>cp file1.txt file2.txt</code></td><td>把 <code>file1.txt</code> 内容复制为 <code>file2.txt</code></td></tr><tr><td>复制文件到目录</td><td><code>cp file1.txt /home/user/docs/</code></td><td>把 <code>file1.txt</code> 复制进目录</td></tr><tr><td>复制目录（加 <code>-r</code>）</td><td><code>cp -r dir1/ dir2/</code></td><td>递归复制整个目录 <code>dir1</code> 到 <code>dir2</code> 中</td></tr><tr><td>保留属性复制文件</td><td><code>cp -p file1.txt file2.txt</code></td><td>保留原文件的时间戳、权限等信息</td></tr><tr><td>强制覆盖目标文件</td><td><code>cp -f file1.txt file2.txt</code></td><td>如果 <code>file2.txt</code> 存在，强制覆盖</td></tr><tr><td>复制并提示</td><td><code>cp -i file1.txt file2.txt</code></td><td>有冲突时会提示确认</td></tr><tr><td>显示复制过程</td><td><code>cp -v file1.txt file2.txt</code></td><td>复制时显示详细过程（verbose 模式）</td></tr></tbody></table><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-r</code></td><td>递归复制目录（必须用于复制目录）</td></tr><tr><td><code>-i</code></td><td>覆盖文件前提示确认</td></tr><tr><td><code>-f</code></td><td>强制覆盖目标文件而不提示</td></tr><tr><td><code>-p</code></td><td>保留原文件的属性（权限、时间等）</td></tr><tr><td><code>-u</code></td><td>只在源文件较新时才复制</td></tr><tr><td><code>-v</code></td><td>显示复制过程（verbose）</td></tr><tr><td><code>-a</code></td><td>归档模式，等价于 <code>-dpR</code>，用于备份</td></tr><tr><td><code>--parents</code></td><td>保留源路径结构复制文件（适用于目录结构迁移）</td></tr></tbody></table><h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><p>是用于在 Linux 中 <strong>删除文件和目录</strong> 的命令。注意：<code>rm</code> 删除后不会进入回收站，<strong>无法轻易恢复</strong>，请务必小心使用。</p><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>删除单个文件</td><td><code>rm file.txt</code></td><td>删除文件 <code>file.txt</code></td></tr><tr><td>删除多个文件</td><td><code>rm file1.txt file2.txt</code></td><td>一次删除多个文件</td></tr><tr><td>递归删除目录及内容</td><td><code>rm -r mydir/</code></td><td>删除目录 <code>mydir</code> 及其所有子目录和文件</td></tr><tr><td>强制删除文件&#x2F;目录</td><td><code>rm -f file.txt</code> &#x2F; <code>rm -rf mydir/</code></td><td>忽略不存在的文件，且不提示确认</td></tr><tr><td>删除前确认</td><td><code>rm -i file.txt</code></td><td>删除前逐一询问确认</td></tr><tr><td>显示正在删除的文件</td><td><code>rm -v file.txt</code></td><td>显示被删除的文件名</td></tr></tbody></table><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-r</code> 或 <code>--recursive</code></td><td>递归删除目录及其内容（删除整个目录树）</td></tr><tr><td><code>-f</code> 或 <code>--force</code></td><td>强制删除，不提示，即使目标不存在也不报错</td></tr><tr><td><code>-i</code></td><td>删除前询问确认，适合新手使用以防误删</td></tr><tr><td><code>-I</code></td><td>删除多个文件或目录时才询问一次，比 <code>-i</code> 安全且不烦人</td></tr><tr><td><code>-v</code> 或 <code>--verbose</code></td><td>显示正在删除的每一个文件或目录</td></tr><tr><td><code>--preserve-root</code></td><td>默认保护根目录 <code>/</code> 不被删除（系统安全机制，防止 <code>rm -rf /</code> 误操作）</td></tr></tbody></table><h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p><strong>移动文件或目录</strong> 到新位置，<strong>重命名</strong> 文件或目录。</p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td>移动文件</td><td><code>mv a.txt /home/user/docs/</code></td><td>把 <code>a.txt</code> 移动到 <code>/home/user/docs/</code> 目录</td></tr><tr><td>重命名文件</td><td><code>mv old.txt new.txt</code></td><td>将 <code>old.txt</code> 重命名为 <code>new.txt</code></td></tr><tr><td>移动并重命名</td><td><code>mv a.txt /home/user/docs/b.txt</code></td><td>移动 <code>a.txt</code> 到新目录并改名为 <code>b.txt</code></td></tr><tr><td>移动目录</td><td><code>mv dir1/ /home/user/backup/</code></td><td>移动整个目录到新的路径</td></tr><tr><td>覆盖已有文件</td><td><code>mv -f a.txt b.txt</code></td><td>如果 <code>b.txt</code> 存在，则强制覆盖</td></tr><tr><td>覆盖前确认</td><td><code>mv -i a.txt b.txt</code></td><td>如果 <code>b.txt</code> 存在，移动前会询问是否覆盖</td></tr><tr><td>显示移动过程</td><td><code>mv -v a.txt b.txt</code></td><td>显示正在移动的内容</td></tr></tbody></table><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-f</code></td><td>强制覆盖已有目标文件，不提示</td></tr><tr><td><code>-i</code></td><td>如果目标文件存在，提示是否覆盖（interactive）</td></tr><tr><td><code>-n</code></td><td>不覆盖已有的目标文件（no-clobber）</td></tr><tr><td><code>-v</code></td><td>显示移动过程（verbose）</td></tr><tr><td><code>-u</code></td><td>仅在源文件较新或目标文件不存在时才移动</td></tr></tbody></table><h2 id="文件内容查看相关命令"><a href="#文件内容查看相关命令" class="headerlink" title="文件内容查看相关命令"></a>文件内容查看相关命令</h2><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>用于 <strong>查看、创建、合并文件</strong> 内容，常用于快速查看文本文件内容。</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-n</code></td><td>给所有行编号</td></tr><tr><td><code>-b</code></td><td>只对非空行编号</td></tr><tr><td><code>-s</code></td><td>压缩连续空白行为一行</td></tr><tr><td><code>-T</code></td><td>显示 Tab 为 <code>^I</code></td></tr><tr><td><code>-E</code></td><td>显示每行结尾的 <code>$</code>（换行符可见）</td></tr><tr><td><code>-A</code></td><td>相当于 <code>-vET</code>，显示所有不可见字符</td></tr></tbody></table><h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p>用于<strong>分页显示文件内容</strong>的命令，支持 <strong>向前&#x2F;向后翻页浏览</strong>，适合查看<strong>大型文本文件</strong>。它比 <code>cat</code> 更强大，且不会一次性加载全部内容到内存中。</p><p>使用时常用快捷键（进入 less 后）</p><table><thead><tr><th>快捷键</th><th>功能说明</th></tr></thead><tbody><tr><td><code>空格</code></td><td>向下翻一页</td></tr><tr><td><code>b</code></td><td>向上翻一页</td></tr><tr><td><code>Enter</code></td><td>向下滚动一行</td></tr><tr><td><code>k</code></td><td>向上一行（vi 风格）</td></tr><tr><td><code>j</code></td><td>向下一行</td></tr><tr><td><code>G</code></td><td>跳到文件末尾</td></tr><tr><td><code>g</code></td><td>跳到文件开头</td></tr><tr><td><code>/关键词</code></td><td>向下搜索（如 <code>/error</code>）</td></tr><tr><td><code>?关键词</code></td><td>向上搜索</td></tr><tr><td><code>n</code></td><td>重复上一次搜索</td></tr><tr><td><code>N</code></td><td>反向重复搜索</td></tr><tr><td><code>q</code></td><td>退出 less</td></tr></tbody></table><h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><p><code>head</code> 用于345</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>-n N</code></td><td>显示前 N 行（如 <code>head -n 15 file.txt</code>）</td></tr><tr><td><code>-c N</code></td><td>显示前 N 个<strong>字节</strong>（如 <code>head -c 100 file.txt</code>）</td></tr><tr><td><code>-q</code></td><td>多文件时不显示文件名头部（quiet）</td></tr><tr><td><code>-v</code></td><td>总是显示文件名头部（verbose）</td></tr></tbody></table><h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>用于<strong>显示文件的最后几行内容</strong>，默认是最后 10 行。常用于：</p><ul><li>查看日志尾部；</li><li>实时监控文件内容变化（配合 <code>-f</code> 选项）；</li><li>截取文件结尾部分数据。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> /etc/passwd <span class="comment">#默认显示后十行</span></span><br><span class="line"><span class="built_in">tail</span> -n 30 文件名 <span class="comment">#显示后30行内容</span></span><br><span class="line"><span class="built_in">tail</span> -c 30 文件名 <span class="comment">#显示后30个字符</span></span><br></pre></td></tr></table></figure><h2 id="du和df命令"><a href="#du和df命令" class="headerlink" title="du和df命令"></a>du和df命令</h2><h3 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h3><p>查看<strong>目录或文件占用的磁盘空间</strong>，会考虑磁盘块对齐、文件系统元数据、软链接等因素。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-h</code></td><td>以<strong>人类可读的方式</strong>显示（如 KB、MB）</td></tr><tr><td><code>-s</code></td><td>显示指定文件&#x2F;目录占用的数据块</td></tr><tr><td><code>-a</code></td><td>显示所有文件和目录的大小（默认只显示目录）</td></tr><tr><td><code>--max-depth=N</code></td><td>显示目录深度（限制递归层数）</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh 文件名/目录</span><br></pre></td></tr></table></figure><table><thead><tr><th>项目</th><th><code>ls -l</code></th><th><code>du -sh</code></th></tr></thead><tbody><tr><td>显示内容</td><td>文件本身大小（内容字节数）</td><td>实际磁盘占用（包含对齐和元数据）</td></tr><tr><td>对目录</td><td>显示目录结构本身大小</td><td>显示目录下所有内容实际占用</td></tr><tr><td>单位</td><td>字节（Bytes）</td><td>自动转换为 KB&#x2F;MB&#x2F;GB</td></tr><tr><td>应用场景</td><td>看文件大小&#x2F;属性</td><td>查哪些文件&#x2F;目录占空间最多</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; file.txt</span><br><span class="line"><span class="built_in">ls</span> -l file.txt      <span class="comment"># 显示 6 bytes</span></span><br><span class="line"><span class="built_in">du</span> -sh file.txt     <span class="comment"># 显示 4.0K</span></span><br></pre></td></tr></table></figure><h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h3><p>查看<strong>整个磁盘的使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h <span class="comment"># 显示所有文件系统的使用情况（人类可读格式）</span></span><br><span class="line"><span class="built_in">df</span> -h /home <span class="comment"># 查看 /home 所在分区的磁盘使用情况</span></span><br></pre></td></tr></table></figure><h2 id="查找相关命令"><a href="#查找相关命令" class="headerlink" title="查找相关命令"></a>查找相关命令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find</code> 是 Linux 中功能非常强大的文件搜索命令，它可以根据名称、类型、时间、大小、权限等多种条件在目录中递归查找文件，还可以执行删除、移动、打印等操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [搜索路径] [搜索条件] [处理动作]</span><br></pre></td></tr></table></figure><p>按文件名查询：使用参数 -name</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name <span class="string">&quot;*.txt&quot;</span> <span class="comment">#查找当前路径下符合后缀是。txt的文件</span></span><br></pre></td></tr></table></figure><p>按文件大小查询：使用参数 -size</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -size +100k</span><br></pre></td></tr></table></figure><p>+100k 表示大于100k的文件</p><p>-100k表示小于100k的文件</p><p>100k 表示等于100k的文件</p><p>大小方面：k小写，M大写</p><p>查询大小范围</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -size +50k -size -100k</span><br></pre></td></tr></table></figure><p>按文件类型查询：使用参数 -type</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -<span class="built_in">type</span> f <span class="comment">#查询当前的普通文件</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>类型代号</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>f</code></td><td>普通文件</td><td><code>find . -type f</code> 查找所有普通文件（这里不是-，要和ls -l的文件类型区分）</td></tr><tr><td><code>d</code></td><td>目录</td><td><code>find . -type d</code> 查找所有目录</td></tr><tr><td><code>l</code></td><td>符号链接（软链接）</td><td><code>find . -type l</code> 查找所有软链接</td></tr><tr><td><code>c</code></td><td>字符设备文件</td><td><code>/dev/null</code> 等</td></tr><tr><td><code>b</code></td><td>块设备文件</td><td>硬盘等块设备</td></tr><tr><td><code>s</code></td><td>套接字文件</td><td>Socket 类型文件</td></tr><tr><td><code>p</code></td><td>命名管道（FIFO）</td><td>通信用的特殊文件</td></tr></tbody></table><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><code>grep</code> 是 Linux 中非常常用的文本搜索工具，用于<strong>在文件或标准输出中查找匹配的字符串</strong>，功能强大，灵活，适合日志分析、配置文件搜索、编程辅助等场景。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] <span class="string">&quot;模式&quot;</span> [文件]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义说明</th></tr></thead><tbody><tr><td><code>-n</code></td><td>显示匹配行的行号</td></tr><tr><td><code>-i</code></td><td>忽略大小写</td></tr><tr><td><code>-v</code></td><td>反向匹配（即显示不包含该字符串的行）</td></tr><tr><td><code>-r</code> or <code>-R</code></td><td>递归搜索目录下的所有文件</td></tr><tr><td><code>-l</code></td><td>只列出匹配的文件名</td></tr><tr><td><code>-c</code></td><td>统计匹配的行数</td></tr><tr><td><code>--color=auto</code></td><td>高亮显示匹配的内容</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&quot;root&quot;</span> /etc/passwd <span class="comment">#不分大小写，在passwd查找root</span></span><br><span class="line">grep -w <span class="string">&quot;hello&quot;</span> /etc/passwd <span class="comment">#在passwd查找完全匹配hello单词的行</span></span><br><span class="line">grep -r <span class="string">&quot;u_char&quot;</span> ./  <span class="comment">#递归搜索当前目录下的符合u_char的行</span></span><br><span class="line">grep -i <span class="string">&quot;hello&quot;</span> /etc/passwd --color=auto <span class="comment">#在/etc/passwd文件中找hello并且忽略大小写，然后高亮显示匹配的关键字</span></span><br></pre></td></tr></table></figure><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道（|）一个命令的输出可以通过管道作为另一个命令的输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig | grep <span class="string">&quot;ens33&quot;</span> <span class="comment">#在ifconfig输出的文字查找存在ens33的行</span></span><br></pre></td></tr></table></figure><h2 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>把一系列文件归档到一个文件，也可以把档案文件解开以恢复数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] -f [文件名.tar] [要打包或解压的文件/目录]#f必须放到选项的最后</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf sysctl.tar sysctl <span class="comment">#打包文件，但是不压缩</span></span><br><span class="line">tar -xvf sysctl.tar <span class="comment">#解包文件</span></span><br><span class="line">tar -tvf sysctl.tar <span class="comment">#查看压缩文件内容</span></span><br></pre></td></tr></table></figure><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p><strong>对单个文件进行压缩或解压</strong>，压缩率高、速度快，默认生成 <code>.gz</code> 文件。</p><p>tar和gzip命令结合使用实现文件打包，压缩。</p><p>tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般为xxx.tar.gz。</p><p>gzip单独使用，只可以对文件压缩和解压，不可以对目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip test1 test2 <span class="comment">#不保留源文件压缩。 </span></span><br></pre></td></tr></table></figure><p>tar和gzip结合对目录压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf sysctl.tar.gz sysctl <span class="comment">#打包和压缩文件</span></span><br><span class="line">tar -xzvf sysctl.tar.gz <span class="comment">#解包和解压文件</span></span><br><span class="line">tar -xzvf sysctl.tar.gz -C /temp <span class="comment">#解包和解压文件到temp目录</span></span><br></pre></td></tr></table></figure><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>和gzip一样和tar结合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cjvf test.tar.bz2 <span class="built_in">test</span> <span class="comment">#生成一个bz2压缩包</span></span><br><span class="line">tar -xjvf share.tar.bz2 <span class="comment">#解压</span></span><br></pre></td></tr></table></figure><h3 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h3><p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip [选项] 目标文件（没有扩展名）源文件/目录</span><br><span class="line">unzip -d 解压后目录文件 压缩文件 <span class="comment">#-d解压到指定目录</span></span><br></pre></td></tr></table></figure><h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><p>访问权限说明：</p><p>读权限（r）</p><p>对文件而言，具有读取文件内容的权限；对目录而言，具有浏览目录的权限。</p><p>写权限（w）</p><p>对文件而言，具有新增，修改文件内容的权限；对目录而言，具有删除，移动目录内文件的权限。</p><p>可执行权限（x）</p><p>对文件而言，具有执行文件的权限；对目录而言，该用户具有进入目录的权限。</p><p>通常。Unix&#x2F;Linux系统只允许文件的属主（所有者）或root用户改变文件的读写权限。</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><code>chmod</code>（<strong>change mode</strong>）是 Linux&#x2F;Unix 系统中用于<strong>修改文件或目录权限</strong>的命令。它支持两种权限设置方式：<strong>数字方式</strong>和<strong>符号方式</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [选项] 模式 文件名</span><br></pre></td></tr></table></figure><p>符号方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u/g/o/a +/-/= rwx 文件 <span class="comment">#+添加权限 -撤销权限 =设定权限 u/g/o对应的是拥有者，同属组，其他。</span></span><br><span class="line">chomd o+w a <span class="comment">#向a的其他用户添加写权限</span></span><br><span class="line">chomd u=rw,g=r,o=r a#把a的拥有者权限为re,同属组权限为r,其他用户权限为r。</span><br></pre></td></tr></table></figure><p>数字方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#由于rwx通过二进制来区分 rwx就是111，十进制为7</span></span><br><span class="line"><span class="comment">#rwx   7</span></span><br><span class="line"><span class="comment">#rw-   6</span></span><br><span class="line"><span class="comment">#r--   4</span></span><br><span class="line"><span class="comment">#r-x   5</span></span><br><span class="line">chomd 0777 a#把a的对应用户的权限变为rwx.</span><br></pre></td></tr></table></figure><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><code>chown</code> 是 Linux&#x2F;Unix 中用于更改文件或目录 <strong>所属用户（owner）</strong> 和 <strong>所属用户组（group）</strong> 的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> [选项] [新用户][:[新用户组]] 文件/目录</span><br></pre></td></tr></table></figure><p><code>新用户</code>：新的文件拥有者</p><p><code>新用户组</code>：新的用户组（可选）</p><p>需要 <code>sudo</code> 权限（普通用户只能修改自己拥有的文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把文件所有者修改为root用户</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> root a</span><br><span class="line"><span class="comment">#把文件所属者改为yustone,所属组改为root</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> yustone:root a</span><br></pre></td></tr></table></figure><h2 id="软件安装和卸载"><a href="#软件安装和卸载" class="headerlink" title="软件安装和卸载"></a>软件安装和卸载</h2><h3 id="使用包管理器安装和卸载"><a href="#使用包管理器安装和卸载" class="headerlink" title="使用包管理器安装和卸载"></a>使用包管理器安装和卸载</h3><p>Ubuntu &#x2F; Debian 系列</p><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update          <span class="comment"># 更新软件源</span></span><br><span class="line"><span class="built_in">sudo</span> apt install 软件名  <span class="comment"># 安装软件</span></span><br></pre></td></tr></table></figure><p>卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt remove 软件名           <span class="comment"># 删除程序但保留配置文件</span></span><br><span class="line"><span class="built_in">sudo</span> apt purge 软件名            <span class="comment"># 连配置文件一并删除</span></span><br></pre></td></tr></table></figure><p>离线软件包安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -i package.deb</span><br></pre></td></tr></table></figure><p>离线软件包卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg -r 软件名</span><br></pre></td></tr></table></figure><p>使用 Snap 安装（跨平台容器化安装方式）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snap install 软件名</span><br></pre></td></tr></table></figure><p>使用 Snap 卸载（跨平台容器化安装方式）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snap remove 软件名</span><br></pre></td></tr></table></figure><p>从源代码编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>主要是把命令输出的内容（之前是屏幕）输入到文件里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /etc/passwd &gt; output.txt <span class="comment">#标准正确输出重定向到output.txt（这里是覆盖原文件）</span></span><br><span class="line"><span class="built_in">ls</span> /etc/passwd &gt;&gt; output.txt <span class="comment">#标准正确输出追加重定向到output.txt(这里是追加)</span></span><br><span class="line">llll 2&gt; error.txt <span class="comment">#标准错误输出重定向到error.txt(这里是覆盖原文件)</span></span><br><span class="line">llll 2&gt;&gt; error.txt <span class="comment">#标准错误输出追加重定向到error.txt</span></span><br><span class="line">lll 2&gt; /dev/null <span class="comment">#标准错误输出重定向到黑洞</span></span><br><span class="line"><span class="built_in">ls</span> ddddd /etc/passwd &amp;&gt; /dev/null <span class="comment">#标准正确输出和标准错误输出全部重定向到黑洞。</span></span><br><span class="line"><span class="built_in">ls</span> ddddd /etc/passwd &amp;&gt;&gt; output.txt <span class="comment">#标准正确输出和标准错误输出以追加的方式全部重定向到output.txt.</span></span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>tree以树状形式查看指定目录内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree 目录</span><br></pre></td></tr></table></figure><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>ln命令主要用于创建链接文件。</p><p>链接文件分为软链接和硬链接：</p><p>硬链接只能链接普通文件，不能链接目录。软链接不占用磁盘空间，源文件删除则链接失效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> 源文件 链接文件 <span class="comment">#硬链接</span></span><br><span class="line"><span class="built_in">ln</span> -s 源文件 链接文件 <span class="comment">#软链接</span></span><br></pre></td></tr></table></figure><p>如果没有-s选项代表建立一个硬链接文件，两个文件占用同一块的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s比较常用。如果软链接文件和源文件不在同一目录，源文件最好使用绝对路径，不要使用相对路径。软链接文件存储的是目标文件的路径。</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p><code>vim</code> 是一款强大的 <strong>文本编辑器</strong>，常用于 <strong>Linux &#x2F; Unix 系统编程、脚本编辑、配置文件修改等场景</strong>。它是 <code>vi</code> 的增强版本，具有更强的功能，比如语法高亮、代码折叠、多窗口、多标签支持等。</p><h3 id="vim的三种模式"><a href="#vim的三种模式" class="headerlink" title="vim的三种模式"></a>vim的三种模式</h3><p><strong>普通模式</strong>（Normal Mode）</p><p><strong>默认启动模式</strong>，你一打开 Vim 就是在这个模式。</p><p><strong>作用</strong>：浏览、复制、剪切、粘贴、删除、移动光标、跳转、执行命令等。</p><p>常用命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>h</code>&#x2F;<code>l</code></td><td>左&#x2F;右移动光标</td></tr><tr><td><code>j</code>&#x2F;<code>k</code></td><td>下&#x2F;上移动光标</td></tr><tr><td><code>[n]dd</code></td><td>删除当前行开始的n行（准确说是剪切）</td></tr><tr><td>[n]x</td><td>删除光标后n个字符</td></tr><tr><td>[n]X</td><td>删除光标前n个字符</td></tr><tr><td><code>[n]yy</code></td><td>复制从当前行开始的n行</td></tr><tr><td><code>p</code></td><td>粘贴</td></tr><tr><td><code>u</code></td><td>撤销前一个命令</td></tr><tr><td><code>Ctrl + r</code></td><td>还原（恢复）</td></tr><tr><td><code>:</code></td><td>进入命令模式</td></tr><tr><td><code>i</code>、<code>a</code></td><td>进入插入模式</td></tr><tr><td>mG&#x2F;mgg</td><td>到指定行，m为目标行数</td></tr><tr><td>&#x2F;字符串</td><td>从当前光标位置向下查找（n,N查找内容切换）</td></tr><tr><td>?字符串</td><td>从当前光标位置向上查找（n,N查找内容切换）</td></tr></tbody></table><p><strong>插入模式</strong>（Insert Mode）</p><p><strong>按 <code>i</code>、<code>a</code>、<code>o</code> 等从普通模式进入插入模式。</strong></p><p><strong>作用</strong>：输入文字、写代码、编辑内容。</p><p>常用进入方式：</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>i</code></td><td>在光标前插入</td></tr><tr><td><code>a</code></td><td>在光标后插入</td></tr><tr><td><code>o</code></td><td>在当前行下方新开一行并插入</td></tr><tr><td><code>I</code></td><td>跳到行首插入</td></tr><tr><td><code>A</code></td><td>跳到行尾插入</td></tr></tbody></table><p><strong>退出插入模式</strong>：按 <code>Esc</code> 返回普通模式。</p><p><strong>命令模式</strong>（Command-Line Mode）</p><p><strong>按 <code>:</code> 从普通模式进入命令模式。</strong></p><p>用于输入各种操作命令，如保存、退出、查找、替换等。</p><p>常用命令：</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>:w</code></td><td>保存</td></tr><tr><td><code>:q</code></td><td>退出</td></tr><tr><td><code>:wq</code> 或 <code>ZZ</code></td><td>保存并退出</td></tr><tr><td><code>:q!</code></td><td>强制退出（不保存）</td></tr><tr><td><code>:x</code></td><td>等同于 <code>:wq</code></td></tr><tr><td><code>:/关键字</code></td><td>向下查找关键字</td></tr><tr><td><code>:s/旧/新/g</code></td><td>当前行替换所有匹配项</td></tr><tr><td>:1,10s&#x2F;abc&#x2F;123&#x2F;g</td><td>把第一行到第十行之间的abc全部替换为123</td></tr><tr><td><code>:%s/旧/新/g</code></td><td>全文替换所有匹配项</td></tr><tr><td>:w filename</td><td>保存到指定文件（绝对路径）</td></tr><tr><td>:sp 文件名</td><td>当前文件和另一个文件水平分屏</td></tr><tr><td>:vsp 文件名</td><td>当前文件和另一个文件垂直分屏</td></tr><tr><td>ctrl+w+w</td><td>在多个窗口切换光标</td></tr></tbody></table><h2 id="gcc编译器"><a href="#gcc编译器" class="headerlink" title="gcc编译器"></a>gcc编译器</h2><p>GCC（<strong>GNU Compiler Collection</strong>）是由 GNU 项目开发的一组编译器，最初是为了 C 语言开发的，现在支持多种编程语言</p><p>gcc编译器从拿到一个c源文件到生成一个可执行文件，中间一共经历了四个步骤：</p><p><img src="/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/2.png" alt="2"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line">gcc hello.o -o hello</span><br><span class="line">./hello <span class="comment">#执行</span></span><br><span class="line">gcc 源文件 -o 可执行文件 <span class="comment">#一步到位</span></span><br><span class="line">gcc hello.c -o hello</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-o</code></td><td>指定输出文件名</td></tr><tr><td><code>-Wall</code></td><td>打开所有警告信息</td></tr><tr><td><code>-g</code></td><td>生成调试信息，用于 GDB 调试</td></tr><tr><td><code>-O0/-O1/-O2/-O3</code></td><td>优化等级（0 表示无优化）</td></tr><tr><td><code>-c</code></td><td>只编译不链接，生成 <code>.o</code> 目标文件</td></tr><tr><td><code>-I</code></td><td>添加头文件搜索路径</td></tr><tr><td><code>-L</code></td><td>添加库文件搜索路径</td></tr><tr><td><code>-l</code></td><td>链接指定的库（例如 <code>-lm</code> 表示链接 <code>math</code> 库）</td></tr><tr><td>-v&#x2F;–version</td><td>查看gcc版本号</td></tr><tr><td>-D</td><td>编译时定义宏</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall test.c <span class="comment">#显示所有的警告信息</span></span><br><span class="line">gcc -Wall -Werror test.c <span class="comment">#把警告信息当作错误处理</span></span><br><span class="line">gcc tmp.c -DDEBUG <span class="comment">#可以用来区分测试版和发布版,DEBUG是定义的宏</span></span><br></pre></td></tr></table></figure><h2 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h2><p>静态链接：由链接器在<strong>链接</strong>时把<strong>库的内容加入到可执行程序中。</strong></p><p>优点：对运行环境的依赖较小，具有较好的兼容性。</p><p>缺点：生成的程序比较大，在装入内存消耗更多的时间。库函数有了更新，必须重新编译。</p><p>动态链接：链接器在<strong>链接时仅仅建立和所需库函数的链接关系，在程序运行时才将所需资源调入可执行程序</strong>。</p><p>优点：在需要的时候才会调入对应的资源函数。简化程序的升级，有着较小的程序体积，实现进程间的资源共享（避免重复拷贝）</p><p>缺点：依赖动态库，不能独立运行，动态库依赖版本问题严重。</p><h3 id="静态和动态编译对比"><a href="#静态和动态编译对比" class="headerlink" title="静态和动态编译对比"></a>静态和动态编译对比</h3><p>我们编写的应用程序大量用到了库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入-static参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br><span class="line">gcc -static test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>静态编译是要比动态编译程序大的多。</p><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。按照习惯，一般以”.a”作为文件后缀名。静态库的命名一般分为三个部分：前缀：lib,库名称：自己定义。后缀：.a。最终静态库的名字为libxxx.a</p><h3 id="静态库制作："><a href="#静态库制作：" class="headerlink" title="静态库制作："></a>静态库制作：</h3><p><img src="/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/3.png" alt="3"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c -o add.o <span class="comment">#-c是只编译不链接输出.o文件</span></span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line">gcc -c mul.c -o mul.o</span><br><span class="line">gcc -c div.c -o dic.o</span><br><span class="line">ar -rcs libtest.a add.o sub.o mul.o div.o#使用打包工具ar将准备好的.o文件打包为.a文件libtest.a</span><br></pre></td></tr></table></figure><p>在使用ar工具需要添加参数：rcs </p><p>r更新，c创建，s建立索引</p><h3 id="静态库使用："><a href="#静态库使用：" class="headerlink" title="静态库使用："></a>静态库使用：</h3><p>静态库制作完成之后，需要将.a文件和头文件一起发布给用户。假设测试文件是main.c,静态库文件为libtest.a，头文件为head.h</p><p>编译命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L./ -I./ -ltest -o main#注意这里链接库的名字</span><br></pre></td></tr></table></figure><p>-L：表示要连接的库所在目录。</p><p>-ltest:指定链接时需要的库，去掉前缀和后缀</p><p>-I(这里是大写的i):表示要连接的头文件目录</p><h3 id="动态库制作"><a href="#动态库制作" class="headerlink" title="动态库制作"></a>动态库制作</h3><p>共享库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</p><p>动态库在程序运行时才被载入，也解决了静态库对程序的更新，部署和发布的再次编译的问题，用户只需要更新动态库即可，增量更新。</p><p>一般以”.so”作为文件后缀名。共享库的命名一般分为三个部分：前缀lib,库名称:自己定义，后缀：.so。所以最终的动态库的名字应该为：libxxx.so。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成目标文件，此时要加编译选项：-fPIC(fpic)参数-fPIC创建与地址无关的编译程序（pic,position independent code）,是为了能在多个应用程序间共享。</span></span><br><span class="line">gcc -fPIC -c add.c</span><br><span class="line">gcc -fPIC -c sub.c</span><br><span class="line">gcc -fPIC -c mul.c</span><br><span class="line">gcc -fPIC -c div.c</span><br><span class="line"><span class="comment">#生成共享库，此时要加链接器选项：-shared(指定生成动态链接库)</span></span><br><span class="line">gcc -shared add.o sub.o mul.o div.o -o libtest.so</span><br><span class="line"><span class="comment">#通过nm命令查看对应的函数</span></span><br><span class="line">nm libtest.so | grep <span class="string">&quot;add&quot;</span></span><br><span class="line"><span class="comment">#通过ldd命令查看可执行文件依赖的动态库</span></span><br><span class="line">ldd <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="动态库使用"><a href="#动态库使用" class="headerlink" title="动态库使用"></a>动态库使用</h3><p>引用动态库编译成可执行文件（和静态库一样）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L./ -I./ -ltest -o main#注意这里链接库的名字</span><br></pre></td></tr></table></figure><p>这一步是可以过的，但是到了，执行main时发现找不到对应文件。第一种就是把libtest.so复制到&#x2F;lib里（需要sudo,这个方法不推荐，最好不要动Linux原本文件，覆盖了就不好玩了。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -I./ -ltest -o main#注意这里链接库的名字,执行可执行文件就可以执行了，这种方法不推荐</span><br></pre></td></tr></table></figure><h3 id="动态库加载失败问题解决"><a href="#动态库加载失败问题解决" class="headerlink" title="动态库加载失败问题解决"></a>动态库加载失败问题解决</h3><p>当系统加载可执行代码，能够知道其所依赖的库的名字，但还需要知道其绝对路径。此时就需要系统动态载入器（dynamic linker&#x2F;loader）。对于elf格式的可执行程序，是由ld-linux.so*来完成，他先后搜索elf文件的DT_RPATH段—环境变量LD_LIBRARY_PATH—&#x2F;etc&#x2F;ld.so.cache文件列表—&#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib目录找到库文件后将其载入内存。</p><p>拷贝自己制作的共享库到&#x2F;lib或者&#x2F;usr&#x2F;lib(不能是&#x2F;lib64目录)</p><p>临时设置LD_LIBRARY_PATH(只在当前终端生效):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:库路径#在原环境变量追加新的变量，库路径为绝对路径。</span><br></pre></td></tr></table></figure><p>永久设置:把export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:库路径这段话，设置到~&#x2F;.bashrc </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc <span class="comment">#让配置文件生效</span></span><br></pre></td></tr></table></figure><p>除了以上三种还有两种将其添加到&#x2F;etc&#x2F;ld.so.conf,这里只需要添加绝对路径，然后sudo ldconfig -v使路径生效。</p><p>还有使用符号链接，但一定要使用绝对路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s 库文件的绝对路径 /lib/库文件</span><br></pre></td></tr></table></figure><h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2><p>GDB主要完成下面四个功能：</p><p>1.启动程序，可以按照你的自定义的要求随心所欲的运行程序。</p><p>2.可让被调试的程序在你指定的断点停住。</p><p>3.当程序被停住时，可以检查此时你的程序中所发生的事。</p><p>4.动态的改变你程序的执行环境。</p><h3 id="生成调试信息"><a href="#生成调试信息" class="headerlink" title="生成调试信息"></a>生成调试信息</h3><p>一般来说GDB主要调试的是C&#x2F;C++的程序，要调试C&#x2F;C++的程序，首先在编译时，我们必须把调试信息加到可执行文件中。使用编译器（cc&#x2F;gcc&#x2F;g++）的-g参数可以做到这一点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g hello.c -o hello</span><br><span class="line">g++ -g hello.c -o hello</span><br></pre></td></tr></table></figure><h3 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h3><p>启动gdb:<strong>gdb program</strong></p><p>program也就是你的执行文件，一般在当前目录下。</p><p>设置启动参数:启动后设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> args <span class="comment">#可指定运行参数</span></span><br><span class="line"><span class="built_in">set</span> args 10 20 30 40 <span class="string">&quot;hello world&quot;</span></span><br><span class="line">show args <span class="comment">#命令可以查看设置好的运行参数</span></span><br></pre></td></tr></table></figure><p><strong>启动程序：</strong></p><p>run:程序开始执行，如果有断点，停在第一个断点处。</p><p>start:程序向下执行一行。</p><p>n:执行下一步。</p><h3 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h3><p>用list（也可直接打l）命令来打印程序的源代码。默认打印10行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list <span class="keyword">function</span>#显示函数名为<span class="keyword">function</span>的函数的源码</span><br><span class="line"><span class="built_in">set</span> listsize count <span class="comment">#设置一次显示源码的行数默认是10行</span></span><br><span class="line">show listsize <span class="comment">#查看当前listsize的设置</span></span><br></pre></td></tr></table></figure><h3 id="断点操作"><a href="#断点操作" class="headerlink" title="断点操作"></a>断点操作</h3><p>简单断点:</p><p>break设置断点，可以简写为b</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b 10 <span class="comment">#设置断点，在源程序第十行</span></span><br><span class="line">b func <span class="comment">#设置断点，在func函数入口处</span></span><br></pre></td></tr></table></figure><p>多文件设置断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> filename:linenum <span class="comment">#在源文件filename的linenum行处停住</span></span><br><span class="line"><span class="built_in">break</span> filename:<span class="keyword">function</span> <span class="comment">#在源文件filename的function函数的入口处停住</span></span><br><span class="line"><span class="built_in">break</span> class::<span class="keyword">function</span>或者<span class="keyword">function</span>(<span class="built_in">type</span>,<span class="built_in">type</span>) <span class="comment">#在类class的function函数入口处停住</span></span><br><span class="line"><span class="built_in">break</span> namespace::class::<span class="keyword">function</span> <span class="comment">#在名称空间为namespace的类class的function函数的入口处停住。</span></span><br></pre></td></tr></table></figure><p>查询所有断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info b</span><br><span class="line">info <span class="built_in">break</span></span><br><span class="line">i <span class="built_in">break</span></span><br><span class="line">i b</span><br></pre></td></tr></table></figure><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。</p><p>设置一个条件断点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b test.c:8 <span class="keyword">if</span> Value == 5 <span class="comment">#对test.c文件的当变量Value满足为5时，在test.c文件的第8行产生断点</span></span><br></pre></td></tr></table></figure><h3 id="维护断点"><a href="#维护断点" class="headerlink" title="维护断点"></a>维护断点</h3><p>delete 范围 删除指定的断点，其简写命令为d。如果不指定断点号，则表示删除所有的断点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d 10-12 <span class="comment">#删除编号为10-12的断点。编号可以使用i b命令查看</span></span><br></pre></td></tr></table></figure><p>比删除更好的一种方法时disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> 断点编号 <span class="comment">#使指定断点无效，简写命令是dis。如果什么都不指定，表示disable所有的停止点。</span></span><br><span class="line"><span class="built_in">enable</span> 断点编号 <span class="comment">#使无效断点生效，简写命令是ena。如果什么都不指定，表示enable所有的停止点</span></span><br></pre></td></tr></table></figure><h3 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">run <span class="comment">#运行程序，可简写为r。程序开始执行，如果有断点，停在第一个断点处。</span></span><br><span class="line">next <span class="comment">#单步跟踪，函数调用当作一条简单语句执行，可简写为n。</span></span><br><span class="line">step <span class="comment">#单步跟踪，函数调用进入被调用函数体内，可简写为s。</span></span><br><span class="line">finish <span class="comment">#退出进入的函数</span></span><br><span class="line"><span class="keyword">until</span> <span class="comment">#在一个循环体单步跟踪时，这个命令可以运行程序直到退出循环体，可简写为u。</span></span><br><span class="line"><span class="built_in">continue</span> <span class="comment">#继续运行程序，停在下一个断点的位置，可简写为c。</span></span><br><span class="line">quit <span class="comment">#退出gdb,可简写为q。</span></span><br></pre></td></tr></table></figure><h3 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看运行时的数据</span></span><br><span class="line"><span class="comment">#print打印变量，字符串，表达式等的值，可简写为p。</span></span><br><span class="line">p count <span class="comment">#打印count的值</span></span><br></pre></td></tr></table></figure><h3 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h3><p>可以设置一些自动显示的变量，当程序停住时，或在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">display 变量名 <span class="comment">#在run启动程序后，使用该命令。</span></span><br><span class="line">info display <span class="comment">#查看display设置的自动显示的信息（可以看到对应变量名的编号）</span></span><br><span class="line">undisplay num <span class="comment">#info display是显示的编号 使对应编号的自动显示功能失效。</span></span><br><span class="line">delete display dnums <span class="comment">#删除自动显示，dnums意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围的编号，可以用减号表示。</span></span><br><span class="line"><span class="built_in">disable</span> display dnums</span><br><span class="line"><span class="built_in">enable</span> display dnums</span><br><span class="line"><span class="built_in">disable</span>和<span class="built_in">enable</span>#不删除自动显示的设置，而只是让其失效和恢复。</span><br></pre></td></tr></table></figure><h3 id="查看修改变量的值"><a href="#查看修改变量的值" class="headerlink" title="查看修改变量的值"></a>查看修改变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptype width <span class="comment">#查看变量width的类型</span></span><br><span class="line">p width <span class="comment">#打印变量width的值 p是print命令的缩写。</span></span><br><span class="line"><span class="built_in">set</span> var width=47 <span class="comment">#将变量var值设置为47。在改变程序变量取值时，最好都使用set var格式的GDB命令。</span></span><br></pre></td></tr></table></figure><h2 id="自动化编译工具Makefile"><a href="#自动化编译工具Makefile" class="headerlink" title="自动化编译工具Makefile"></a>自动化编译工具Makefile</h2><p>make是个命令工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install make <span class="comment">#下载make命令</span></span><br></pre></td></tr></table></figure><h3 id="Makefile语法规则"><a href="#Makefile语法规则" class="headerlink" title="Makefile语法规则"></a>Makefile语法规则</h3><p>一条规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标：依赖文件列表</span><br><span class="line">&lt;Tab&gt;命令列表</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:test1 test2</span></span><br><span class="line">echo <span class="string">&quot;hello all&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">test1:</span></span><br><span class="line">echo <span class="string">&quot;hello test1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">test2:</span></span><br><span class="line">echo <span class="string">&quot;hello test2&quot;</span></span><br><span class="line"><span class="comment">#总共三条规则</span></span><br><span class="line"><span class="comment">#执行结果：make -f 1.mk</span></span><br><span class="line">echo <span class="string">&quot;hello test1&quot;</span></span><br><span class="line">hello test1</span><br><span class="line">echo <span class="string">&quot;hello test2&quot;</span></span><br><span class="line">hello test2</span><br><span class="line">echo <span class="string">&quot;hello all&quot;</span></span><br><span class="line">hello all</span><br></pre></td></tr></table></figure><p>Makefile基本规则三要素：</p><p>目标:</p><p>​通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作的名称。</p><p>依赖文件：</p><p>​用来输入从而产生目标的文件。</p><p>​一个目标通常有几个依赖文件（可以没有）</p><p>命令：</p><p>​make执行的动作，一个规则可以含几个命令（可以没有）</p><p>​有多个命令，每个命令占一行。</p><h3 id="make命令格式"><a href="#make命令格式" class="headerlink" title="make命令格式"></a>make命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">make [-f file][options][targets]</span><br><span class="line">[-f file]:</span><br><span class="line">make默认在工作目录中寻找为GNUmakefile,makefile,Makefile的文件作为makefile输入文件。</span><br><span class="line">-f可以指定以上名字以外的文件作为makefile输入文件。</span><br><span class="line">[options]:</span><br><span class="line">-v 显示make工具的版本</span><br><span class="line">-w 在处理makefile之前和之后显示工作路径</span><br><span class="line">-C <span class="built_in">dir</span> 读取makefile之前改变工作路径至<span class="built_in">dir</span>目录</span><br><span class="line">-n 只打印要执行的命令但不执行</span><br><span class="line">-s 执行但不显示执行的命令</span><br><span class="line">[targets]:</span><br><span class="line">若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个规则</span><br><span class="line">指定了make工具要实现的目标，目标可以是一个或多个（多个目标用空格隔开）</span><br><span class="line">make test1 -f 1.mk <span class="comment">#就会执行目标为test1对应的语句。</span></span><br></pre></td></tr></table></figure><h3 id="Makefile示例"><a href="#Makefile示例" class="headerlink" title="Makefile示例"></a>Makefile示例</h3><p>测试程序：test.c add.c sub.c mul.c div.c add.h sub.h mul.h div.h</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#最简单的Makefile(首先vim Makefile)</span></span><br><span class="line"><span class="section">test:test.c add.c sub.c mul.c div.c</span></span><br><span class="line">gcc test.c add.c sub.c mul.c div.c -o test</span><br></pre></td></tr></table></figure><p>缺点：效率低，修改一个文件，所有文件都要重新编译。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:test.o add.o sub.o mul.o div.o </span></span><br><span class="line">gcc test.o add.o sub.o mul.o div.o -o test</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">gcc -c mul.c -o mul.o</span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">gcc -c div.c -o div.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure><p>这样，下次编译，他只会编译你修改的文件，最后再链接，这样是比较高效的。</p><h3 id="Makefile中的变量"><a href="#Makefile中的变量" class="headerlink" title="Makefile中的变量"></a>Makefile中的变量</h3><p>在Makefile中使用变量有点类似c语言的宏定义，使用该变量相当于内容替换，使用变量可以使Makefile易于维护。如果.o文件很多，难道我们要一个一个打吗，这也未免太麻烦，还可能漏打。</p><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><p>定义变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名=变量值</span><br></pre></td></tr></table></figure><p>引用变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(变量名)或$&#123;变量名&#125;</span><br></pre></td></tr></table></figure><p>makefile的变量名：</p><p>makefile变量名可以以数字开头。</p><p>变量是大小写敏感的。</p><p>变量一般在makefile的头部定义</p><p>变量几乎可在makefile的任何地方使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJS = test.o add.o sub.o mul.o div.o</span><br><span class="line"><span class="section">test:<span class="variable">$(OBJS)</span></span></span><br><span class="line">gcc <span class="variable">$(OBJS)</span> -o test</span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">gcc -c mul.c -o mul.o</span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">gcc -c div.c -o div.o</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure><p>除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户使用，我们可以直接对其进行赋值。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line"><span class="section">CPPFLAGS:</span></span><br><span class="line"><span class="section">CFLAGS:</span></span><br><span class="line"><span class="section">LDFLAGS:</span></span><br></pre></td></tr></table></figure><h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这些变量不能单独使用 必须在命令中使用</span></span><br><span class="line"><span class="comment"># $@ 表示目标</span></span><br><span class="line"><span class="comment"># $^ 表示所有的依赖</span></span><br><span class="line"><span class="comment"># $&lt; 表示第一个依赖</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OBJS = test.o add.o sub.o mul.o div.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h4 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#模式规则匹配示例</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line"><span class="variable">$(cc)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJS=test.o add.o sub.o mul.o div.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="comment">#模式匹配 所有的.o都依赖对应的.c</span></span><br><span class="line"><span class="comment">#将所有的.c生成对应的.o</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h3 id="Makefile的函数"><a href="#Makefile的函数" class="headerlink" title="Makefile的函数"></a>Makefile的函数</h3><p>常用的函数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wildcard <span class="comment">#查找指定目录下的指定类型的文件</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="comment">#找到当前目录下所有后缀为.c的文件，赋值给src</span></span><br><span class="line">patsubst <span class="comment">#匹配替换</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(src)</span>)</span> <span class="comment">#把src变量里所有后缀为.c的文件替换成.o</span></span><br></pre></td></tr></table></figure><p>在makefile中所有的函数都是有返回值的。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取当前目录下所有的.c文件</span></span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"><span class="comment">#将SRC中所有出现的.c的替换成.o</span></span><br><span class="line">OBJS=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SRC)</span>)</span></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="comment">#模式匹配 所有的.o都依赖对应的.c</span></span><br><span class="line"><span class="comment">#将所有的.c生成对应的.o</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#clean目标清除编译生成的中间文件</span></span><br><span class="line"><span class="comment">#执行命令 make clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><h3 id="Makefile中的伪目标"><a href="#Makefile中的伪目标" class="headerlink" title="Makefile中的伪目标"></a>Makefile中的伪目标</h3><p>clean用途：清除编译生成的中间.o文件和最终目标文件</p><p>make clean 如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：</p><p>伪目标声明：.PHONY:clean 声明目标为伪目标之后，makefile将不会判断目标是否存在或者该目标是否需要更新。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取当前目录下所有的.c文件</span></span><br><span class="line">SRC=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"><span class="comment">#将SRC中所有出现的.c的替换成.o</span></span><br><span class="line">OBJS=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SRC)</span>)</span></span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="comment">#模式匹配 所有的.o都依赖对应的.c</span></span><br><span class="line"><span class="comment">#将所有的.c生成对应的.o</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#clean目标清除编译生成的中间文件</span></span><br><span class="line"><span class="comment">#执行命令 make clean</span></span><br><span class="line"><span class="comment">#声明clean为伪目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>上面这个版本就是最终版。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="comment">#在命令前加上@符号，表示不显示命令本身（默认显示），只显示结果</span></span><br><span class="line">-gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="comment">#加上-符号，此条命令出错，make也会继续执行后续的命令。</span></span><br></pre></td></tr></table></figure><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用说的是操作系统提供给用户程序调用的一组”特殊”接口</p><h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h3><p>Linux下对文件操作有两种方式：系统调用和库函数调用</p><p>库函数调用有两类函数组成：</p><p>不需要系统调用：不需要切换到内核空间即可完成函数全部功能，并且结果反馈给应用程序，如strcpy,bzero等字符串操作函数。</p><p>需要调用系统调用：需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如printf,fread等。</p><p><img src="/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/4.png" alt="4"></p><h3 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h3><p>errno是记录系统的最后一次错误代码，代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。</p><p>当Linux C api函数出现异常时，一般会将errno全局变量赋一个整数值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//fopen</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> <span class="comment">//errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">//strerror(errno)</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *fp=fopen(<span class="string">&quot;xxxx&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,errno);<span class="comment">//打印错误码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,strerror(errno));<span class="comment">//把errno的数字转换为相应的文字</span></span><br><span class="line">        perror(<span class="string">&quot;fopen err&quot;</span>); <span class="comment">//打印错误原因的字符串</span></span><br><span class="line">        <span class="comment">//perror和printf(&quot;%d\n&quot;,strerror(errno));实现效果相同。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>每个进程都会分配虚拟地址空间，在32位机器上，该地址空间为4G。Linux每个运行的程序（进程），操作系统就会为其分配一个0<del>4G的地址空间（虚拟地址空间）。0</del>3G是用户区，3G~4G是内核区。在进程里平时所说的指针变量，保存的就是虚拟地址，当应用程序使用虚拟地址访问内存时，处理器会将其转换为物理地址（MMU）MMU将虚拟地址转换为物理地址。这样做的好处在于：进程隔离，更好的保护系统安全运行，屏蔽物理差异带来的麻烦，方便操作系统和编译器安排进程地址。</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>打开现存文件或新建文件时，系统内核会返回一个文件描述符，文件描述符用来指定已打开的的文件。这个文件描述符相当于已打开文件的标号，文件描述符是非负整数，是文件的标识，操作这个文件描述符相当于操作这个描述符所指定的文件。</p><p>程序运行起来后（每个进程）都有一张文件描述符的表，标准输入，标准输出，标准错误输出设备文件被打开，对应的文件描述符0，1，2记录在表中。程序运行起来后这三个文件描述符是默认打开的。</p><p>在程序运行起来后，打开其他文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中。</p><h4 id="最大打开的文件个数："><a href="#最大打开的文件个数：" class="headerlink" title="最大打开的文件个数："></a>最大打开的文件个数：</h4><p>​Linux中一个进程最多只能打开NR_OPEN_DEFAULT(即1024)个文件（当然这个数量的设定是可以修改的），故当文件不再使用时应该及时调用close()函数关闭文件。</p><h3 id="常用文件IO函数"><a href="#常用文件IO函数" class="headerlink" title="常用文件IO函数"></a>常用文件IO函数</h3><h4 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">int</span> flags,<span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>功能：</p><p>​打开文件，如果文件不存在则可以选择创建。</p><h4 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span></span><br></pre></td></tr></table></figure><p>功能：</p><p>​关闭已打开的文件。</p><p>需要说明的是，当一个进程终止时，内核对该进程所有未关闭的文件描述符调用close关闭，所以即使用户程序不调用close,在终止时内核也会自动关闭它打开的文件。</p><p>但是对于一个常年累月的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量的文件描述符和系统资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/type.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//打开和关闭文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//以只读的方式打开一个文件，如果文件不存在就报错。</span></span><br><span class="line">    <span class="comment">//fd=open(&quot;txt&quot;,O_RDONLY);</span></span><br><span class="line">    <span class="comment">//以只写的方式打开一个文件 如果文件存在就直接打开 如果文件不存在就新建一个文件。</span></span><br><span class="line">    <span class="comment">//fd=open(&quot;txt&quot;,O_WRONLY|O_CREAT,644);</span></span><br><span class="line">    <span class="comment">//以只写的方式打开一个文件，如果文件存在就报错，如果文件不存在就新建一个。</span></span><br><span class="line">    <span class="comment">//fd=open(&quot;txt&quot;,O_WRONLY|O_CREAT|O_EXCL,644);</span></span><br><span class="line">    <span class="comment">//以读写方式打开一个文件，如果文件存在就打开，如果文件不存在就新建一个文件。</span></span><br><span class="line">    <span class="comment">//fd=open(&quot;txt&quot;,O_RDWR|O_CREAT,644);</span></span><br><span class="line">    <span class="comment">//O_TRUNC 清空文件内容,如果文件存在，打开并清空，不存在就新建一个文件。</span></span><br><span class="line">    <span class="comment">//fd=open(&quot;txt&quot;,O_WRONLY|O_TRUNC|O_CREAT,644);</span></span><br><span class="line">    <span class="comment">//O_APPEND 追加的方式</span></span><br><span class="line">    <span class="comment">//以只写的方式和追加的方式打开一个文件 如果文件不存在会报错。</span></span><br><span class="line">    fd=open(<span class="string">&quot;txt&quot;</span>,O_WRONLY|O_APPEND)</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">void</span>* buf,<span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据写到文件（fd）</span><br><span class="line">参数：</span><br><span class="line">    fd: 文件描述符</span><br><span class="line">    buf:数据首地址</span><br><span class="line">    count:写入数据的长度（字节）</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际写入数据的字节个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span> *buf,<span class="type">size_t</span> count)</span>;</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据读到内存（缓冲区）</span><br><span class="line">参数：</span><br><span class="line">    fd:文件描述符</span><br><span class="line">    buf:内存首地址</span><br><span class="line">    count:读取的字节个数</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际读取的字节个数</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="阻塞和非阻塞的概念"><a href="#阻塞和非阻塞的概念" class="headerlink" title="阻塞和非阻塞的概念"></a>阻塞和非阻塞的概念</h4><p>读常规文件是不会阻塞，不管读多少字节，read一定会在有限的时间内返回。</p><p>从终端设备或网络则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会堵塞，如果网络上没有接受到数据包，调用read从网络读就会，至于会阻塞多久也是不确定的，如果没有一直收到数据到达就一直阻塞在那里。</p><p>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</p><p>阻塞和非阻塞是对于文件而言，而不是指read,write等的属性。</p><h4 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd,<span class="type">off_t</span> offset,<span class="type">int</span> whence)</span>;</span><br><span class="line">功能：</span><br><span class="line">    改变文件的偏移量</span><br><span class="line">参数：</span><br><span class="line">    fd:文件描述符</span><br><span class="line">    offset:根据whence来移动的位移数（偏移量），可以是正数，也可以是负数，如果正数，则相对于whence往右移动，如果是负数则相对于whence向左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。</span><br><span class="line">    whence:其取值如下：</span><br><span class="line">        SEEK_SET:从文件开头移动offset个字节</span><br><span class="line">        SEEK_CUR:从当前位置移动offset个字节</span><br><span class="line">        SEEK_END:从文件末尾移动offset个字节</span><br><span class="line">返回值：</span><br><span class="line">   若lseek成功执行，则返回新的偏移量</span><br><span class="line">    如果失败，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>所有打开的文件都有一个当前文件偏移量（current file offset）以下简称为cfo。cfo通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。</p><p>读写操作通常开始cfo,并且使cfo变大，增量为读写的字节数。文件被打开时，cfo会被初始化为0，除非使用了O_APPEND。</p><p>如果把文件偏移量移到最后，使用read函数，将不会读出数据。要将文件描述符提前移到开头或者其他可以读到的位置。所以要注意文件描述符的位置。</p><h3 id="文件操作相关函数"><a href="#文件操作相关函数" class="headerlink" title="文件操作相关函数"></a>文件操作相关函数</h3><h4 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path,<span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line">功能：</span><br><span class="line">获取文件状态信息</span><br><span class="line">    stat和lstat的区别：</span><br><span class="line">    当文件是一个符号链接时,lstat返回的是该符号链接本身的信息；</span><br><span class="line">    而stat返回的是该链接指向的文件的信息。</span><br><span class="line">参数：</span><br><span class="line">    path:文件名</span><br><span class="line">    buf:保存文件信息的结构体</span><br><span class="line">返回值:</span><br><span class="line">成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span> 文件不存在</span><br></pre></td></tr></table></figure><p>stat函数和命令stat 文件名的功能类似。</p><p>struct stat *buf结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">           <span class="type">dev_t</span>      st_dev;      <span class="comment">/* ID of device containing file */</span></span><br><span class="line">           <span class="type">ino_t</span>      st_ino;      <span class="comment">/* Inode number */</span></span><br><span class="line">           <span class="type">mode_t</span>     st_mode;     <span class="comment">/* File type and mode */</span></span><br><span class="line">           <span class="type">nlink_t</span>    st_nlink;    <span class="comment">/* Number of hard links */</span></span><br><span class="line">           <span class="type">uid_t</span>      st_uid;      <span class="comment">/* User ID of owner */</span></span><br><span class="line">           <span class="type">gid_t</span>      st_gid;      <span class="comment">/* Group ID of owner */</span></span><br><span class="line">           <span class="type">dev_t</span>      st_rdev;     <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">           <span class="type">off_t</span>      st_size;     <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">           <span class="type">blksize_t</span>  st_blksize;  <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">           <span class="type">blkcnt_t</span>   st_blocks;   <span class="comment">/* Number of 512 B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Since POSIX.1-2008, this structure supports nanosecond</span></span><br><span class="line"><span class="comment">              precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">              For the details before POSIX.1-2008, see VERSIONS. */</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>  <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>  <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>  <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">       <span class="meta">#<span class="keyword">define</span> st_atime  st_atim.tv_sec  <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">define</span> st_mtime  st_mtim.tv_sec</span></span><br><span class="line">       <span class="meta">#<span class="keyword">define</span> st_ctime  st_ctim.tv_sec</span></span><br><span class="line">       &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line">        <span class="comment">//获取指定文件信息</span></span><br><span class="line">        ret=stat(<span class="string">&quot;txt&quot;</span>,&amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//文件属性信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st_dev:%lu\n&quot;</span>,s.st_dev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st_ino:%ld\n&quot;</span>,s.st_ino);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> st_mode;可以获取文件类型和文件三种用户的权限。</p><h4 id="access函数"><a href="#access函数" class="headerlink" title="access函数"></a>access函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">int</span> mode)</span>;</span><br><span class="line">功能：测试指定文件是否具有某种属性</span><br><span class="line">参数：</span><br><span class="line">    pathname:文件名</span><br><span class="line">    mode:文件权限，<span class="number">4</span>种权限（判断文件所属者）</span><br><span class="line">        R_OK:是否有读权限</span><br><span class="line">        W_OK:是否有写权限</span><br><span class="line">        X_OK:是否有执行权限</span><br><span class="line">        F_OK:测试文件是否存在</span><br><span class="line">返回值：</span><br><span class="line">     <span class="number">0</span>：有某种权限，或者文件存在</span><br><span class="line">     <span class="number">-1</span>：没有，或者文件不存在</span><br></pre></td></tr></table></figure><h4 id="chmod函数"><a href="#chmod函数" class="headerlink" title="chmod函数"></a>chmod函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*pathname,<span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：修改文件权限</span><br><span class="line">参数：</span><br><span class="line">    pathname:文件名</span><br><span class="line">    mode:权限（<span class="number">8</span>进制数）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="chown函数"><a href="#chown函数" class="headerlink" title="chown函数"></a>chown函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">uid_t</span> owner,<span class="type">gid_t</span> group)</span>;</span><br><span class="line">功能：修改文件所有者和所属组</span><br><span class="line">参数：</span><br><span class="line">    pathname:文件或目录名</span><br><span class="line">    owner:文件所有者id，通过查看/etc/passwd得到所有者id</span><br><span class="line">    group；文件所属组id,通过查看/etc/group得到用户组id</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="truncate函数"><a href="#truncate函数" class="headerlink" title="truncate函数"></a>truncate函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">off_t</span> length)</span>;</span><br><span class="line">功能：修改文件大小</span><br><span class="line">参数：</span><br><span class="line">    path:文件名字</span><br><span class="line">    length:指定的文件大小</span><br><span class="line">        比原来小，删掉后边的部分</span><br><span class="line">        比原来大，向后拓展</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="link函数"><a href="#link函数" class="headerlink" title="link函数"></a>link函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldpath,<span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br><span class="line">功能：创建一个硬链接</span><br><span class="line">参数：</span><br><span class="line">    oldpath:源文件名字</span><br><span class="line">    newpath:硬链接名字</span><br><span class="line">返回值：</span><br><span class="line">   成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="symlink函数"><a href="#symlink函数" class="headerlink" title="symlink函数"></a>symlink函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* target,<span class="type">const</span> <span class="type">char</span>* linkpath)</span>;</span><br><span class="line">功能：创建一个软链接</span><br><span class="line">参数：</span><br><span class="line">    target：源文件名字</span><br><span class="line">    linKpath:软链接名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>剩下的还有<strong>readlink函数</strong>，<strong>unlink函数</strong>，<strong>rename函数</strong></p><h3 id="文件描述符复制"><a href="#文件描述符复制" class="headerlink" title="文件描述符复制"></a>文件描述符复制</h3><p>dup()和dup2()是两个非常有用的系统调用，都是用来复制一个文件的描述符，使新的文件描述符也标识旧的文件描述符所标识的文件</p><p>对比于dup(),dup2()也一样，通过原来的文件描述符复制出一个新的文件描述符，这样的话，原来的文件描述符和新的文件描述符都指向同一个文件，我们操作这两个文件描述符的任何一个，都能操作它所对应的文件。</p><h4 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    通过oldfd复制出一个新的文件描述符，新的文件描述符使调用进程文件描述符表中最小可用的文件描述符，最终oldfd和新的文件描述符都指向同一个文件。</span><br><span class="line">参数：</span><br><span class="line">    oldfd:需要复制的文件描述符oldfd</span><br><span class="line">返回值：</span><br><span class="line">    成功：新文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>函数示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//dup dup2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> newfd=<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//1.打开文件</span></span><br><span class="line">        fd=open(<span class="string">&quot;txt&quot;</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">newfd=dup(fd);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span>==newfd)&#123;</span><br><span class="line">             perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newfd=%d\n&quot;</span>,newfd);</span><br><span class="line">        <span class="comment">//2.操作</span></span><br><span class="line">        write(fd,<span class="string">&quot;ABCDEFG&quot;</span>,<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//因为这两个文件描述符共享一张文件表，所以当前文件的偏移量是共享的，所以下次不会覆盖而是追加</span></span><br><span class="line">        <span class="comment">//使用另外一个文件描述符</span></span><br><span class="line">        write(newfd,<span class="string">&quot;1234567&quot;</span>,<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//3.关闭文件描述符</span></span><br><span class="line">        close(fd);</span><br><span class="line">        close(newfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dup2函数"><a href="#dup2函数" class="headerlink" title="dup2函数"></a>dup2函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd,<span class="type">int</span> newfd)</span>;</span><br><span class="line">功能：</span><br><span class="line">    通过oldfd复制出一个新的文件描述符newfd,如果成功，newfd和函数返回值是同一个返回值，最终oldfd和新的文件描述符newfd都指向同一个文件。</span><br><span class="line">参数：</span><br><span class="line">    oldfd:需要复制的文件描述符</span><br><span class="line">    newfd:新的文件描述符，这个描述符可以人为指定一个合法数字（<span class="number">0</span><span class="number">-1023</span>），如果指定的数字已经被占用，此函数会自动关闭close()断开这个数字和某个文件的关联，再来使用这个合法数字。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回newfd</span><br><span class="line">    失败；返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><p>注意：这里有个场景，我有两个程序都是要打开同一个文件并且向里面写东西，当然这就有两个open函数，那我先后打开该文件，前者写的会被后者写的覆盖掉吗，这是会的。因为每次open函数都会把文件偏移量的位置放回0。但是dup函数和dup2函数不会，因为复制的文件描述符共享一个文件描述符表项的。</p><h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> cmd,...<span class="comment">/*arg */</span>)</span>;</span><br><span class="line">功能：改变已打开的文件性质，fcntl针对描述符提供控制。</span><br><span class="line">参数：</span><br><span class="line">    fd:操作的文件描述符</span><br><span class="line">    cmd:操作方式</span><br><span class="line">    arg:针对cmd的值，fcntl能够接受第三个参数<span class="type">int</span> arg。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回某个其他值</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//fcntl复制文件描述符功能</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> newfd=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.打开文件</span></span><br><span class="line">    fd=open(<span class="string">&quot;txt&quot;</span>,O_WRONLY|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd=%d\n&quot;</span>,fd);</span><br><span class="line">    <span class="comment">//2.文件描述符复制</span></span><br><span class="line">    <span class="comment">//功能等价于dup函数</span></span><br><span class="line">    <span class="comment">//第三个参数0 表示返回一个最小的可用的文件描述符，并且大于或者等于0</span></span><br><span class="line">    newfd=fcntl(fd,F_DUPFD,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==newfd)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;newfd=%d\n&quot;</span>,newfd);</span><br><span class="line">    <span class="comment">//3.写操作</span></span><br><span class="line">    write(fd,<span class="string">&quot;123456789&quot;</span>,<span class="number">9</span>);</span><br><span class="line">    write(newfd,<span class="string">&quot;ABCDEFGH&quot;</span>,<span class="number">8</span>);</span><br><span class="line">    <span class="comment">//4.关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    close(newfd)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fcntl函数还可以改变文件状态标记。</p><h3 id="目录相关操作"><a href="#目录相关操作" class="headerlink" title="目录相关操作"></a>目录相关操作</h3><h4 id="getcwd函数"><a href="#getcwd函数" class="headerlink" title="getcwd函数"></a>getcwd函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf,<span class="type">size_t</span> size)</span>;</span><br><span class="line">功能：获取当前进程的工作目录</span><br><span class="line">参数：</span><br><span class="line">    buf:缓冲区，存储当前的工作目录</span><br><span class="line">    size:缓冲区大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：buf中保存当前进程工作目录位置</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><h4 id="chdir函数"><a href="#chdir函数" class="headerlink" title="chdir函数"></a>chdir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line">功能：修改当前进程（应用程序）的路径</span><br><span class="line">参数：</span><br><span class="line">    path:切换的路径</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="opendir函数"><a href="#opendir函数" class="headerlink" title="opendir函数"></a>opendir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*name)</span>;</span><br><span class="line">功能：打开一个目录</span><br><span class="line">参数：</span><br><span class="line">    name:目录名</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回指向该目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><h4 id="closedir函数"><a href="#closedir函数" class="headerlink" title="closedir函数"></a>closedir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">功能：关闭目录</span><br><span class="line">参数：</span><br><span class="line">    dirp:opendir返回指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent* <span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line">功能：读取目录</span><br><span class="line">参数：</span><br><span class="line">    dirp:opendir的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p><strong>readdir函数要读取目录所有内容是要循环读取。</strong> </p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h3><p>我们平时写的C语言代码，通过编译器编译，最终它会成为一个可执行程序，当这个可执行程序运行起来后（没有结束前），他就成为了一个进程。程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建，调度和消亡。程序是静态的，进程是动态的。</p><p>在Linux系统中，操作系统是通过进程去完成一个一个的任务，<strong>进程是管理事务的基本单元</strong>。</p><p>进程拥有自己独立的处理环境（当前需要用到那些环境变量，程序运行的目录在哪里，当前是哪个用户在运行此程序）和系统资源（处理器cpu占用率，存储器，I&#x2F;O设备，数据，程序）。</p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并行：指在同一时刻，有多条指令在多个处理器上同时执行。</p><p>并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><h3 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h3><p>MMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器，物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。</p><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><p>进程运行时，内核为进程每个进程分配一个PCB(进程控制块)，维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p><p>这个结构体的内部成员有很多，我们要知道的：</p><ol><li>进程id。系统中每个进程有唯一的id,在C语言中用pid_t类型表示，其实就是一个非负整数。</li><li>进程的状态，有就绪，运行，挂起，停止等状态。</li><li>进程切换时需要保存和恢复的一些CPU寄存器。</li><li>描述虚拟地址空间的信息。</li><li>描述控制终端的信息。</li><li>当前工作目录。</li><li>umask掩码</li><li>文件描述符表，包含很多指向file结构体的指针。</li><li>和信号相关的信息。</li><li>用户id和组id</li><li>会话（Session）和进程组。</li><li>进程可以使用的资源上限（Resource Limit）。</li></ol><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。</p><p>在三态模型中，进程状态分为三个基本状态，即运行态，就绪态，阻塞态。</p><p>在五态模型中，进程分为新建态，终止态，运行态，就绪态，阻塞态。</p><p><img src="/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/5.png" alt="5"></p><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。</p><p>ps命令可以查看进程的详细情况，常用选项（选项可以不加”-“）。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示终端上的所有进程，包括其他用户的进程</td></tr><tr><td><code>-u</code></td><td>显示进程的详细状态&#96;</td></tr><tr><td><code>-x</code></td><td>显示无控制终端的进程</td></tr><tr><td><code>-r</code></td><td>只显示正在运行的进程</td></tr></tbody></table><p>ps aux</p><p>ps ef和aux等价</p><p>ps -a</p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>用来动态显示运行中的进程。</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>kill命令指定进程号的进程，需要配合ps使用。</p><p>使用格式：</p><p>kill [-signal] pid</p><p>信号值从0-15，其中9为绝对终止，可以处理一般信号无法终止的进程。</p><p>有些进程不能直接杀死，这时候我们需要加一个参数”-9”,”-9”代表强制结束。</p><h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><p>通过进程名字杀死进程,进程名字是可以重复的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -9 <span class="built_in">sleep</span></span><br></pre></td></tr></table></figure><h3 id="进程号和相关函数"><a href="#进程号和相关函数" class="headerlink" title="进程号和相关函数"></a>进程号和相关函数</h3><p>每个进程都由一个进程号来标识，其类型为pid_t（整型），进程号的范围：0~32767（2的15次方-1）。进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用。</p><h4 id="三个不同的进程号"><a href="#三个不同的进程号" class="headerlink" title="三个不同的进程号"></a>三个不同的进程号</h4><p><strong>进程号（PID）</strong>:</p><p>标识进程的一个非负整型数。</p><p><strong>父进程号（PPID）</strong>:<br>任何进程（除init进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号成为父进程号（PPID）。如A进程创建了B进程，A的进程号就是B进程的父进程号。</p><p><strong>进程组号（PGID）</strong>:</p><p>进程组是一个或多个进程的集合，他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当作当前的进程组号。</p><h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a>getpid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">()</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取本进程号（PID）</span><br><span class="line">参数：无</span><br><span class="line">返回值：本进程号</span><br></pre></td></tr></table></figure><h4 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a>getppid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">()</span>;</span><br><span class="line">功能：获取调用此函数的进程的父进程号</span><br><span class="line">参数：无</span><br><span class="line">返回值：调用此函数的进程的父进程号（PPID）</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="getpgid函数"><a href="#getpgid函数" class="headerlink" title="getpgid函数"></a>getpgid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line">功能：获取进程组号（PGID）</span><br><span class="line">参数：</span><br><span class="line">    pid:进程号</span><br><span class="line">返回值：</span><br><span class="line">    参数为<span class="number">0</span>时返回当前进程组号，否则返回参数指定的进程的进程组号。</span><br></pre></td></tr></table></figure><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">()</span>;</span><br><span class="line">功能：</span><br><span class="line">    用于从一个已存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。</span><br><span class="line">参数：无</span><br><span class="line">返回值：</span><br><span class="line">    成功：子进程返回<span class="number">0</span>，父进程中返回子进程ID，<span class="type">pid_t</span>为整型。</span><br><span class="line">    失败：返回<span class="number">-1</span>。</span><br><span class="line">    失败的两个主要原因:</span><br><span class="line"><span class="number">1.</span>当前的进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN。</span><br><span class="line">        <span class="number">2.</span>系统内存不足，这时errno的值被设置为ENOMEM。</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个子进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    fork();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里的结果会输出两次hello world。这是为什么呢？</strong></p><p><strong>首先，fork函数创建子进程，子进程会将父进程的代码复制下来来执行了，当然这就有人说了，那么子进程执行fork函数，那就不是一直创建子进程了吗。这里涉及到了一个问题。当父进程调用fork函数，父进程会有一个pc指针指向fork函数调用后的代码，当然，子进程也把这个pc指针的值也继承了下来，所以子进程也是一样执行。</strong></p><h3 id="父子进程关系"><a href="#父子进程关系" class="headerlink" title="父子进程关系"></a>父子进程关系</h3><p>使用fork函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的的静态描述），进程堆栈，打开的文件描述符，信号控制设定，进程优先级，进程组号等。</p><p>子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用fork()函数的代价是很大的。</p><p>简单来说，一个进程调用fork函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值和原来的进程的值不同。相当于克隆了一个自己。</p><p><strong>实际上，Linux的fork函数使用是通过写时拷贝（copy-on-write）实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</strong></p><p><strong>fork之后父子进程共享文件，fork产生的子进程和父进程相同的文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</strong></p><h3 id="区分父子进程"><a href="#区分父子进程" class="headerlink" title="区分父子进程"></a>区分父子进程</h3><p>fork()函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是0，而父进程的返回值则是新子进程的进程ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//区分父子进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建一个子进程</span></span><br><span class="line">    <span class="comment">//fork函数在在子进程中返回0 在父进程中返回子进程的pid</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello pid:%d ppid:%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">       <span class="comment">//这里pid返回的就是新子进程的进程id</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world pid:%d cpid:%d\n&quot;</span>,getpid(),pid);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="父子进程堆空间"><a href="#父子进程堆空间" class="headerlink" title="父子进程堆空间"></a>父子进程堆空间</h3><p>当在创建子进程前在堆声明时，一定要对该指针指向区域释放两次。不然会出现内存泄露。</p><h3 id="如何检测内存是否泄露"><a href="#如何检测内存是否泄露" class="headerlink" title="如何检测内存是否泄露"></a>如何检测内存是否泄露</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc zfork.c</span><br><span class="line">valgrind ./a.out</span><br></pre></td></tr></table></figure><h3 id="GDB调试多进程"><a href="#GDB调试多进程" class="headerlink" title="GDB调试多进程"></a>GDB调试多进程</h3><p>使用GDB调试的时候，GDB只能跟踪一个进程。可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者跟踪子进程。默认跟踪父进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-mode child <span class="comment">#设置gdb在fork之后跟踪子进程</span></span><br><span class="line"><span class="built_in">set</span> follow-fork-mode parent <span class="comment">#设置跟踪父进程（默认）</span></span><br><span class="line"><span class="comment">#注意，一定要在fork函数调用之前设置才有效。</span></span><br></pre></td></tr></table></figure><h3 id="进程退出函数"><a href="#进程退出函数" class="headerlink" title="进程退出函数"></a>进程退出函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line">功能：</span><br><span class="line">    结束调用此函数的进程</span><br><span class="line">参数：</span><br><span class="line">    status:返回给父进程的参数（低<span class="number">8</span>位有效），至于这个参数是多少根据需要来填写。</span><br><span class="line">返回值：</span><br><span class="line">    无</span><br></pre></td></tr></table></figure><p>exit()和_exit()函数功能和用法是一样的，无非是包含的头文件不一样，还有的区别就是：exit()属于标准库函数，_exit()属于系统调用函数。</p><p>_exit()函数不会关闭文件描述符和I刷新I&#x2F;O缓冲区。exit()函数会做这些。</p><h3 id="等待子进程退出函数"><a href="#等待子进程退出函数" class="headerlink" title="等待子进程退出函数"></a>等待子进程退出函数</h3><p>在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号，退出状态，运行时间）。</p><p>父进程可以调用wait或waitpid得到他的退出状态同时彻底清除掉这个进程。</p><p>wait()和waitpid函数的功能一样，区别在于wait()函数会堵塞，waitpid()可以设置不堵塞，waitpid()还可以指定等待那个子进程结束。</p><p>一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p><h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    status:进程退出时的状态信息。</span><br><span class="line">返回值：</span><br><span class="line">    成功：已经结束子进程的进程号</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>调用wait函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒（相当于继续往下执行）。</p><p>若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。</p><p><strong>所以wait函数的主要功能为回收已经结束子进程的资源。如果参数status的值不是NULL,wait函数就会把子进程退出时的状态取出并且存入其中，这是一个整数值（int）,指出了子进程是正常退出还是被非正常结束的。这个退出信息在一个int中包含了多个字段，直接使用这个值是没有意义的，我们需要宏定义取出其中的每个字段。</strong></p><p>使用对应的宏函数如WIFEXITED(status)为非0表明进程正常结束。WEXITSTATUS(status)若WIFEXITED(status)值为真，获取进程退出状态（exit的参数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属于正常退出</span></span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程退出状态码：%d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">    <span class="comment">//在bash输入kill 子进程号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程被信号%d杀死了\n&quot;</span>,WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</span><br><span class="line">    <span class="comment">//向指定进程发送暂停信号</span></span><br><span class="line">    <span class="comment">//kill -19 子进程号</span></span><br><span class="line">    <span class="comment">//唤醒指定暂停的进程</span></span><br><span class="line">    <span class="comment">//kill -18 子进程号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程被信号%d暂停\n&quot;</span>,WSTOPSIG(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *status,<span class="type">int</span> options)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    pid:参数pid的值有以下几种类型：</span><br><span class="line">        pid&gt;<span class="number">0</span> 等待进程ID等于pid的子进程。</span><br><span class="line">        pid=<span class="number">0</span> 等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会等待他。</span><br><span class="line">        pid=<span class="number">-1</span> 等待任一子进程，此时waitpid和wait作用一样。</span><br><span class="line">        pid&lt;<span class="number">-1</span> 等待指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。</span><br><span class="line">    status:进程退出时的状态信息。和wait()用法一样。</span><br><span class="line">    options:options提供了一些额外的选项来控制waitpid().</span><br><span class="line">        <span class="number">0</span>:同wait(),阻塞父进程，等待子进程退出。</span><br><span class="line">        WNOHANG:没有任何已经结束的子进程，则立即返回</span><br><span class="line">        WUNTRACED:如果子进程暂停了则此函数马上返回，并且不予理会子进程的结束状态。</span><br><span class="line">返回值：</span><br><span class="line">     当正常返回时，返回收集到的已经回收子进程的进程号</span><br><span class="line">     如果设置了选项WNOHANG,而调用中waitpid()发现没有已经退出的子进程可等待，则返回<span class="number">0</span>;</span><br><span class="line"> 如果调用中出错，则返回<span class="number">-1</span>，这是errno会被设置成相应的值以指示错误所在。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于wait()</span></span><br><span class="line">waitpid(<span class="number">-1</span>,&amp;status,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//第三个参数表示不阻塞</span></span><br><span class="line">waitpid(<span class="number">-1</span>,&amp;status,WNOHANG)</span><br></pre></td></tr></table></figure><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p><strong>父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程。</strong></p><p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init,而init进程会循环wait()它的已经退出的子进程。所以init进程会处理孤儿进程的善后工作。</p><p><strong>孤儿进程并没有什么危害。</strong></p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p><strong>进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程。</strong>这样就导致了一个问题，如果进程不调用wait()或者waitpid（）的话，那么保留的那段信息就不会释放，其进程号就会一直被占用。如果产生大量的僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><h3 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h3><p>在Windows平台下，我们可以通过双击运行可执行程序，让这个可执行程序成为一个进程；而在Linux平台，我们可以通过.&#x2F;运行，让一个可执行程序成为一个进程。</p><p>但是，如果我们本来就运行着一个程序，我们如何在这个进程内部启动一个外部程序，由内核将这个外部程序读入内存，使其执行起来成为一个进程呢，我们通过exec函数族实现。</p><p>exec函数族是一组函数，在Linux并不存在exec函数。这组函数一共有6个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/*(char *) NULL*/</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file,<span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/*(char *) NULL*/</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/*,(char *) NULL,char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file,<span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file,<span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p>其中只有execve()是真正意义的系统调用，其他都是在此基础上经过包装的库函数。</p><p><strong>exec函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容。</strong></p><p><strong>进程在调用一种exec函数时，该进程完全由新程序替换，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后进程ID(当然还有父进程号，进程组号，当前工作目录)并未改变。exec只是用另一个新程序替换了当前进程的正文，数据，堆和栈段（进程替换）。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello \n&quot;</span>);</span><br><span class="line">    <span class="comment">//arg0 arg1 arg2 ... argn</span></span><br><span class="line">    <span class="comment">//arg0一般是可执行文件名 argn必须是NULL</span></span><br><span class="line">    <span class="comment">//execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;-l&quot;,&quot;/home&quot;,NULL);</span></span><br><span class="line">    <span class="comment">//第一个参数是可执行文件的绝对路径或者相对路径</span></span><br><span class="line">    <span class="comment">//第二个参数一般是可执行文件的名字</span></span><br><span class="line">    <span class="comment">//中间的参数就是可执行文件的参数</span></span><br><span class="line">    <span class="comment">//最后一个参数是NULL</span></span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/home&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *argv[]=&#123;<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/home&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *envp[]=&#123;<span class="string">&quot;ADDR=BEIJING&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="comment">//第一个参数是可执行文件</span></span><br><span class="line">    <span class="comment">//第二个参数是指针数组 最后一定以NULL结束</span></span><br><span class="line">    <span class="comment">//execvp(&quot;ls&quot;,argv);</span></span><br><span class="line">    <span class="comment">//第一个参数是可执行文件</span></span><br><span class="line">    <span class="comment">//第二个参数是指针数组 最后一定以NULL结束</span></span><br><span class="line">    <span class="comment">//execv(&quot;/bin/ls&quot;,argv);</span></span><br><span class="line">    <span class="comment">//最后一个参数是环境变量指针数组</span></span><br><span class="line">    <span class="comment">//execle(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,&quot;/home&quot;,NULL,envp);</span></span><br><span class="line">    <span class="comment">//第一个参数是可执行文件</span></span><br><span class="line">    <span class="comment">//第二个参数是参数列表 指针数组</span></span><br><span class="line">    <span class="comment">//第三个参数是环境变量列表 指针数组</span></span><br><span class="line">    execvpe(<span class="string">&quot;ls&quot;</span>,argv,envp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p><p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信。（IPC）</p><p><strong>进程间通信的目的：</strong></p><p><strong>数据传输：一个进程需要将它的数据发送给另一个进程。</strong></p><p><strong>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</strong></p><p><strong>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</strong></p><p><strong>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</strong></p><p><strong>Linux操作系统支持的主要进程间通信的通信机制：</strong></p><p><img src="/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/6.png" alt="6"></p><h3 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h3><p>管道也叫无名管道，它是UNIX系统IPC(进程间通信)的最古老方式，所有的UNIX系统都支持这种通信机制。</p><p>管道有如下特点：</p><ol><li>半双工，数据在同一时刻只能在一个方向上流动。</li><li>数据只能从管道的一端写入，从另一端读出。</li><li>写入管道中的数据遵循先入先出的规则。</li><li>管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息。</li><li>管道不是普通文件，不属于某个文件系统，其只存在于<strong>内存</strong>中。</li><li>管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。</li><li><strong>从管道读数据是一次性操作</strong>，数据一旦被读走，他就从管道中被抛弃，释放空间以便写更多的数据。</li><li>管道没有名字，<strong>只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</strong></li></ol><p>管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。</p><p><img src="/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/7.png" alt="7"></p><h4 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line">功能：创建无名管道</span><br><span class="line">参数：</span><br><span class="line">    pipefd:为<span class="type">int</span>型数组的首地址，其存放了管道的文件描述符pipefd[<span class="number">0</span>],pipefd[<span class="number">1</span>]。</span><br><span class="line">    当一个管道建立时，他会创建两个文件描述符fd[<span class="number">0</span>]和fd[<span class="number">1</span>]。其中fd[<span class="number">0</span>]固定用于读管道，而fd[<span class="number">1</span>]固定用于写管道。一般文件I/O的函数都可以用来操作管道（lseek()除外）。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//用于创建无名管道</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建一个无名管道</span></span><br><span class="line">    ret=pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fd[0]用于读 fd[1]用于写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd[0]:%d fd[1]:%d\n&quot;</span>,fd[<span class="number">0</span>],fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="父子进程通过无名管道通信"><a href="#父子进程通过无名管道通信" class="headerlink" title="父子进程通过无名管道通信"></a>父子进程通过无名管道通信</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 64</span></span><br><span class="line"><span class="comment">//父子进程使用无名管道进行通信</span></span><br><span class="line"><span class="comment">//父进程写管道 子进程读管道</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buffer[SIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//1.创建无名管道</span></span><br><span class="line">    ret=pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建子进程</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程 读管道</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">        <span class="comment">//关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">        ret=read(fd[<span class="number">0</span>],buf,SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process buf :%s\n&quot;</span>,buf);</span><br><span class="line">        <span class="comment">//关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程 写管道</span></span><br><span class="line">    <span class="comment">//关闭读端</span></span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    ret=write(fd[<span class="number">1</span>],<span class="string">&quot;ABCDE&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent process write: len:%d\n&quot;</span>,ret);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭写端</span></span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管道读写特点"><a href="#管道读写特点" class="headerlink" title="管道读写特点"></a>管道读写特点</h4><p>四种情况：</p><p>​第一种：</p><p>​如果写端没有关闭，管道中没有数据，这个时候读管道进程去读管道会阻塞。</p><p>​如果写端没有关闭，管道中有数据，这个时候读管道进程会将数据读出，下一次读没数据就会阻塞。</p><p>​第二种：</p><p>​管道所有的写端关闭，读进程去读管道的内容，读取全部内容，最后返回0。</p><p>​第三种：</p><p>​所有读端没有关闭，如果管道被写满了，写管道进程写管道会被阻塞。</p><p>​第四种：</p><p>​所有的读端被关闭，写管道进程写管道会收到一个信号，然后退出。</p><h4 id="设置为非阻塞的方法"><a href="#设置为非阻塞的方法" class="headerlink" title="设置为非阻塞的方法"></a>设置为非阻塞的方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取原来的flags</span></span><br><span class="line"><span class="type">int</span> flags=fcntl(fd[<span class="number">0</span>],F_GETFL);</span><br><span class="line"><span class="comment">//设置新的flags</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(fd[<span class="number">0</span>],F_SETFL,flags);</span><br></pre></td></tr></table></figure><p>如果写端没有关闭，读端设置为非阻塞，如果没有数据，直接返回-1。</p><h4 id="查看管道缓冲区的大小"><a href="#查看管道缓冲区的大小" class="headerlink" title="查看管道缓冲区的大小"></a>查看管道缓冲区的大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a#可以查看管道大小（大小为4k）</span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> name)</span>;</span><br><span class="line">功能：该函数可以通过name参数查看不同的属性值</span><br><span class="line">参数：</span><br><span class="line">    fd:文件描述符</span><br><span class="line">    name:</span><br><span class="line">_PC_PIPE_BUF，查看管道缓冲区大小</span><br><span class="line">        _PC_NAME_MAX,文件名字字节数的上限</span><br><span class="line">返回值：</span><br><span class="line">    成功：根据name返回的值的意义也不同。</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h3><p>管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这一缺点，提出了命名管道（FIFO）,也叫有名管道，FIFO文件。</p><p>命名管道不同于无名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径马，就能够彼此通过FIFO互相通信，因此，通过FIFO不相关的进程也能交换数据。</p><ol><li>命名管道和无名管道有一些特点是相同的，不一样的地方在于：</li><li>FIFO在文件系统中作为一个特殊的文件而存在，但FIFO的内容却放在内存中。</li><li>当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。</li><li>FIFO有名字，不相关的进程可以通过打开命名管道进行通信。</li></ol><h4 id="通过命令创建有名管道"><a href="#通过命令创建有名管道" class="headerlink" title="通过命令创建有名管道"></a>通过命令创建有名管道</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> fifo <span class="comment">#创建有名管道 fifo是管道的名字</span></span><br></pre></td></tr></table></figure><h4 id="通过函数创建有名管道"><a href="#通过函数创建有名管道" class="headerlink" title="通过函数创建有名管道"></a>通过函数创建有名管道</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">mode_t</span> mode)</span>;</span><br><span class="line">功能：</span><br><span class="line">    命名管道的创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname:普通的路径名，也就是创建后FIFO的名字。</span><br><span class="line">    mode:文件的权限，与打开普通文件的open()函数中的mode参数相同。（<span class="number">0644</span>）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span> 状态码</span><br><span class="line">    失败：如果文件已经存在，则会出错且返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过mkfifo函数创建一个管道文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建一个有名管道 管道的名字fifo</span></span><br><span class="line">    ret=mkfifo(<span class="string">&quot;fifo&quot;</span>,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建一个有名管道ok\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有名管道读写操作"><a href="#有名管道读写操作" class="headerlink" title="有名管道读写操作"></a>有名管道读写操作</h4><p>一旦使用mkfifo创建了FIFO,就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close，read,write,unlink等。</p><p>FIFO严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对他们的写则把数据添加到末尾。他们不支持诸如lseek()等文件定位操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程1，写操作</span></span><br><span class="line"><span class="type">int</span> fd=open(<span class="string">&quot;my_fifo&quot;</span>,O_WRONLY);</span><br><span class="line"><span class="type">char</span> send[<span class="number">100</span>]=<span class="string">&quot;hello Mike&quot;</span>;</span><br><span class="line">write(fd,send,<span class="built_in">strlen</span>(send));</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程2，读操作</span></span><br><span class="line"><span class="type">int</span> fd=open(<span class="string">&quot;my_fifo&quot;</span>,O_RDONLY);<span class="comment">//等着只写</span></span><br><span class="line"><span class="type">char</span> recv[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//读数据，命名管道没数据时会阻塞，有数据时就取出来</span></span><br><span class="line">read(fd,recv,<span class="keyword">sizeof</span>(revc));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read from my_fifo buf=[%s]\n&quot;</span>,recv);</span><br></pre></td></tr></table></figure><p>一个为只读而打开一个管道的进程会阻塞直到另外一个进程为只写打开该管道。</p><p>一个为只写而打开一个管道的进程会阻塞直到另外一个进程为只读打开该管道。</p><p>读管道：</p><p>​管道中有数据，read返回实际读到的字节数。</p><p>​管道无数据：</p><p>​管道写端被全部关闭，read返回0（相当于读文件末尾）。</p><p>​写端没有完全被关闭，read阻塞等待。</p><p>写管道：</p><p>​管道读端全部被关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程终止）；</p><p>​管道读端没有全部关闭：</p><p>​管道已满，write阻塞。</p><p>​管道未满，write将数据写入，并返回实际写入的字节数。</p><h3 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a>共享存储映射</h3><p>存储映射I&#x2F;O使一个磁盘文件与存储空间中的一个缓冲区相映射。</p><p>于是当从缓冲区中取数据，就相当于读文件中的相应字节。将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I&#x2F;O操作。</p><p>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式，因为进程可以直接读内存，而不需要任何数据的拷贝。</p><h4 id="存储映射函数"><a href="#存储映射函数" class="headerlink" title="存储映射函数"></a>存储映射函数</h4><h5 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    一个文件或者其他对象映射进内存</span><br><span class="line">参数：</span><br><span class="line">    addr:指定映射的起始地址，通常设为<span class="literal">NULL</span>,由系统指定</span><br><span class="line">    length:映射到内存的文件长度</span><br><span class="line">    prot:映射区的保护方式，最常用的：</span><br><span class="line">        读：PROT_READ</span><br><span class="line">        写：PROT_WRITE</span><br><span class="line">        读写：PROT_READ|PROT_WRITE</span><br><span class="line">    flags:映射区的特性，可以是</span><br><span class="line">        MAP_SHARED:写入映射区的数据会复制回文件，且允许其他映射该文件的进程共享。</span><br><span class="line">        MAP_PRIVATE:对映射区的写入操作会产生一个映射区的复制（copy-on-write）,对此区域所作的修改不会写回原文件。</span><br><span class="line">    fd:由open返回的文件描述符，代表要映射的文件。</span><br><span class="line">    offset:以文件开始处的偏移量，必须是<span class="number">4</span>k的整数倍（<span class="number">4</span>k为页的大小），通常为<span class="number">0</span>,表示从文件头开始映射</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回创建的映射区首地址</span><br><span class="line">    失败：MAP_FAILED宏</span><br></pre></td></tr></table></figure><h5 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a>munmap函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length)</span>;</span><br><span class="line">功能：</span><br><span class="line">    释放内存映射区</span><br><span class="line">参数：</span><br><span class="line">    addr:使用mmap函数创建的映射区的首地址</span><br><span class="line">    length:映射区的大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储映射</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> *addr=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1.以读写形式打开一个文件。</span></span><br><span class="line">    fd=open(<span class="string">&quot;txt&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==fd)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.将文件映射到内存</span></span><br><span class="line">    addr=mmap(<span class="literal">NULL</span>,<span class="number">1024</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(addr==MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">//4.写文件</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr,<span class="string">&quot;1234567890&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//5.断开存储映射</span></span><br><span class="line">    munmap(addr,<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名映射实现父子进程通信"><a href="#匿名映射实现父子进程通信" class="headerlink" title="匿名映射实现父子进程通信"></a>匿名映射实现父子进程通信</h3><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。</p><p>通常为了建立映射区要open一个temp文件，创建好了再unlink,close掉，比较麻烦。同样需要借助标志位flags来指定。使用MAP_ANONYMOUS（或者MAP_ANON）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//父子进程使用匿名映射进行进程间通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> *addr=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1.创建匿名映射</span></span><br><span class="line">    addr=mmap(<span class="literal">NULL</span>,<span class="number">4096</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(MAP_FAILED==addr)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建子进程</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        munmap(addr,<span class="number">4096</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.父子进程通信</span></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程写</span></span><br><span class="line">        <span class="built_in">memcpy</span>(addr,<span class="string">&quot;123456789&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程读</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process %s\n&quot;</span>,(<span class="type">char</span> *)addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.断开映射</span></span><br><span class="line">    munmap(addr,<span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是Linux进程间通信的最古老的方式。<strong>信号是软件中断</strong>，它是在<strong>软件层次上对中断机制的一次模拟，是一种异步通信的方式</strong>。信号可以导致一个正在运行的进程被另一个进程正在运行的异步进程中断，转而处理某一个突发事件。</p><p>信号的特点：简单，不能携带大量信息，满足某个特设条件才发送。</p><p>信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了那些系统事件。</p><p>一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数。</p><p><img src="/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/8.png" alt="8"></p><p>这里信号的产生，注册，注销是信号的内部机制，而不是信号的函数实现。</p><h3 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a>信号的编号</h3><p>Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley和AT&amp;T都对信号做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p><p>Linux可使用命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -l(字母l)#查看相应的信号。</span><br></pre></td></tr></table></figure><p>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。</p><p> <strong>Linux 常用信号（signals）一览表</strong></p><table><thead><tr><th>编号</th><th>信号名</th><th>默认行为</th><th>说明（用途）</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>终止进程</td><td>终端挂起或控制进程终止（如终端关闭）</td></tr><tr><td>2</td><td>SIGINT</td><td>终止进程</td><td>键盘中断（Ctrl+C）</td></tr><tr><td>3</td><td>SIGQUIT</td><td>创建核心转储</td><td>键盘退出（Ctrl+\），带 core dump</td></tr><tr><td>4</td><td>SIGILL</td><td>创建核心转储</td><td>非法指令</td></tr><tr><td>6</td><td>SIGABRT</td><td>创建核心转储</td><td>调用 <code>abort()</code> 函数终止程序</td></tr><tr><td>8</td><td>SIGFPE</td><td>创建核心转储</td><td>浮点异常（如除以0）</td></tr><tr><td>9</td><td>SIGKILL</td><td>强制终止</td><td>无法被捕获或忽略，立即终止</td></tr><tr><td>11</td><td>SIGSEGV</td><td>创建核心转储</td><td>无效内存引用（段错误）</td></tr><tr><td>13</td><td>SIGPIPE</td><td>终止进程</td><td>管道破裂（写到没有读者的管道）</td></tr><tr><td>14</td><td>SIGALRM</td><td>终止进程</td><td>计时器超时（<code>alarm()</code>）</td></tr><tr><td>15</td><td>SIGTERM</td><td>终止进程</td><td>终止信号（kill 默认发送）</td></tr><tr><td>17</td><td>SIGCHLD</td><td>忽略&#x2F;捕获</td><td>子进程结束时通知父进程</td></tr><tr><td>18</td><td>SIGCONT</td><td>继续执行</td><td>继续一个停止的进程</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止进程</td><td>无法被捕获或忽略，强制停止</td></tr><tr><td>20</td><td>SIGTSTP</td><td>停止进程</td><td>用户请求停止（Ctrl+Z）</td></tr><tr><td>21</td><td>SIGTTIN</td><td>停止进程</td><td>后台进程读终端输入</td></tr><tr><td>22</td><td>SIGTTOU</td><td>停止进程</td><td>后台进程写终端输出</td></tr><tr><td>23</td><td>SIGURG</td><td>忽略&#x2F;捕获</td><td>套接字有紧急数据</td></tr><tr><td>24</td><td>SIGXCPU</td><td>创建核心转储</td><td>超出 CPU 时间限制</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>创建核心转储</td><td>超出文件大小限制</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>终止进程</td><td>虚拟定时器到期</td></tr><tr><td>27</td><td>SIGPROF</td><td>终止进程</td><td>分析定时器到期</td></tr><tr><td>28</td><td>SIGWINCH</td><td>忽略&#x2F;捕获</td><td>终端窗口大小发生变化</td></tr><tr><td>29</td><td>SIGIO</td><td>忽略&#x2F;捕获</td><td>I&#x2F;O 事件通知</td></tr><tr><td>30</td><td>SIGPWR</td><td>忽略&#x2F;终止</td><td>电源故障</td></tr><tr><td>31</td><td>SIGSYS</td><td>创建核心转储</td><td>非法的系统调用</td></tr></tbody></table><h3 id="信号四要素"><a href="#信号四要素" class="headerlink" title="信号四要素"></a>信号四要素</h3><p>每个信号必备四要素，分别是：</p><p>编号，名称，事件，默认处理动作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 7 signal#查看帮助文档获取信号的信息</span><br></pre></td></tr></table></figure><p>默认动作：</p><p>​Term:终止进程</p><p>​Ign:忽略信号（默认即时对该种信号忽略操作）</p><p>​Core:终止进程，生成Core文件。（查验死亡原因，用于gdb调试）</p><p>​Stop:停止（暂停）进程</p><p>​Cont:继续运行进程</p><p>SIGKILL(9)和SIGSTOP(19)，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</p><p>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不应乱发信号。</p><h3 id="阻塞信号集和未决信号集"><a href="#阻塞信号集和未决信号集" class="headerlink" title="阻塞信号集和未决信号集"></a>阻塞信号集和未决信号集</h3><p>信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。</p><p>Linux内核的进程控制块PCB是一个结构体，task_struct,除了包含进程id，状态，工作目录，用户id,组id,文件描述符表，还包含了信号相关信息，主要指阻塞信号集和未决信号集。</p><p><strong>阻塞信号集</strong>：</p><p>将某些信号加入集合，对他们设置屏蔽，当屏蔽X信号后，再收到该信号，该信号的处理将推后（处理发生在解除屏蔽后）。</p><p><strong>未决信号集</strong>：</p><p>信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回0。这一时刻往往非常短暂。</p><p>信号产生后由于某些原因（主要是阻塞）不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</p><h3 id="信号产生函数"><a href="#信号产生函数" class="headerlink" title="信号产生函数"></a>信号产生函数</h3><h4 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给指定进程发送指定信号（不一定杀死）</span><br><span class="line">参数：</span><br><span class="line">    pid:取值有<span class="number">4</span>种情况：</span><br><span class="line">        pid&gt;<span class="number">0</span>:将信号传送给进程ID为pid的进程。</span><br><span class="line">        pid=<span class="number">0</span>：将信号传送给当前进程所在进程组中的所有进程。</span><br><span class="line">        pid=<span class="number">-1</span>:将信号传送给系统内所有的进程</span><br><span class="line">        pid&lt;<span class="number">-1</span>:将信号传送给指定进程组的所有进程。这个进程组号等于pid的绝对值。</span><br><span class="line">    sig:信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令kill -l进行查看，不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>超级用户（root）可以发送信号给任意用户，普通用户是不能向系统用户发送信号。也不能向其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//父进程杀死子进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建一个子进程</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==pid)&#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;child process do work....\n&quot;</span>);</span><br><span class="line">           sleep(<span class="number">1</span>);</span><br><span class="line">       &#125; </span><br><span class="line">        <span class="comment">//进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程退出\n&quot;</span>);</span><br><span class="line">        kill(pid,SIGTERM);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程该结束了，已经完成了他的使命\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="raise函数"><a href="#raise函数" class="headerlink" title="raise函数"></a>raise函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给当前进程发送指定信号（自己给自己发），等价于kill(getpid(),sig);</span><br><span class="line">参数：</span><br><span class="line">    sig:信号编号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>值</span><br></pre></td></tr></table></figure><h4 id="abort函数"><a href="#abort函数" class="headerlink" title="abort函数"></a>abort函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：给自己发送异常终止信号编号为<span class="number">6</span> SIGABRT,并产生core文件，等价于kill(getpid(),SIGABRT);</span><br><span class="line">参数：无</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure><h4 id="alarm函数（闹钟）"><a href="#alarm函数（闹钟）" class="headerlink" title="alarm函数（闹钟）"></a>alarm函数（闹钟）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line">功能：</span><br><span class="line">    设置定时器（闹钟）。在指定seconds后，内核会给当前进程发送编号<span class="number">14</span> SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有一个唯一的定时器。</span><br><span class="line">    取消定时器alarm(<span class="number">0</span>),返回旧闹钟余下秒数。</span><br><span class="line">参数：</span><br><span class="line">    seconds:指定的时间，以秒为单位</span><br><span class="line">返回值：</span><br><span class="line">    返回<span class="number">0</span>或剩余的秒数</span><br></pre></td></tr></table></figure><p>定时，与进程状态无关（自然定时法）。就绪，运行，挂起（阻塞。暂停），终止，僵尸。。。。无论进程处于何种状态，alarm都计时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试alarm函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一次设置闹钟 5秒钟之后就超时 发送对应的信号</span></span><br><span class="line">    ret=alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;上一次闹钟剩下的时间是%u\n&quot;</span>,ret);<span class="comment">//这时ret为0</span></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//之前没有超时的闹钟被新的设置给覆盖</span></span><br><span class="line">    ret=alarm(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;上一次闹钟剩下的时间是%u\n&quot;</span>,ret);<span class="comment">//这时ret为3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键继续。。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="setitimer函数（定时器）"><a href="#setitimer函数（定时器）" class="headerlink" title="setitimer函数（定时器）"></a>setitimer函数（定时器）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which,<span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value,<span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    设置定时器（闹钟）。可替代alarm函数。精度微妙us,可以实现周期定时。</span><br><span class="line">参数：</span><br><span class="line">    which:指定定时方式</span><br><span class="line">        自然定时:ITIMER_REAL 编号<span class="number">14</span>的信号SIGALRM计算自然时间</span><br><span class="line">        虚拟空间计时（用户空间）:ITIMER_VIRTUAL 编号<span class="number">26</span>的信号SIGVTALRM 只计算进程占用cpu的时间</span><br><span class="line">        运行时计时（用户+内核）:ITIMER_PROF 编号<span class="number">27</span>的信号SIGPROF计算占用cpu及执行系统调用的时间</span><br><span class="line">    new_value:<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>,负责设定<span class="title">timeout</span>时间</span></span><br><span class="line"><span class="class">        <span class="keyword">struct</span> <span class="title">itimerval</span>&#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_interval</span>;</span><span class="comment">//闹钟触发周期</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_value</span>;</span><span class="comment">//闹钟触发时间</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timerval</span>&#123;</span></span><br><span class="line">            <span class="type">long</span> tv_sec;<span class="comment">//秒</span></span><br><span class="line">            <span class="type">long</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">        &#125;</span><br><span class="line">itimerval.it_value:设定第一次执行function所延迟的秒数</span><br><span class="line">        itimerval.it_interval:设定以后每几秒执行function</span><br><span class="line">    old_value:存放旧的timeout值，一般指定为<span class="literal">NULL</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tmo</span>;</span></span><br><span class="line">    <span class="comment">//第一次触发时间</span></span><br><span class="line">    tmo.it_value.tv_sec=<span class="number">3</span>;</span><br><span class="line">    tmo.it_value.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//触发周期</span></span><br><span class="line">    tmo.it_interval.tv_sec=<span class="number">2</span>;</span><br><span class="line">    tmo.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置定时器</span></span><br><span class="line">    ret=setitimer(ITIMER_REAL,&amp;tmo,<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进程收到闹钟超时信号之后就会终止该进程，要想周期起来，要把信号捕捉</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键继续。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><p>在PCB中有两个非常重要的信号集。一个称之为”阻塞信号集”，另一个称之为”未决信号集”。</p><p>这两个信号集都是内核使用位图机制来实现的。但是操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。阻塞信号集可以读写，未决信号集不可以写，只可以读。</p><h4 id="自定义信号集函数"><a href="#自定义信号集函数" class="headerlink" title="自定义信号集函数"></a>自定义信号集函数</h4><p>信号集是一个能表示多个信号的数据类型，sigset_t set,set即一个数据集。既然是一个集合，就需要对集合进行添加&#x2F;删除等操作。</p><p>相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;<span class="comment">//将set集合置空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;<span class="comment">//将所有的信号加入set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>,<span class="type">int</span> signo)</span>;<span class="comment">//将signo信号加入到set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>,<span class="type">int</span> signo)</span>;<span class="comment">//将set集合中移除signo信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>,<span class="type">int</span> signo)</span>;<span class="comment">//判断信号是否存在</span></span><br></pre></td></tr></table></figure><p>示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//显示信号集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_set</span><span class="params">(<span class="type">sigset_t</span> *s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//判断指定的信号是否在集合中</span></span><br><span class="line">        <span class="keyword">if</span>(sigismember(s,i))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号集处理函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//信号集集合</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">//清空集合</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    show_set(&amp;<span class="built_in">set</span>)</span><br><span class="line">    <span class="comment">//将所有的信号加入到set集合中</span></span><br><span class="line">    sigfillset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    show_set(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">//将信号2和信号3从信号集中移除</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>,SIGQUIT);</span><br><span class="line">    show_set(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">//将信号2添加到集合中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    show_set(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h4><p>信号阻塞集也称信号屏蔽集。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述那些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。</p><p>所谓阻塞并不是禁止传送信号，而是暂缓信号的传送。若将被阻塞的信号从信号阻塞中删除，且对应的信号在被阻塞时发生了，进程会收到相应的信号。</p><p>我们可以通过sigprocmask()修改当前的信号掩码来改变信号的阻塞情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how,<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>,<span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改信号阻塞集，根据how指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由<span class="built_in">set</span>指定，而原先的信号阻塞集合由oldset保存。</span><br><span class="line">参数：</span><br><span class="line">    how:信号阻塞集合的修改方法，有三种情况：</span><br><span class="line">SIG_BLOCK:向信号阻塞集合中添加<span class="built_in">set</span>信号集，新的信号掩码是<span class="built_in">set</span>和旧信号掩码的并集。相当于mask=mask|<span class="built_in">set</span>.</span><br><span class="line">        SIG_UNBLOCK:从信号阻塞集合中删除<span class="built_in">set</span>信号集，从当前信号掩码中去除<span class="built_in">set</span>中的信号，相当于mask=mask&amp;~<span class="built_in">set</span>.</span><br><span class="line">        SIG_SETMASK:将信号阻塞集合设为<span class="built_in">set</span>信号集，相当于原来信号阻塞集内容清空，然后按照<span class="built_in">set</span>中的信号重新设置信号阻塞集。相当于mask=<span class="built_in">set</span>.</span><br><span class="line">    <span class="built_in">set</span>:要操作的信号集地址。</span><br><span class="line">    若<span class="built_in">set</span>为<span class="literal">NULL</span>，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到oldset中。</span><br><span class="line">    oldset:保存原先信号阻塞集地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span>，失败时错误代码只可能是EINVAL,表示参数how不合法</span><br></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,signum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号处理函数2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,signum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号注册函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="type">sigset_t</span> oldset;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    <span class="comment">//Ctrl+C</span></span><br><span class="line">    signal(SIGINT,func1);</span><br><span class="line">    <span class="comment">//Ctrl+\</span></span><br><span class="line"><span class="comment">    signal(SIGQUIT,func2);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键 阻塞信号2\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigemptyset(&amp;oldset);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    <span class="comment">//设置屏蔽编号为2的信号</span></span><br><span class="line">    ret=sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;设置屏蔽编号为2的信号成功了。。。。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键 解除阻塞信号2\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">//将信号屏蔽集设置为原来的集合,解除屏蔽后，不管之前发了多少次相同的信号，最后只会捕捉一次</span></span><br><span class="line">    ret=sigprocmask(SIG_SETMASK,&amp;oldset,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键退出。。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sigpending函数"><a href="#sigpending函数" class="headerlink" title="sigpending函数"></a>sigpending函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">功能：读取当前进程的未决信号集</span><br><span class="line">参数：</span><br><span class="line">    <span class="built_in">set</span>：未决信号集</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><h4 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h4><p>一个进程收到一个信号的时候，可以用如下方法进行处理：</p><ol><li><p>执行系统默认动作</p><p>对大多数信号来说，系统默认动作是用来终止该进程。</p></li><li><p>忽略此信号（丢弃）</p><p>接受到此信号后没有任何动作。</p></li><li><p>执行自定义信号处理函数（捕获）</p><p>用用户自定义的信号处理函数处理该信号。</p></li></ol><p>SIGKILL和SIGSTOP不能更改信号的处理方式，因为他们向用户提供了一种使进程终止的可靠方法。</p><h4 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum,<span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">功能：</span><br><span class="line">    注册信号处理函数（不可用于SIGKILL,SIGSTOP信号），即可确定收到信号后处理函数的入口地址。此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    signum:信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令kill -l进行相应查看。</span><br><span class="line">    handler:取值有三种情况</span><br><span class="line">        SIG_IGN:忽略该信号。</span><br><span class="line">        SIG_DFL:执行系统默认动作</span><br><span class="line">        信号处理函数名：自定义信号处理函数。如：func</span><br><span class="line">        回调函数的定义如下：</span><br><span class="line">            <span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">            <span class="comment">//signo 为触发的信号，为signal()第一个参数</span></span><br><span class="line">        &#125;</span><br><span class="line">返回值：</span><br><span class="line">    成功：第一次返回<span class="literal">NULL</span>,下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面声明此函数指针的类型。</span><br><span class="line">    失败：返回SIG_ERR</span><br></pre></td></tr></table></figure><p>该函数有ANSI定义，由于历史原因在不同版本的UNIX和不同版本的LINUX中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,signum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号处理函数2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,signum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//信号注册函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//信号注册</span></span><br><span class="line">    <span class="comment">//Ctrl+C</span></span><br><span class="line">    signal(SIGINT,func1);</span><br><span class="line">    <span class="comment">//Ctrl+\</span></span><br><span class="line"><span class="comment">    signal(SIGQUIT,func2);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在学会捕捉后，对之前的setitimer函数实现的例子更新一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号：%d\n&quot;</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tmo</span>;</span></span><br><span class="line">    <span class="comment">//第一次触发时间</span></span><br><span class="line">    tmo.it_value.tv_sec=<span class="number">3</span>;</span><br><span class="line">    tmo.it_value.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//触发周期</span></span><br><span class="line">    tmo.it_interval.tv_sec=<span class="number">2</span>;</span><br><span class="line">    tmo.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//捕捉信号 SIGALRM</span></span><br><span class="line">    signal(SIGALRM,func);</span><br><span class="line">    <span class="comment">//设置定时器</span></span><br><span class="line">    ret=setitimer(ITIMER_REAL,&amp;tmo,<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进程收到闹钟超时信号之后就会终止该进程，要想周期起来，要把信号捕捉</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键继续。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum,<span class="type">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改指定信号的设置（或同时执行这两种操作）。</span><br><span class="line">操作：</span><br><span class="line">    signum:要操作的信号。</span><br><span class="line">    act: 要设置的对信号的新处理方式（传入参数）。</span><br><span class="line">    oldact:原来对信号的处理方式（传出参数）。</span><br><span class="line">    如果act指针非空，则要改变指定信号的处理方式（设置）,如果oldact指针非空，则系统将此前指定信号的处理方式存入oldact</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>struct sigaction 结构体</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">  <span class="type">void</span>(*sa_handler)(<span class="type">int</span>);<span class="comment">//旧的信号处理函数指针</span></span><br><span class="line">  <span class="type">void</span>(*sa_sigaction)(<span class="type">int</span>,<span class="type">siginfo_t</span>*,<span class="type">void</span> *);<span class="comment">//新的信号处理函数指针</span></span><br><span class="line">  <span class="type">sigset_t</span> sa_mask; <span class="comment">//信号阻塞集 在信号处理函数执行过程中，临时屏蔽指定的信号</span></span><br><span class="line">  <span class="type">int</span> sa_flags; <span class="comment">//信号处理方式</span></span><br><span class="line">  <span class="type">void</span>(*sa_restorer)(<span class="type">void</span>); <span class="comment">//已弃用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号 %d\n&quot;</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//演示sigaction函数使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用旧的信号处理函数指针</span></span><br><span class="line">    act.sa_handler=fun;</span><br><span class="line">    <span class="comment">//标志为默认 默认使用旧的信号处理函数指针</span></span><br><span class="line">    act.sa_flags=<span class="number">0</span>;</span><br><span class="line">    ret=sigaction(SIGINT,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键退出。。。。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//新的信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> signo,<span class="type">siginfo_t</span> *info,<span class="type">void</span> *context)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号 %d\n&quot;</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//演示sigaction函数使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用新的信号处理函数指针</span></span><br><span class="line">  act.sa_sigaction=fun1;</span><br><span class="line">    <span class="comment">//标志指定使用新的信号处理函数指针</span></span><br><span class="line">    act.sa_flags=SA_SIGINFO;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==ret)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键退出。。。。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sigqueue函数（一般不用，用kill函数）"><a href="#sigqueue函数（一般不用，用kill函数）" class="headerlink" title="sigqueue函数（一般不用，用kill函数）"></a>sigqueue函数（一般不用，用kill函数）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> sig,<span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    给指定进程发送信号</span><br><span class="line">参数：</span><br><span class="line">    pid:进程号</span><br><span class="line">    sig：信号的编号</span><br><span class="line">    value:通过信号传递的参数。</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">sigval</span>类型如下：</span></span><br><span class="line"><span class="class">        <span class="title">union</span> <span class="title">sigval</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> sival_int;</span><br><span class="line">        <span class="type">void</span> *sival_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="不可重入，可重入函数"><a href="#不可重入，可重入函数" class="headerlink" title="不可重入，可重入函数"></a>不可重入，可重入函数</h3><p>如果有一个函数不幸被设计成为这样：那么不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。</p><p>满足下列条件的函数多数是不可重入（不安全）的：</p><ol><li><strong>函数体内使用了静态的数据结构；</strong></li><li><strong>函数体内调用了malloc()或者free()函数（谨慎使用堆）；</strong></li><li><strong>函数体内调用了标准I&#x2F;O函数（包含缓冲区）。</strong></li></ol><p>相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。</p><p>保证函数的可重入性的方法：</p><ol><li><strong>在写函数时候尽量使用局部变量（例如寄存器，栈中变量）；</strong></li><li><strong>对于要使用的全局变量要加以保护（如采取中断，信号量等互斥方法），这样构成的函数就一定是一个可重入的函数。</strong></li></ol><p>信号处理函数应为可重入函数。</p><h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h3><h4 id="SIGCHLD信号产生的条件"><a href="#SIGCHLD信号产生的条件" class="headerlink" title="SIGCHLD信号产生的条件"></a>SIGCHLD信号产生的条件</h4><ol><li>子进程终止时</li><li>子进程接收到SIGSTOP信号停止时</li><li>子进程处在停止态，接受到SIGCONT后唤醒时</li></ol><h3 id="如何避免僵尸进程"><a href="#如何避免僵尸进程" class="headerlink" title="如何避免僵尸进程"></a>如何避免僵尸进程</h3><ol><li>最简单的方法，父进程通过wait()和waitpid()等函数等待子进程结束，但是，这会导致父进程挂起。</li><li>如果父进程要处理的事情很多，不能够挂起，通过signal()函数人为处理信号SIGCHLD，只要有子进程退出自动调用指定好的回调函数，因为子进程结束后，父进程会收到该信号SIGCHLD（17号）,可以在其回调函数里调用wait()或waitpid()回收。</li></ol><p>示例程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号 %d\n&quot;</span>,signo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有子进程退出。。。。\n&quot;</span>);</span><br><span class="line">    <span class="comment">//以非阻塞方式</span></span><br><span class="line">    <span class="keyword">while</span>((waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//演示sigaction函数使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="comment">//使用旧的信号处理函数指针</span></span><br><span class="line">    act.sa_handler=fun;</span><br><span class="line">    <span class="comment">//标志为默认 默认使用旧的信号处理函数指针</span></span><br><span class="line">    act.sa_flags=<span class="number">0</span>;</span><br><span class="line">    sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程累&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程退出&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;父进程do working&quot;</span>);</span><br><span class="line">           sleep(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="守护进程和线程"><a href="#守护进程和线程" class="headerlink" title="守护进程和线程"></a>守护进程和线程</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>进程组，也称之为作业。代表一个或多个进程的集合。</p><p>每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用过。操作系统设计的进程组的概念，是为了简化堆多个进程的管理。</p><p>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID为第一个进程ID（组长进程）。</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话是一个或多个进程组的集合。</p><ol><li>一个会话可以有一个控制终端。这通常是终端设备或伪终端设备；</li><li>建立与控制终端连接的会话首进程被称为控制进程；</li><li>一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组；</li><li>如果一个会话有一个控制终端，则他有一个前台进程组，其他进程组为后台进程组。</li><li>如果终端接口检测到断开连接，则将挂断信号发送至控制进程（会话首进程）。</li></ol><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程也就是通常说的Daemon进程（精灵进程），是Linux的后台服务进程。它是一个生存期较长的进程，<strong>通常独立于控制终端并且周期性执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</strong></p><p>守护进程是一个<strong>特殊的孤儿进程</strong>，这种进程脱离终端，为了避免进程被任何终端产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在Linux中，每个系统与用户进行交流的界面叫做终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程会自动关闭。</p><h4 id="守护进程模型"><a href="#守护进程模型" class="headerlink" title="守护进程模型"></a>守护进程模型</h4><ol><li><p>创建子进程，父进程退出（必须）</p><p>所有工作在子进程中进行形式上脱离了控制终端</p></li><li><p>在子进程中创建新会话（必须）</p><p>setsid()函数</p><p>使子进程完全独立出来，脱离控制</p></li><li><p>改变当前目录为根目录（不是必须）</p><p>chdir()函数</p><p>防止占用可卸载的文件系统</p><p>也可以换成其他路径</p></li><li><p>重设文件权限掩码（不是必须）</p><p>umask()函数(可以对文件权限进行修改，如果umask为0000,那创建普通文件文件权限为0666，目录文件文件权限为0777，但是umask默认为0002)</p><p>防止继承的文件创建屏蔽字拒绝某些权限</p><p>增加守护进程灵活性</p></li><li><p>关闭文件描述符（不是必须）</p><p>继承的打开文件不会用到，浪费系统资源，无法卸载。标准输入，标准输出，标准错误输出设备文件默认被打开</p></li><li><p>开始执行守护进程核心工作（必须）</p><p>守护进程退出处理程序模型</p></li></ol><h4 id="守护进程参考代码"><a href="#守护进程参考代码" class="headerlink" title="守护进程参考代码"></a>守护进程参考代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建守护进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//1.创建子进程 父进程退出</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建新的会话 完全脱离控制终端</span></span><br><span class="line">    pid=setsid();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.改变当前工作目录</span></span><br><span class="line">    ret=chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.设置权限掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//5.关闭文件描述符</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line">    <span class="comment">//6.执行核心的任务</span></span><br><span class="line">    <span class="comment">//每隔一秒钟输出当前的时间到/tmp/txt.log文件中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        system(<span class="string">&quot;date &gt;&gt; /tmp/txt.log&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取系统时间，日志文件需要创建当天的文件，文件名为当天的日期。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 64</span></span><br><span class="line"><span class="comment">//创建守护进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">time_t</span> t=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">pT</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> file_name[SIZE];</span><br><span class="line">    <span class="comment">//1.创建子进程 父进程退出</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建新的会话 完全脱离控制终端</span></span><br><span class="line">    pid=setsid();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==pid)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setsid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.改变当前工作目录</span></span><br><span class="line">    ret=chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.设置权限掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//5.关闭文件描述符</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line">    <span class="comment">//6.执行核心的任务</span></span><br><span class="line">    <span class="comment">//每隔一秒钟输出当前的时间到/tmp/txt.log文件中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//获取当前时间 以秒为单位 从1970-01-01 00:00:00 开始到现在秒数。</span></span><br><span class="line">        t=time(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="comment">//转化为时间</span></span><br><span class="line">        pT=localtime(&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(pT==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转化为文件名</span></span><br><span class="line">        <span class="built_in">memset</span>(file_name,<span class="number">0</span>,SIZE);</span><br><span class="line">        <span class="built_in">sprintf</span>(file_name,<span class="string">&quot;%s%d%d%d%d%d%d.log&quot;</span>,<span class="string">&quot;touch /home/deng/log/&quot;</span>,pT-&gt;tm_year+<span class="number">1990</span>,pT-&gt;tm_mon+<span class="number">1</span>,pT-&gt;tm_mday,pT-&gt;tm_hour,pT-&gt;tm_min,pT-&gt;tm_sec);</span><br><span class="line">        system(file_name);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在许多经典的操作系统教科书中，总是把进程定义为程序的执行实例，她并不执行什么，只是维护应用程序所需的各种资源，而<strong>线程才是真正的执行实体。</strong></p><p>所以线程是轻量级的线程，在Linux环境下线程的本质仍是进程。</p><p>为了让进程完成一定的工作，进程必须至少包含一个线程。</p><p><img src="/2025/06/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/9.png" alt="9"></p><p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统以进程为单位，分配系统资源，所以我们也说，<strong>进程是CPU分配资源的最小单位。</strong></p><p><strong>线程存在进程当中，是操作系统调度执行的最小单位。</strong></p><h4 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h4><ol><li>线程是轻量级进程（light-weight process），也有PCB,创建线程使用的底层函数和进程一样，都是clone。</li><li>从内核里看进程和线程是一样的，都有各自不同的PCB。</li><li>进程可以蜕变成线程。</li><li>在Linux下，线程是最小的执行单位；进程是最小的分配资源单位。</li></ol><p>查看指定进程的LWP号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -Lf pid</span><br></pre></td></tr></table></figure><p>实际上，无论是创建进程的fork,还是创建线程的pthread_create,底层实现都是调用同一个内核函数clone。</p><ol><li><strong>如果复制对方的地址空间（深拷贝），那么就产生一个进程</strong></li><li><strong>如果共享对方的地址空间（浅拷贝），就产生一个线程。</strong></li></ol><p>*<em>Linux内核是不区分进程和线程的，只在用户层面上进行区分。所以，线程所有操作函数pthread_<em>是库函数，而非系统调用。</em></em></p><h4 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h4><ol><li><strong>文件描述符表</strong></li><li><strong>每种信号的处理方式</strong></li><li><strong>当前工作目录</strong></li><li><strong>用户ID和组ID</strong></li><li><strong>内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)(这里是多线程共享)</strong></li></ol><h4 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h4><ol><li><strong>线程id</strong></li><li><strong>处理器现场和栈指针（内核栈）</strong></li><li><strong>独立的栈空间（用户空间栈）</strong></li><li><strong>errno变量</strong></li><li><strong>信号屏蔽字</strong></li><li><strong>调度优先级</strong></li></ol><h4 id="线程常用操作"><a href="#线程常用操作" class="headerlink" title="线程常用操作"></a>线程常用操作</h4><p>进程号在整个系统中是唯一的，但线程号不同，线程号只在它所属的进程环境中有效。</p><p>进程号用pid_t数据类型表示，是一个非负整数。<strong>线程号则用pthread_t数据类型来表示，Linux使用无符号长整数表示。</strong></p><p><strong>有的系统在实现pthread_t的时候，用一个结构体来表示，所以在可移植的操作系统实现不能把他作为整数处理。</strong></p><p>pthread_self函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：</span><br><span class="line">    获取线程号</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    调用线程的线程id。</span><br></pre></td></tr></table></figure><p>pthread_equal函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1,<span class="type">pthread_t</span> t2)</span>;</span><br><span class="line">功能：</span><br><span class="line">    判断线程号t1和t2是否相等。为了方便移植，尽量使用函数来比较线程ID.</span><br><span class="line">参数：</span><br><span class="line">    t1,t2:待判断的线程号</span><br><span class="line">返回值：</span><br><span class="line">    相等：非<span class="number">0</span></span><br><span class="line">    不相等：<span class="number">0</span></span><br></pre></td></tr></table></figure><p>参考程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定链接线程库</span></span><br><span class="line"><span class="comment">//gcc pthread_self.c -pthread </span></span><br><span class="line"><span class="comment">//线程常用函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取当前线程的线程号</span></span><br><span class="line">    tid=pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid: %lu\n&quot;</span>,tid);</span><br><span class="line">    <span class="comment">//比较两个线程ID是否相同</span></span><br><span class="line">    <span class="keyword">if</span>(pthread_equal(tid,pthread_self()))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个线程ID相同\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;两个线程ID不相同\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h5><p>pthread_create函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread,<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,<span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    创建一个线程。</span><br><span class="line">参数：</span><br><span class="line">    thread:线程标识符地址</span><br><span class="line">    attr:线程属性结构体地址，通常设置为<span class="literal">NULL</span></span><br><span class="line">    start_routine:线程函数的入口地址</span><br><span class="line">    arg:传入线程函数的参数</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>在一个线程中调用pthread_create()函数创建新的进程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。</p><p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以用strerror()把错误码转换成错误信息再打印。</p><p>参考程序:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//线程调度后执行的任务</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新的线程执行任务 tid:%lu\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> var=(<span class="type">int</span>)(<span class="type">long</span>)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程2 var=%d\n&quot;</span>,var);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid2=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建一个线程</span></span><br><span class="line">    ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_Create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个线程</span></span><br><span class="line">    ret=pthread_create(&amp;tid2,<span class="literal">NULL</span>,fun1,(<span class="type">void</span> *)<span class="number">0x3</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_Create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread....tid:%lu\n&quot;</span>,pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键主线程退出&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程资源回收"><a href="#线程资源回收" class="headerlink" title="线程资源回收"></a>线程资源回收</h5><p>pthread_join函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread,<span class="type">void</span> **retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    等待线程结束（此函数会阻塞），并回收线程资源，类似进程的wait函数。如果线程已经结束，那么该函数会立即返回。</span><br><span class="line">参数：</span><br><span class="line">    thread:被等待的线程号。</span><br><span class="line">    retval:用来存储线程退出状态的指针的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>参考程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//线程处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun thread do working %d\n&quot;</span>,i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">0x3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回收线程的资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> *retp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//创建一个线程</span></span><br><span class="line">    ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread running...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//等待线程结束 会阻塞</span></span><br><span class="line">    ret=pthread_join(tid,&amp;retp);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_join failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;retp: %p\n&quot;</span>,retp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main thread running...</span><br><span class="line">fun thread <span class="keyword">do</span> working 0</span><br><span class="line">fun thread <span class="keyword">do</span> working 1</span><br><span class="line">fun thread <span class="keyword">do</span> working 2</span><br><span class="line">fun thread <span class="keyword">do</span> working 3</span><br><span class="line">fun thread <span class="keyword">do</span> working 4</span><br><span class="line">retp: 0x3</span><br><span class="line">main thread <span class="built_in">exit</span>...</span><br></pre></td></tr></table></figure><h5 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h5><p>一般情况下，<strong>线程终止后，其终止状态一直保留到其他线程调用pthread_join获取它的状态为止。</strong>但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它所占用的资源，而不保留终止状态。</p><p>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。</p><p>pthread_detach函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    使调用线程与当前进程分离，分离后不代表此线程不依赖当前进程（进程退出，线程也结束），线程分离的目的是将线程资源的回收工作交由系统自动完成，也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以。此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    thread:线程号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun thread do working %d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回收线程的资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread running...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">    ret=pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_detach failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键主线程退出。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main thread running...</span><br><span class="line">按下任意键主线程退出。。。</span><br><span class="line">fun thread <span class="keyword">do</span> working 0</span><br><span class="line">fun thread <span class="keyword">do</span> working 1</span><br><span class="line">fun thread <span class="keyword">do</span> working 2</span><br><span class="line">fun thread <span class="keyword">do</span> working 3</span><br><span class="line">fun thread <span class="keyword">do</span> working 4</span><br></pre></td></tr></table></figure><h5 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h5><p>在进程中我们可以用exit函数或_exit函数来结束进程，在一个线程中我们可以通过一下三种在不终止整个进程的情况下停止它的控制流。</p><ol><li>线程从执行函数返回。</li><li>线程调用pthread_exit退出线程</li><li>线程可以被同一进程中的其他线程取消。</li></ol><p>pthread_exit函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line">功能：</span><br><span class="line">    退出调用线程。一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源并不会释放。</span><br><span class="line">参数：</span><br><span class="line">    retval:存储线程退出状态的指针。</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun thread do working %d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return NULL;</span></span><br><span class="line">    <span class="comment">//相当于return NULL</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//终止整个进程</span></span><br><span class="line">    <span class="comment">//exit(0);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回收线程的资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread running...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">    ret=pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_detach failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键主线程退出。。。\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line">功能：</span><br><span class="line">    杀死（取消）线程</span><br><span class="line">参数：</span><br><span class="line">    thread:目标线程ID</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：出错编号</span><br></pre></td></tr></table></figure><p><strong>注:线程的取消并不是实时的，而又一定的延时。需要等待线程到达某个取消点（检查点）。</strong></p><p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat,open，pause,close,read,write…可粗略认为一个系统调用（进入内核）为一个取消点。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程处理函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun thread do working %d\n&quot;</span>, i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回收线程的资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread running...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">    ret=pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_detach failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   sleep(<span class="number">3</span>);</span><br><span class="line">   pthread_cancel(tid);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;主线程睡眠了3秒 取消子线程。。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main thread running...</span><br><span class="line">fun thread <span class="keyword">do</span> working 0</span><br><span class="line">fun thread <span class="keyword">do</span> working 1</span><br><span class="line">fun thread <span class="keyword">do</span> working 2</span><br><span class="line">主线程睡眠了3秒 取消子线程。。</span><br></pre></td></tr></table></figure><h5 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h5><ol><li>主线程退出其他线程不退出，主线程应调用pthread_exit</li><li>避免僵尸线程，pthread_join&#x2F;pthread_detach&#x2F;pthread_create指定分离属性</li><li>malloc和mmap申请的内存可以被其他线程释放。</li><li>避免在多线程模型中调用fork,除非马上exec,子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</li><li>信号的复杂语义很难和多线程共存，避免在多线程引入信号机制。</li></ol><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>现代操作系统基本都是多任务操作系统，即同时有大量可调度实体在运行。在多任务操作系统中，同时运行的多个任务：</p><ol><li>都需要访问&#x2F;使用同一种资源</li><li>多个任务之间有依赖关系，某个任务的运行依赖另一个任务</li></ol><p>同步和互斥就是用于解决这两个问题。</p><p><strong>互斥：是指散步在不同任务之间的若干程序片段，当某个任务运行其中一个程序片段时，其他任务就不能运行他们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</strong></p><p><strong>同步：是指散步在不同任务之间的若干程序片段，他们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如A任务的运行依赖于B任务产生的数据。</strong></p><h4 id="互斥锁Mutex介绍"><a href="#互斥锁Mutex介绍" class="headerlink" title="互斥锁Mutex介绍"></a>互斥锁Mutex介绍</h4><p>在线程里，也有这么一把锁：互斥锁（mutex）,也叫互斥量，互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态，即加锁（lock）和解锁（unlock）。</p><p>互斥锁的操作流程如下：</p><ol><li>在访问共享资源后临界区域前，对互斥锁进行加锁。</li><li>在访问完成后释放互斥锁</li><li>对互斥锁进行加锁后，任何试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。</li></ol><p>互斥锁的数据类型是：pthread_mutex_t</p><h4 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a>pthread_mutex_init函数</h4><p>初始化互斥锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个互斥锁</span><br><span class="line">参数：</span><br><span class="line">    mutex:互斥锁地址。类型是<span class="type">pthread_mutex_t</span>.</span><br><span class="line">    attr:设置互斥量的属性，通常采用默认属性，即可将attr设为<span class="literal">NULL</span>.</span><br><span class="line">        </span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，成功申请的锁是默认打开的。</span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><h4 id="pthread-mutex-destory函数"><a href="#pthread-mutex-destory函数" class="headerlink" title="pthread_mutex_destory函数"></a>pthread_mutex_destory函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁指定的一个互斥锁。互斥锁在使用完毕，必须要对互斥锁进行销毁，以释放资源。</span><br><span class="line">参数：</span><br><span class="line">    mutex:互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><h4 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a>pthread_mutex_lock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对互斥锁上锁，若互斥锁已经上锁，则调用者阻塞，直到互斥锁解锁后上锁。</span><br><span class="line">参数:</span><br><span class="line">mutex:互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">调用该函数时，若互斥锁未加锁，则上锁，返回<span class="number">0</span>；</span><br><span class="line">    若互斥锁已加锁，则函数直接返回失败，即EBUSY.</span><br></pre></td></tr></table></figure><h4 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a>pthread_mutex_unlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    对指定的互斥锁解锁</span><br><span class="line">参数：</span><br><span class="line">    mutex:互斥锁地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//互斥锁变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出大写字母</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&#x27;A&#x27;</span>;i&lt;<span class="string">&#x27;Z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出小写字母</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&#x27;a&#x27;</span>;i&lt;<span class="string">&#x27;z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="comment">//初始化一个互斥量 互斥锁</span></span><br><span class="line">    ret=pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>!=ret)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化一个互斥量成功。。。。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,fun1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,fun2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//等待两个线程结束</span></span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//销毁互斥量 互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化一个互斥量成功。。。。</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy</span><br><span class="line">main thread <span class="built_in">exit</span>...</span><br></pre></td></tr></table></figure><h3 id="死锁（DeadLock）"><a href="#死锁（DeadLock）" class="headerlink" title="死锁（DeadLock）"></a>死锁（DeadLock）</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。若无外力作用，他们将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><h4 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h4><p><strong>破坏请求和保持条件</strong></p><p> 协议1：所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会提出资源需求，破坏了请求条件，即使有一种资源不能满足需求，也不会给他分配正在空闲的进程，这样他就没有资源，这样他就没有资源，就破环了保持条件，从而预防。</p><p>协议2：允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来。然后再请求新的资源。</p><p><strong>破坏不可抢占条件</strong></p><p>当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能满足时，他必须释放已经保持的所有资源，以后需要时再重新申请。</p><p><strong>破坏循环等待条件</strong></p><p>对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其他几个线程也想读取这个共享资源，但是由于互斥锁的排他性，所有其他线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。</p><p>为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。</p><p>读写锁的特点如下：</p><ol><li>如果有其他线程读数据，则允许其他线程执行读操作，但不允许写操作。</li><li>如果有其他线程写数据，则其他线程都不允许读，写操作。</li></ol><p>POSIX定义的读写锁的数据类型是：pthread_rwlock_t。</p><h4 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a>pthread_rwlock_init函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,<span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用来初始化rwlock所指向的读写锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock:指向要初始化的读写指针。</span><br><span class="line">    attr:读写锁的属性指针。如果attr为<span class="literal">NULL</span>则会使用默认的属性初始化读写锁，否则使用指定的attr初始化读写锁。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>,读写锁的状态将成为已初始化和已解锁</span><br><span class="line">    失败:非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><h4 id="pthread-rwlock-destroy函数"><a href="#pthread-rwlock-destroy函数" class="headerlink" title="pthread_rwlock_destroy函数"></a>pthread_rwlock_destroy函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    用于销毁一个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init()自动申请的资源）</span><br><span class="line">参数：</span><br><span class="line">    rwlock:读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><h4 id="pthread-rwlock-rdlock函数"><a href="#pthread-rwlock-rdlock函数" class="headerlink" title="pthread_rwlock_rdlock函数"></a>pthread_rwlock_rdlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    以阻塞方式在读写锁上获取读锁（读锁定）</span><br><span class="line">    如果没有写者持有该锁，并且没有写者阻塞在该锁上，则调用线程会获取读锁。</span><br><span class="line">    如果调用线程未获取读锁，则它将阻塞直到他获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。线程可以成功调用pthread_rwlock_rdlock函数多次，但是之后该线程必须调用pthread_rwlock_unlock函数n次才能解除锁定。</span><br><span class="line">参数：</span><br><span class="line">    rwlock；读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">用于尝试以非阻塞的方式来在读写锁上获取读锁</span><br><span class="line">    如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。</span><br></pre></td></tr></table></figure><h4 id="pthread-rwlock-wrlock函数"><a href="#pthread-rwlock-wrlock函数" class="headerlink" title="pthread_rwlock_wrlock函数"></a>pthread_rwlock_wrlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    在读写锁上获取写锁（写锁定）</span><br><span class="line">    如果没有写者持有该锁，并且没有读者持有该锁，则调用线程获取写锁</span><br><span class="line">    如果调用线程未获取写锁，则它将阻塞直到它获取了该锁。</span><br><span class="line">参数：</span><br><span class="line">    rwlock:读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">用于尝试以非阻塞的方式来在读写锁上获取写锁</span><br><span class="line">    如果有任何的读者和写者持有该锁，则立即失败返回。</span><br></pre></td></tr></table></figure><h4 id="pthread-rwlock-unlock函数"><a href="#pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_unlock函数"></a>pthread_rwlock_unlock函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    无论是写锁还是读锁，都可以通过此函数解锁</span><br><span class="line">参数：</span><br><span class="line">    rwlock:读写锁指针</span><br><span class="line">返回值：</span><br><span class="line">   成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读写锁变量</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//读线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun_read</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//获取线程的编号</span></span><br><span class="line">    <span class="type">int</span> index=(<span class="type">int</span>)(<span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="comment">//加读写锁读锁</span></span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程%d 读取num的值 %d\n&quot;</span>,index,num);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">//随机睡眠1到3秒</span></span><br><span class="line">        sleep(random()%<span class="number">3</span>+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun_write</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程的编号</span></span><br><span class="line">    <span class="type">int</span> index=(<span class="type">int</span>)(<span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//加读写锁的写锁</span></span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程%d 修改num的值 %d\n&quot;</span>,index,num);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        <span class="comment">//随机睡眠1到3秒</span></span><br><span class="line">        sleep(random()%<span class="number">3</span>+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//设置随机种子</span></span><br><span class="line">    srandom(getpid());</span><br><span class="line">    <span class="comment">//初始化读写锁</span></span><br><span class="line">    ret=pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_rwlock_init failed..\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建8个线程</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//创建读线程</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">           </span><br><span class="line">            pthread_create(&amp;tid[i],<span class="literal">NULL</span>,fun_read,(<span class="type">void</span> *)(<span class="type">long</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//创建写线程</span></span><br><span class="line">            pthread_create(&amp;tid[i],<span class="literal">NULL</span>,fun_write,(<span class="type">void</span> *)(<span class="type">long</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收八个线程的资源</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁读写锁</span></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">线程0 读取num的值 0</span><br><span class="line">线程1 读取num的值 0</span><br><span class="line">线程2 读取num的值 0</span><br><span class="line">线程3 读取num的值 0</span><br><span class="line">线程4 读取num的值 0</span><br><span class="line">线程5 修改num的值 1</span><br><span class="line">线程7 修改num的值 2</span><br><span class="line">线程6 修改num的值 3</span><br><span class="line">线程3 读取num的值 3</span><br><span class="line">线程4 读取num的值 3</span><br><span class="line">线程6 修改num的值 4</span><br><span class="line">线程0 读取num的值 4</span><br><span class="line">线程2 读取num的值 4</span><br><span class="line">线程5 修改num的值 5</span><br><span class="line">线程6 修改num的值 6</span><br><span class="line">线程1 读取num的值 6</span><br><span class="line">线程0 读取num的值 6</span><br><span class="line">线程2 读取num的值 6</span><br><span class="line">线程4 读取num的值 6</span><br><span class="line">线程7 修改num的值 7</span><br><span class="line">线程5 修改num的值 8</span><br><span class="line">线程6 修改num的值 9</span><br><span class="line">线程3 读取num的值 9</span><br><span class="line">线程7 修改num的值 10</span><br></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是用来等待而不是用来上锁的，条件变量本身不是锁。</p><p>条件变量用来自动阻塞一个线程，直到某种特殊情况发生为止。<strong>通常条件变量和互斥锁同时使用。</strong></p><p>条件变量的两个动作：</p><ol><li>条件不满足，阻塞线程</li><li>当条件满足时，通知阻塞的线程开始工作</li></ol><p>条件变量的类型：pthread_cond_t</p><h4 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a>pthread_cond_init函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    初始化一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond:指向要初始化的条件变量指针。</span><br><span class="line">    attr:条件变量属性，通常为默认值，传<span class="literal">NULL</span>即可</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><h4 id="pthread-cond-destroy函数"><a href="#pthread-cond-destroy函数" class="headerlink" title="pthread_cond_destroy函数"></a>pthread_cond_destroy函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁一个条件变量</span><br><span class="line">参数:</span><br><span class="line">cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><h4 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a>pthread_cond_wait函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待一个条件变量</span><br><span class="line">      <span class="number">1.</span>阻塞等待条件变量cond(参数<span class="number">1</span>)满足</span><br><span class="line">      <span class="number">2.</span>释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">以上的两步为一个原子操作（不可中断，取消）</span><br><span class="line">      <span class="number">3.</span>当被唤醒时，pthread_cond_wait函数返回时，解除阻塞并重新申请互斥锁pthread_mutex_lock(&amp;mutex);</span><br><span class="line">参数：</span><br><span class="line">    cond:指向要初始化的条件变量指针</span><br><span class="line">    mutex:互斥锁</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><h4 id="pthread-cond-signal函数"><a href="#pthread-cond-signal函数" class="headerlink" title="pthread_cond_signal函数"></a>pthread_cond_signal函数</h4><p>唤醒阻塞在条件变量上的线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond:指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒全部阻塞在条件变量上的线程</span><br><span class="line">参数:</span><br><span class="line">cond:指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变条件的线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//唤醒因为条件而阻塞线程</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待条件的线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//表示条件不满足</span></span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//等待条件满足 会阻塞</span></span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程2因为条件满足 开始运行。。。\n&quot;</span>);</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//条件变量的应用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="comment">//初始化条件变量</span></span><br><span class="line">    ret=pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_cond_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化互斥量</span></span><br><span class="line">    ret=pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,fun1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,fun2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收线程</span></span><br><span class="line">    ret=pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_join failed..\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret=pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_join failed..\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁互斥量</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="comment">//销毁条件变量</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br><span class="line">线程2因为条件满足 开始运行。。。</span><br></pre></td></tr></table></figure><h4 id="生产者和消费者模型（由条件变量实现）"><a href="#生产者和消费者模型（由条件变量实现）" class="headerlink" title="生产者和消费者模型（由条件变量实现）"></a>生产者和消费者模型（由条件变量实现）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">node_t</span> *head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环生产产品</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(new, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="comment">// 1-100</span></span><br><span class="line">        new-&gt;data = random() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头插法</span></span><br><span class="line">        new-&gt;next = head;</span><br><span class="line">        head = new;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者生产产品%d\n&quot;</span>,new-&gt;data);</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//唤醒因为条件变量阻塞的线程</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        <span class="comment">// 随机睡眠</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">customer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环消费</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果链表为空 就阻塞</span></span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;消费者消费 %d\n&quot;</span>,tmp-&gt;data);</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者和消费者模型 条件变量的版本</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1 = <span class="number">-1</span>, tid2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//设置随机种子</span></span><br><span class="line">    srandom(getpid());</span><br><span class="line">    <span class="comment">//初始化条件变量</span></span><br><span class="line">    ret=pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_cond_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化互斥量</span></span><br><span class="line">    ret=pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_mutex_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个线程 生产者线程 消费者线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个线程结束</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">产者生产产品71</span><br><span class="line">消费者消费 71</span><br><span class="line">生产者生产产品69</span><br><span class="line">消费者消费 69</span><br><span class="line">生产者生产产品69</span><br><span class="line">消费者消费 69</span><br><span class="line">生产者生产产品54</span><br><span class="line">消费者消费 54</span><br><span class="line">生产者生产产品20</span><br><span class="line">消费者消费 20</span><br><span class="line">生产者生产产品4</span><br><span class="line">消费者消费 4</span><br><span class="line">生产者生产产品33</span><br><span class="line">消费者消费 33</span><br><span class="line">生产者生产产品23</span><br><span class="line">消费者消费 23</span><br></pre></td></tr></table></figure><h4 id="条件变量的优缺点"><a href="#条件变量的优缺点" class="headerlink" title="条件变量的优缺点"></a>条件变量的优缺点</h4><p>相对于mutex而言，条件变量可以减少竞争。</p><p>如直接使用mutex,除了生产者，消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果链表中没有数据，消费者之间竞争互斥锁是无意义的。</p><p>有了条件变量机制后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>信号量广泛用于进程或进程间的同步和互斥，信号量本质上是一个非负的整数计数器，它用来控制对公共资源的访问。</strong></p><p><strong>编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号值大于0时，则可以访问，否则将阻塞。</strong></p><p><strong>PV原语对信号量的操作，一次P操作使信号量减1，一次V操作使信号量加1.</strong></p><p><strong>信号量主要用于进程或线程间的同步和互斥这两种典型情况。</strong></p><p><strong>信号量数据类型：sem_t</strong></p><h4 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a>sem_init函数</h4><p>初始化信号量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">int</span> pshared,<span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化。</span><br><span class="line">参数：</span><br><span class="line">    sem:信号量地址</span><br><span class="line">    pshared:等于<span class="number">0</span>，信号量在线程间共享（常用）；不等于<span class="number">0</span>，信号量在进程间共享</span><br><span class="line">    value:信号量的初始值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a>sem_destroy函数</h4><p>销毁信号量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    删除sem标识的信号量</span><br><span class="line">参数：</span><br><span class="line">    sem:信号量地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="信号量P操作（减1）"><a href="#信号量P操作（减1）" class="headerlink" title="信号量P操作（减1）"></a>信号量P操作（减1）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值减<span class="number">1</span>，操作前，先检查信号量（sem）的值是否为<span class="number">0</span>，若信号量为<span class="number">0</span>，此函数会阻塞，直到信号量大于<span class="number">0</span>时才进行减<span class="number">1</span>操作。</span><br><span class="line">参数：</span><br><span class="line">    sem:信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">以阻塞的方式来对信号量进行减<span class="number">1</span>操作。</span><br><span class="line">    若操作前，信号量的值等于<span class="number">0</span>，则对信号量的操作失败，函数立即返回。</span><br></pre></td></tr></table></figure><h4 id="信号量V操作（加1）"><a href="#信号量V操作（加1）" class="headerlink" title="信号量V操作（加1）"></a>信号量V操作（加1）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line">功能：</span><br><span class="line">    将信号量的值加<span class="number">1</span>并发出信号唤醒等待线程（ sem_wait() ）;</span><br><span class="line">参数：</span><br><span class="line">    sem:信号量的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="获取信号量的值"><a href="#获取信号量的值" class="headerlink" title="获取信号量的值"></a>获取信号量的值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">int</span> *sval)</span>;</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    获取sem标识的信号量的值，保存在sval中</span><br><span class="line">参数：</span><br><span class="line">    sem:信号量地址</span><br><span class="line">    sval:保存信号量值的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="信号量用于互斥"><a href="#信号量用于互斥" class="headerlink" title="信号量用于互斥"></a>信号量用于互斥</h4><p>一次性打印完大写或者小写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量变量</span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出大写字母</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//申请资源 将可用资源减1</span></span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&#x27;A&#x27;</span>;i&lt;<span class="string">&#x27;Z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源 将可用资源加1</span></span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出小写字母</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//申请资源 将可用资源减1</span></span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&#x27;a&#x27;</span>;i&lt;<span class="string">&#x27;z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(i);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源 将可用资源加1</span></span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1,tid2;</span><br><span class="line">    <span class="comment">//初始化一个信号量</span></span><br><span class="line">    ret=sem_init(&amp;sem,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>!=ret)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化一个信号量成功。。。。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    pthread_create(&amp;tid1,<span class="literal">NULL</span>,fun1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2,<span class="literal">NULL</span>,fun2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//等待两个线程结束</span></span><br><span class="line">    pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;sem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化一个信号量成功。。。。</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy</span><br><span class="line">main thread <span class="built_in">exit</span>...</span><br></pre></td></tr></table></figure><h4 id="信号量用于同步"><a href="#信号量用于同步" class="headerlink" title="信号量用于同步"></a>信号量用于同步</h4><p>生产者和消费者模型（信号量）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"><span class="type">node_t</span> *head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 信号量变量</span></span><br><span class="line"><span class="comment">// 容器的个数</span></span><br><span class="line"><span class="type">sem_t</span> sem_producer;</span><br><span class="line"><span class="comment">// 可以卖产品的个数</span></span><br><span class="line"><span class="type">sem_t</span> sem_customer;</span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环生产产品</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请一个资源 容器</span></span><br><span class="line">        sem_wait(&amp;sem_producer);</span><br><span class="line">        <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(new, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="comment">// 1-100</span></span><br><span class="line">        new-&gt;data = random() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头插法</span></span><br><span class="line">        new-&gt;next = head;</span><br><span class="line">        head = new;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者生产产品%d\n&quot;</span>, new-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知消费者消费 将可以卖的商品个数加1</span></span><br><span class="line">        sem_post(&amp;sem_customer);</span><br><span class="line">        <span class="comment">// 随机睡眠</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">customer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环消费</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请资源 可以卖的商品个数减1</span></span><br><span class="line">        sem_wait(&amp;sem_customer);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果链表为空 就阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;产品为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者消费 %d\n&quot;</span>, tmp-&gt;data);</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        <span class="comment">// 释放资源 将容器个数加1</span></span><br><span class="line">        sem_post(&amp;sem_producer);</span><br><span class="line">        <span class="comment">// 睡眠1-3秒</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者和消费者模型 条件变量的版本</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid1 = <span class="number">-1</span>, tid2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    srandom(getpid());</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    ret = sem_init(&amp;sem_producer, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem_producer_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = sem_init(&amp;sem_customer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem_customer_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建两个线程 生产者线程 消费者线程</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个线程结束</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    sem_destroy(&amp;sem_producer);</span><br><span class="line">    sem_destroy(&amp;sem_customer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">生产者生产产品7</span><br><span class="line">消费者消费 7</span><br><span class="line">生产者生产产品10</span><br><span class="line">消费者消费 10</span><br><span class="line">生产者生产产品65</span><br><span class="line">消费者消费 65</span><br><span class="line">生产者生产产品84</span><br><span class="line">消费者消费 84</span><br><span class="line">生产者生产产品13</span><br><span class="line">消费者消费 13</span><br><span class="line">生产者生产产品10</span><br><span class="line">消费者消费 10</span><br><span class="line">生产者生产产品51</span><br></pre></td></tr></table></figure><p><strong>多生产者和多消费者</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"><span class="type">node_t</span> *head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 信号量变量</span></span><br><span class="line"><span class="comment">// 容器的个数</span></span><br><span class="line"><span class="type">sem_t</span> sem_producer;</span><br><span class="line"><span class="comment">// 可以卖产品的个数</span></span><br><span class="line"><span class="type">sem_t</span> sem_customer;</span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环生产产品</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请一个资源 容器</span></span><br><span class="line">        sem_wait(&amp;sem_producer);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(new, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="comment">// 1-100</span></span><br><span class="line">        new-&gt;data = random() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        new-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头插法</span></span><br><span class="line">        new-&gt;next = head;</span><br><span class="line">        head = new;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者生产产品%d\n&quot;</span>, new-&gt;data);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 通知消费者消费 将可以卖的商品个数加1</span></span><br><span class="line">        sem_post(&amp;sem_customer);</span><br><span class="line">        <span class="comment">// 随机睡眠</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">customer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环消费</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请资源 可以卖的商品个数减1</span></span><br><span class="line">        sem_wait(&amp;sem_customer);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果链表为空 就阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;产品为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者消费 %d\n&quot;</span>, tmp-&gt;data);</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 释放资源 将容器个数加1</span></span><br><span class="line">        sem_post(&amp;sem_producer);</span><br><span class="line">        <span class="comment">// 睡眠1-3秒</span></span><br><span class="line">        sleep(random() % <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者和消费者模型 条件变量的版本</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">6</span>];</span><br><span class="line">    <span class="comment">// 设置随机种子</span></span><br><span class="line">    srandom(getpid());</span><br><span class="line">    <span class="comment">//互斥锁初始化</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    ret = sem_init(&amp;sem_producer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem_producer_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = sem_init(&amp;sem_customer, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sem_customer_init failed...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            pthread_create(&amp;tid[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pthread_create(&amp;tid[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    sem_destroy(&amp;sem_producer);</span><br><span class="line">    sem_destroy(&amp;sem_customer);</span><br><span class="line">    <span class="comment">//互斥锁销毁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">生产者生产产品59</span><br><span class="line">消费者消费 59</span><br><span class="line">生产者生产产品68</span><br><span class="line">消费者消费 68</span><br><span class="line">生产者生产产品12</span><br><span class="line">消费者消费 12</span><br><span class="line">生产者生产产品28</span><br><span class="line">消费者消费 28</span><br><span class="line">生产者生产产品97</span><br><span class="line">消费者消费 97</span><br><span class="line">生产者生产产品12</span><br><span class="line">消费者消费 12</span><br><span class="line">生产者生产产品51</span><br><span class="line">消费者消费 51</span><br><span class="line">生产者生产产品99</span><br><span class="line">消费者消费 99</span><br><span class="line">生产者生产产品96</span><br></pre></td></tr></table></figure><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux常见目录&quot;&gt;&lt;a href=&quot;#Linux常见目录&quot; class=&quot;headerlink&quot; title=&quot;Linux常见目录&quot;&gt;&lt;/a&gt;Linux常见目录&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
</summary>
      
    
    
    
    <category term="Linux System Programming" scheme="http://yustonerain.top/categories/Linux-System-Programming/"/>
    
    
    <category term="Linux System Programming" scheme="http://yustonerain.top/tags/Linux-System-Programming/"/>
    
  </entry>
  
  <entry>
    <title>数据结构100题</title>
    <link href="http://yustonerain.top/2025/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84100%E9%A2%98/"/>
    <id>http://yustonerain.top/2025/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84100%E9%A2%98/</id>
    <published>2025-06-03T00:02:57.000Z</published>
    <updated>2025-06-23T15:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">两数之和</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​ 给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h3><h4 id="具体思路："><a href="#具体思路：" class="headerlink" title="具体思路："></a>具体思路：</h4><p>首先使用unordered_map，在遍历原数组时，边查边找。</p><p>如果没找到，就把当前值的值和下标存入unordered_map，以便下次寻找可以搜素以前的键值对，看是否有满足情况（target-nums[i]）的key,若有，取出对应的value(iter-&gt;second)和当前的数组下标一起返回。当然最坏的情况，遍历完了，也没有符合情况的出现。可以直接返回空。</p><h4 id="std-unordered-map的核心特性："><a href="#std-unordered-map的核心特性：" class="headerlink" title="std::unordered_map的核心特性："></a>std::unordered_map的核心特性：</h4><p><strong>1. 基于哈希表实现（Hash Table）</strong></p><ul><li><code>unordered_map</code> 通过哈希函数（<code>std::hash</code>）将键（key）映射到一个桶（bucket）中，实现<strong>常数时间复杂度（O(1)）</strong>的查找、插入和删除操作（平均情况）。</li><li>哈希冲突通过链表（或更优化的结构）解决。</li></ul><hr><ol start="2"><li><strong>键唯一（Key is Unique）</strong></li></ol><ul><li>每个键（key）在 <code>unordered_map</code> 中必须是唯一的，如果插入相同键，会覆盖原有值或插入失败（取决于操作方式）。</li></ul><hr><p><strong>3. 无序（Unordered）</strong></p><ul><li>元素的存储顺序<strong>不保证稳定性或有序性</strong>，与插入顺序无关。</li><li>如果需要有序容器，应使用 <code>std::map</code>。</li></ul><hr><p><strong>4. 自动扩容</strong></p><ul><li><code>unordered_map</code> 会根据负载因子（load factor）自动扩展桶的数量，以保持操作效率。</li><li>用户可以手动调整负载因子和桶数量（如 <code>rehash()</code> 或 <code>reserve()</code> 函数）。</li></ul><hr><p><strong>5. 允许自定义哈希函数与相等比较器</strong></p><ul><li>支持用户为自定义类型指定哈希函数（通过模板参数 <code>Hash</code> 和 <code>KeyEqual</code>）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">std::unordered_map&lt;MyType, int, MyHash, MyEqual&gt;</span><br></pre></td></tr></table></figure><p> <strong>6. 快速访问接口</strong></p><ul><li><code>operator[]</code>：快速访问键对应的值，如果键不存在，则自动插入默认值。</li><li><code>find()</code>：返回一个迭代器，指向查找到的键值对，否则为 <code>end()</code>。</li></ul><hr><p><strong>7. 不支持排序算法</strong></p><ul><li>由于无序存储，标准排序算法（如 <code>sort</code>）不能直接应用于 <code>unordered_map</code>，但可以通过将其内容复制到 <code>vector&lt;pair&lt;&gt;&gt;</code> 后排序实现。</li></ul><hr><p><strong>8. 多线程下非线程安全</strong></p><ul><li>多线程环境下访问 <code>unordered_map</code> 必须加锁或使用线程安全容器。</li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iter =map.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter!=map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i,iter-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><ul><li>一次遍历 <code>nums</code> 数组，时间是 <code>O(n)</code>。</li><li>对于每个元素：<ul><li><code>map.find(...)</code> 查找操作的平均时间复杂度是 **O(1)**。</li><li><code>map.insert(...)</code> 插入操作的平均时间复杂度也是 **O(1)**。</li></ul></li></ul><p>因此，总体时间复杂度是：</p><p>**O(n)**（n 是数组中元素的数量）</p><h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>最多会向 <code>unordered_map</code> 中插入 <code>n</code> 个元素（每个 <code>nums[i]</code> 和其索引 <code>i</code>）。</li><li>所以空间复杂度与 <code>nums</code> 的大小成正比。</li></ul><p>**O(n)**（额外使用了哈希表来存储 n 个键值对）</p><h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="具体思路：-1"><a href="#具体思路：-1" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​首先使用std::unordered_map结构，当然不用再介绍了。这个题的意思是把那些排序之后相同的单词放在一个组合。</p><p>所以我们可以先使用unordered_map&lt;string,vector<string>&gt;存储键值对，键就是排序之后的单词，毕竟排序之后都一样。</string></p><p>键对应的值就是对应的单词（排序相同的单词），最后再遍历这个unordered_map，输出结果。</p><h4 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="comment">//做这道题首先对于字母异位词 排序之后是相同的，所以可以用一个哈希表，键存储排序后的结果，值为结果集</span></span><br><span class="line">        std::unordered_map&lt;string,vector&lt;string&gt;&gt; record;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string temp=strs[i];</span><br><span class="line">            <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">            record[temp].<span class="built_in">emplace_back</span>(strs[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=record.<span class="built_in">begin</span>();it!=record.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>假设：</p><ul><li><code>n</code> 是字符串数组 <code>strs</code> 的长度。</li><li><code>k</code> 是每个字符串的平均长度。</li></ul><ol><li>遍历 <code>strs</code> 中的每个字符串，共 <code>n</code> 次。</li><li>对每个字符串排序：<code>O(k log k)</code></li><li>哈希表插入&#x2F;查找键值对：<code>O(1)</code> 平均时间。</li></ol><p>所以总时间复杂度为：</p><p><strong>O(n * k log k)</strong></p><h4 id="空间复杂度：-1"><a href="#空间复杂度：-1" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>哈希表 <code>record</code> 最多存 <code>n</code> 个键，每个键存一个 <code>vector&lt;string&gt;</code>，整体字符串内容不变，只是重新组织。</li><li>排序后的中间变量 <code>temp</code> 的开销为 <code>O(k)</code>，共用一次。</li><li>最终结果 <code>ans</code> 存储所有原字符串内容。</li></ul><p>所以额外空间主要包括：</p><ol><li>哈希表键（排序后的字符串）：最多 <code>n</code> 个，每个长度为 <code>k</code>：<code>O(n * k)</code></li><li>哈希表值（字符串集合）：整体还是输入的字符串，只是重新组织，<strong>不算重复存储</strong></li><li>排序的临时变量（重复使用）：忽略不计</li></ol><p>因此总空间复杂度为：</p><p><strong>O(n * k)</strong></p><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,1,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-2"><a href="#具体思路：-2" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​首先将数组存入unordered_set中避免重复，为什么用unordered_set，因为找元素它是O(1)。</p><p>接下来遍历unordered_set，先判断当前元素有没有前一个连续的元素（例子：当前元素为5，查是否有4），有则跳过，没有则进行下一步，并且这个节点是作为开始节点。</p><p>然后先保存当前节点的值和连续序列的长度（这个时候为1），然后循环查找连续序列，最后获得连续序列的长度，再和历史最长连续序</p><p>列比较，更新历史最长连续序列。遍历完unordered_set，返回历史最长连续序列即可。</p><h4 id="std-unordered-set的特性："><a href="#std-unordered-set的特性：" class="headerlink" title="std::unordered_set的特性："></a>std::unordered_set的特性：</h4><p><code>std::unordered_set</code> 是 C++ 标准库中提供的 <strong>无序集合容器</strong>，它内部基于哈希表实现，主要用于快速判断一个元素是否存在，并确保元素唯一。下面是它的详细特性：</p><hr><p><strong>1. 元素唯一（Unique Elements）</strong></p><ul><li>它是一个 <strong>集合（set）</strong>，<strong>不允许重复元素</strong>。</li><li>插入相同元素将失败，已有的不会被替换。</li></ul><hr><p><strong>2. 基于哈希表（Hash Table）</strong></p><ul><li>内部使用哈希表存储元素。</li><li>插入、查找、删除的**平均时间复杂度是 O(1)**，非常高效。</li><li>如果发生大量哈希冲突，最坏情况会退化为 O(n)，但 STL 默认哈希函数表现良好，一般不会发生。</li></ul><hr><p><strong>3. 元素无序（Unordered）</strong></p><ul><li>和 <code>std::set</code>（基于红黑树，有序）不同，<code>unordered_set</code> 中的元素<strong>存储顺序不固定</strong>。</li><li>遍历时元素的顺序是哈希桶顺序，<strong>不可预测</strong>。</li></ul><hr><p><strong>4. 可自定义哈希函数（支持自定义类型）</strong></p><ul><li>可以为自定义类型提供哈希函数和等价比较函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_set&lt;MyType, MyHash, MyEqual&gt;</span><br></pre></td></tr></table></figure><hr><p><strong>5. 常用操作和函数</strong></p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>insert(val)</code></td><td>插入元素，若已存在则不插入</td></tr><tr><td><code>erase(val)</code></td><td>删除元素</td></tr><tr><td><code>find(val)</code></td><td>查找元素，返回迭代器</td></tr><tr><td><code>count(val)</code></td><td>判断元素是否存在（返回 0 或 1）</td></tr><tr><td><code>size()</code></td><td>元素个数</td></tr><tr><td><code>empty()</code></td><td>是否为空</td></tr><tr><td><code>clear()</code></td><td>清空所有元素</td></tr><tr><td><code>begin()</code>, <code>end()</code></td><td>返回迭代器（可用于范围遍历）</td></tr></tbody></table><hr><p><strong>5.与 <code>std::set</code> 的区别</strong></p><table><thead><tr><th>特性</th><th><code>std::set</code>（有序）</th><th align="center"><code>std::unordered_set</code>（无序）</th></tr></thead><tbody><tr><td>底层结构</td><td>红黑树（平衡 BST）</td><td align="center">哈希表</td></tr><tr><td>元素是否有序</td><td>是</td><td align="center">否</td></tr><tr><td>查找&#x2F;插入效率</td><td><code>O(log n)</code></td><td align="center">平均 <code>O(1)</code></td></tr><tr><td>内存使用</td><td>较少</td><td align="center">较多（需额外存哈希结构）</td></tr><tr><td>自定义排序</td><td>支持</td><td align="center">不支持</td></tr></tbody></table><h4 id="代码块：-1"><a href="#代码块：-1" class="headerlink" title="代码块："></a>代码块：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; num_set;</span><br><span class="line">        <span class="comment">//使用unordered_set存储nums的所有值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> &amp;num:nums)&#123;</span><br><span class="line">            num_set.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> longSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> &amp;num:num_set)&#123;</span><br><span class="line">            <span class="comment">//上述遍历用nums和num_set有什么区别，在leetcode一个能过一个不能过</span></span><br><span class="line">            <span class="comment">//以遍历的每个元素为起点，满足才进行下一步操作</span></span><br><span class="line">            <span class="keyword">if</span>(!num_set.<span class="built_in">count</span>(num<span class="number">-1</span>))&#123;</span><br><span class="line">                <span class="comment">//满足条件后，存储当前节点的信息</span></span><br><span class="line">                <span class="type">int</span> currentNum=num;</span><br><span class="line">                <span class="type">int</span> currentSum=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//寻找该节点的最长连续序列</span></span><br><span class="line">                <span class="keyword">while</span>(num_set.<span class="built_in">count</span>(currentNum<span class="number">+1</span>))&#123;</span><br><span class="line">                    currentNum=currentNum<span class="number">+1</span>;</span><br><span class="line">                    currentSum+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后与longSum比较，更新历史最长连续序列</span></span><br><span class="line">                longSum=<span class="built_in">max</span>(currentSum,longSum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="编写代码产生的问题："><a href="#编写代码产生的问题：" class="headerlink" title="编写代码产生的问题："></a>编写代码产生的问题：</h4><p>上述遍历用nums和num_set有什么区别，在leetcode一个能过一个不能过</p><p><strong>遍历 <code>num_set</code>：</strong></p><ul><li>每个元素最多只被作为“起点”处理一次。</li><li>例如：对于序列 <code>[100, 101, 102, 103]</code>，只有 <code>100</code> 会进入 while 循环处理。</li><li>其他如 <code>101</code>、<code>102</code> 在 <code>if (!num_set.count(num - 1))</code> 时会被跳过（因为 <code>100</code> 已经处理了它们）。</li><li>所以是 <strong>O(n)</strong> 时间复杂度。</li></ul><p><strong>遍历 <code>nums</code>：</strong></p><ul><li><code>nums</code> 可能包含重复值，也可能无序。</li><li>比如你在 <code>nums</code> 中遇到 <code>102</code>，它不是起点，但你仍会试图查找连续数字，造成<strong>重复计算</strong>。</li><li>重复调用 <code>count()</code>，浪费性能，导致 <strong>超时</strong> 或 <strong>错误结果</strong>（重复统计）。</li></ul><h4 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>设输入数组 <code>nums</code> 的长度为 <code>n</code>。</p><ol><li><code>unordered_set</code> 插入 <code>n</code> 个元素：**O(n)**（平均时间，插入是 O(1)）。</li><li>第二个循环遍历 <code>num_set</code> 中的每个元素，<strong>每个连续序列只处理一次</strong>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!num_set.count(num - 1))</span><br></pre></td></tr></table></figure><ul><li>这个判断确保每个序列的起点只会被处理一次。</li><li>例如序列 <code>[100, 101, 102, 103]</code> 只会从 <code>100</code> 开始处理一次，不会在遍历到 <code>101</code> 时重复处理。</li></ul><p>因此：</p><p>**总时间复杂度：O(n)**（哈希表操作均为 O(1) 平均时间）</p><h4 id="空间复杂度：-2"><a href="#空间复杂度：-2" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>使用了一个 <code>unordered_set</code> 存储 <code>n</code> 个整数，占用 O(n) 的空间。</li><li>其他变量如 <code>currentNum</code>, <code>currentSum</code> 等为常数空间。</li></ul><p>因此：</p><p><strong>总空间复杂度：O(n)</strong></p><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">移动零</a></h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-3"><a href="#具体思路：-3" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​我们可以采用双指针的方法，先left,right同时指向起始点，right到最后位置结束。当right找到非零节点，与left进行值交换，left只有交换结束才left++;这样最后非零节点都在前面，0都在末尾。</p><h4 id="代码块：-2"><a href="#代码块：-2" class="headerlink" title="代码块："></a>代码块：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>(),left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[left],nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><ul><li><code>right</code> 从 <code>0</code> 遍历到 <code>n-1</code>，每个元素访问一次。</li><li>最多发生 <code>n</code> 次 <code>swap</code> 操作（每个非零元素最多被交换一次）。</li><li>所以：</li></ul><p><strong>总时间复杂度：O(n)</strong></p><h4 id="空间复杂度：-3"><a href="#空间复杂度：-3" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>只使用了常量级别的辅助变量 <code>left</code> 和 <code>right</code>。</li><li>所有操作都在原数组上进行，<strong>原地修改</strong>，没有开辟额外数组。</li></ul><p><strong>总空间复杂度：O(1)</strong></p><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a></h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-4"><a href="#具体思路：-4" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​我们采用双指针的方式求解。这个题目的是求解柱子之间的最大面积。我们可以采用将两个指针放在两端，如果左边的柱子高度大于或等于右边的柱子高度，我们先算出容器对应的面积（高度以低柱子为准）。算出后更新历史最大面积。执行完，将右边的柱子向左移动。同时，还有一种情况，左边的柱子高度小于右边的柱子高度，先算出容器对应的面积（高度以低柱子为准）。算出后更新历史最大面积。执行完，将左边的柱子向右移动。直到当前的左柱子和右柱子重合。</p><h4 id="代码块：-3"><a href="#代码块：-3" class="headerlink" title="代码块："></a>代码块：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//采用双指针的方式求解</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left]&gt;=height[right])&#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,(right-left)*height[right]);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,(right-left)*height[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度：-4"><a href="#时间复杂度：-4" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>时间复杂度：<code>O(n)</code></p><ul><li>解释：使用的是<strong>双指针</strong>方法，从两端向中间遍历整个数组，每一次迭代都会<strong>移动左指针或右指针之一</strong>，因此总共最多移动 <code>n-1</code> 次。</li><li>所以时间复杂度是 **线性的 O(n)**，其中 <code>n</code> 是 <code>height</code> 数组的长度。</li></ul><h4 id="空间复杂度：-4"><a href="#空间复杂度：-4" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(1)</code></p><ul><li>解释：只使用了常数个额外变量（如 <code>ans</code>, <code>left</code>, <code>right</code>, <code>h</code>, <code>w</code>），不依赖于输入数据的大小。</li><li>因此空间复杂度是 **常数级 O(1)**。</li></ul><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode.cn/problems/3sum/">三数之和</a></h2><h3 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。 </span><br></pre></td></tr></table></figure><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-5"><a href="#具体思路：-5" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​这题的目标是在在整数数组中，找到所有三个数满足和为零，最后结果不可以重复。这个题我们可以先定下一个值，剩下两个值用双指针法遍历，找到符合结果的。还有一些细节，还要考虑不能重复的问题，对于这个问题，我们可以先排序（升序）这个数组，从小到大定第一个值，首先如果这第一个值大于0，这个可以结束了，这个数组就不会存在符合条件的三元组。当然如果当前元素与上一个元素相同，也跳过，这样执行，首先我想的是定第一个元素，当当前元素和下一个元素相同直接跳过，后来发现，[-1,-1,2]这种情况没有考虑。当然那你为甚么还是要写当前元素与上一个元素相同，也跳过，我完全可以不管嘛，那不行，我的思路是当第一个元素是-1时，这一次直接找出所有符合第一个元素是-1的情况，要不然会十分混乱，所以我会说如果当前元素与上一个元素相同，也跳过。因为上一个元素已经找完了第一个元素为-1的三元组了，当避免找完-1还会再出现，我们用了排序。这样第一个元素的逻辑就结束了，接下来找剩下两个，用双指针，左指针指向当前元素的下一个元素，右指针指向末尾元素。我们是要找到所有符合情况，当三元组的值大于0，将右指针左移。当三元组的值小于0，将左指针右移。当三元组的值等于0，将三元组的值加入结果集。接下来再判断找到的左元素是否与后面的元素重复（因为是排序的，相同的元素就在身边）。跳过这些元素，找到的右元素是否与后面的元素重复（因为是排序的，相同的元素就在身边）。跳过这些元素。只要左指针和右指针没有重合，就一直找，找完符合情况的三元组。</p><h4 id="代码块：-4"><a href="#代码块：-4" class="headerlink" title="代码块："></a>代码块：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="comment">//先升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">//遍历排序后的数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//先定第一个元素</span></span><br><span class="line">            <span class="comment">//第一个元素大于0,因为是升序排序，后面都大于零，那没有满足条件的结果了</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果上一个元素相同，跳过当前，用下一个</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//采用双指针定剩下两个</span></span><br><span class="line">            <span class="type">int</span> left=i<span class="number">+1</span>;</span><br><span class="line">            <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]==<span class="number">0</span>)&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    <span class="comment">//下面判断是否有相同的，避免重复</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left<span class="number">+1</span>])left++;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度：-5"><a href="#时间复杂度：-5" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p> 时间复杂度：<code>O(n^2)</code></p><p>详细分析：</p><ol><li><p>外层循环遍历数组中的每个数作为固定值 <code>nums[i]</code>，这部分是 <code>O(n)</code>。</p></li><li><p>内层使用双指针 <code>left</code> 和 <code>right</code> 来查找另外两个数，最坏情况下每次都需要遍历一次剩余数组，即 <code>O(n)</code>。</p></li><li><p>所以总的时间复杂度是：</p><p>O(n^2)</p></li></ol><p>去重操作的影响：</p><ul><li>去重操作使用的是 <code>while(left &lt; right &amp;&amp; nums[left] == nums[left + 1])</code> 这类逻辑，在最坏情况下最多也只是跳过相同元素，不改变主导复杂度。</li></ul><h4 id="空间复杂度：-5"><a href="#空间复杂度：-5" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(1)</code>（不计输出）</p><p>解释：</p><ul><li>如果<strong>不考虑返回结果 <code>ans</code> 所占用的空间</strong>（即题目允许将返回值空间复杂度忽略），则使用的额外空间为：<ul><li>排序使用的可能是原地排序（如 <code>std::sort</code>），**空间复杂度为常数级 <code>O(1)</code>**。</li><li>其他仅使用了一些指针和变量，都是常数级空间。</li></ul></li><li>如果 <strong>将返回结果的空间也算入</strong>，最坏情况是 <code>O(k)</code>，其中 <code>k</code> 是满足条件的三元组个数。</li></ul><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></h2><h3 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-6"><a href="#具体思路：-6" class="headerlink" title="具体思路："></a>具体思路：</h4><p>这里采用的是动态规划解法，还有其他方法。动态规划解法，需要构造两个数组分别储存各个节点的左边最大高度和右边最大高度，便于计算当前节点所积水高度。问题在于左边和右边最大高度该如何获取。最左边的左边最大高度就是它自身，最右边的右边最大高度就是它自身，以这两个边界条件，左边最大高度就是当前节点的左边节点的左边最大高度和当前节点的高度的最大值，右边最大高度也是一样。求解出放入之前的两个数组中。已知这两个数组，可以遍历这两个数组，把当前节点的积水量算出，再累加一起，就是所求的雨水量。</p><h4 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这题采用动态规划</span></span><br><span class="line">        <span class="type">int</span> n=height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(n)</span></span>;</span><br><span class="line">        leftMax[<span class="number">0</span>]=height[<span class="number">0</span>];</span><br><span class="line">        rightMax[n<span class="number">-1</span>]=height[n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            leftMax[i]=<span class="built_in">max</span>(leftMax[i<span class="number">-1</span>],height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            rightMax[i]=<span class="built_in">max</span>(rightMax[i<span class="number">+1</span>],height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans+=<span class="built_in">min</span>(leftMax[i],rightMax[i])-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度：-6"><a href="#时间复杂度：-6" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>时间复杂度：<code>O(n)</code></p><ul><li><p>遍历了三次数组：</p><ol><li>构造 <code>leftMax</code>：<code>O(n)</code></li><li>构造 <code>rightMax</code>：<code>O(n)</code></li><li>遍历一次计算总雨水量：<code>O(n)</code></li></ol></li><li><p>所以总时间复杂度是：</p><p>O(n)</p></li></ul><h4 id="空间复杂度：-6"><a href="#空间复杂度：-6" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(n)</code></p><ul><li>使用了两个辅助数组：<ul><li><code>leftMax</code>：大小为 <code>n</code></li><li><code>rightMax</code>：大小为 <code>n</code></li></ul></li><li>所以额外空间是 <code>2n</code>，即 <strong><code>O(n)</code> 空间复杂度</strong>。</li></ul><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><h3 id="题目描述：-6"><a href="#题目描述：-6" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-7"><a href="#具体思路：-7" class="headerlink" title="具体思路："></a>具体思路：</h4><p>我们使用滑动窗口和哈希表实现这个题目。哈希表存储枚举值的下标，初始值为-1，j值在没有重合的情况下，会在每次循环+1，但是如果遇到重合，j值会跑到对应的下标位置之后的位置（下标位置存储在哈希表中）。只要有重合就调整窗口。</p><h4 id="代码块：-5"><a href="#代码块：-5" class="headerlink" title="代码块："></a>代码块：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//滑动窗口和哈希表</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(<span class="number">128</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//j为滑动窗口的起始节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            j=<span class="built_in">max</span>(j,pos[s[i]]<span class="number">+1</span>);</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,i-j<span class="number">+1</span>);</span><br><span class="line">            pos[s[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度：-7"><a href="#时间复杂度：-7" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>时间复杂度：<code>O(n)</code></p><ul><li>其中 <code>n</code> 是字符串 <code>s</code> 的长度。</li><li>每个字符最多访问两次（一次作为右指针扩展窗口，一次作为左指针缩小窗口）。</li><li>所以整体是线性时间复杂度 <code>O(n)</code>。</li></ul><h4 id="空间复杂度：-7"><a href="#空间复杂度：-7" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(1)</code></p><ul><li>使用了一个 <code>pos</code> 数组来记录 ASCII 字符上次出现的位置，长度是固定的 128（ASCII 字符集）。</li><li>即使改成 <code>256</code>（扩展 ASCII）或 <code>100,000</code>（Unicode 范围），只要是<strong>定长的字符集</strong>，空间复杂度都是 <strong><code>O(1)</code> 常数级</strong>。</li><li>如果字符集不固定，比如用 <code>unordered_map&lt;char, int&gt;</code>，那空间复杂度是 <code>O(k)</code>，其中 <code>k</code> 是字符集大小。</li></ul><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h2><h3 id="题目描述：-7"><a href="#题目描述：-7" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure><h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-8"><a href="#具体思路：-8" class="headerlink" title="具体思路："></a>具体思路：</h4><p>这道题的整体思路是让我找到对应字符串的所有异位词在一个陌生的字符串里。这里要解决两个问题，首先是异位词问题，找异位词可以通过枚举法，总共26个字母，我们通过数组存储使用字母的个数，最后对比，如果数组相等，就说明是异位词。还有一个问题：在陌生字符串找到所有的异位词，并且返回索引，找异位词是一个范围问题，所以我要使用流动窗口，大小就是对应字符串的大小。在陌生字符串扫描。最后返回结果。</p><h4 id="代码块：-6"><a href="#代码块：-6" class="headerlink" title="代码块："></a>代码块：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先记录两字符串的长度</span></span><br><span class="line">        <span class="type">int</span> sLen=s.<span class="built_in">size</span>(),pLen=p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//如果字符串s的长度还不比p字符串长</span></span><br><span class="line">        <span class="keyword">if</span>(sLen&lt;pLen)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">//记录s字符串和p字符串的字母对应的个数，枚举法</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sletter</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pletter</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="comment">//先试试索引为0的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pLen;i++)&#123;</span><br><span class="line">            ++sletter[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++pletter[p[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果符合，说明索引为0符合情况</span></span><br><span class="line">        <span class="keyword">if</span>(sletter==pletter)&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//之后按照索引为1往后遍历，采取流动窗口,把前一次的流动窗口的第一个去掉，再往后补一个，形成新的流动窗口.</span></span><br><span class="line">        <span class="comment">//注意这里是按流动窗口为整体，上面的循环是为了形成流动窗口。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sLen-pLen;i++)&#123;</span><br><span class="line">            --sletter[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++sletter[s[i+pLen]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sletter==pletter)&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(i<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度：-8"><a href="#时间复杂度：-8" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><ul><li>初始化部分：O(p)</li><li>滑动窗口：O(n)</li></ul><p>由于通常 <code>p</code> 比 <code>n</code> 小，所以总时间复杂度是：O(n)</p><h4 id="空间复杂度：-8"><a href="#空间复杂度：-8" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>使用了两个长度为 26 的数组：<code>sletter</code>, <code>pletter</code>；</li><li>还使用了一个结果数组 <code>ans</code>，最坏情况下长度也是 O(n)；</li></ul><p>因此：</p><p>空间复杂度是 O(1) + O(k)，其中 k 是结果中异位词的数量，通常最多为 O(n)。</p><h2 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h2><h3 id="题目描述：-8"><a href="#题目描述：-8" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-9"><a href="#具体思路：-9" class="headerlink" title="具体思路："></a>具体思路：</h4><p>这里采取两个方法，第一种方法就是枚举法，暴力轮询。（为什莫要两种，因为我第一种leetcode超时了）。</p><p>方法二：首先通过前缀和这个点，定义 pre[i] 为 [0..i] 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：pre[i]&#x3D;pre[i−1]+nums[i]<br>那么[j..i] 这个子数组和为 k 这个条件我们可以转化为pre[i]−pre[j−1]&#x3D;&#x3D;k<br>简单移项可得符合条件的下标 j 需要满足pre[j−1]&#x3D;&#x3D;pre[i]−k<br>所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。建立以上条件，我们的问题就简化为寻找有多少个符合条件的pre[j]即可，我们建立哈希表，键是前缀和，值是前缀和重复的个数。在遍历的过程中，pre存储当前的前缀和，先不放进哈希表中，先在哈希表中查找是否有键pre-k,有的话，就取出对应的值加到count里，不管找没找到，都要将当前的前缀和存到哈希表中。这代码的逻辑是基于前缀和得出的只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。</p><h4 id="代码块：-7"><a href="#代码块：-7" class="headerlink" title="代码块："></a>代码块：</h4><p>方法一：枚举法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这题我们采用枚举法</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//返回的结果值</span></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start=<span class="number">0</span>;start&lt;n;++start)&#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> end=start;end&lt;n;++end)&#123;</span><br><span class="line">                sum+=nums[end];</span><br><span class="line">                <span class="keyword">if</span>(sum==k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：前缀和+哈希表优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前缀和+哈希表优化</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//初始前缀和的个数为1</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>,pre=<span class="number">0</span>;<span class="comment">//count是返回结果的，pre是前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;temp:nums)&#123;</span><br><span class="line">            pre+=temp;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(pre-k)!=mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                count+=mp[pre-k];</span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度：-9"><a href="#时间复杂度：-9" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>方法一：</p><p>时间复杂度：<strong>O(n²)</strong></p><p>方法二：</p><p>O(n) 时间</p><h4 id="空间复杂度：-9"><a href="#空间复杂度：-9" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>方法一：</p><p>空间复杂度：<strong>O(1)</strong></p><p>方法二：</p><p>**O(n)**（最坏情况下所有前缀和都不相同，哈希表大小为 n）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot;&gt;两数之和&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;</summary>
      
    
    
    
    <category term="数据结构100题" scheme="http://yustonerain.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84100%E9%A2%98/"/>
    
    
    <category term="data structure" scheme="http://yustonerain.top/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>c++实现集群聊天服务器</title>
    <link href="http://yustonerain.top/2025/06/02/c-%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yustonerain.top/2025/06/02/c-%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2025-06-02T15:57:52.000Z</published>
    <updated>2025-06-23T15:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="json学习"><a href="#json学习" class="headerlink" title="json学习"></a>json学习</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> json=nlohmann::json;</span><br></pre></td></tr></table></figure><p>使用json,要包含json的头文件 ，方便使用可以重命名nlohmann::json为json。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//json序列化示例1</span></span><br><span class="line"><span class="function">std::string <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msg_type&quot;</span>]=<span class="number">2</span>;</span><br><span class="line">    js[<span class="string">&quot;from&quot;</span>]=<span class="string">&quot;zhang san&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;to&quot;</span>] = <span class="string">&quot;li si&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>]=<span class="string">&quot;hello,what are you doing now&quot;</span>;</span><br><span class="line">    std::string sendBuf=js.<span class="built_in">dump</span>();</span><br><span class="line">    std::cout&lt;&lt;sendBuf.<span class="built_in">c_str</span>()&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> sendBuf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js使用很像键值对。js.dump()是 nlohmann::json库中用于将 JSON 对象序列化（转为字符串）的方法，它会把一个 json类型的变量转换成 JSON 格式的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::string recvBuf= <span class="built_in">func1</span>();</span><br><span class="line">   <span class="comment">//数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）</span></span><br><span class="line">   json jsbuf=json::<span class="built_in">parse</span>(recvBuf);</span><br><span class="line">   std::cout&lt;&lt;jsbuf[<span class="string">&quot;msg_type&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">   std::cout&lt;&lt;jsbuf[<span class="string">&quot;from&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">   std::cout&lt;&lt;jsbuf[<span class="string">&quot;to&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">   std::cout&lt;&lt;jsbuf[<span class="string">&quot;msg&quot;</span>]&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>这是main函数中执行。<code>json::parse()</code> 是 <code>nlohmann::json</code> 库中用来将 <strong>JSON 字符串 → JSON 对象</strong> 的函数，也就是实现<strong>反序列化</strong>。</p><p>转化为json对象后使用对应的键可以把对应的值取出来。结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;from&quot;:&quot;zhang san&quot;,&quot;msg&quot;:&quot;hello,what are you doing now&quot;,&quot;msg_type&quot;:2,&quot;to&quot;:&quot;li si&quot;&#125;</span><br><span class="line">2</span><br><span class="line">&quot;zhang san&quot;</span><br><span class="line">&quot;li si&quot;</span><br><span class="line">&quot;hello,what are you doing now&quot;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//json序列化示例2</span></span><br><span class="line"><span class="function">std::string <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    <span class="comment">//添加数组</span></span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//添加key-value</span></span><br><span class="line">    js[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;zhang san&quot;</span>;</span><br><span class="line">    <span class="comment">//添加对象</span></span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>][<span class="string">&quot;zhang san&quot;</span>]= <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>][<span class="string">&quot;liu shuo&quot;</span>] =<span class="string">&quot;hello china&quot;</span>;</span><br><span class="line">    <span class="comment">//上面等同下面这句一次性添加数组对象</span></span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>]=&#123;&#123;<span class="string">&quot;zhang san&quot;</span>,<span class="string">&quot;hello world&quot;</span>&#125;,&#123;<span class="string">&quot;liu shuo&quot;</span>,<span class="string">&quot;hello china&quot;</span>&#125;&#125;;</span><br><span class="line">    std::cout&lt;&lt;js&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> js.<span class="built_in">dump</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json还可以放数组，还可以嵌套json语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::string recvBuf= <span class="built_in">func2</span>();</span><br><span class="line">    <span class="comment">//数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）</span></span><br><span class="line">    json jsbuf=json::<span class="built_in">parse</span>(recvBuf);</span><br><span class="line">    std::cout&lt;&lt;jsbuf[<span class="string">&quot;id&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">auto</span> arr=jsbuf[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">    std::cout&lt;&lt;arr[<span class="number">2</span>]&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">auto</span> msgjs=jsbuf[<span class="string">&quot;msg&quot;</span>];</span><br><span class="line">    std::cout&lt;&lt;msgjs[<span class="string">&quot;zhang san&quot;</span>]&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;msgjs[<span class="string">&quot;liu shuo&quot;</span>]&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>“id”存储的是一个数组，取出来还可以作为数组使用。“msg”存储的值还可以是json语句，并且可以进入再取里面的值。</p><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:[1,2,3,4,5],&quot;msg&quot;:&#123;&quot;liu shuo&quot;:&quot;hello china&quot;,&quot;zhang san&quot;:&quot;hello world&quot;&#125;,&quot;name&quot;:&quot;zhang san&quot;&#125;</span><br><span class="line">[1,2,3,4,5]</span><br><span class="line">3</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">&quot;hello china&quot;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//json序列化示例3</span></span><br><span class="line"><span class="function">std::string <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    <span class="comment">//直接序列化一个vector容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    js[<span class="string">&quot;list&quot;</span>]=vec;</span><br><span class="line">    <span class="comment">//直接序列化一个map容器</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>,std::string&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="string">&quot;黄山&quot;</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">2</span>,<span class="string">&quot;华山&quot;</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">3</span>,<span class="string">&quot;泰山&quot;</span>&#125;);</span><br><span class="line">    js[<span class="string">&quot;path&quot;</span>] =m;</span><br><span class="line">    std::string sendBuf =js.<span class="built_in">dump</span>();<span class="comment">//json数据对象-&gt;序列化json字符串</span></span><br><span class="line">    std::cout&lt;&lt;sendBuf&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> sendBuf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以序列化容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::string recvBuf= <span class="built_in">func3</span>();</span><br><span class="line">    <span class="comment">//数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）</span></span><br><span class="line">    json jsbuf=json::<span class="built_in">parse</span>(recvBuf);</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec =jsbuf[<span class="string">&quot;list&quot;</span>];<span class="comment">//js对象里面的数组类型，直接放入vector容器当中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;v:vec)&#123;</span><br><span class="line">        std::cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    std::map&lt;<span class="type">int</span>,std::string&gt; mymap=jsbuf[<span class="string">&quot;path&quot;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;p:mymap)&#123;</span><br><span class="line">        std::cout&lt;&lt;p.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p.second&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;list&quot;:[1,2,5],&quot;path&quot;:[[1,&quot;黄山&quot;],[2,&quot;华山&quot;],[3,&quot;泰山&quot;]]&#125;</span><br><span class="line">1 2 5 </span><br><span class="line">1 黄山</span><br><span class="line">2 华山</span><br><span class="line">3 泰山</span><br></pre></td></tr></table></figure><h2 id="muduo网络库学习"><a href="#muduo网络库学习" class="headerlink" title="muduo网络库学习"></a>muduo网络库学习</h2><p><strong>muduo</strong> 是一个现代 C++ 的非阻塞 I&#x2F;O 网络库，采用 <strong>Reactor 模式 + 多线程 + epoll + 定时器 + 高效缓冲区 + 智能指针设计</strong>，在性能和工程性方面都表现非常优秀。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">muduo网络库给用户提供了两个主要的类</span></span><br><span class="line"><span class="comment">TcpServer :用于编写服务器程序的</span></span><br><span class="line"><span class="comment">TcpClient :用于编写客户端程序的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">epoll+线程池</span></span><br><span class="line"><span class="comment">好处：能够把网络I/O的代码和业务代码区分开了</span></span><br><span class="line"><span class="comment">业务代码 :用户的连接和断开 用户的可读写事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholders;</span><br><span class="line"><span class="comment">/*基于muduo网络库开发服务器程序</span></span><br><span class="line"><span class="comment">1.组合TcpServer对象</span></span><br><span class="line"><span class="comment">2.创建EventLoop事件循环对象的指针</span></span><br><span class="line"><span class="comment">3.明确TcpServer构造函数需要什么参数，输出ChatServer的构造函数</span></span><br><span class="line"><span class="comment">4.在当前服务器类的构造函数当中，注册处理连接的回调函数和处理读写事件的回调函数</span></span><br><span class="line"><span class="comment">5.设置合适的服务端线程数量，muduo库会自己分配I/O线程和worker线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatServer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ChatServer</span>(EventLoop* loop,<span class="comment">//事件循环</span></span><br><span class="line">            <span class="type">const</span> InetAddress&amp; listenAddr,<span class="comment">//ip+port</span></span><br><span class="line">            <span class="type">const</span> string&amp; nameArg)<span class="comment">//服务器的名字</span></span><br><span class="line">        :_server(loop,listenAddr,nameArg),_loop(loop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//给服务器注册用户连接的创建和断开回调</span></span><br><span class="line">            _server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;ChatServer::onConnection,<span class="keyword">this</span>,_1));            </span><br><span class="line">            <span class="comment">//给服务器注册用户读写事件回调</span></span><br><span class="line">            _server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;ChatServer::onMessage,<span class="keyword">this</span>,_1,_2,_3));</span><br><span class="line">            <span class="comment">//设置服务器端的线程数量 1个I/o线程 3个worker线程</span></span><br><span class="line">            _server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启事件循环</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            _server.<span class="built_in">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//专门处理用户的连接创建和断开</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp;conn)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">            cout&lt;&lt;conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>()&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;</span><br><span class="line">            conn-&gt;<span class="built_in">localAddress</span>().<span class="built_in">toIpPort</span>()&lt;&lt;<span class="string">&quot;state:online&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//对方关闭连接或断开</span></span><br><span class="line">            cout&lt;&lt;conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>()&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;</span><br><span class="line">            conn-&gt;<span class="built_in">localAddress</span>().<span class="built_in">toIpPort</span>()&lt;&lt;<span class="string">&quot;state:offline&quot;</span>&lt;&lt;endl;</span><br><span class="line">            conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">//close(fd)//关闭连接</span></span><br><span class="line">            <span class="comment">// _loop-&gt;quit();通常用于程序结束或手动控制关闭 Muduo</span></span><br><span class="line">            <span class="comment">//loop-&gt;quit() 使loop.loop()不再阻塞。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//专门处理用户的读写事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp;conn,<span class="comment">//连接</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            Buffer* buffer,<span class="comment">//缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            Timestamp time)</span><span class="comment">//接受数据的时间信息</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//是一个指向 muduo::net::Buffer 对象的指针，用于暂存客户端发送的数据。</span></span><br><span class="line"><span class="comment">//Muduo 采用 非阻塞、事件驱动的方式，当客户端发送数据时，数据先被读入 Buffer 中，之后由用户注册的回调函数（例如 onMessage）来处理。</span></span><br><span class="line">        <span class="comment">//retrieveAllAsString()把缓冲区中的所有可读数据提取为一个 std::string，然后清空缓冲区。</span></span><br><span class="line">        string buf=buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;recv data:&quot;</span> &lt;&lt;buf&lt;&lt;<span class="string">&quot;time:&quot;</span>&lt;&lt;time.<span class="built_in">toString</span>()&lt;&lt;endl;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(buf);<span class="comment">//原封不动发回去                        </span></span><br><span class="line">    &#125;</span><br><span class="line">    muduo::net::TcpServer _server;</span><br><span class="line">    muduo::net::EventLoop *_loop;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EventLoop loop;<span class="comment">//epoll</span></span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6000</span>)</span></span>;</span><br><span class="line">    <span class="function">ChatServer <span class="title">server</span><span class="params">(&amp;loop,addr,<span class="string">&quot;ChatServer&quot;</span>)</span></span>;</span><br><span class="line">    server.<span class="built_in">start</span>();<span class="comment">//listenfd epoll_ctl-&gt;epoll</span></span><br><span class="line">    loop.<span class="built_in">loop</span>(); <span class="comment">//epoll wait以阻塞方式等待新用户连接，已连接用户的读写事件等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将bind函数讲清楚，</p><p>基本格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::bind(&amp;类名::成员函数, 对象指针, 占位符参数...)</span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::bind(&amp;ChatServer::onConnection, this, _1)</span><br></pre></td></tr></table></figure><p>意思是：</p><p>把当前对象（<code>this</code>）的 <code>onConnection</code> 成员函数绑定起来，形成一个可调用对象，并接受一个参数 <code>_1</code>。</p><p>分解解释</p><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><code>&amp;ChatServer::onConnection</code></td><td>指向 <code>ChatServer</code> 类的成员函数 <code>onConnection</code> 的指针</td></tr><tr><td><code>this</code></td><td>当前对象的指针，告诉 <code>bind</code> 这个函数是哪个对象的方法（即调用 this-&gt;onConnection）</td></tr><tr><td><code>_1</code></td><td>占位符，代表回调传入的第一个参数，实际调用时会被替换</td></tr><tr><td></td><td></td></tr></tbody></table><p>最终生成一个 <code>std::function&lt;void(const TcpConnectionPtr&amp;)&gt;</code> 类型的函数对象。</p><h2 id="CMakeList-txt学习"><a href="#CMakeList-txt学习" class="headerlink" title="CMakeList.txt学习"></a>CMakeList.txt学习</h2><p>主CMakeList.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"></span><br><span class="line">project(chat)</span><br><span class="line"></span><br><span class="line">#配置编译选项</span><br><span class="line">set(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)</span><br><span class="line">#配置最终的可执行文件输出的路径</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line">#配置头文件搜索路径</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include/server)</span><br><span class="line"></span><br><span class="line">#加载子目录</span><br><span class="line">add_subdirectory(src)</span><br></pre></td></tr></table></figure><p>src文件夹下的CMakeList.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(server)</span><br></pre></td></tr></table></figure><p>src文件夹下的server文件夹下的CMakeList.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#定义了SRC_LIST变量，包含了当前目录下的所有源文件</span><br><span class="line">aux_source_directory(. SRC_LIST) #获取当前目录下所有源文件</span><br><span class="line">#指定生成可执行文件</span><br><span class="line">add_executable(ChatServer $&#123;SRC_LIST&#125;)</span><br><span class="line">#指定可执行文件需要链接的库</span><br><span class="line">target_link_libraries(ChatServer muduo_net muduo_base pthread) #链接muduo库和pthread库</span><br></pre></td></tr></table></figure><h3 id="项目常见的cmake指令使用步骤"><a href="#项目常见的cmake指令使用步骤" class="headerlink" title="项目常见的cmake指令使用步骤"></a>项目常见的cmake指令使用步骤</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make         # 如果你使用的是 Unix/Linux/macOS，或者是 MinGW</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>mkdir build</code>：创建构建目录（推荐 out-of-source build）</li><li><code>cd build</code>：进入构建目录</li><li><code>cmake ..</code>：执行 CMake，读取上一级目录的 <code>CMakeLists.txt</code>，生成构建系统（默认是 Makefile）</li><li><code>make</code>：使用生成的 Makefile 编译项目</li></ul><h2 id="集群聊天服务器"><a href="#集群聊天服务器" class="headerlink" title="集群聊天服务器"></a>集群聊天服务器</h2><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p><img src="/2025/06/02/c-%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/1.png" alt="1"></p><p>bin文件夹编译完成后的 <code>.exe</code>（Windows）或无扩展的可执行文件。</p><p>build文件夹通常用于存放 <strong>构建过程中产生的所有中间文件</strong>，它是整个编译流程的“临时工作区”。</p><p>include文件夹存放头文件（Header Files），src文件夹是 C++ 项目中最常见也最核心的目录之一，用于存放 <strong>源代码实现文件（source files）</strong>，主要是 <code>.cpp</code> 文件（也包括 <code>.c</code>, <code>.cc</code>, <code>.cxx</code> 等）。</p><p>test文件夹在 C++ 项目中用于存放<strong>测试代码</strong>，主要用于验证项目功能是否正确，确保每个模块在修改后仍然可以正常工作。</p><p>thirdparty文件夹在 C++ 项目中用于存放<strong>第三方依赖库的源码或接口文件</strong>。在这里存储了json.hpp文件。</p><h3 id="CMakeLists-txt文件存放和使用"><a href="#CMakeLists-txt文件存放和使用" class="headerlink" title="CMakeLists.txt文件存放和使用"></a>CMakeLists.txt文件存放和使用</h3><p>CMakeLists.txt文件放在了主目录，src文件夹里，src&#x2F;server文件夹里，接下来分别说明对应文件夹中CMakeLists.txt的作用。</p><p>主目录文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line"></span><br><span class="line">project(chat)</span><br><span class="line"></span><br><span class="line">#配置编译选项</span><br><span class="line">set(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)</span><br><span class="line">#配置最终的可执行文件输出的路径</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line">#配置头文件搜索路径</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include/server)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include/server/db)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/thirdparty)</span><br><span class="line"></span><br><span class="line">#加载子目录</span><br><span class="line">add_subdirectory(src)</span><br></pre></td></tr></table></figure><p>主目录 <code>CMakeLists.txt</code> 的作用概括：</p><ol><li><strong>设置项目基本信息</strong>：指定 CMake 最低版本和项目名称。</li><li><strong>配置全局编译选项</strong>：例如添加调试信息（<code>-g</code>）以便调试。</li><li><strong>设置可执行文件输出路径</strong>：统一将程序输出到 <code>bin/</code> 目录。</li><li><strong>配置头文件搜索路径</strong>：包括项目头文件目录和第三方库目录，便于代码引用。</li><li><strong>组织子目录构建</strong>：通过 <code>add_subdirectory(src)</code> 加载 <code>src</code> 子目录，交由其继续组织源码编译。</li></ol><p>src文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(server)</span><br></pre></td></tr></table></figure><p><code>add_subdirectory(server)</code> 把 <code>server</code> 子目录纳入构建流程，交由其内部的 <code>CMakeLists.txt</code> 具体定义编译规则，是模块化项目管理的关键步骤。</p><p>src&#x2F;server文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#定义了SRC_LIST变量，包含了当前目录下的所有源文件</span><br><span class="line">aux_source_directory(. SRC_LIST) #获取当前目录下所有源文件</span><br><span class="line">aux_source_directory(./db DB_LIST)#获取db文件下的所有源文件</span><br><span class="line">#指定生成可执行文件</span><br><span class="line">add_executable(ChatServer $&#123;SRC_LIST&#125; $&#123;DB_LIST&#125;)</span><br><span class="line">#指定可执行文件需要链接的库</span><br><span class="line">target_link_libraries(ChatServer muduo_net muduo_base mysqlclient pthread) #链接muduo库和pthread库</span><br></pre></td></tr></table></figure><p><code>src/server/CMakeLists.txt</code> 的作用概括：</p><ol><li><strong>收集源文件</strong>：自动获取当前目录和 <code>db</code> 子目录下的所有 <code>.cpp</code> 文件。</li><li><strong>生成可执行程序</strong>：将源文件编译为 <code>ChatServer</code> 可执行文件。</li><li><strong>链接依赖库</strong>：链接 Muduo 网络库、MySQL 客户端库和 pthread 线程库。</li></ol><h3 id="thirdparty文件夹（第三方库）json-hpp"><a href="#thirdparty文件夹（第三方库）json-hpp" class="headerlink" title="thirdparty文件夹（第三方库）json.hpp"></a>thirdparty文件夹（第三方库）json.hpp</h3><p>聊天服务器项目中，<code>json.hpp</code> 负责处理客户端与服务端之间的 JSON 数据格式，承担消息的 <strong>解析、构建与传输格式化</strong>，是通信协议的关键组件。</p><h3 id="include-server-chatserver-hpp-聊天服务器的主类"><a href="#include-server-chatserver-hpp-聊天服务器的主类" class="headerlink" title="include&#x2F;server&#x2F;chatserver.hpp 聊天服务器的主类"></a>include&#x2F;server&#x2F;chatserver.hpp 聊天服务器的主类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHATSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHATSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"><span class="comment">//聊天服务器的主类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//初始化聊天服务器队对象</span></span><br><span class="line">    <span class="built_in">ChatServer</span>(EventLoop* loop,</span><br><span class="line">            <span class="type">const</span> InetAddress&amp; listenAddr,</span><br><span class="line">            <span class="type">const</span> string&amp; nameArg);</span><br><span class="line">    <span class="comment">//启动服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//上报连接相关信息的回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line">    <span class="comment">//上报读写事件的回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp; conn,</span></span></span><br><span class="line"><span class="params"><span class="function">            Buffer* buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">            Timestamp time)</span></span>;</span><br><span class="line">    TcpServer _server;<span class="comment">//组合的muduo库，实现服务器功能的类对象</span></span><br><span class="line">    EventLoop *_loop;<span class="comment">//指向事件循环的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>ChatServer.h</code> 作用及结构概括</p><ol><li><strong>类功能</strong></li></ol><p>定义了聊天服务器的主类 <code>ChatServer</code>，负责网络服务的初始化、启动和事件处理。</p><ol start="2"><li><strong>成员变量</strong></li></ol><ul><li><code>_server</code>：<code>muduo::net::TcpServer</code> 对象，负责网络连接管理和服务端监听。</li><li><code>_loop</code>：<code>muduo::net::EventLoop</code> 指针，负责事件循环和调度。</li></ul><ol start="3"><li><strong>核心接口</strong></li></ol><ul><li>构造函数 <code>ChatServer(EventLoop*, const InetAddress&amp;, const string&amp;)</code>：初始化服务器监听地址、名称和事件循环。</li><li><code>start()</code>：启动服务器监听，进入事件循环。</li></ul><ol start="4"><li><strong>回调函数</strong>（私有）</li></ol><ul><li><code>onConnection()</code>：处理客户端连接和断开事件。</li><li><code>onMessage()</code>：处理客户端消息接收事件，进行消息读写。</li></ul><p><code>ChatServer</code> 类是整个聊天项目的网络核心，利用 Muduo 库提供的 TCP 服务器功能，封装了网络事件的注册与处理，负责服务器端的网络通信逻辑。</p><h3 id="src-server-chatserver-cpp"><a href="#src-server-chatserver-cpp" class="headerlink" title="src&#x2F;server&#x2F;chatserver.cpp"></a>src&#x2F;server&#x2F;chatserver.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chatserver.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chatservice.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> json =nlohmann::json;</span><br><span class="line"><span class="comment">//初始化聊天服务器队对象</span></span><br><span class="line">ChatServer::<span class="built_in">ChatServer</span>(EventLoop* loop,</span><br><span class="line">            <span class="type">const</span> InetAddress&amp; listenAddr,</span><br><span class="line">            <span class="type">const</span> string&amp; nameArg)</span><br><span class="line">    : _server(loop, listenAddr, nameArg),</span><br><span class="line">      _loop(loop)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注册连接回调</span></span><br><span class="line">    _server.<span class="built_in">setConnectionCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ChatServer::onConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    <span class="comment">//注册消息回调</span></span><br><span class="line">    _server.<span class="built_in">setMessageCallback</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;ChatServer::onMessage, <span class="keyword">this</span>, std::placeholders::_1,</span><br><span class="line">                  std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">//设置线程数量</span></span><br><span class="line">    _server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatServer::start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _server.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上报连接相关信息的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatServer::onConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="comment">//客户端断开连接</span></span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//上报读写事件的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatServer::onMessage</span><span class="params">(<span class="type">const</span> TcpConnectionPtr&amp; conn,</span></span></span><br><span class="line"><span class="params"><span class="function">            Buffer* buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">            Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string buf=buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">    <span class="comment">//数据的反序列化</span></span><br><span class="line">    json js=json::<span class="built_in">parse</span>(buf);</span><br><span class="line">    <span class="comment">//达到的目的:完全解耦网络模块的代码和业务模块的代码</span></span><br><span class="line">    <span class="comment">//通过js[&quot;msgid&quot;] 获取=》业务handler=&gt;conn js time</span></span><br><span class="line">    <span class="keyword">auto</span> msgHandler=ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">getHandler</span>(js[<span class="string">&quot;msgid&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="comment">//回调消息绑定好的事件处理器，来执行相应的业务处理</span></span><br><span class="line">    <span class="built_in">msgHandler</span>(conn,js,time);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatServer.cpp 作用与关键点概括</p><ol><li><strong>构造函数初始化</strong></li></ol><ul><li>初始化 Muduo 的 TCP 服务器对象 <code>_server</code> 和事件循环 <code>_loop</code>。</li><li>注册回调函数：<ul><li><code>onConnection</code> 处理连接建立与断开；</li><li><code>onMessage</code> 处理客户端消息。</li></ul></li><li>设置线程数为4，支持多线程处理网络事件。</li></ul><ol start="2"><li><strong>启动服务</strong></li></ol><ul><li><code>start()</code> 调用 Muduo 的 <code>_server.start()</code> 启动监听和事件循环。</li></ul><ol start="3"><li><strong>连接回调 <code>onConnection</code></strong></li></ol><ul><li>判断客户端是否断开连接，断开时调用 <code>conn-&gt;shutdown()</code> 关闭连接。</li></ul><ol start="4"><li><strong>消息回调 <code>onMessage</code></strong></li></ol><ul><li>将网络缓冲区中的数据读取为字符串。</li><li>使用 <code>json.hpp</code> 将字符串反序列化成 JSON 对象。</li><li>通过消息中的 <code>&quot;msgid&quot;</code> 字段，调用业务层 <code>ChatService</code> 获取对应的消息处理函数（回调）。</li><li>执行该消息处理函数，完成具体的业务逻辑处理。</li></ul><hr><p>作用总结</p><p>这段代码实现了聊天服务器的核心网络处理逻辑，做到：</p><ul><li><strong>网络层与业务层解耦</strong>：网络部分只负责收发和解析数据，业务处理由 <code>ChatService</code> 中注册的处理器完成。</li><li><strong>灵活消息分发</strong>：根据 JSON 中的 <code>msgid</code> 动态调用对应业务处理函数，实现消息驱动机制。</li><li><strong>高效异步处理</strong>：基于 Muduo 多线程事件循环模型，支持高并发网络请求。</li></ul><h3 id="include-server-chatservice-hpp-聊天服务器业务类"><a href="#include-server-chatservice-hpp-聊天服务器业务类" class="headerlink" title="include&#x2F;server&#x2F;chatservice.hpp 聊天服务器业务类"></a>include&#x2F;server&#x2F;chatservice.hpp 聊天服务器业务类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHATSERVICE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHATSERVICE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"><span class="keyword">using</span> json =nlohmann::json;</span><br><span class="line"><span class="comment">//表示处理消息的事件回调方法类型</span></span><br><span class="line"><span class="keyword">using</span> MsgHandler = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&gt;;</span><br><span class="line"><span class="comment">//聊天服务器业务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatService</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//获取单例对象的接口函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ChatService * <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理登录业务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">login</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>;</span><br><span class="line">    <span class="comment">//处理注册业务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reg</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>;</span><br><span class="line">    <span class="comment">//获取消息对应的处理器</span></span><br><span class="line">    <span class="function">MsgHandler <span class="title">getHandler</span><span class="params">(<span class="type">int</span> msgid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ChatService</span>();</span><br><span class="line">    <span class="comment">//存储消息id和其对应的业务处理方法</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,MsgHandler&gt; _msgHandlerMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>ChatService.h 作用与结构概括</p><ol><li><strong>类功能</strong></li></ol><ul><li>负责处理聊天服务器的核心业务逻辑，如登录、注册等。</li><li>管理消息 ID 与对应的处理函数的映射，实现消息的动态分发。</li></ul><ol start="2"><li><strong>核心类型</strong></li></ol><ul><li><code>MsgHandler</code>：消息处理函数类型，参数包括 TCP 连接指针、JSON 消息对象和时间戳。</li></ul><ol start="3"><li><strong>接口函数</strong></li></ol><ul><li><code>static ChatService* instance()</code>：单例模式，获取业务服务唯一实例。</li><li><code>void login(...)</code>：处理登录业务逻辑。</li><li><code>void reg(...)</code>：处理注册业务逻辑。</li><li><code>MsgHandler getHandler(int msgid)</code>：根据消息 ID 获取对应的消息处理函数。</li></ul><ol start="4"><li><strong>成员变量</strong></li></ol><ul><li><code>_msgHandlerMap</code>：存储消息 ID 与处理函数的映射，支持根据消息类型快速调用相应业务处理器。</li></ul><h3 id="src-server-chatservice-cpp"><a href="#src-server-chatservice-cpp" class="headerlink" title="src&#x2F;server&#x2F;chatservice.cpp"></a>src&#x2F;server&#x2F;chatservice.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chatservice.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//获取单例对象的接口函数</span></span><br><span class="line"><span class="comment">//在cpp文件就不需要写static了</span></span><br><span class="line"><span class="function">ChatService * <span class="title">ChatService::instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> ChatService service;</span><br><span class="line">    <span class="keyword">return</span> &amp;service;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册消息以及对应的Handler回调操作</span></span><br><span class="line"> ChatService::<span class="built_in">ChatService</span>()&#123;</span><br><span class="line">    <span class="comment">//注册业务</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(&#123;LOGIN_MSG,std::<span class="built_in">bind</span>(&amp;ChatService::login,<span class="keyword">this</span>,_1,_2,_3)&#125;);</span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(&#123;REG_MSG,std::<span class="built_in">bind</span>(&amp;ChatService::reg,<span class="keyword">this</span>,_1,_2,_3)&#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//获取消息对应的处理器</span></span><br><span class="line"> <span class="function">MsgHandler <span class="title">ChatService::getHandler</span><span class="params">(<span class="type">int</span> msgid)</span></span>&#123;</span><br><span class="line">    <span class="comment">//记录错误日志，msgid没有对应的事件处理回调</span></span><br><span class="line">    <span class="keyword">auto</span> it =_msgHandlerMap.<span class="built_in">find</span>(msgid);</span><br><span class="line">    <span class="keyword">if</span>(it ==_msgHandlerMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="comment">//返回一个默认的处理器，空操作</span></span><br><span class="line">        <span class="keyword">return</span> [=](<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;</span><br><span class="line">            LOG_ERROR&lt;&lt;<span class="string">&quot;msgid:&quot;</span>&lt;&lt; msgid &lt;&lt;<span class="string">&quot;can not find handler!&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _msgHandlerMap[msgid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理登录业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::login</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt;<span class="string">&quot;do login service!!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理注册业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::reg</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>&#123;</span><br><span class="line">    LOG_INFO&lt;&lt;<span class="string">&quot;do reg service!!!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChatService.cpp 作用和关键点</p><ol><li><strong>单例模式实现</strong></li></ol><ul><li><code>instance()</code> 函数内部静态变量实现线程安全的单例模式，保证 <code>ChatService</code> 只有一个实例。</li></ul><ol start="2"><li><strong>构造函数注册消息处理函数</strong></li></ol><ul><li>在构造函数中通过 <code>_msgHandlerMap.insert</code> 将消息 ID（<code>LOGIN_MSG</code>、<code>REG_MSG</code>）绑定到成员函数 <code>login</code> 和 <code>reg</code> 的回调。</li><li>使用 <code>std::bind</code> 绑定成员函数和 <code>this</code> 指针，方便后续调用。</li></ul><ol start="3"><li><strong>动态消息处理函数获取</strong></li></ol><ul><li><code>getHandler(int msgid)</code> 根据传入的消息 ID 返回对应的处理函数。</li><li>如果消息 ID 未注册，返回一个默认空操作的 lambda，同时写错误日志，保证系统健壮性。</li></ul><ol start="4"><li><strong>业务处理函数示例</strong></li></ol><ul><li><code>login()</code> 和 <code>reg()</code> 目前仅打印日志，代表登录和注册的业务处理接口，后续可以扩展具体业务逻辑。</li></ul><h3 id="include-public-hpp"><a href="#include-public-hpp" class="headerlink" title="include&#x2F;public.hpp"></a>include&#x2F;public.hpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PUBLIC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUBLIC_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">server和client的公共文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EnMsgType</span>&#123;</span><br><span class="line">    LOGIN_MSG = <span class="number">1</span>,<span class="comment">//登录消息</span></span><br><span class="line">    REG_MSG<span class="comment">//注册消息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>public.h 作用简述</p><ul><li><strong>共享消息类型定义</strong><ul><li>定义了枚举类型 <code>EnMsgType</code>，用于区分不同的消息类型。</li><li>目前包含两种消息：<ul><li><code>LOGIN_MSG = 1</code>：登录消息</li><li><code>REG_MSG</code>：注册消息</li></ul></li></ul></li><li><strong>作用</strong><ul><li>服务端和客户端都包含这个头文件，保证双方对消息类型有统一的理解和对应关系，方便通信协议的设计与实现。</li></ul></li></ul><h3 id="src-server-main-cpp"><a href="#src-server-main-cpp" class="headerlink" title="src&#x2F;server&#x2F;main.cpp"></a>src&#x2F;server&#x2F;main.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chatserver.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6000</span>)</span></span>;</span><br><span class="line">    <span class="function">ChatServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;ChatServer&quot;</span>)</span></span>;</span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">//开启事件循环</span></span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启动聊天服务器</strong>：<br> 创建事件循环和服务器监听地址，初始化 <code>ChatServer</code> 对象，启动服务器后进入事件循环，开始接受和处理客户端连接与消息。</p><h3 id="include-server-db-db-h-数据库操作类"><a href="#include-server-db-db-h-数据库操作类" class="headerlink" title="include&#x2F;server&#x2F;db&#x2F;db.h 数据库操作类"></a>include&#x2F;server&#x2F;db&#x2F;db.h 数据库操作类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 数据库操作类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySQL</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// 初始化数据库连接</span></span><br><span class="line"><span class="built_in">MySQL</span>();</span><br><span class="line"><span class="comment">// 释放数据库连接资源</span></span><br><span class="line">~<span class="built_in">MySQL</span>();</span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 更新操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span>;</span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="function">MYSQL_RES* <span class="title">query</span><span class="params">(string sql)</span></span>;</span><br><span class="line"><span class="comment">//获取连接</span></span><br><span class="line"><span class="function">MYSQL * <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *_conn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>MySQL 数据库操作类说明</strong></p><p><strong>类功能</strong></p><p>封装对 MySQL 数据库的连接、查询和更新操作，方便上层业务调用。</p><p><strong>主要成员函数</strong></p><ul><li>**构造函数 <code>MySQL()</code>**：初始化数据库连接相关资源。</li><li>**析构函数 <code>~MySQL()</code>**：释放数据库连接资源。</li><li>**<code>bool connect()</code>**：连接数据库，返回连接是否成功。</li><li>**<code>bool update(string sql)</code>**：执行更新类 SQL 语句（如 INSERT、UPDATE、DELETE）。</li><li>**<code>MYSQL_RES* query(string sql)</code>**：执行查询类 SQL 语句，返回结果集指针。</li><li>**<code>MYSQL* getConnection()</code>**：获取底层 MySQL 连接对象，便于其他操作。</li></ul><p><strong>成员变量</strong></p><ul><li>**<code>MYSQL *_conn</code>**：指向 MySQL 连接句柄的指针。</li></ul><h3 id="src-server-db-db-cpp"><a href="#src-server-db-db-cpp" class="headerlink" title="src&#x2F;server&#x2F;db&#x2F;db.cpp"></a>src&#x2F;server&#x2F;db&#x2F;db.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;db.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据库配置信息</span></span><br><span class="line"><span class="type">static</span> string server = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="type">static</span> string user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">static</span> string password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">static</span> string dbname = <span class="string">&quot;chat&quot;</span>;</span><br><span class="line"><span class="comment">// 初始化数据库连接</span></span><br><span class="line">MySQL::<span class="built_in">MySQL</span>()</span><br><span class="line">&#123;</span><br><span class="line">    _conn = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放数据库连接资源</span></span><br><span class="line">MySQL::~<span class="built_in">MySQL</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_conn != <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="built_in">mysql_close</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MySQL::connect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MYSQL *p = <span class="built_in">mysql_real_connect</span>(_conn, server.<span class="built_in">c_str</span>(), user.<span class="built_in">c_str</span>(),password.<span class="built_in">c_str</span>(), dbname.<span class="built_in">c_str</span>(), <span class="number">3306</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//C和C++代码默认的编码字符是ASCII,如果不设置，从MySQL上拉下来的中文显示？</span></span><br><span class="line">        <span class="built_in">mysql_query</span>(_conn, <span class="string">&quot;set names gbk&quot;</span>);</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;connect mysql success!&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">&quot;connect mysql failed!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MySQL::update</span><span class="params">(string sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">                &lt;&lt; sql &lt;&lt; <span class="string">&quot;更新失败!&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="function">MYSQL_RES* <span class="title">MySQL::query</span><span class="params">(string sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_INFO &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">                &lt;&lt; sql &lt;&lt; <span class="string">&quot;查询失败!&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mysql_use_result</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取连接</span></span><br><span class="line"><span class="function">MYSQL * <span class="title">MySQL::getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MySQL 类实现功能简述</strong></p><ol><li><strong>初始化连接</strong><ul><li>构造函数 <code>MySQL()</code> 调用 <code>mysql_init</code> 初始化 MySQL 连接对象。</li></ul></li><li><strong>释放连接资源</strong><ul><li>析构函数 <code>~MySQL()</code> 关闭数据库连接，释放资源。</li></ul></li><li><strong>连接数据库</strong><ul><li><code>connect()</code> 使用 <code>mysql_real_connect</code> 连接到数据库。</li><li>成功连接后设置字符集为 <code>gbk</code>，防止中文乱码。</li><li>通过日志打印连接成功或失败信息。</li></ul></li><li><strong>执行更新操作</strong><ul><li><code>update(string sql)</code> 执行 SQL 更新语句（如 INSERT、UPDATE、DELETE）。</li><li>失败时打印错误日志，返回 <code>false</code>。</li></ul></li><li><strong>执行查询操作</strong><ul><li><code>query(string sql)</code> 执行 SQL 查询语句。</li><li>返回查询结果指针，失败时返回 <code>nullptr</code>。</li></ul></li><li><strong>获取底层连接</strong><ul><li><code>getConnection()</code> 返回当前的 MySQL 连接指针，方便其他数据库操作调用。</li></ul></li></ol><h3 id="include-server-user-hpp-数据库中user表对应的类"><a href="#include-server-user-hpp-数据库中user表对应的类" class="headerlink" title="include&#x2F;server&#x2F;user.hpp 数据库中user表对应的类"></a>include&#x2F;server&#x2F;user.hpp 数据库中user表对应的类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//User表的ORM类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">User</span>(<span class="type">int</span> id=<span class="number">1</span>,string name=<span class="string">&quot;&quot;</span>,string pwd=<span class="string">&quot;&quot;</span>,string state=<span class="string">&quot;offline&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">            <span class="keyword">this</span>-&gt;password=pwd;</span><br><span class="line">            <span class="keyword">this</span>-&gt;state=state;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;<span class="keyword">this</span>-&gt;id=id;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123;<span class="keyword">this</span>-&gt;name=name;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setPwd</span><span class="params">(string pwd)</span></span>&#123;<span class="keyword">this</span>-&gt;password=pwd;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(string state)</span></span>&#123;<span class="keyword">this</span>-&gt;state=state;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;&#125;</span><br><span class="line">        <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;&#125;</span><br><span class="line">        <span class="function">string <span class="title">getPwd</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;password;&#125;</span><br><span class="line">        <span class="function">string <span class="title">getState</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;state;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        string name;</span><br><span class="line">        string password;</span><br><span class="line">        string state;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong><code>User</code> 类作用概括：</strong></p><ol><li><strong>ORM 映射作用</strong></li></ol><ul><li>该类是对数据库 <code>User</code> 表的一个对象化表示（Object-Relational Mapping）。</li><li>将数据库中的一条用户记录封装成一个 C++ 对象，便于在程序中操作。</li></ul><ol start="2"><li><strong>属性封装</strong></li></ol><p>类中包含如下用户信息字段：</p><ul><li><code>id</code>: 用户编号</li><li><code>name</code>: 用户名</li><li><code>password</code>: 用户密码</li><li><code>state</code>: 用户状态（如 <code>&quot;online&quot;</code> &#x2F; <code>&quot;offline&quot;</code>）</li></ul><ol start="3"><li><strong>基本接口功能</strong></li></ol><p>提供了以下功能函数：</p><ul><li>构造函数（支持默认值）</li><li><code>setXXX()</code> 设置各字段值</li><li><code>getXXX()</code> 获取各字段值</li></ul><p><strong>项目中的实际用途</strong></p><p>基于 Muduo 的聊天服务器项目中：</p><ul><li>用户数据从数据库中查询出来后，可以封装成 <code>User</code> 类对象；</li><li>在业务逻辑中传递用户信息时，使用 <code>User</code> 类便于管理；</li><li>与数据库交互模块（如 DAO 类）进行数据传递、封装与解封装；</li><li>便于将用户信息序列化为 JSON 数据发送到客户端。</li></ul><h3 id="include-server-usermodel-hpp-user表的数据操作类"><a href="#include-server-usermodel-hpp-user表的数据操作类" class="headerlink" title="include&#x2F;server&#x2F;usermodel.hpp  user表的数据操作类"></a>include&#x2F;server&#x2F;usermodel.hpp  user表的数据操作类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USERMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USERMODEL_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.hpp&quot;</span></span></span><br><span class="line"><span class="comment">//user表的数据操作类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserModel</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//User表的增加方法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(User &amp;user)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>#ifndef/#define/#endif</code>：防止头文件重复包含（include guard）；</p><p><code>#include &quot;user.hpp&quot;</code>：引入用户实体类定义；</p><p><code>class UserModel</code>：封装了对 <code>User</code> 表的数据库操作；</p><p><code>bool insert(User &amp;user)</code>：定义了插入用户的方法，返回是否成功。</p><h3 id="src-server-usermodel-cpp"><a href="#src-server-usermodel-cpp" class="headerlink" title="src&#x2F;server&#x2F;usermodel.cpp"></a>src&#x2F;server&#x2F;usermodel.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usermodel.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;db.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//User表的增加方法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UserModel::insert</span><span class="params">(User &amp;user)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;insert into User(name,password,state) values(&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">        user.<span class="built_in">getName</span>().<span class="built_in">c_str</span>(),user.<span class="built_in">getPwd</span>().<span class="built_in">c_str</span>(),user.<span class="built_in">getState</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(mysql.<span class="built_in">update</span>(sql))&#123;</span><br><span class="line">            <span class="comment">//获取插入成功的用户数据生成的主键id</span></span><br><span class="line">            user.<span class="built_in">setId</span>(<span class="built_in">mysql_insert_id</span>(mysql.<span class="built_in">getConnection</span>()));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sprintf</code> 组装 SQL；</p><p><code>MySQL</code> 是你自定义的数据库操作类，封装了 <code>connect()</code> 和 <code>update()</code>；</p><p>插入成功后，用 <code>mysql_insert_id()</code> 获取刚插入的记录主键 ID。</p><h3 id="注册业务实现"><a href="#注册业务实现" class="headerlink" title="注册业务实现"></a>注册业务实现</h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>public.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnMsgType</span>&#123;</span><br><span class="line">    LOGIN_MSG = <span class="number">1</span>,<span class="comment">//登录消息</span></span><br><span class="line">    REG_MSG,<span class="comment">//注册消息</span></span><br><span class="line">    REG_MSG_ACK <span class="comment">//注册响应消息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再加上REG_MSG_ACK 注册响应消息，告诉客户端已经收到消息。</p><p>chatservice.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ChatService</span>();</span><br><span class="line">    <span class="comment">//存储消息id和其对应的业务处理方法</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,MsgHandler&gt; _msgHandlerMap;</span><br><span class="line">    <span class="comment">//数据操作类对象</span></span><br><span class="line">    UserModel _userModel;</span><br></pre></td></tr></table></figure><p>在private中加入数据操作类对象UserModel _userModel，这个是自定义的对象在usermodel.hpp</p><p>chatservice.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::reg</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>&#123;</span><br><span class="line">    string name=js[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">    string pwd=js[<span class="string">&quot;password&quot;</span>];</span><br><span class="line">    User user;</span><br><span class="line">    user.<span class="built_in">setName</span>(name);</span><br><span class="line">    user.<span class="built_in">setPwd</span>(pwd);</span><br><span class="line">    <span class="type">bool</span> state=_userModel.<span class="built_in">insert</span>(user);</span><br><span class="line">    <span class="keyword">if</span>(state)&#123;</span><br><span class="line">        <span class="comment">//注册成功</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">&quot;msgid&quot;</span>]= REG_MSG_ACK;</span><br><span class="line">        response[<span class="string">&quot;errno&quot;</span>]=<span class="number">0</span>;</span><br><span class="line">        response[<span class="string">&quot;id&quot;</span>]=user.<span class="built_in">getId</span>();</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//注册失败</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">&quot;msgid&quot;</span>]= REG_MSG_ACK;</span><br><span class="line">        response[<span class="string">&quot;errno&quot;</span>]=<span class="number">1</span>;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ChatService类的reg函数，负责处理注册业务的。js中存储的是我们的消息以json存储的。这里面的字段例如msgid,name,password都是服务端和客户端约定好的。首先将消息中的name,和password拿出来赋值给User类对象user,注册业务，把对应的值存入数据库chat中的User表中。当数据操作类对象_userModel插入成功时，返回消息给客户端，msgid是客户端和服务端规定的消息类型，消息REG_MSG_ACK注册后的回应消息。返回的消息有消息类型和是否注册成功的标志errno(0表示成功，1表示失败)，注册失败id也不会产生，所以不用发了。最后使用json的dump()函数转换为字符串通过conn的send函数再发出去。</p><h4 id="conn是TcpConnectionPtr类型"><a href="#conn是TcpConnectionPtr类型" class="headerlink" title="conn是TcpConnectionPtr类型"></a>conn是TcpConnectionPtr类型</h4><p><code>TcpConnectionPtr</code> 是 <strong>Muduo 网络库</strong> 中定义的一个智能指针类型，指向 <code>TcpConnection</code> 对象，通常用于表示一条活跃的 TCP 连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;</span><br></pre></td></tr></table></figure><p>它的生命周期由 <code>Muduo</code> 网络库自动管理。</p><p>常见成员函数（通过 <code>TcpConnectionPtr</code> 调用）</p><ul><li><code>conn-&gt;send(data)</code>：发送数据到客户端</li><li><code>conn-&gt;shutdown()</code>：关闭连接（半关闭）</li><li><code>conn-&gt;connected()</code>：是否仍保持连接</li><li><code>conn-&gt;peerAddress()</code>：对端地址</li><li><code>conn-&gt;localAddress()</code>：本地地址</li><li><code>conn-&gt;setContext()</code> &#x2F; <code>conn-&gt;getContext()</code>：绑定上下文（可保存登录信息、用户ID等）</li></ul><h4 id="实现注册业务时出现的问题"><a href="#实现注册业务时出现的问题" class="headerlink" title="实现注册业务时出现的问题"></a>实现注册业务时出现的问题</h4><p>实现注册业务时，使用vscod远程连接Linux出现了连接数据库不上的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20250604 13:22:35.282815Z 18893 INFO  connect mysql failed!Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; - db.cpp:29</span><br></pre></td></tr></table></figure><p>数据库拒绝了 root 用户从 localhost 的访问请求。</p><p>解决方案</p><p>1.使用Linux root用户登录mysql</p><p>2.修改root用户认证方式为密码登录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">EXIT;</span><br></pre></td></tr></table></figure><p>第一句ALTER USER修改存在的用户 ‘root‘@’localhost’用户名为root,本地连接。IDENTIFIED WITH mysql_native_password 设置认证插件为 <code>mysql_native_password</code>（密码方式）</p><p>第二句MySQL 会将用户和权限信息缓存在内存中，这条命令强制它 重新加载所有权限表。<code>ALTER USER</code> 做的更改立即生效，而不必重启 MySQL 服务</p><p>第三句对用户权限和密码的修改完成了，退出命令行界面即可。</p><p><code>auth_socket</code> 是 MySQL 默认的一种用户认证方式，<strong>主要用于本地登录</strong>，<strong>不使用密码，而是通过操作系统身份验证</strong>。MySQL 会验证：</p><ul><li>你是否是当前 Linux 系统的 <code>root</code> 用户；</li><li>如果是，允许登录；</li><li>否则，拒绝访问，即使你输入了正确的密码也没用。</li></ul><h3 id="登录业务实现"><a href="#登录业务实现" class="headerlink" title="登录业务实现"></a>登录业务实现</h3><h4 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h4><p>public.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnMsgType</span>&#123;</span><br><span class="line">    LOGIN_MSG = <span class="number">1</span>,<span class="comment">//登录消息</span></span><br><span class="line">    LOGIN_MSG_ACK,<span class="comment">//登录响应消息</span></span><br><span class="line">    REG_MSG,<span class="comment">//注册消息</span></span><br><span class="line">    REG_MSG_ACK <span class="comment">//注册响应消息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>加入LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息</p><p>usermodel.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据用户号码查询用户信息</span></span><br><span class="line"><span class="function">User <span class="title">query</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"><span class="comment">//更新用户的状态信息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">updateState</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure><p>加入这两个函数，后面会在登录业务用到</p><p>usermodel.cpp 对应函数的具体实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据用户号码查询用户信息</span></span><br><span class="line"><span class="function">User <span class="title">UserModel::query</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;select * from User where id=%d&quot;</span>,id);</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        MYSQL_RES* res=mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="literal">nullptr</span>)&#123;<span class="comment">//查询成功</span></span><br><span class="line">            MYSQL_ROW row=<span class="built_in">mysql_fetch_row</span>(res);<span class="comment">//查一行</span></span><br><span class="line">            <span class="keyword">if</span>(row!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                User user;</span><br><span class="line">                user.<span class="built_in">setId</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));<span class="comment">//转换id为int，从数据库取出的都是字符串</span></span><br><span class="line">                user.<span class="built_in">setName</span>(row[<span class="number">1</span>]);<span class="comment">//用户名</span></span><br><span class="line">                user.<span class="built_in">setPwd</span>(row[<span class="number">2</span>]);<span class="comment">//密码</span></span><br><span class="line">                user.<span class="built_in">setState</span>(row[<span class="number">3</span>]);<span class="comment">//状态，以上是根据查询出的结果集取得</span></span><br><span class="line">                <span class="built_in">mysql_free_result</span>(res);<span class="comment">//释放结果集资源</span></span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">User</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新用户的状态信息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UserModel::updateState</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;update User set state = &#x27;%s&#x27; where id = %d&quot;</span>,user.<span class="built_in">getState</span>().<span class="built_in">c_str</span>(),user.<span class="built_in">getId</span>());</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(mysql.<span class="built_in">update</span>(sql))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chatservice.cpp</p><p>实现login函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理登录业务 id pwd</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::login</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> id=js[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">    string pwd=js[<span class="string">&quot;password&quot;</span>];</span><br><span class="line">    User user=_userModel.<span class="built_in">query</span>(id);</span><br><span class="line">    <span class="keyword">if</span>(user.<span class="built_in">getId</span>()==id&amp;&amp;user.<span class="built_in">getPwd</span>()==pwd)&#123;</span><br><span class="line">        <span class="keyword">if</span>(user.<span class="built_in">getState</span>()==<span class="string">&quot;online&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">//该用户已经登录，不允许重复登录</span></span><br><span class="line">            json response;</span><br><span class="line">            response[<span class="string">&quot;msgid&quot;</span>]= LOGIN_MSG_ACK;</span><br><span class="line">            response[<span class="string">&quot;errno&quot;</span>]=<span class="number">2</span>;</span><br><span class="line">            response[<span class="string">&quot;errmsg&quot;</span>]=<span class="string">&quot;该账号已经登录，请输入新账号&quot;</span>;</span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//登录成功，更新用户状态信息 state offline=&gt;online</span></span><br><span class="line">            user.<span class="built_in">setState</span>(<span class="string">&quot;online&quot;</span>);</span><br><span class="line">            _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line">            json response;</span><br><span class="line">            response[<span class="string">&quot;msgid&quot;</span>]= LOGIN_MSG_ACK;</span><br><span class="line">            response[<span class="string">&quot;errno&quot;</span>]=<span class="number">0</span>;</span><br><span class="line">            response[<span class="string">&quot;id&quot;</span>]=user.<span class="built_in">getId</span>();</span><br><span class="line">            response[<span class="string">&quot;name&quot;</span>]=user.<span class="built_in">getName</span>();</span><br><span class="line">            conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//该用户不存在，登陆失败</span></span><br><span class="line">        json response;</span><br><span class="line">        response[<span class="string">&quot;msgid&quot;</span>]= LOGIN_MSG_ACK;</span><br><span class="line">        response[<span class="string">&quot;errno&quot;</span>]=<span class="number">1</span>;</span><br><span class="line">        response[<span class="string">&quot;errmsg&quot;</span>]=<span class="string">&quot;用户名或者密码错误&quot;</span>;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response.<span class="built_in">dump</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="记录用户的连接信息及线程安全性"><a href="#记录用户的连接信息及线程安全性" class="headerlink" title="记录用户的连接信息及线程安全性"></a>记录用户的连接信息及线程安全性</h3><p>因为要实现用户与用户之间的消息往来，所以要实现记录上线用户的连接信息和下线的删除。</p><p>chatservice.hpp private:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储在线用户的通信连接 注意线程安全</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,TcpConnectionPtr&gt; _userConnMap;</span><br></pre></td></tr></table></figure><p>那么这个值在什么时候更新，首先在登录成功时，添加连接</p><p>chatservice.cpp login函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_userConnMap.<span class="built_in">insert</span>(&#123;id,conn&#125;);<span class="comment">//unordered_map容器没有线程安全需要添加线程互斥操作</span></span><br></pre></td></tr></table></figure><p>当然插入了还不够，多个用户连接服务器，_userConnMap这个是在多线程环境下，要保证线程互斥性。</p><p>大多数 <strong>C++ STL 容器本身</strong>（如 <code>vector</code>、<code>map</code>、<code>unordered_map</code> 等）<strong>不是线程安全的</strong>。</p><p>所以我们要在对这个插入数据加锁。</p><p>chatservice.hpp private:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记得包含头文件#include &lt;mutex&gt;</span></span><br><span class="line"><span class="comment">//定义互斥锁，保证_userConnMap的线程安全</span></span><br><span class="line">    mutex _connMutex;</span><br></pre></td></tr></table></figure><p>chatservice.cpp login函数 </p><p>还是在登录成功那里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="comment">//登录成功，记录用户连接信息</span></span><br><span class="line">     <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;<span class="comment">//如果不析构，得得遇到&#125;为止，都是互斥，所以加个域</span></span><br><span class="line">     _userConnMap.<span class="built_in">insert</span>(&#123;id,conn&#125;);<span class="comment">//unordered_map容器没有线程安全需要添加线程互斥操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人会问为什么再加一个花括号，这是为了让lock_guard的生命周期结束，这个变量的特性是构造时加锁，析构时自动解锁。</p><h3 id="客户端异常退出业务"><a href="#客户端异常退出业务" class="headerlink" title="客户端异常退出业务"></a>客户端异常退出业务</h3><p>当客户端异常退出时，我们的数据库还没有修改当前状态时在线还是下线，所以要实现这个业务</p><p>chatservice.cpp 定义公共函数clientCloseException</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理客户端异常退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clientCloseException</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br></pre></td></tr></table></figure><p>chatservice.cpp 对应函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理客户端异常退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::clientCloseException</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>&#123;</span><br><span class="line">    User user;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;<span class="comment">//如果不析构，得得遇到&#125;为止，都是互斥，所以加个域</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=_userConnMap.<span class="built_in">begin</span>();it!=_userConnMap.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second == conn)&#123;</span><br><span class="line">                user.<span class="built_in">setId</span>(it-&gt;first);</span><br><span class="line">                <span class="comment">//从map表删除用户的连接信息</span></span><br><span class="line">                _userConnMap.<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新用户的状态信息</span></span><br><span class="line">    <span class="keyword">if</span>(user.<span class="built_in">getId</span>()!=<span class="number">-1</span>)&#123;</span><br><span class="line">        user.<span class="built_in">setState</span>(<span class="string">&quot;offline&quot;</span>);</span><br><span class="line">        _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chatserver.cpp  onConnection函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">       <span class="comment">//处理异常退出业务，state更新为offline</span></span><br><span class="line">       ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">clientCloseException</span>(conn);</span><br><span class="line">       conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在确认断开后，使用clientCloseException将state更新为offline。</p><h3 id="一对一聊天业务：在线聊天实现"><a href="#一对一聊天业务：在线聊天实现" class="headerlink" title="一对一聊天业务：在线聊天实现"></a>一对一聊天业务：在线聊天实现</h3><p>public.hpp 加入聊天消息ONE_CHAT_MSG</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">server和client的公共文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EnMsgType</span>&#123;</span><br><span class="line">    LOGIN_MSG = <span class="number">1</span>,<span class="comment">//登录消息</span></span><br><span class="line">    LOGIN_MSG_ACK,<span class="comment">//登录响应消息</span></span><br><span class="line">    REG_MSG,<span class="comment">//注册消息</span></span><br><span class="line">    REG_MSG_ACK, <span class="comment">//注册响应消息</span></span><br><span class="line">    ONE_CHAT_MSG, <span class="comment">//聊天消息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>既然注册了业务，所以还要在chatservice.cpp的构造函数，注册业务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_msgHandlerMap.<span class="built_in">insert</span>(&#123;ONE_CHAT_MSG,std::<span class="built_in">bind</span>(&amp;ChatService::oneChat,<span class="keyword">this</span>,_1,_2,_3)&#125;);</span><br></pre></td></tr></table></figure><p>chatservice.hpp 声明一对一聊天业务函数声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一对一聊天业务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">oneChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>;</span><br></pre></td></tr></table></figure><p>chatservice.cpp 声明一对一聊天业务函数声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::oneChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> toid=js[<span class="string">&quot;to&quot;</span>];</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it=_userConnMap.<span class="built_in">find</span>(toid);</span><br><span class="line">        <span class="keyword">if</span>(it!=_userConnMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//toid在线，转发消息</span></span><br><span class="line">            <span class="comment">//凡涉及_userConnMap注意线程安全性</span></span><br><span class="line">            <span class="comment">//服务器主动推送原消息给toid用户</span></span><br><span class="line">            it-&gt;second-&gt;<span class="built_in">send</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//toid不在线，存储离线信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里js里面的构成是</p><p>msgid &#x2F;&#x2F;消息类型<br>id发消息的id<br>from 发消息的name<br>to接受方的id<br>msg 要发送的消息</p><p>在线发送消息整体实现就是服务端接收到消息，之后查看接受用户是否在线，在线则调出服务端与接收端的连接，转发原消息。</p><h3 id="一对一聊天业务：离线消息"><a href="#一对一聊天业务：离线消息" class="headerlink" title="一对一聊天业务：离线消息"></a>一对一聊天业务：离线消息</h3><p>首先离线消息是存储在数据库的一张表里</p><p>这张表只有两个字段userid和message 这里就不用ORM映射构造一个类来保留，所以我们直接构造一个关于这张表的操作类OfflineMsgModel</p><p>offlinemessagemodel.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//提供离线消息表的操作接口方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OfflineMsgModel</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//存储用户的离线消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> userid,string msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除用户的离线消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> userid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询用户的离线消息</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> userid)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>offlinemessagemodel.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;offlinemessagemodel.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;db.h&quot;</span></span></span><br><span class="line"><span class="comment">// 存储用户的离线消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OfflineMsgModel::insert</span><span class="params">(<span class="type">int</span> userid, string msg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;insert into offlineMessage values(%d,&#x27;%s&#x27;)&quot;</span>,userid,msg.<span class="built_in">c_str</span>());</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        mysql.<span class="built_in">update</span>(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除用户的离线消息</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">OfflineMsgModel::remove</span><span class="params">(<span class="type">int</span> userid)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;delete from offlineMessage where userid=%d&quot;</span>,userid);</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        mysql.<span class="built_in">update</span>(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询用户的离线消息并返回对应id的消息数组</span></span><br><span class="line"><span class="function">vector&lt;string&gt;  <span class="title">OfflineMsgModel::query</span><span class="params">(<span class="type">int</span> userid)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;select message from offlineMessage where userid=%d&quot;</span>,userid);</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    vector&lt;string&gt; vec;   </span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        MYSQL_RES* res=mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="literal">nullptr</span>)&#123;<span class="comment">//查询成功</span></span><br><span class="line">             <span class="comment">//把userid用户的所有离线消息放入vec中返回</span></span><br><span class="line">             <span class="comment">//查多行</span></span><br><span class="line">             MYSQL_ROW row;</span><br><span class="line">             <span class="keyword">while</span>((row=<span class="built_in">mysql_fetch_row</span>(res))!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(row[<span class="number">0</span>]);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">             <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造好对应的数据操作类，要在chatservice类实现功能</p><p>chatservice.hpp 添加对应类的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OfflineMsgModel _offlineMsgModel;</span><br></pre></td></tr></table></figure><p>chatservice.cpp</p><p>首先在用户登录成功后，要查看离线表中是否有属于它的离线消息，所以在login函数中登录成功板块还要添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询该用户是否有离线消息</span></span><br><span class="line">            vector&lt;string&gt; vec=_offlineMsgModel.<span class="built_in">query</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(!vec.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                response[<span class="string">&quot;offlinemsg&quot;</span>]=vec;</span><br><span class="line">                <span class="comment">//读取该用户的离线消息后，把该用户的所有离线消息删除掉</span></span><br><span class="line">                _offlineMsgModel.<span class="built_in">remove</span>(id);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>首先查询对应id是否有离线消息存在，存到vector数组中，如果不为空的话，response添加offlinemsg字段存储离线消息，并且在服务端删除属于接收端的离线消息，做完这些转发给接收端。</p><p>还有存储离线消息在onechat函数中对应的接收端不在线，存储离线消息在服务端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//toid不在线，存储离线信息</span></span><br><span class="line">    _offlineMsgModel.<span class="built_in">insert</span>(toid,js.<span class="built_in">dump</span>());</span><br></pre></td></tr></table></figure><p>这样一对一的聊天业务就算实现了。</p><h3 id="服务器异常退出问题解决（ctrl-c退出）"><a href="#服务器异常退出问题解决（ctrl-c退出）" class="headerlink" title="服务器异常退出问题解决（ctrl+c退出）"></a>服务器异常退出问题解决（ctrl+c退出）</h3><p>这里遇到的问题是服务器异常退出，User表中用户们的在线状态并没有改变，所以我们要将其改变。</p><p>因为这里数据库的操作，所以在usermodel.cpp UserModel类实现resetState函数，记得在hpp文件声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重置用户的状态信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserModel::resetState</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] =<span class="string">&quot;update User set state = &#x27;offline&#x27; where state = &#x27;online&#x27;&quot;</span>;</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        mysql.<span class="built_in">update</span>(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就在chatservice.cpp中ChatService类的reset新函数调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器异常，业务重置方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//把online状态的用户，设置成offline</span></span><br><span class="line">    _userModel.<span class="built_in">resetState</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在main.cpp实现这一功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理服务器ctrl+c结束后，重置user的状态信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resetHandler</span><span class="params">(<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    ChatService::<span class="built_in">instance</span>()-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数添加对应的信号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT,resetHandler);</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">addr</span><span class="params">(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6000</span>)</span></span>;</span><br><span class="line">    <span class="function">ChatServer <span class="title">server</span><span class="params">(&amp;loop, addr, <span class="string">&quot;ChatServer&quot;</span>)</span></span>;</span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">//开启事件循环</span></span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点：signal(SIGINT,resetHandler);</p><p>注册信号处理函数</p><ul><li><strong><code>SIGINT</code></strong> 是一个信号，表示 <strong>中断信号</strong>，通常在终端按下 <code>Ctrl+C</code> 时触发。</li><li><strong><code>resetHandler</code></strong> 是你定义的函数，用来在收到这个信号时执行一些清理逻辑。它的参数类型必须是 <code>int</code>，因为它接受信号编号</li></ul><p>当然signal(SIGINT,resetHandler);这句话也不能随便放，得放在服务端启动前。</p><p>SIGINT 信号是：</p><p>Interrupt Signal（中断信号），编号是 2，表示用户希望中断（终止）正在运行的程序。</p><p>常见触发方式：</p><ul><li>当你在 终端&#x2F;命令行里运行一个程序时，按下 Ctrl + C，操作系统就会向该程序发送一个 SIGINT 信号。</li></ul><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash复制编辑$ ./chat_server</span><br><span class="line"># 运行中...</span><br><span class="line"></span><br><span class="line"># 你按下 Ctrl+C</span><br></pre></td></tr></table></figure><p>这时，系统向 <code>chat_server</code> 进程发送 <code>SIGINT</code> 信号：</p><ul><li>如果你没处理这个信号，程序会<strong>直接终止</strong>；</li><li>如果你写了 <code>signal(SIGINT, resetHandler);</code>，就会先执行 <code>resetHandler()</code>，再退出。</li></ul><p>背后原理：</p><ul><li>Linux&#x2F;Unix 中，信号（signal）是一种<strong>异步通知机制</strong>，用于通知进程发生了某种事件。</li><li><code>SIGINT</code> 是一种 <strong>软件信号</strong>，由终端驱动程序发送给前台进程组。</li></ul><p>常见信号对比：</p><table><thead><tr><th>信号名</th><th>编号</th><th>含义</th><th>默认行为</th></tr></thead><tbody><tr><td><code>SIGINT</code></td><td>2</td><td>终端中断（Ctrl+C）</td><td>终止进程</td></tr><tr><td><code>SIGTERM</code></td><td>15</td><td>程序终止（系统或用户发送）</td><td>终止进程</td></tr><tr><td><code>SIGKILL</code></td><td>9</td><td>强制终止（不能捕获）</td><td>立即终止进程</td></tr><tr><td><code>SIGQUIT</code></td><td>3</td><td>退出（Ctrl+\）并生成 core dump</td><td>终止+生成转储文件</td></tr><tr><td><code>SIGSEGV</code></td><td>11</td><td>段错误（访问非法内存）</td><td>终止进程</td></tr></tbody></table><p>总结一句话：SIGINT 是终端用户通过 Ctrl+C 发出的“中断信号”，默认会终止程序，但你可以捕获它，在程序退出前做一些清理处理。</p><h3 id="添加好友业务代码"><a href="#添加好友业务代码" class="headerlink" title="添加好友业务代码"></a>添加好友业务代码</h3><p>public.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnMsgType</span>&#123;</span><br><span class="line">    LOGIN_MSG = <span class="number">1</span>,<span class="comment">//登录消息</span></span><br><span class="line">    LOGIN_MSG_ACK,<span class="comment">//登录响应消息</span></span><br><span class="line">    REG_MSG,<span class="comment">//注册消息</span></span><br><span class="line">    REG_MSG_ACK, <span class="comment">//注册响应消息</span></span><br><span class="line">    ONE_CHAT_MSG, <span class="comment">//聊天消息</span></span><br><span class="line">    ADD_FRIEND_MSG,<span class="comment">//添加好友消息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>添加ADD_FRIEND_MSG,&#x2F;&#x2F;添加好友消息</p><p>添加好友在数据库中对应的一张Friend表，其中字段是userid和friendid,所以我们实现一个操控Friend表的model类</p><p>friendmodel.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FRIENDMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRIENDMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护好友信息的操作接口方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendModel</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//添加好友关系</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> userid,<span class="type">int</span> friendid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回用户好友列表 friendid</span></span><br><span class="line">    <span class="function">vector&lt;User&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> userid)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>friendmodel.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;friendmodel.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;db.h&quot;</span></span></span><br><span class="line"><span class="comment">//添加好友关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FriendModel::insert</span><span class="params">(<span class="type">int</span> userid,<span class="type">int</span> friendid)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;insert into Friend values(%d,%d)&quot;</span>,userid,friendid);</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        mysql.<span class="built_in">update</span>(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回用户好友列表 friendid</span></span><br><span class="line"><span class="function">vector&lt;User&gt; <span class="title">FriendModel::query</span><span class="params">(<span class="type">int</span> userid)</span></span>&#123;</span><br><span class="line">     <span class="comment">//1 组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;select a.id,a.name,a.state from User a inner join Friend b on b.friendid=a.id where b.userid=%d&quot;</span>,userid);</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    vector&lt;User&gt; vec;   </span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        MYSQL_RES* res=mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="literal">nullptr</span>)&#123;<span class="comment">//查询成功</span></span><br><span class="line">             <span class="comment">//把userid用户的所有离线消息放入vec中返回</span></span><br><span class="line">             <span class="comment">//查多行</span></span><br><span class="line">             MYSQL_ROW row;</span><br><span class="line">             <span class="keyword">while</span>((row=<span class="built_in">mysql_fetch_row</span>(res))!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                User user;</span><br><span class="line">                user.<span class="built_in">setId</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">                user.<span class="built_in">setName</span>(row[<span class="number">1</span>]);</span><br><span class="line">                user.<span class="built_in">setState</span>(row[<span class="number">2</span>]);</span><br><span class="line">                vec.<span class="built_in">push_back</span>(user);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">             <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert函数实现的是将好友关系加到数据库中。query返回的是从数据库中返回的好友数据。</p><p>当然还有一个业务绑定</p><p>首先在chatservice.hpp声明一个FriendModel对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FriendModel _friendModel;</span><br></pre></td></tr></table></figure><p>在ChatService的构造函数实现绑定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_msgHandlerMap.<span class="built_in">insert</span>(&#123;ADD_FRIEND_MSG,std::<span class="built_in">bind</span>(&amp;ChatService::addFriend,<span class="keyword">this</span>,_1,_2,_3)&#125;);</span><br></pre></td></tr></table></figure><p>在chatservice.hpp声明一个addFriend的函数</p><p>addFriend函数实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加好友业务 msgid id friendid</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::addFriend</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> userid=js[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">    <span class="type">int</span> friendid=js[<span class="string">&quot;friendid&quot;</span>];</span><br><span class="line">    <span class="comment">//存储好友信息</span></span><br><span class="line">    _friendModel.<span class="built_in">insert</span>(userid,friendid);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里收到的json消息格式为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;msgid&quot;</span><span class="punctuation">:</span><span class="number">6</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;friendid&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>还有一个问题，在用户登录时，也要好友信息的显示，所以在用户登陆成功时，服务端也要把好友信息发给用户端。</p><p>所以在服务端登录的回复信息这里需要加上好友信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询该用户的好友信息并返回</span></span><br><span class="line">            vector&lt;User&gt; userVec=_friendModel.<span class="built_in">query</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(!userVec.<span class="built_in">empty</span>())&#123;</span><br><span class="line">               vector&lt;string&gt; vec2;</span><br><span class="line">               <span class="keyword">for</span>(User &amp;user:userVec)&#123;</span><br><span class="line">                json js;</span><br><span class="line">                js[<span class="string">&quot;id&quot;</span>]=user.<span class="built_in">getId</span>();</span><br><span class="line">                js[<span class="string">&quot;name&quot;</span>]=user.<span class="built_in">getName</span>();</span><br><span class="line">                js[<span class="string">&quot;state&quot;</span>]=user.<span class="built_in">getState</span>();</span><br><span class="line">                vec<span class="number">2.</span><span class="built_in">push_back</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">               &#125;</span><br><span class="line">               response[<span class="string">&quot;friends&quot;</span>]=vec2;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>这里添加好友的业务就实现了。</p><h3 id="群组业务"><a href="#群组业务" class="headerlink" title="群组业务"></a>群组业务</h3><p>首先要实现群组业务，我在数据库有两张表实现群组业务AllGroup和GroupUser</p><p>AllGroup的数据结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-----------+--------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> Field     <span class="operator">|</span> Type         <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id        <span class="operator">|</span> <span class="type">int</span>          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> groupname <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">50</span>)  <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> groupdesc <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">200</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span>         <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------------+------+-----+---------+----------------+</span></span><br></pre></td></tr></table></figure><p>GroupUSer的数据结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------------+--------------------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field      <span class="operator">|</span> Type                     <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> groupid    <span class="operator">|</span> <span class="type">int</span>                      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> userid     <span class="operator">|</span> <span class="type">int</span>                      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> groupprole <span class="operator">|</span> enum(<span class="string">&#x27;creator&#x27;</span>,<span class="string">&#x27;normal&#x27;</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> normal  <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+--------------------------+------+-----+---------+-------+</span></span><br></pre></td></tr></table></figure><p>groupuser.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GROUPUSER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUPUSER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user.hpp&quot;</span></span></span><br><span class="line"><span class="comment">//群组用户，多了个role角色信息，从User类直接继承，复用User的其他信息</span></span><br><span class="line"><span class="comment">//对应的GroupUser表，但是光是这张表的不够，还要联表查询，所以继承User类。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GroupUser</span>:<span class="keyword">public</span> User&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRole</span><span class="params">(string role)</span></span>&#123;<span class="keyword">this</span>-&gt;role=role;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getRole</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;role;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string role;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>GroupUser类对象是记录关于组成员的详细信息的类，所以继承User。</p><p>group.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GROUP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;groupuser.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//AllGroup表的ORM类但也不完全是还加了储存组用户的数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Group</span>(<span class="type">int</span> id=<span class="number">-1</span>,string name =<span class="string">&quot;&quot;</span>,string desc=<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDesc</span><span class="params">(string desc)</span></span>&#123;<span class="keyword">this</span>-&gt;desc=desc;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;GroupUser&gt; &amp;<span class="title">getUsers</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;users;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//组id</span></span><br><span class="line">    string name;<span class="comment">//组名</span></span><br><span class="line">    string desc;<span class="comment">//组功能描述</span></span><br><span class="line">    vector&lt;GroupUser&gt; users;<span class="comment">//组员的详细信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>Group类对象是AllGroup表的ORM类，但也不完全，这个类还添加了存储组成员详细信息的结构vector<GroupUser> users;</GroupUser></p><p>因为这两张表的关联系很大，所以我们第一这个群组业务的数据操作接口。</p><p>groupmodel.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GROUPMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUPMODEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;group.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//维护群组信息的操作接口方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GroupModel</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//创建群组</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">createGroup</span><span class="params">(Group &amp;group)</span></span>;</span><br><span class="line">    <span class="comment">//加入群组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addGroup</span><span class="params">(<span class="type">int</span> userid,<span class="type">int</span> groupid,string role)</span></span>;</span><br><span class="line">    <span class="comment">//查询用户所在群组消息</span></span><br><span class="line">    <span class="function">vector&lt;Group&gt; <span class="title">queryGroups</span><span class="params">(<span class="type">int</span> userid)</span></span>;</span><br><span class="line">    <span class="comment">//根据指定的groupid查询群组用户id列表，除userid自己，主要用户群聊业务给群组其他成员群发消息。</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">queryGroupUsers</span><span class="params">(<span class="type">int</span> userid,<span class="type">int</span> groupid)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>对应函数实现</p><p>创建群组createGroup函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建群组</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GroupModel::createGroup</span><span class="params">(Group &amp;group)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;insert into AllGroup(groupname,groupdesc) values(&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>,group.<span class="built_in">getName</span>().<span class="built_in">c_str</span>(),group.<span class="built_in">getDesc</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(mysql.<span class="built_in">update</span>(sql))&#123;</span><br><span class="line">            group.<span class="built_in">setId</span>(<span class="built_in">mysql_insert_id</span>(mysql.<span class="built_in">getConnection</span>()));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将组名和组介绍存到AllGroup表中。</p><p>加入群组addGroup函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入群组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GroupModel::addGroup</span><span class="params">(<span class="type">int</span> userid, <span class="type">int</span> groupid, string role)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.组装sql语句</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;insert into GroupUser values(%d,%d,&#x27;%s&#x27;)&quot;</span>,groupid,userid,role.<span class="built_in">c_str</span>());</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">       mysql.<span class="built_in">update</span>(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F; 查询用户所在群组信息queryGroups</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户所在群组消息</span></span><br><span class="line"><span class="function">vector&lt;Group&gt; <span class="title">GroupModel::queryGroups</span><span class="params">(<span class="type">int</span> userid)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.先根据userid在GroupUser表中查询该用户所属的群组消息</span></span><br><span class="line">    <span class="comment">// 2.再根据群组消息，查询属于该群组的所有用户的userid,并且和User表进行多表联合查询，查出用户的详细信息</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;select a.id,a.groupname,a.groupdesc from AllGroup a inner join GroupUser b on a.id=b.groupid where b.userid=%d&quot;</span>,userid);</span><br><span class="line">    vector&lt;Group&gt; groupVec;</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        MYSQL_RES *res=mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            MYSQL_ROW row;</span><br><span class="line">            <span class="comment">//查出userid所有的群组消息</span></span><br><span class="line">            <span class="keyword">while</span>((row=<span class="built_in">mysql_fetch_row</span>(res))!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                Group group;</span><br><span class="line">                group.<span class="built_in">setId</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">                group.<span class="built_in">setName</span>(row[<span class="number">1</span>]);</span><br><span class="line">                group.<span class="built_in">setDesc</span>(row[<span class="number">2</span>]);</span><br><span class="line">                groupVec.<span class="built_in">push_back</span>(group);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询群组的用户信息</span></span><br><span class="line">    <span class="keyword">for</span>(Group &amp;group:groupVec)&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(sql,<span class="string">&quot;select a.id,a.name,a.state,b.grouprole from User a inner join GroupUser b on b.userid=a.id where b.groupid=%d&quot;</span>,group.<span class="built_in">getId</span>());</span><br><span class="line">        MYSQL_RES *res=mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            MYSQL_ROW row;</span><br><span class="line">            <span class="keyword">while</span>((row=<span class="built_in">mysql_fetch_row</span>(res))!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                GroupUser user;</span><br><span class="line">                user.<span class="built_in">setId</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">                user.<span class="built_in">setName</span>(row[<span class="number">1</span>]);</span><br><span class="line">                user.<span class="built_in">setState</span>(row[<span class="number">2</span>]);</span><br><span class="line">                user.<span class="built_in">setRole</span>(row[<span class="number">3</span>]);</span><br><span class="line">                group.<span class="built_in">getUsers</span>().<span class="built_in">push_back</span>(user);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> groupVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据指定的groupid查询群组用户id列表，除userid自己。queryGroupUsers函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据指定的groupid查询群组用户id列表，除userid自己，主要用户群聊业务给群组其他成员群发消息。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GroupModel::queryGroupUsers</span><span class="params">(<span class="type">int</span> userid, <span class="type">int</span> groupid)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> sql[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;select userid from GroupUser where groupid=%d and userid!=%d&quot;</span>,groupid,userid);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; idVec;</span><br><span class="line">    MySQL mysql;</span><br><span class="line">    <span class="keyword">if</span>(mysql.<span class="built_in">connect</span>())&#123;</span><br><span class="line">        MYSQL_RES *res=mysql.<span class="built_in">query</span>(sql);</span><br><span class="line">        <span class="keyword">if</span>(res!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            MYSQL_ROW row;</span><br><span class="line">            <span class="keyword">while</span>((row=<span class="built_in">mysql_fetch_row</span>(res))!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                idVec.<span class="built_in">push_back</span>(<span class="built_in">atoi</span>(row[<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idVec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成这些在业务类使用这些功能</p><p>首先在public.hpp更新消息类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE_GROUP_MSG,<span class="comment">//创建群组</span></span><br><span class="line">    ADD_GROUP_MSG,<span class="comment">//加入群组</span></span><br><span class="line">    GROUP_CHAT_MSG,<span class="comment">//群聊天</span></span><br></pre></td></tr></table></figure><p>在业务类ChatService中添加对应的数据操作类对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GroupModel _groupModel;</span><br></pre></td></tr></table></figure><p>加入功能实现函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建群组业务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createGroup</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>;</span><br><span class="line">    <span class="comment">//加入群组业务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addGroup</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>;</span><br><span class="line">    <span class="comment">//群组聊天业务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">groupChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>;</span><br></pre></td></tr></table></figure><p>创建群组业务:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建群组业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::createGroup</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> userid=js[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">    string name=js[<span class="string">&quot;groupname&quot;</span>];</span><br><span class="line">    string desc=js[<span class="string">&quot;groupdesc&quot;</span>];</span><br><span class="line">    <span class="comment">//存储新创建的群组消息</span></span><br><span class="line">    <span class="function">Group <span class="title">group</span><span class="params">(<span class="number">-1</span>,name,desc)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(_groupModel.<span class="built_in">createGroup</span>(group))&#123;</span><br><span class="line">        <span class="comment">//存储群组创建人消息</span></span><br><span class="line">        _groupModel.<span class="built_in">addGroup</span>(userid,group.<span class="built_in">getId</span>(),<span class="string">&quot;creator&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入群组业务:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入群组业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::addGroup</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> userid=js[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">    <span class="type">int</span> groupid=js[<span class="string">&quot;groupid&quot;</span>];</span><br><span class="line">    _groupModel.<span class="built_in">addGroup</span>(userid,groupid,<span class="string">&quot;normal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>群组聊天业务:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//群组聊天业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::groupChat</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> userid=js[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">    <span class="type">int</span> groupid=js[<span class="string">&quot;groupid&quot;</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; useridVec=_groupModel.<span class="built_in">queryGroupUsers</span>(userid,groupid);</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id:useridVec)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> it=_userConnMap.<span class="built_in">find</span>(id);</span><br><span class="line">        <span class="keyword">if</span>(it!=_userConnMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//转发群消息</span></span><br><span class="line">            it-&gt;second-&gt;<span class="built_in">send</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//存储离线群消息</span></span><br><span class="line">            _offlineMsgModel.<span class="built_in">insert</span>(id,js.<span class="built_in">dump</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要在构造函数绑定消息对应函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//群组业务注册</span></span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(&#123;CREATE_GROUP_MSG,std::<span class="built_in">bind</span>(&amp;ChatService::createGroup,<span class="keyword">this</span>,_1,_2,_3)&#125;);</span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(&#123;ADD_GROUP_MSG,std::<span class="built_in">bind</span>(&amp;ChatService::addGroup,<span class="keyword">this</span>,_1,_2,_3)&#125;);</span><br><span class="line">    _msgHandlerMap.<span class="built_in">insert</span>(&#123;GROUP_CHAT_MSG,std::<span class="built_in">bind</span>(&amp;ChatService::groupChat,<span class="keyword">this</span>,_1,_2,_3)&#125;);</span><br></pre></td></tr></table></figure><p>当然在用户登录成功时，还要把群组的信息发给客户端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询用户的群组信息</span></span><br><span class="line">            vector&lt;Group&gt; groupuserVec=_groupModel.<span class="built_in">queryGroups</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(!groupuserVec.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="comment">//group:[&#123;groupid:[xxx,xxx,xxx,xxx]&#125;]</span></span><br><span class="line">                vector&lt;string&gt; groupV;</span><br><span class="line">                <span class="keyword">for</span>(Group &amp;group:groupuserVec)&#123;</span><br><span class="line">                    json grpjson;</span><br><span class="line">                    grpjson[<span class="string">&quot;id&quot;</span>]=group.<span class="built_in">getId</span>();</span><br><span class="line">                    grpjson[<span class="string">&quot;groupname&quot;</span>]=group.<span class="built_in">getName</span>();</span><br><span class="line">                    grpjson[<span class="string">&quot;groupdesc&quot;</span>]=group.<span class="built_in">getDesc</span>();</span><br><span class="line">                    vector&lt;string&gt; userV;</span><br><span class="line">                    <span class="keyword">for</span>(GroupUser &amp;user:group.<span class="built_in">getUsers</span>())&#123;</span><br><span class="line">                        json js;</span><br><span class="line">                        js[<span class="string">&quot;id&quot;</span>]=user.<span class="built_in">getId</span>();</span><br><span class="line">                        js[<span class="string">&quot;name&quot;</span>]=user.<span class="built_in">getName</span>();</span><br><span class="line">                        js[<span class="string">&quot;state&quot;</span>]=user.<span class="built_in">getState</span>();</span><br><span class="line">                        js[<span class="string">&quot;role&quot;</span>]=user.<span class="built_in">getRole</span>();</span><br><span class="line">                        userV.<span class="built_in">push_back</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                    grpjson[<span class="string">&quot;users&quot;</span>]=userV;</span><br><span class="line">                    groupV.<span class="built_in">push_back</span>(grpjson.<span class="built_in">dump</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                response[<span class="string">&quot;groups&quot;</span>]=groupV;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>群组业务就完成了。</p><h3 id="客户端开发-首页面开发"><a href="#客户端开发-首页面开发" class="headerlink" title="客户端开发-首页面开发"></a>客户端开发-首页面开发</h3><p>首先在src&#x2F;client编写CMakeLists.txt和main.cpp</p><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义了一个SRC_LIST变量，包含了该目录下所有的源文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定生成可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(ChatClient <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment">#指定可执行文件链接时所需要依赖的库文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(ChatClient pthread)</span><br></pre></td></tr></table></figure><p>main.cpp编写我们的客户端程序</p><p>首先保存的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录当前系统登录的用户信息</span></span><br><span class="line">User g_currentUser;</span><br><span class="line"><span class="comment">//记录当前登录用户的好友列表信息</span></span><br><span class="line">vector&lt;User&gt; g_currentUserFriendList;</span><br><span class="line"><span class="comment">//记录当前登录用户的群组列表信息</span></span><br><span class="line">vector&lt;Group&gt; g_currentUserGroupList;</span><br></pre></td></tr></table></figure><p>目前的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示当前登录成功用户的基本信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showCurrentUserData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//接受线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTaskHandler</span><span class="params">(<span class="type">int</span> clientfd)</span></span>;</span><br><span class="line"><span class="comment">//获取系统时间(聊天信息需要添加时间信息)</span></span><br><span class="line"><span class="function">string <span class="title">getCurrentTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//主聊天页面程序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mainMenu</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>主线程main函数</p><p>int main(int argc,char **argv) </p><p>参数说明：</p><ul><li><code>int argc</code>：Argument Count，命令行参数的数量（包括程序本身的名称）。</li><li><code>char **argv</code>：Argument Vector，命令行参数的数组。<code>argv[0]</code> 是程序的名字，<code>argv[1]</code> 到 <code>argv[argc-1]</code> 是你在命令行中输入的其他参数。</li></ul><p>在命令行运行.&#x2F;ChatClient 127.0.0.1 6000即可运行</p><h4 id="客户端和服务端的连接"><a href="#客户端和服务端的连接" class="headerlink" title="客户端和服务端的连接"></a>客户端和服务端的连接</h4><p>首先客户端和服务端的连接代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">3</span>)&#123;</span><br><span class="line">    cerr&lt;&lt;<span class="string">&quot;command invalid!example:./ChatClient 127.0.0.1 6000&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//异常退出 exit(0)是正常退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析通过命令行参数传递的ip和port</span></span><br><span class="line"><span class="type">char</span> *ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="type">uint16_t</span> port=<span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//创建client端的socket</span></span><br><span class="line"><span class="type">int</span> clientfd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span>==clientfd)&#123;</span><br><span class="line">    cerr&lt;&lt;<span class="string">&quot;socket create error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//填写client需要连接的server信息ip+port</span></span><br><span class="line">sockaddr_in server;</span><br><span class="line"><span class="built_in">memset</span>(&amp;server,<span class="number">0</span>,<span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line">server.sin_family=AF_INET;</span><br><span class="line">server.sin_port=<span class="built_in">htons</span>(port);</span><br><span class="line">server.sin_addr.s_addr=<span class="built_in">inet_addr</span>(ip);</span><br><span class="line"><span class="comment">//client和server进行连接</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span>==<span class="built_in">connect</span>(clientfd,(sockaddr *)&amp;server,<span class="built_in">sizeof</span>(sockaddr_in)))&#123;</span><br><span class="line">    cerr &lt;&lt;<span class="string">&quot;connect server error&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">close</span>(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其中的函数解释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> clientfd=<span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>socket函数功能：创建一个 TCP 套接字（socket）</p><p>其中的socket函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure><p> 各个参数含义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">socket</span>(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span><br></pre></td></tr></table></figure><ol><li><code>AF_INET</code>（地址族）</li></ol><ul><li>指定使用 <strong>IPv4</strong> 地址（Internet Protocol version 4）。</li><li>如果是 <code>AF_INET6</code>，那就是 IPv6。</li></ul><ol start="2"><li><code>SOCK_STREAM</code>（套接字类型）</li></ol><ul><li>表示使用的是 <strong>面向连接的、可靠的、基于字节流</strong> 的通信方式。</li><li>通常对应 <strong>TCP</strong> 协议。</li></ul><ol start="3"><li><code>0</code>（协议编号）</li></ol><ul><li>填 <code>0</code> 表示让系统根据前两个参数自动选择合适的协议。</li><li>对于 <code>AF_INET + SOCK_STREAM</code>，系统会自动选择 <strong>TCP</strong> 协议。</li></ul><p>返回值：</p><ul><li>成功时返回一个非负整数（<strong>文件描述符</strong>，也就是 <code>clientfd</code>），用于后续的读写操作。</li><li>失败时返回 <code>-1</code>，常见原因包括：系统资源耗尽、参数错误等。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in server;</span><br></pre></td></tr></table></figure><p><code>sockaddr_in</code> 是 C&#x2F;C++ 中专门用来表示 <strong>IPv4 网络地址</strong> 的结构体。</p><p>对应的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;server,<span class="number">0</span>,<span class="built_in">sizeof</span>(sockaddr_in));</span><br></pre></td></tr></table></figure><p>把 <code>server</code> 结构体从首地址开始，连续 <code>sizeof(server)</code> 个字节都设置为 <code>0</code>。</p><p>memset函数用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">int</span> value, <span class="type">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p> 参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>ptr</code></td><td>指向要被设置的内存的指针</td></tr><tr><td><code>value</code></td><td>要设置的值（会被转换为 <code>unsigned char</code> 类型）</td></tr><tr><td><code>num</code></td><td>要设置的字节数</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.sin_family=AF_INET;</span><br><span class="line">server.sin_port=<span class="built_in">htons</span>(port);</span><br><span class="line">server.sin_addr.s_addr=<span class="built_in">inet_addr</span>(ip);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.sin_family = AF_INET;</span><br></pre></td></tr></table></figure><ul><li>表示使用的地址类型是 <strong>IPv4</strong>。</li><li><code>AF_INET</code> 是 <strong>Address Family Internet</strong> 的缩写。</li><li>这是 <code>sockaddr_in</code> 中的 <code>sin_family</code> 字段，必须设置为 <code>AF_INET</code>，否则系统无法识别地址格式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.sin_port = <span class="built_in">htons</span>(port);</span><br></pre></td></tr></table></figure><ul><li>设置端口号，例如：6000。</li><li><code>htons()</code> 是 <strong>Host to Network Short</strong> 的缩写：h<ul><li>它把本地主机的字节序（可能是小端）转换为网络字节序（大端）。</li><li>因为 TCP&#x2F;IP 协议使用大端字节序进行数据传输。</li></ul></li><li><code>port</code> 是你从命令行传进来的端口号字符串转成的整数。</li></ul><p>htons函数头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br></pre></td></tr></table></figure><p> 端口必须转换成网络字节序，否则客户端连接服务器时会出错！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br></pre></td></tr></table></figure><ul><li>设置 IP 地址。</li><li><code>inet_addr()</code> 函数把点分十进制的 IP 字符串（如 <code>&quot;127.0.0.1&quot;</code>）转换成 32 位的二进制整数。</li><li>转换后的结果赋值给 <code>sin_addr.s_addr</code>，用于 socket 连接。</li></ul><p>inet_addr函数头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client和server进行连接</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span>==<span class="built_in">connect</span>(clientfd,(sockaddr *)&amp;server,<span class="built_in">sizeof</span>(sockaddr_in)))&#123;</span><br><span class="line">        cerr &lt;&lt;<span class="string">&quot;connect server error&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">close</span>(clientfd);<span class="comment">//释放socket资源</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>connect()</code> 函数详解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>sockfd</code></td><td>用 <code>socket()</code> 创建的套接字文件描述符（即 <code>clientfd</code>）</td></tr><tr><td><code>addr</code></td><td>服务器地址结构指针（需要强转成 <code>sockaddr*</code> 类型）</td></tr><tr><td><code>addrlen</code></td><td><code>addr</code> 结构体的大小，通常是 <code>sizeof(sockaddr_in)</code></td></tr></tbody></table><h4 id="客户端业务实现"><a href="#客户端业务实现" class="headerlink" title="客户端业务实现"></a>客户端业务实现</h4><p>首先在一个死循环中实现循环选择：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示首页面菜单 登录,注册，退出</span></span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;==================================&quot;</span>&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;1. login&quot;</span>&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;2. register&quot;</span>&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;3. quit&quot;</span>&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;==================================&quot;</span>&lt;&lt;endl;</span><br><span class="line">       cout&lt;&lt; <span class="string">&quot;choice:&quot;</span>;</span><br><span class="line">       <span class="type">int</span> choice=<span class="number">0</span>;</span><br><span class="line">       cin&gt;&gt;choice;</span><br><span class="line">       cin.<span class="built_in">get</span>();<span class="comment">//读掉缓冲区残留的回车</span></span><br></pre></td></tr></table></figure><p>使用switch语句实现不断选择。</p><h5 id="首先登录业务："><a href="#首先登录业务：" class="headerlink" title="首先登录业务："></a>首先登录业务：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//login业务</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">                <span class="type">char</span> pwd[<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;userid:&quot;</span>;</span><br><span class="line">                cin&gt;&gt; id;</span><br><span class="line">                cin.<span class="built_in">get</span>();<span class="comment">//读掉缓冲区残留的回车</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;user password:&quot;</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(pwd,<span class="number">50</span>);</span><br><span class="line">                json js;</span><br><span class="line">                js[<span class="string">&quot;msgid&quot;</span>]=LOGIN_MSG;</span><br><span class="line">                js[<span class="string">&quot;id&quot;</span>]=id;</span><br><span class="line">                js[<span class="string">&quot;password&quot;</span>]=pwd;</span><br><span class="line">                string request =js.<span class="built_in">dump</span>();</span><br><span class="line">                <span class="type">int</span> len=<span class="built_in">send</span>(clientfd,request.<span class="built_in">c_str</span>(),<span class="built_in">strlen</span>(request.<span class="built_in">c_str</span>())<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len==<span class="number">-1</span>)&#123;</span><br><span class="line">                    cerr&lt;&lt;<span class="string">&quot;send login msg error:&quot;</span>&lt;&lt;request&lt;&lt;endl;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">char</span> buffer[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    len=<span class="built_in">recv</span>(clientfd,buffer,<span class="number">1024</span>,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(len==<span class="number">-1</span>)&#123;</span><br><span class="line">                        cerr &lt;&lt;<span class="string">&quot;recv login response error&quot;</span>&lt;&lt;endl;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        json responsejs=json::<span class="built_in">parse</span>(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(responsejs[<span class="string">&quot;errno&quot;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                            cerr&lt;&lt;responsejs[<span class="string">&quot;errmsg&quot;</span>]&lt;&lt;endl;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;<span class="comment">//登录成功</span></span><br><span class="line">                            <span class="comment">//记录当前用户的id和name</span></span><br><span class="line">                            g_currentUser.<span class="built_in">setId</span>(responsejs[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">                            g_currentUser.<span class="built_in">setName</span>(responsejs[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">                            <span class="comment">//记录当前用户的好友列表信息</span></span><br><span class="line">                            <span class="keyword">if</span>(responsejs.<span class="built_in">contains</span>(<span class="string">&quot;friends&quot;</span>))&#123;<span class="comment">//看是否包含friends这个键</span></span><br><span class="line">                                vector&lt;string&gt; vec=responsejs[<span class="string">&quot;friends&quot;</span>];</span><br><span class="line">                                <span class="keyword">for</span>(string &amp;str:vec)&#123;</span><br><span class="line">                                    json js=json::<span class="built_in">parse</span>(str);</span><br><span class="line">                                    User user;</span><br><span class="line">                                    user.<span class="built_in">setId</span>(js[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">                                    user.<span class="built_in">setName</span>(js[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">                                    user.<span class="built_in">setState</span>(js[<span class="string">&quot;state&quot;</span>]);</span><br><span class="line">                                    g_currentUserFriendList.<span class="built_in">push_back</span>(user);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//记录当前用户的群组列表信息</span></span><br><span class="line">                            <span class="keyword">if</span>(responsejs.<span class="built_in">contains</span>(<span class="string">&quot;groups&quot;</span>))&#123;</span><br><span class="line">                                vector&lt;string&gt; vec1=responsejs[<span class="string">&quot;groups&quot;</span>];</span><br><span class="line">                                <span class="keyword">for</span>(string &amp;groupstr:vec1)&#123;</span><br><span class="line">                                    json grpjs=json::<span class="built_in">parse</span>(groupstr);</span><br><span class="line">                                    Group group;</span><br><span class="line">                                    group.<span class="built_in">setId</span>(grpjs[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">                                    group.<span class="built_in">setName</span>(grpjs[<span class="string">&quot;groupname&quot;</span>]);</span><br><span class="line">                                    group.<span class="built_in">setDesc</span>(grpjs[<span class="string">&quot;groupdesc&quot;</span>]);</span><br><span class="line">                                    vector&lt;string&gt; vec2=grpjs[<span class="string">&quot;users&quot;</span>];</span><br><span class="line">                                    <span class="keyword">for</span>(string &amp;userstr:vec2)&#123;</span><br><span class="line">                                        GroupUser user;</span><br><span class="line">                                        json js=json::<span class="built_in">parse</span>(userstr);</span><br><span class="line">                                        user.<span class="built_in">setId</span>(js[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">                                        user.<span class="built_in">setName</span>(js[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">                                        user.<span class="built_in">setState</span>(js[<span class="string">&quot;state&quot;</span>]);</span><br><span class="line">                                        user.<span class="built_in">setRole</span>(js[<span class="string">&quot;role&quot;</span>]);</span><br><span class="line">                                        group.<span class="built_in">getUsers</span>().<span class="built_in">push_back</span>(user);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    g_currentUserGroupList.<span class="built_in">push_back</span>(group);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//显示登录用户的基本信息</span></span><br><span class="line">                            <span class="built_in">showCurrentUserData</span>();</span><br><span class="line">                            <span class="comment">//显示当前用户的离线消息 个人聊天消息或者群组消息</span></span><br><span class="line">                            <span class="keyword">if</span>(responsejs.<span class="built_in">contains</span>(<span class="string">&quot;offlinemsg&quot;</span>))&#123;</span><br><span class="line">                                vector&lt;string&gt; vec=responsejs[<span class="string">&quot;offlinemsg&quot;</span>];</span><br><span class="line">                                <span class="keyword">for</span>(string &amp;str:vec)&#123;</span><br><span class="line">                                    json js=json::<span class="built_in">parse</span>(str);</span><br><span class="line">                                    <span class="comment">//time +[id]+name+&quot;said: &quot;+xxx</span></span><br><span class="line">                                    cout&lt;&lt;js[<span class="string">&quot;time&quot;</span>]&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;js[<span class="string">&quot;id&quot;</span>]&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;js[<span class="string">&quot;name&quot;</span>]&lt;&lt;<span class="string">&quot; said &quot;</span>&lt;&lt;js[<span class="string">&quot;msg&quot;</span>]&lt;&lt;endl;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//登录成功，启动接受线程负责接受数据</span></span><br><span class="line">                            <span class="function">std::thread <span class="title">readTask</span><span class="params">(readTaskHandler,clientfd)</span></span>;</span><br><span class="line">                            readTask.<span class="built_in">detach</span>();</span><br><span class="line">                            <span class="comment">//进入聊天主菜单页面</span></span><br><span class="line">                            <span class="built_in">mainMenu</span>();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这里解释一些函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len=<span class="built_in">send</span>(clientfd,request.<span class="built_in">c_str</span>(),<span class="built_in">strlen</span>(request.<span class="built_in">c_str</span>())<span class="number">+1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>通过 <code>send()</code> 函数将字符串 <code>request</code> 的内容发送到套接字 <code>clientfd</code> 所代表的对端。</p><p>各参数详解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">send</span>(socket, buffer, length, flags)</span><br></pre></td></tr></table></figure><ul><li><code>clientfd</code>：套接字描述符，表示要发送数据的目标。</li><li><code>request.c_str()</code>：将 <code>std::string</code> 类型的 <code>request</code> 转为 C 风格的字符串（返回 <code>const char*</code> 指针）。c++</li><li><code>strlen(request.c_str()) + 1</code>：表示发送的数据长度，<code>+1</code> 是为了包括字符串末尾的 <code>\0</code>（空字符终止符），这是为了让接收方知道字符串结束。</li><li><code>0</code>：表示不使用额外的标志（默认行为）。</li></ul><p>关于返回值：</p><table><thead><tr><th>返回值 <code>len</code></th><th>意义说明</th></tr></thead><tbody><tr><td>&gt; 0</td><td>成功发送了 <code>len</code> 字节的数据</td></tr><tr><td>&#x3D;&#x3D; 0</td><td>TCP 连接被优雅关闭（几乎不会出现在 <code>send()</code>，常出现在 <code>recv()</code>）</td></tr><tr><td>&#x3D;&#x3D; -1</td><td>发送失败，需检查 <code>errno</code> 查看错误原因</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len=<span class="built_in">recv</span>(clientfd,buffer,<span class="number">1024</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>从 <code>clientfd</code> 套接字接收最多 1024 字节的数据，存入 <code>buffer</code> 缓冲区中</strong>。</p><p>各参数详解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">recv</span>(socket, buffer, length, flags)</span><br></pre></td></tr></table></figure><ul><li><code>clientfd</code>：连接的套接字描述符（已连接的对端）。</li><li><code>buffer</code>：用于存放接收数据的内存区域（<code>char buffer[1024];</code> 或 <code>char* buffer = new char[1024];</code>）。</li><li><code>1024</code>：最多接收 1024 字节（防止缓冲区溢出）。</li><li><code>0</code>：标志位，通常设置为 0（表示默认阻塞接收）。</li></ul><p>返回值说明（关键点）：</p><table><thead><tr><th>返回值 <code>len</code></th><th>意义说明</th></tr></thead><tbody><tr><td>&gt; 0</td><td>实际接收到的数据字节数（并不一定等于 1024）</td></tr><tr><td>&#x3D;&#x3D; 0</td><td><strong>连接已关闭</strong>（对方调用了 <code>close()</code>）</td></tr><tr><td>&#x3D;&#x3D; -1</td><td><strong>接收失败</strong>，可通过 <code>errno</code> 查看错误原因</td></tr></tbody></table><p>注意recv() 并不会自动在 buffer 的末尾添加 ‘\0‘</p><p>所以我们定义buffer:保证末尾有’\0‘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登录成功，启动接受线程负责接受数据</span></span><br><span class="line">                            <span class="function">std::thread <span class="title">readTask</span><span class="params">(readTaskHandler,clientfd)</span></span>;</span><br><span class="line">                            readTask.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure><p>创建了一个<strong>新线程</strong>，并立刻将它<strong>分离（detach）</strong>，用来异步执行函数 <code>readTaskHandler(clientfd)</code>。</p><p>分析每一行作用：</p><ol><li><code>std::thread readTask(readTaskHandler, clientfd);</code></li></ol><ul><li>创建一个线程对象 <code>readTask</code>，该线程会立即开始运行 <code>readTaskHandler(clientfd)</code>。</li><li>通常用于处理客户端请求，比如接收数据、解析消息等。</li></ul><ol start="2"><li><code>readTask.detach();</code></li></ol><ul><li>将线程<strong>分离</strong>，让它独立运行。</li><li><strong>主线程不再管理这个子线程</strong>，也无法调用 <code>join()</code> 等待它。</li><li>线程资源会在线程函数执行完毕后由系统自动回收。</li></ul><p> detach 的 <strong>优点与风险</strong>：</p><p>优点：</p><ul><li>简单，<strong>不阻塞主线程</strong>，不需要显式 <code>join()</code>。</li><li>适合执行时间短、无需主线程等待的任务（比如客户端的消息监听）。</li></ul><p>风险：</p><ol><li><strong>无法再追踪或管理线程</strong>：你不能再 join 或获取其返回状态。</li><li><strong>容易引发悬空引用或资源泄漏问题</strong>：<ul><li>如果 <code>readTaskHandler()</code> 里访问了已经销毁的变量，会崩。</li><li>比如使用了传进来的 <code>clientfd</code> 后，主线程先关闭了它。</li></ul></li><li><strong>调试困难</strong>：detach 后的线程出错更难排查。</li></ol><h5 id="注册业务："><a href="#注册业务：" class="headerlink" title="注册业务："></a>注册业务：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//register业务</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> name[<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">char</span> pwd[<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">                cout&lt;&lt; <span class="string">&quot;username:&quot;</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(name,<span class="number">50</span>);</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;user password:&quot;</span>;</span><br><span class="line">                cin.<span class="built_in">getline</span>(pwd,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">                json js;</span><br><span class="line">                js[<span class="string">&quot;msgid&quot;</span>]=REG_MSG;</span><br><span class="line">                js[<span class="string">&quot;name&quot;</span>]=name;</span><br><span class="line">                js[<span class="string">&quot;password&quot;</span>]=pwd;</span><br><span class="line">                string request=js.<span class="built_in">dump</span>();</span><br><span class="line">                <span class="type">int</span> len=<span class="built_in">send</span>(clientfd,request.<span class="built_in">c_str</span>(),<span class="built_in">strlen</span>(request.<span class="built_in">c_str</span>())<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(len==<span class="number">-1</span>)&#123;</span><br><span class="line">                    cerr &lt;&lt;<span class="string">&quot;send reg msg error:&quot;</span>&lt;&lt;request&lt;&lt;endl;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">char</span> buffer[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    len=<span class="built_in">recv</span>(clientfd,buffer,<span class="number">1024</span>,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(len==<span class="number">-1</span>)&#123;</span><br><span class="line">                        cerr&lt;&lt;<span class="string">&quot;recv reg response error&quot;</span>&lt;&lt;endl;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        json responsejs=json::<span class="built_in">parse</span>(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(<span class="number">0</span>!=responsejs[<span class="string">&quot;errno&quot;</span>])&#123;<span class="comment">//注册失败</span></span><br><span class="line">                            cerr&lt;&lt;name&lt;&lt;<span class="string">&quot;is already exist,register error!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;<span class="comment">//注册成功</span></span><br><span class="line">                            cout&lt;&lt;name&lt;&lt;<span class="string">&quot;register success,userid is &quot;</span>&lt;&lt;responsejs[<span class="string">&quot;id&quot;</span>]&lt;&lt;<span class="string">&quot;, do not forget it!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h5 id="退出业务："><a href="#退出业务：" class="headerlink" title="退出业务："></a>退出业务：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//quit 业务</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">close</span>(clientfd);<span class="comment">//释放连接，不要重复关闭</span></span><br><span class="line">               <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h5 id="聊天主界面业务："><a href="#聊天主界面业务：" class="headerlink" title="聊天主界面业务："></a>聊天主界面业务：</h5><p>首先在登录业务实现，登录成功又该何去何从，所以聊天主界面业务，首先在登录业务有几个函数，还没有实现，实现一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示登录用户的基本信息</span></span><br><span class="line"><span class="built_in">showCurrentUserData</span>();</span><br></pre></td></tr></table></figure><p>具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示当前登录成功用户的基本信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showCurrentUserData</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;==========================login user==============================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;current login user =&gt;id:&quot;</span>&lt;&lt;g_currentUser.<span class="built_in">getId</span>()&lt;&lt;<span class="string">&quot;name:&quot;</span>&lt;&lt;g_currentUser.<span class="built_in">getName</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-------------------------friend list------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(!g_currentUserFriendList.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(User &amp;user:g_currentUserFriendList)&#123;</span><br><span class="line">            cout&lt;&lt;user.<span class="built_in">getId</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;user.<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;user.<span class="built_in">getState</span>() &lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------------------group list-------------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(!g_currentUserGroupList.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(Group &amp;group:g_currentUserGroupList)&#123;</span><br><span class="line">            cout&lt;&lt;group.<span class="built_in">getId</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;group.<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;group.<span class="built_in">getDesc</span>()&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">for</span>(GroupUser &amp;user:group.<span class="built_in">getUsers</span>())&#123;</span><br><span class="line">                cout&lt;&lt;user.<span class="built_in">getId</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;user.<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;user.<span class="built_in">getState</span>()&lt;&lt;user.<span class="built_in">getRole</span>()&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;====================================================================&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登录成功，启动接受线程负责接受数据</span></span><br><span class="line"><span class="function">std::thread <span class="title">readTask</span><span class="params">(readTaskHandler,clientfd)</span></span>;</span><br><span class="line">readTask.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure><p>其中readTaskHandler的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readTaskHandler</span><span class="params">(<span class="type">int</span> clientfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len =<span class="built_in">recv</span>(clientfd,buffer,<span class="number">1024</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span>==len||<span class="number">0</span>==len)&#123;</span><br><span class="line">            <span class="built_in">close</span>(clientfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接收ChatServer转发的数据，反序列化生成json数据对象</span></span><br><span class="line">        json js=json::<span class="built_in">parse</span>(buffer);</span><br><span class="line">        <span class="keyword">if</span>(ONE_CHAT_MSG==js[<span class="string">&quot;msgid&quot;</span>])&#123;</span><br><span class="line">            cout&lt;&lt;js[<span class="string">&quot;time&quot;</span>].<span class="built_in">get</span>&lt;string&gt;()&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;js[<span class="string">&quot;id&quot;</span>]&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;js[<span class="string">&quot;name&quot;</span>].<span class="built_in">get</span>&lt;string&gt;()&lt;&lt; <span class="string">&quot; said: &quot;</span>&lt;&lt;js[<span class="string">&quot;msg&quot;</span>].<span class="built_in">get</span>&lt;string&gt;()&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是用来接受服务端发来的消息的。主线程是发消息的。但是当前就实现了关于一对一聊天的接受消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入聊天主菜单页面</span></span><br><span class="line"> <span class="built_in">mainMenu</span>(clientfd);</span><br></pre></td></tr></table></figure><p>进入聊天主菜单页面实现具体的业务：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主聊天页面程序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mainMenu</span><span class="params">(<span class="type">int</span> clientfd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">help</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        cin.<span class="built_in">getline</span>(buffer,<span class="number">1024</span>);</span><br><span class="line">        <span class="function">string <span class="title">commandbuf</span><span class="params">(buffer)</span></span>;</span><br><span class="line">        string command;</span><br><span class="line">        <span class="type">int</span> idx=commandbuf.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx==<span class="number">-1</span>)&#123;</span><br><span class="line">            command=commandbuf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            command=commandbuf.<span class="built_in">substr</span>(<span class="number">0</span>,idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it=commandHandlerMap.<span class="built_in">find</span>(command);</span><br><span class="line">        <span class="keyword">if</span>(it==commandHandlerMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            cerr&lt;&lt; <span class="string">&quot;invalid input command!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用相应命令的事件处理回调，mainMenu对修改封闭，添加新功能不需要修改该函数</span></span><br><span class="line">        it-&gt;<span class="built_in">second</span>(clientfd,commandbuf.<span class="built_in">substr</span>(idx<span class="number">+1</span>,commandbuf.<span class="built_in">size</span>()-idx));<span class="comment">//调用命令处理方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数实现进入主页面使用对应的指令使用对应的功能。接下来说说其中的变量commandHandlerMap。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册系统支持的客户端命令处理</span></span><br><span class="line">unordered_map&lt;string,function&lt;<span class="type">void</span>(<span class="type">int</span>,string)&gt;&gt;commandHandlerMap=&#123;</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>,help&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;chat&quot;</span>,chat&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;addfriend&quot;</span>,addfriend&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;creategroup&quot;</span>,creategroup&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;addgroup&quot;</span>,addgroup&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;groupchat&quot;</span>,groupchat&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;loginout&quot;</span>,loginout&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过哈希表绑定对应的字符串和对应函数的实现。</p><p>当然在实现这些功能时得要有一个文字说明，这就是help功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;help&quot; command handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">(<span class="type">int</span> fd,string str)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;show command lists:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;p:commandMap)&#123;</span><br><span class="line">        cout&lt;&lt;p.first&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;p.second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这有个细节，因为后续用户如果还想要再次使用help功能，所以把他放在commandHandlerMap中，但是help()函数不满足function&lt;void(int,string)&gt;,所以我们在声明的时候赋初始值，这样就可以直接help()实现了。在其中commandMap也是自己定义提示用户如何使用这些功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统支持的客户端命令列表</span></span><br><span class="line">unordered_map&lt;string,string&gt; commandMap=&#123;</span><br><span class="line">    &#123;<span class="string">&quot;help&quot;</span>,<span class="string">&quot;显示所有支持的命令，格式help&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;chat&quot;</span>,<span class="string">&quot;一对一聊天，格式chat:friendid:message&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;addfriend&quot;</span>,<span class="string">&quot;添加好友，格式addfriend:friendid&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;creategroup&quot;</span>,<span class="string">&quot;创建群组，格式creategroup:groupname:groupdesc&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;addgroup&quot;</span>,<span class="string">&quot;加入群组，格式addgroup:groupid&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;groupchat&quot;</span>,<span class="string">&quot;群聊，格式groupchat:groupid:message&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;loginout&quot;</span>,<span class="string">&quot;注销，格式loginout&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由commandHandlerMap知道要实现的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用相应命令的事件处理回调，mainMenu对修改封闭，添加新功能不需要修改该函数</span></span><br><span class="line">it-&gt;<span class="built_in">second</span>(clientfd,commandbuf.<span class="built_in">substr</span>(idx<span class="number">+1</span>,commandbuf.<span class="built_in">size</span>()-idx));<span class="comment">//调用命令处理方法</span></span><br></pre></td></tr></table></figure><p>这样就可以把具体实现的内容封装到每一个函数中，所以接下来聚集每个实现的函数。</p><h6 id="chat功能实现："><a href="#chat功能实现：" class="headerlink" title="chat功能实现："></a>chat功能实现：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;chat&quot; command handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chat</span><span class="params">(<span class="type">int</span> clientfd,string str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx=str.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);<span class="comment">//friendid:message</span></span><br><span class="line">    <span class="keyword">if</span>(idx==<span class="number">-1</span>)&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;chat command invalid!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> friendid=<span class="built_in">atoi</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>,idx).<span class="built_in">c_str</span>());</span><br><span class="line">    string message=str.<span class="built_in">substr</span>(idx<span class="number">+1</span>,str.<span class="built_in">size</span>()-idx);</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msgid&quot;</span>]=ONE_CHAT_MSG;</span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>]=g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    js[<span class="string">&quot;name&quot;</span>]=g_currentUser.<span class="built_in">getName</span>();</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>] = message;</span><br><span class="line">    js[<span class="string">&quot;toid&quot;</span>]=friendid;</span><br><span class="line">    js[<span class="string">&quot;time&quot;</span>]=<span class="built_in">getCurrentTime</span>();</span><br><span class="line">    string buffer=js.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">send</span>(clientfd,buffer.<span class="built_in">c_str</span>(),<span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>())<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">-1</span>)&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;send chat msg error:&quot;</span>&lt;&lt;buffer&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要实现getCurrentTime函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取系统时间(聊天信息需要添加时间信息)</span></span><br><span class="line"><span class="function">string <span class="title">getCurrentTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> tt = std::chrono::system_clock::<span class="built_in">to_time_t</span>(std::chrono::system_clock::<span class="built_in">now</span>());</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *ptm = <span class="built_in">localtime</span>(&amp;tt);</span><br><span class="line">    <span class="type">char</span> date[<span class="number">60</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(date, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">            (<span class="type">int</span>)ptm-&gt;tm_year + <span class="number">1900</span>, (<span class="type">int</span>)ptm-&gt;tm_mon + <span class="number">1</span>, (<span class="type">int</span>)ptm-&gt;tm_mday,</span><br><span class="line">            (<span class="type">int</span>)ptm-&gt;tm_hour, (<span class="type">int</span>)ptm-&gt;tm_min, (<span class="type">int</span>)ptm-&gt;tm_sec);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="addfriend功能实现："><a href="#addfriend功能实现：" class="headerlink" title="addfriend功能实现："></a>addfriend功能实现：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;addfriend&quot; command handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfriend</span><span class="params">(<span class="type">int</span> clienfd,string str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> friendid=<span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msgid&quot;</span>]=ADD_FRIEND_MSG;</span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>]=g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    js[<span class="string">&quot;friendid&quot;</span>]=friendid;</span><br><span class="line">    string buffer=js.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">send</span>(clienfd,buffer.<span class="built_in">c_str</span>(),<span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>())<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">-1</span>)&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;send addfriend msg error-&gt;&quot;</span>&lt;&lt;buffer&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="creategroup功能实现："><a href="#creategroup功能实现：" class="headerlink" title="creategroup功能实现："></a>creategroup功能实现：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;creategroup&quot; command handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creategroup</span><span class="params">(<span class="type">int</span> clientfd, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = str.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;creategroup command invalid!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string groupname = str.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">    string groupdesc = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msgid&quot;</span>] = CREATE_GROUP_MSG;</span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    js[<span class="string">&quot;groupname&quot;</span>] = groupname;</span><br><span class="line">    js[<span class="string">&quot;groupdesc&quot;</span>] = groupdesc;</span><br><span class="line">    string buffer = js.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;send creategroup msg error:&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="addgroup功能实现："><a href="#addgroup功能实现：" class="headerlink" title="addgroup功能实现："></a>addgroup功能实现：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;addgroup&quot; command handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addgroup</span><span class="params">(<span class="type">int</span> clientfd, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> groupid = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msgid&quot;</span>] = ADD_GROUP_MSG;</span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    js[<span class="string">&quot;groupid&quot;</span>] = groupid;</span><br><span class="line">    string buffer = js.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;send addgroup msg error:&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="groupchat功能实现："><a href="#groupchat功能实现：" class="headerlink" title="groupchat功能实现："></a>groupchat功能实现：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;groupchat&quot; command handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">groupchat</span><span class="params">(<span class="type">int</span> clientfd, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = str.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;groupchat command invalid!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> groupid = <span class="built_in">atoi</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>, idx).<span class="built_in">c_str</span>());</span><br><span class="line">    string message = str.<span class="built_in">substr</span>(idx + <span class="number">1</span>, str.<span class="built_in">size</span>() - idx);</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msgid&quot;</span>] = GROUP_CHAT_MSG;</span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>] = g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    js[<span class="string">&quot;name&quot;</span>] = g_currentUser.<span class="built_in">getName</span>();</span><br><span class="line">    js[<span class="string">&quot;groupid&quot;</span>] = groupid;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>] = message;</span><br><span class="line">    js[<span class="string">&quot;time&quot;</span>] = <span class="built_in">getCurrentTime</span>();</span><br><span class="line">    string buffer = js.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">send</span>(clientfd, buffer.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>()) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;send groupchat msg error:&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现群聊功能后，需要在接受线程实现解析返回的信息，并且输出。服务端在这里是直接将消息转发。所以如下实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (GROUP_CHAT_MSG == msgtype)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;群消息[&quot;</span> &lt;&lt; js[<span class="string">&quot;groupid&quot;</span>] &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; js[<span class="string">&quot;time&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; js[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; js[<span class="string">&quot;name&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot; said: &quot;</span> &lt;&lt; js[<span class="string">&quot;msg&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当然离线消息同时也要输出群组消息.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ONE_CHAT_MSG == js[<span class="string">&quot;msgid&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;())</span><br><span class="line">                                &#123;</span><br><span class="line">                                    cout &lt;&lt; js[<span class="string">&quot;time&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; js[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; js[<span class="string">&quot;name&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot; said: &quot;</span> &lt;&lt; js[<span class="string">&quot;msg&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">                                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                    cout &lt;&lt; <span class="string">&quot;群消息[&quot;</span> &lt;&lt; js[<span class="string">&quot;groupid&quot;</span>] &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; js[<span class="string">&quot;time&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; js[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; js[<span class="string">&quot;name&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot; said: &quot;</span> &lt;&lt; js[<span class="string">&quot;msg&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">                                &#125;</span><br></pre></td></tr></table></figure><p>else部分即为离线群组消息。</p><h6 id="loginout功能实现："><a href="#loginout功能实现：" class="headerlink" title="loginout功能实现："></a>loginout功能实现：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;login out&quot; command handler</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loginout</span><span class="params">(<span class="type">int</span> clientfd, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msgid&quot;</span>]=LOGINOUT_MSG;</span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>]=g_currentUser.<span class="built_in">getId</span>();</span><br><span class="line">    string buffer=js.<span class="built_in">dump</span>();</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">send</span>(clientfd,buffer.<span class="built_in">c_str</span>(),<span class="built_in">strlen</span>(buffer.<span class="built_in">c_str</span>())<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">-1</span>)&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;send loginout msg error:&quot;</span>&lt;&lt;buffer&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        isMainMenuRunning=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个函数实现需要在public.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGINOUT_MSG,<span class="comment">//注销消息</span></span><br></pre></td></tr></table></figure><p>在服务器端做出对应的函数：（记得在构造函数注册注销业务）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理注销业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::loginout</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> userid=js[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it=_userConnMap.<span class="built_in">find</span>(userid);</span><br><span class="line">        <span class="keyword">if</span>(it!=_userConnMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            _userConnMap.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新用户的状态信息</span></span><br><span class="line">    <span class="function">User <span class="title">user</span><span class="params">(userid,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;offline&quot;</span>)</span></span>;</span><br><span class="line">    _userModel.<span class="built_in">updateState</span>(user);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将_userConnMap对应的id的连接删去，并且更新用户的状态。</p><p>isMainMenuRunning是一个全局变量，用来确保loginout后会回到首页。所以默认值为false。当进入主菜单界面时，变为true。这样mainMenu函数就会退出循环，运行结束，进入首页的循环。</p><p>当然这里就出现了一个问题就是loginoutr退出但是程序没有退出，很多全局变量还保留着上一次的值，这就会在输出这些变量时会把上一次登录的用户信息都输出。所以在登录成功时，记得将对应变量初始化清空，再进行赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录当前登录用户的好友列表信息</span></span><br><span class="line">vector&lt;User&gt; g_currentUserFriendList;</span><br><span class="line"><span class="comment">// 记录当前登录用户的群组列表信息</span></span><br><span class="line">vector&lt;Group&gt; g_currentUserGroupList;</span><br></pre></td></tr></table></figure><p>这两个变量在登录成功后，会进行赋值，记得在赋值前，初始化，清空。</p><p>这里还有一个问题，每次登录成功都会创造一个线程，当我在loginout后再次登录，又创造了一个新线程。所以要保证只有一个线程实现接受。所以在登录成功部分修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 登录成功，启动接受线程负责接受数据 ,该线程只启动一次</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> readthreadnumber=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(readthreadnumber==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">readTask</span><span class="params">(readTaskHandler, clientfd)</span></span>; <span class="comment">// 在Linux pthread_create</span></span><br><span class="line">readTask.<span class="built_in">detach</span>();</span><br><span class="line">readthreadnumber++;                               <span class="comment">// Linux pthread_detach</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入负载均衡器："><a href="#引入负载均衡器：" class="headerlink" title="引入负载均衡器："></a>引入负载均衡器：</h3><p>以上我们基本完成了客户端和服务端的开发，由于是一个聊天服务器，要考虑一台服务器同时可以多少用户在线。我借用muduo模型创建 1个主线程（accept连接）+ 4个子线程（处理连接和事件）总共 5个线程，用于服务端 I&#x2F;O。主线程用于 accept 新连接4 个 <code>EventLoop</code> 子线程处理客户端连接的 I&#x2F;O 事件（读写、消息分发等）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置线程数量</span></span><br><span class="line">_server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="操作系统的限制"><a href="#操作系统的限制" class="headerlink" title="操作系统的限制"></a><strong>操作系统的限制</strong></h4><p>操作系统对单个进程的文件描述符数量有限制，每个客户端连接通常占用一个文件描述符（socket）。</p><ul><li><strong>Linux默认值</strong>（可以用 <code>ulimit -n</code> 查看）：通常是 <strong>1024</strong>，也就是说一个进程默认最多只能同时处理约1000个客户端连接。</li></ul><h4 id="实际可支持的并发连接数（估算）："><a href="#实际可支持的并发连接数（估算）：" class="headerlink" title="实际可支持的并发连接数（估算）："></a>实际可支持的并发连接数（估算）：</h4><table><thead><tr><th>类型</th><th>数量</th></tr></thead><tbody><tr><td>Idle连接（不活跃）</td><td>40,000 ~ 100,000（受内核和 FD 限制）</td></tr><tr><td>活跃连接（频繁收发消息）</td><td>10,000 ~ 20,000（实际取决于业务逻辑复杂度）</td></tr></tbody></table><p>这是<strong>单进程、多线程、epoll</strong> 架构下的典型并发能力，非常高效。</p><h4 id="什么是-Idle连接（不活跃连接）？"><a href="#什么是-Idle连接（不活跃连接）？" class="headerlink" title="什么是 Idle连接（不活跃连接）？"></a>什么是 <strong>Idle连接（不活跃连接）</strong>？</h4><p><strong>Idle（空闲）连接</strong> 是指：</p><p>客户端虽然 <strong>已经建立了连接</strong>，但 <strong>长时间没有发送或接收任何数据</strong>，也就是说：</p><ul><li><strong>连接处于打开状态（TCP连接存在）</strong></li><li>但没有发生 <strong>读写事件</strong></li><li>占用资源极少（仅占用文件描述符、少量内存）</li></ul><h4 id="为什么要区分-Idle-与-活跃连接？"><a href="#为什么要区分-Idle-与-活跃连接？" class="headerlink" title="为什么要区分 Idle 与 活跃连接？"></a>为什么要区分 Idle 与 活跃连接？</h4><ol><li><strong>资源占用不同</strong></li></ol><ul><li>Idle 连接不产生消息，不触发回调，服务器处理负担极低</li><li>活跃连接需要处理消息、业务逻辑，负担高</li></ul><ol start="2"><li><strong>并发能力的评估</strong></li></ol><ul><li>很多高并发服务器说能支持“10万连接”，指的是 <strong>Idle连接数量</strong></li><li>真正活跃（消息频繁）的连接，一般几千~上万就会达到服务器上限</li></ul><ol start="3"><li><strong>是否需要清理 Idle连接</strong></li></ol><ul><li>有些服务器会设置 <strong>心跳&#x2F;超时机制</strong>，长时间不活跃的连接会被断开，防止资源泄漏或恶意占用</li></ul><p>我们还要提高并发量，就要引入<strong>负载均衡器</strong>的概念。</p><h4 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h4><p><strong>负载均衡器（Load Balancer）</strong> 是一个把大量客户端请求 <strong>均匀分发</strong> 给多个后端服务器的组件，以提高系统的 <strong>吞吐能力、稳定性和可用性</strong>。</p><h5 id="为什么需要它？"><a href="#为什么需要它？" class="headerlink" title="为什么需要它？"></a>为什么需要它？</h5><p>在高并发系统中，如果所有请求都打到一个服务器上，容易导致：</p><ul><li>响应慢</li><li>连接超时</li><li>服务宕机</li></ul><p>使用负载均衡器可以：</p><ul><li><strong>水平扩展</strong>服务器（多个 Muduo 实例）</li><li><strong>分担压力</strong></li><li>实现高可用（某个服务器挂了不影响整体）</li></ul><h5 id="按协议层划分（TCP-HTTP）"><a href="#按协议层划分（TCP-HTTP）" class="headerlink" title="按协议层划分（TCP&#x2F;HTTP）"></a>按协议层划分（TCP&#x2F;HTTP）</h5><table><thead><tr><th>类型</th><th>层级</th><th>说明</th><th>常用代表</th></tr></thead><tbody><tr><td><strong>四层负载均衡（L4）</strong></td><td>TCP&#x2F;UDP</td><td>基于 IP、端口、协议</td><td>LVS、HAProxy、Nginx Stream、Keepalived</td></tr><tr><td><strong>七层负载均衡（L7）</strong></td><td>HTTP、HTTPS</td><td>基于 URL、Header、Cookie</td><td>Nginx、HAProxy、Traefik、Envoy、Kong</td></tr></tbody></table><h5 id="常见软件负载均衡器对比"><a href="#常见软件负载均衡器对比" class="headerlink" title="常见软件负载均衡器对比"></a>常见软件负载均衡器对比</h5><table><thead><tr><th>名称</th><th>协议支持</th><th>类型</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td><strong>LVS</strong></td><td>L4 (TCP&#x2F;UDP)</td><td>内核模块</td><td>性能极高、稳定、复杂配置</td><td>超高并发、基础设施层</td></tr><tr><td><strong>HAProxy</strong></td><td>L4 + L7</td><td>用户态</td><td>灵活、高性能、支持健康检查、监控完备</td><td>Web、API 网关、数据库代理</td></tr><tr><td><strong>Nginx</strong></td><td>L7 (也支持 L4)</td><td>用户态</td><td>配置简单，静态资源支持好</td><td>Web服务器、轻量级反代</td></tr><tr><td><strong>Traefik</strong></td><td>L7</td><td>云原生</td><td>自动发现服务（K8s、Docker）、面向微服务</td><td>DevOps、容器化</td></tr><tr><td><strong>Envoy</strong></td><td>L4 + L7</td><td>云原生</td><td>微服务架构核心组件、支持 gRPC、动态配置</td><td>Istio、Service Mesh</td></tr><tr><td><strong>Kong</strong></td><td>L7 API网关</td><td>插件丰富</td><td>基于 Nginx，提供限流、安全等扩展能力</td><td>企业 API 管理</td></tr><tr><td><strong>Keepalived</strong></td><td>L4</td><td>高可用</td><td>常与 LVS 配合，提供主备切换</td><td>双主结构、高可用架构</td></tr><tr><td><strong>OpenResty</strong></td><td>L7</td><td>基于 Nginx</td><td>支持 Lua，适合做复杂业务逻辑</td><td>高定制需求</td></tr><tr><td><strong>Caddy</strong></td><td>L7</td><td>自动 TLS</td><td>HTTPS 自动配置简单</td><td>个人、低门槛网站部署</td></tr></tbody></table><p>我们这里要使用的是Nginx 的 TCP 负载均衡模块（即 stream 模块）</p><p><img src="/2025/06/02/c-%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/2.png" alt="2"></p><p>这是负载均衡器在本项目发挥的作用图。</p><p>Nginx 默认是 HTTP 层负载均衡（七层），但它的 <strong><code>stream</code> 模块</strong> 支持四层（TCP&#x2F;UDP）负载均衡，非常适合。</p><p>说白了，通过多台后台服务器提高并发量。但也面临着如何处理跨服务器通信的问题。</p><h3 id="引入服务器中间件（redis）"><a href="#引入服务器中间件（redis）" class="headerlink" title="引入服务器中间件（redis）"></a>引入服务器中间件（redis）</h3><p><strong>Redis（Remote Dictionary Server）</strong> 是一个<strong>开源</strong>的、基于内存的<strong>键值对存储（Key-Value Store）数据库</strong>，支持丰富的数据结构，<strong>读写极快</strong>，非常适合用作缓存、中间件、消息队列等。</p><p>引入redis是要解决如果一个用户要和另一个用户通信，但是另一个用户在另一台服务器上，我们能从数据库中看到他在线，但是我们不能获取他的连接，所以引入中间件。这样就可以解决跨服务器通信的问题。</p><p>这里是redis在本项目的作用图：</p><p><img src="/2025/06/02/c-%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/3.png" alt="3"></p><h3 id="nginx项目配置"><a href="#nginx项目配置" class="headerlink" title="nginx项目配置"></a>nginx项目配置</h3><p>nginx配置编译好后，去修改&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf中修改nginx.conf文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nginx tcp loadbalance config</span></span><br><span class="line">stream &#123;</span><br><span class="line">        upstream MyServer &#123;</span><br><span class="line">                server 127.0.0.1:6000 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">                server 127.0.0.1:6002 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server &#123;</span><br><span class="line">                proxy_connect_timeout 1s;</span><br><span class="line">                <span class="comment">#proxy_timeout 3s; # 可以根据需要开启，控制代理的读写超时</span></span><br><span class="line">                listen 8000;</span><br><span class="line">                proxy_pass MyServer;</span><br><span class="line">                tcp_nodelay on;</span><br><span class="line">        &#125;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在events和http领域之间加入上述代码。这一段代码就是加入**<code>stream</code> 模块** 。</p><p>说明</p><ul><li>**stream{}**：用于 TCP&#x2F;UDP 负载均衡。</li><li><strong>upstream MyServer</strong>：定义了两个后端服务器，权重相等。</li><li><strong>max_fails&#x3D;3 fail_timeout&#x3D;30s</strong>：3次失败后，30秒内认为该节点不可用。</li><li><strong>listen 8000</strong>：监听本机 8000 端口。</li><li><strong>proxy_connect_timeout 1s</strong>：连接超时时间为1秒。</li><li><strong>proxy_pass MyServer</strong>：请求转发到 MyServer 负载均衡组。</li><li><strong>tcp_nodelay on</strong>：开启 TCP_NODELAY，减少延迟。</li></ul><p>这样就实现了多个客户端只需要向一个ip+port就可以。通过nginx对多台服务器管理，这样就增加了聊天服务器的并发量。当然跨服务器通信这一问题还没有解决。</p><h3 id="Redis项目配置"><a href="#Redis项目配置" class="headerlink" title="Redis项目配置"></a>Redis项目配置</h3><p>首先在include和src建立redis文件夹，在对应的文件夹添加redis.hpp和redis.cpp。记得更新CMakeLists.txt文件。这里调用了hiredis库。hiredis是c++使用redis封装的库。</p><p>redis.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> REDIS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Redis</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Redis</span>();</span><br><span class="line">        ~<span class="built_in">Redis</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接redis服务器</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//向redis指定的通道channel发布消息</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">publish</span><span class="params">(<span class="type">int</span> channel,string message)</span></span>;</span><br><span class="line">        <span class="comment">//向redis指定的通道subscribe订阅消息</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">subscribe</span><span class="params">(<span class="type">int</span> channel)</span></span>;</span><br><span class="line">        <span class="comment">//向redis指定的通道unsubscribe取消订阅消息</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">unsubscribe</span><span class="params">(<span class="type">int</span> channel)</span></span>;</span><br><span class="line">        <span class="comment">//在独立线程中接受订阅通道中的消息</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">observer_channel_message</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//初始化向业务层上报通道消息的回调对象</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init_notify_handler</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>,string)&gt; fn)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//hiredis同步上下文对象，负责publish消息</span></span><br><span class="line">        redisContext *_publish_context;</span><br><span class="line">        <span class="comment">//hiredis同步上下文对象，负责subscribe消息</span></span><br><span class="line">        redisContext * _subscribe_context;</span><br><span class="line">        <span class="comment">//回调操作，收到订阅的消息，给service层上报</span></span><br><span class="line">        function&lt;<span class="type">void</span> (<span class="type">int</span>,string)&gt; _notify_message_handler;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>redis.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;redis.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">Redis::<span class="built_in">Redis</span>():_publish_context(<span class="literal">nullptr</span>),_subscribe_context(<span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Redis::~<span class="built_in">Redis</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(_publish_context!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">redisFree</span>(_publish_context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_subscribe_context!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">redisFree</span>(_subscribe_context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Redis::connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//负责publish发布消息的上下文连接</span></span><br><span class="line">    _publish_context=<span class="built_in">redisConnect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">if</span>(_publish_context==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;connect redis failed!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//负责subscribe订阅消息的上下文连接</span></span><br><span class="line">    _subscribe_context=<span class="built_in">redisConnect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">if</span>(_subscribe_context==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;connect redis failed!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在单独的线程中，监听通道上的事件，有消息给业务层进行上报</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">([&amp;]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        observer_channel_message();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;connect redis_server success!&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向redis指定的通道channel发布消息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Redis::publish</span><span class="params">(<span class="type">int</span> channel,string message)</span></span>&#123;</span><br><span class="line">    redisReply *reply=(redisReply*)<span class="built_in">redisCommand</span>(_publish_context,<span class="string">&quot;PUBLISH %d %s&quot;</span>,channel,message.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span>(reply==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;publish command failed&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向redis指定的通道subscribe订阅消息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Redis::subscribe</span><span class="params">(<span class="type">int</span> channel)</span></span>&#123;</span><br><span class="line">    <span class="comment">//subscribe命令本身会造成线程阻塞等待通道里面发生消息，这里只做订阅通道，不接受消息</span></span><br><span class="line">    <span class="comment">//通道消息的接受专门在observer_channel_message函数中的独立线程中进行</span></span><br><span class="line">    <span class="comment">//只负责发送命令，不阻塞接受redis server响应消息，否则和notifyMsg线程抢占响应资源。</span></span><br><span class="line">    <span class="keyword">if</span>(REDIS_ERR==<span class="built_in">redisAppendCommand</span>(<span class="keyword">this</span>-&gt;_subscribe_context,<span class="string">&quot;SUBSCRIBE %d&quot;</span>,channel))&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;subscribe command failed!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//redisBufferWrite 可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1）</span></span><br><span class="line">    <span class="type">int</span> done=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!done)&#123;</span><br><span class="line">        <span class="keyword">if</span>(REDIS_ERR==<span class="built_in">redisBufferWrite</span>(<span class="keyword">this</span>-&gt;_subscribe_context,&amp;done))&#123;</span><br><span class="line">            cerr&lt;&lt;<span class="string">&quot;subscribe command failed!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//redisGetReply不执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向redis指定的通道unsubscribe取消订阅消息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Redis::unsubscribe</span><span class="params">(<span class="type">int</span> channel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(REDIS_ERR==<span class="built_in">redisAppendCommand</span>(<span class="keyword">this</span>-&gt;_subscribe_context,<span class="string">&quot;UNSUBSCRIBE %d&quot;</span>,channel))&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;unsubscribe command failed!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//redisBufferWrite 可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1）</span></span><br><span class="line">    <span class="type">int</span> done=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!done)&#123;</span><br><span class="line">        <span class="keyword">if</span>(REDIS_ERR==<span class="built_in">redisBufferWrite</span>(<span class="keyword">this</span>-&gt;_subscribe_context,&amp;done))&#123;</span><br><span class="line">            cerr&lt;&lt;<span class="string">&quot;unsubscribe command failed!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在独立线程中接受订阅通道中的消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Redis::observer_channel_message</span><span class="params">()</span></span>&#123;</span><br><span class="line">    redisReply *reply=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(REDIS_OK==<span class="built_in">redisGetReply</span>(<span class="keyword">this</span>-&gt;_subscribe_context,(<span class="type">void</span>**)&amp;reply))&#123;</span><br><span class="line">        <span class="comment">//订阅收到的消息是一个带三元组的数组</span></span><br><span class="line">        <span class="keyword">if</span>(reply!=<span class="literal">nullptr</span>&amp;&amp;reply-&gt;element[<span class="number">2</span>]!=<span class="literal">nullptr</span>&amp;&amp;reply-&gt;element[<span class="number">2</span>]-&gt;str!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//给业务层上报通道上发生的消息</span></span><br><span class="line">            _notify_message_handler(<span class="built_in">atoi</span>(reply-&gt;element[<span class="number">1</span>]-&gt;str),reply-&gt;element[<span class="number">2</span>]-&gt;str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">freeReplyObject</span>(reply);</span><br><span class="line">    &#125;</span><br><span class="line">    cerr&lt;&lt;<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;observer_channel_message quit &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化向业务层上报通道消息的回调对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Redis::init_notify_handler</span><span class="params">(function&lt;<span class="type">void</span>(<span class="type">int</span>,string)&gt; fn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_notify_message_handler=fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的点就是关于订阅和发布，发布publish直接用redisCommand函数即可，因为这个命令直接执行本身不会堵塞（服务器会很快给出回复）。但是subscribe不一样，他直接执行会卡在那里，一直等待消息进入通道里（服务器不会很快回复）。所以我们这里使用redisAppendCommand<code>+</code>redisBufferWrite这两个函数一起，不用再等待响应。所以我们单开一个线程来接受通道里的消息。</p><p>总结对比</p><table><thead><tr><th>功能</th><th><code>redisCommand</code></th><th><code>redisAppendCommand</code> + <code>redisBufferWrite</code></th></tr></thead><tbody><tr><td>用法</td><td>直接发送+等待响应</td><td>仅发送命令到 Redis，不等待响应</td></tr><tr><td>是否阻塞</td><td>会阻塞直到响应</td><td>不会阻塞</td></tr><tr><td>适用场景</td><td>普通命令（GET&#x2F;SET）</td><td>发布订阅等需要后台线程响应的命令</td></tr></tbody></table><p>所以我们把监听逻辑放到线程里。</p><p>注意：</p><p>Redis 的订阅-发布机制设计：</p><ul><li><strong>订阅连接会被阻塞监听消息，不允许执行其他命令。</strong></li><li>如果同一个连接既用来订阅又用来发布，订阅时会阻塞导致发布失败或延迟。</li><li>所以一般建议<strong>发布和订阅使用独立的连接</strong>，保证各自的流畅性和响应效率。</li></ul><h3 id="解决跨服务器通信问题"><a href="#解决跨服务器通信问题" class="headerlink" title="解决跨服务器通信问题"></a>解决跨服务器通信问题</h3><p>我们已经配置好redis,并且封装了对应的redis类。接下来在业务类实现加入redis。</p><p>在对应的ChatService类声明私有变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//redis操作对象</span></span><br><span class="line"> Redis _redis;</span><br></pre></td></tr></table></figure><p>在ChatService类的构造函数，实现redis连接并且加入回调函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接redis服务器</span></span><br><span class="line"><span class="keyword">if</span>(_redis.<span class="built_in">connect</span>())&#123;</span><br><span class="line"><span class="comment">//设置上报消息的回调</span></span><br><span class="line">_redis.<span class="built_in">init_notify_handler</span>(std::<span class="built_in">bind</span>(&amp;ChatService::handleRedisSubscribeMessage,<span class="keyword">this</span>,_1,_2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleRedisSubscribeMessage函数是从redis消息队列中获取订阅的消息（在另一个线程执行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从redis消息队列中获取订阅的消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChatService::handleRedisSubscribeMessage</span><span class="params">(<span class="type">int</span> userid,string msg)</span></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(_connMutex)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it=_userConnMap.<span class="built_in">find</span>(userid);</span><br><span class="line">    <span class="keyword">if</span>(it!=_userConnMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        it-&gt;second-&gt;<span class="built_in">send</span>(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储该用户的离线消息</span></span><br><span class="line">    _offlineMsgModel.<span class="built_in">insert</span>(userid,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从redis返回的userid和message是当前服务器订阅的通道返回的消息，所以当前userid一定在当前服务器的_userConnMap中，当然也存在一种情况，发消息给redis时，还在线，redis传给对应的服务器时，该用户下线了，所以也要存储该用户的离线消息。</p><p>接着还要在登录功能和注销功能做修改</p><p>在登录成功后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id用户登录成功后，向redis订阅channel(id)</span></span><br><span class="line">_redis.<span class="built_in">subscribe</span>(id);</span><br></pre></td></tr></table></figure><p>要向redis订阅消息，有向当前用户发送的消息会向在redis通道存储，之后会向当前用户输送。</p><p>在注销（退出）后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户注销，相当于下线，在redis中取消订阅通道</span></span><br><span class="line">_redis.<span class="built_in">unsubscribe</span>(userid);</span><br></pre></td></tr></table></figure><p>关闭掉订阅通道。当然还有客户端异常退出时，也要关闭订阅</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端关闭，相当于下线，在redis中取消订阅通道</span></span><br><span class="line">_redis.<span class="built_in">unsubscribe</span>(user.<span class="built_in">getId</span>());</span><br></pre></td></tr></table></figure><p>最后对一对一聊天和群聊功能做修改。</p><p>一对一聊天，当查到目标用户没有在_userConnMap中，说明目标用户不在当前服务器上或者不在线，所以接下来去数据库查看目标用户是否在线，若在线，则向redis对应的通道发布消息。不在线则存储连线消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询toid是否在线（可能在其他服务器上）</span></span><br><span class="line">User user=_userModel.<span class="built_in">query</span>(toid);</span><br><span class="line"><span class="keyword">if</span>(user.<span class="built_in">getState</span>()==<span class="string">&quot;online&quot;</span>)&#123;</span><br><span class="line">_redis.<span class="built_in">publish</span>(toid,js.<span class="built_in">dump</span>());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>群聊，当查到目标用户没有在_userConnMap中，说明目标用户不在当前服务器上或者不在线，所以接下来去数据库查看目标用户是否在线，若在线，则向redis对应的通道发布消息。不在线则存储连线消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it=_userConnMap.<span class="built_in">find</span>(id);</span><br><span class="line"><span class="keyword">if</span>(it!=_userConnMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//转发群消息</span></span><br><span class="line">            it-&gt;second-&gt;<span class="built_in">send</span>(js.<span class="built_in">dump</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//查询id是否在线</span></span><br><span class="line">            User user=_userModel.<span class="built_in">query</span>(id);</span><br><span class="line">            <span class="keyword">if</span>(user.<span class="built_in">getState</span>()==<span class="string">&quot;online&quot;</span>)&#123;</span><br><span class="line">                _redis.<span class="built_in">publish</span>(id,js.<span class="built_in">dump</span>());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//存储离线群消息</span></span><br><span class="line">                _offlineMsgModel.<span class="built_in">insert</span>(id,js.<span class="built_in">dump</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>至此解决跨服务器通信问题。</p><h3 id="解决登录注销后再次登录会阻塞的问题"><a href="#解决登录注销后再次登录会阻塞的问题" class="headerlink" title="解决登录注销后再次登录会阻塞的问题"></a>解决登录注销后再次登录会阻塞的问题</h3><p>在登录后注销退出后，在进行登录会一直卡住，没有关于用户的信息展示和指令展示，核查发现是主线程在执行recv,接受线程也在recv同一个socket,所以这里我们引入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于读写线程的通信</span></span><br><span class="line"><span class="type">sem_t</span> rwem;</span><br><span class="line"><span class="comment">// 记录登录状态</span></span><br><span class="line">atomic_bool g_isLoginSuccess&#123;<span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>sem_t</code> 是 POSIX 信号量类型（semaphore），用于线程之间同步或通信。</p><p><code>tomic_bool</code> 是 C++ 的原子变量类型之一，用于线程安全地读写布尔值，防止并发条件竞争。</p><p>一、信号量 <code>sem_t</code> 的初始化</p><p>在使用前，<strong>必须初始化</strong>。常用的是 <code>sem_init</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> rwem;</span><br><span class="line"><span class="built_in">sem_init</span>(&amp;rwem, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>参数解释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>sem</code></td><td>指向信号量的指针</td></tr><tr><td><code>pshared=0</code></td><td>表示是线程之间使用（同一进程）</td></tr><tr><td><code>value=0</code></td><td>初始值为 0（表示“没有资源”）</td></tr></tbody></table><p> 通常设为 0，表示线程必须等待 <code>sem_post()</code> 才能继续。</p><p>二、sem_post 和 sem_wait 的配合逻辑</p><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td><code>sem_post(&amp;rwem)</code></td><td>给信号量加1，表示“有资源了”或“可以继续了”</td></tr><tr><td><code>sem_wait(&amp;rwem)</code></td><td>阻塞等待信号量值&gt;0，然后减1，表示“我来用这个资源”</td></tr></tbody></table><p>总体步骤：</p><table><thead><tr><th>步骤</th><th>函数</th><th>示例</th></tr></thead><tbody><tr><td>初始化</td><td><code>sem_init(&amp;rwem, 0, 0);</code></td><td>启动阶段</td></tr><tr><td>发送信号（通知）</td><td><code>sem_post(&amp;rwem);</code></td><td>接收线程收到数据时</td></tr><tr><td>等待信号</td><td><code>sem_wait(&amp;rwem);</code></td><td>处理线程等待数据</td></tr><tr><td>销毁</td><td><code>sem_destroy(&amp;rwem);</code></td><td>程序结束或退出登录时</td></tr></tbody></table><p>由于登录成功和注册成功的消息的收取是在主线程进行的，其他信息的收取是在另一个进程中，所以我要修改代码，把登录和注册的回复消息由接受进程收取。</p><p>首先在客户端main函数中连接服务器端成功后，插入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化读写线程通信用的信号量</span></span><br><span class="line"><span class="built_in">sem_init</span>(&amp;rwem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接服务器成功，启动接受线程</span></span><br><span class="line"><span class="function">std::thread <span class="title">readTask</span><span class="params">(readTaskHandler, clientfd)</span></span>; <span class="comment">// 在Linux pthread_create</span></span><br><span class="line">readTask.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure><p>在登录时向服务端发送登录消息后，插入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sem_wait</span>(&amp;rwem); <span class="comment">// 等待信号量，由子线程处理完登录的响应消息后，通知这里</span></span><br><span class="line">g_isLoginSuccess = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>sem_wait(&amp;rwem); 是为了<strong>接受线程</strong>消息处理好后会sem_post(&amp;rewm)，主线程接受到信号进行往下走。</p><p>g_isLoginSuccess时为了确认登录是否成功，如不成功，就进入首页面，成功进主菜单页面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g_isLoginSuccess)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 进入聊天主菜单页面</span></span><br><span class="line">                isMainMenuRunning = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">mainMenu</span>(clientfd);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>注册就只需要等待信号就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sem_wait</span>(&amp;rwem); <span class="comment">// 等待信号量，由子线程处理完注册的响应消息后，通知这里</span></span><br></pre></td></tr></table></figure><p>在退出业务记得把信号回收</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sem_destroy</span>(&amp;rwem);</span><br></pre></td></tr></table></figure><p>在接受线程里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (LOGIN_MSG_ACK == msgtype)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">doLoginResponse</span>(js); <span class="comment">// 处理登录响应的业务逻辑</span></span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;rwem);     <span class="comment">// 通知主线程，登录结果处理完成</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (REG_MSG_ACK == msgtype)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">doRegResponse</span>(js);</span><br><span class="line">            <span class="built_in">sem_post</span>(&amp;rwem); <span class="comment">// 通知主线程，注册结果处理完成</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>当收到对应业务的消息，就执行对应逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理登录响应的业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doLoginResponse</span><span class="params">(json &amp;responsejs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (responsejs[<span class="string">&quot;errno&quot;</span>] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; responsejs[<span class="string">&quot;errmsg&quot;</span>] &lt;&lt; endl;</span><br><span class="line">        g_isLoginSuccess = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 登录成功</span></span><br><span class="line">        <span class="comment">// 记录当前用户的id和name</span></span><br><span class="line">        g_currentUser.<span class="built_in">setId</span>(responsejs[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">        g_currentUser.<span class="built_in">setName</span>(responsejs[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">        <span class="comment">// 记录当前用户的好友列表信息</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">&quot;friends&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            g_currentUserFriendList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 看是否包含friends这个键</span></span><br><span class="line">            vector&lt;string&gt; vec = responsejs[<span class="string">&quot;friends&quot;</span>];</span><br><span class="line">            <span class="keyword">for</span> (string &amp;str : vec)</span><br><span class="line">            &#123;</span><br><span class="line">                json js = json::<span class="built_in">parse</span>(str);</span><br><span class="line">                User user;</span><br><span class="line">                user.<span class="built_in">setId</span>(js[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">                user.<span class="built_in">setName</span>(js[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">                user.<span class="built_in">setState</span>(js[<span class="string">&quot;state&quot;</span>]);</span><br><span class="line">                g_currentUserFriendList.<span class="built_in">push_back</span>(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录当前用户的群组列表信息</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">&quot;groups&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            g_currentUserGroupList.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            vector&lt;string&gt; vec1 = responsejs[<span class="string">&quot;groups&quot;</span>];</span><br><span class="line">            <span class="keyword">for</span> (string &amp;groupstr : vec1)</span><br><span class="line">            &#123;</span><br><span class="line">                json grpjs = json::<span class="built_in">parse</span>(groupstr);</span><br><span class="line">                Group group;</span><br><span class="line">                group.<span class="built_in">setId</span>(grpjs[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">                group.<span class="built_in">setName</span>(grpjs[<span class="string">&quot;groupname&quot;</span>]);</span><br><span class="line">                group.<span class="built_in">setDesc</span>(grpjs[<span class="string">&quot;groupdesc&quot;</span>]);</span><br><span class="line">                vector&lt;string&gt; vec2 = grpjs[<span class="string">&quot;users&quot;</span>];</span><br><span class="line">                <span class="keyword">for</span> (string &amp;userstr : vec2)</span><br><span class="line">                &#123;</span><br><span class="line">                    GroupUser user;</span><br><span class="line">                    json js = json::<span class="built_in">parse</span>(userstr);</span><br><span class="line">                    user.<span class="built_in">setId</span>(js[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">                    user.<span class="built_in">setName</span>(js[<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">                    user.<span class="built_in">setState</span>(js[<span class="string">&quot;state&quot;</span>]);</span><br><span class="line">                    user.<span class="built_in">setRole</span>(js[<span class="string">&quot;role&quot;</span>]);</span><br><span class="line">                    group.<span class="built_in">getUsers</span>().<span class="built_in">push_back</span>(user);</span><br><span class="line">                &#125;</span><br><span class="line">                g_currentUserGroupList.<span class="built_in">push_back</span>(group);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 显示登录用户的基本信息</span></span><br><span class="line">        <span class="built_in">showCurrentUserData</span>();</span><br><span class="line">        <span class="comment">// 显示当前用户的离线消息 个人聊天消息或者群组消息</span></span><br><span class="line">        <span class="keyword">if</span> (responsejs.<span class="built_in">contains</span>(<span class="string">&quot;offlinemsg&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;string&gt; vec = responsejs[<span class="string">&quot;offlinemsg&quot;</span>];</span><br><span class="line">            <span class="keyword">for</span> (string &amp;str : vec)</span><br><span class="line">            &#123;</span><br><span class="line">                json js = json::<span class="built_in">parse</span>(str);</span><br><span class="line">                <span class="comment">// time +[id]+name+&quot;said: &quot;+xxx</span></span><br><span class="line">                <span class="keyword">if</span> (ONE_CHAT_MSG == js[<span class="string">&quot;msgid&quot;</span>].<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;())</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; js[<span class="string">&quot;time&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; js[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; js[<span class="string">&quot;name&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot; said: &quot;</span> &lt;&lt; js[<span class="string">&quot;msg&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;群消息[&quot;</span> &lt;&lt; js[<span class="string">&quot;groupid&quot;</span>] &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; js[<span class="string">&quot;time&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; js[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; js[<span class="string">&quot;name&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; <span class="string">&quot; said: &quot;</span> &lt;&lt; js[<span class="string">&quot;msg&quot;</span>].<span class="built_in">get</span>&lt;string&gt;() &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g_isLoginSuccess = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在登陆成功后记得把g_isLoginSuccess置为true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理注册响应的业务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doRegResponse</span><span class="params">(json &amp;responsejs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != responsejs[<span class="string">&quot;errno&quot;</span>])</span><br><span class="line">    &#123; <span class="comment">// 注册失败</span></span><br><span class="line">        cerr &lt;&lt;<span class="string">&quot;name is already exist,register error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 注册成功</span></span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;name register success,userid is &quot;</span> &lt;&lt; responsejs[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot;, do not forget it!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就把这个问题解决了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;json学习&quot;&gt;&lt;a href=&quot;#json学习&quot; class=&quot;headerlink&quot; title=&quot;json学习&quot;&gt;&lt;/a&gt;json学习&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="c++实现集群聊天服务器" scheme="http://yustonerain.top/categories/c-%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="C++ chatserver" scheme="http://yustonerain.top/tags/C-chatserver/"/>
    
  </entry>
  
</feed>
