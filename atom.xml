<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YuStone Blogs</title>
  
  <subtitle>the world</subtitle>
  <link href="http://yustonerain.top/atom.xml" rel="self"/>
  
  <link href="http://yustonerain.top/"/>
  <updated>2025-06-23T13:25:20.506Z</updated>
  <id>http://yustonerain.top/</id>
  
  <author>
    <name>YuStone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统编程</title>
    <link href="http://yustonerain.top/2025/06/20/Linux-System%20Programming.html"/>
    <id>http://yustonerain.top/2025/06/20/Linux-System%20Programming.html</id>
    <published>2025-06-20T13:26:00.000Z</published>
    <updated>2025-06-23T13:25:20.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux常见目录"><a href="#Linux常见目录" class="headerlink" title="Linux常见目录"></a>Linux常见目录</h2><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td><code>/</code></td><td>根目录，所有目录的起点，Linux 文件系统的顶级目录</td></tr><tr><td><code>/bin</code></td><td>存放常用的二进制可执行文件（如 <code>ls</code>、<code>cp</code>、<code>mv</code> 等），普通用户和系统都可使用</td></tr><tr><td><code>/sbin</code></td><td>系统管理命令，只有 root 用户可用（如 <code>reboot</code>、<code>ifconfig</code>）</td></tr><tr><td><code>/etc</code></td><td>配置文件目录（如 <code>/etc/passwd</code>、<code>/etc/fstab</code>、<code>/etc/ssh/sshd_config</code>）</td></tr><tr><td><code>/home</code></td><td>普通用户的家目录（如 <code>/home/user1</code>）</td></tr><tr><td><code>/root</code></td><td>超级用户（root）的家目录</td></tr><tr><td><code>/lib</code></td><td>核心共享库和驱动模块，供 <code>/bin</code> 和 <code>/sbin</code> 下的程序使用</td></tr><tr><td><code>/usr</code></td><td>存放用户应用程序和文件，子目录中包括 <code>/usr/bin</code>、<code>/usr/lib</code> 等</td></tr><tr><td><code>/usr/bin</code></td><td>普通用户使用的应用程序（非基本命令）</td></tr><tr><td><code>/usr/sbin</code></td><td>非系统引导时使用的系统管理员命令</td></tr><tr><td><code>/var</code></td><td>可变数据，如日志文件 <code>/var/log</code>、邮件、缓存、锁等</td></tr><tr><td><code>/tmp</code></td><td>临时文件，系统重启后可能会被清空</td></tr><tr><td><code>/opt</code></td><td>第三方软件安装目录（如 Chrome、VMware 等）</td></tr><tr><td><code>/dev</code></td><td>设备文件（如硬盘 <code>/dev/sda</code>，终端 <code>/dev/tty</code>）</td></tr><tr><td><code>/proc</code></td><td>虚拟文件系统，内核和进程信息（如 <code>/proc/cpuinfo</code>、<code>/proc/meminfo</code>）</td></tr><tr><td><code>/sys</code></td><td>另一种虚拟文件系统，提供与内核、设备驱动的交互接口</td></tr><tr><td><code>/boot</code></td><td>存放启动相关文件，如内核、grub 等（如 <code>/boot/vmlinuz-*</code>）</td></tr><tr><td><code>/media</code></td><td>可移动媒体挂载点（如 U 盘、光盘）</td></tr><tr><td><code>/mnt</code></td><td>临时挂载点，一般管理员手动挂载文件系统用</td></tr><tr><td><code>/run</code></td><td>系统运行时临时文件（如 PID、Socket）</td></tr><tr><td><code>/srv</code></td><td>提供服务的数据目录（如 Web 服务、FTP 服务的数据）</td></tr></tbody></table><h2 id="Bash解析器常用快捷键"><a href="#Bash解析器常用快捷键" class="headerlink" title="Bash解析器常用快捷键"></a>Bash解析器常用快捷键</h2><p>1.tap键</p><p>补齐命令，补齐路径，显示当前目录下的所有目录</p><p>2.清屏 clear</p><p>3.中断进程 ctrl+c</p><p>4 遍历输入的历史命令箭头上（ctrl+p）箭头下(ctrl+n)</p><p>5 光标相关操作</p><p>光标左移： ctrl+b（箭头左）</p><p>光标右移： ctrl+f(箭头右)</p><p>移动到头部: ctrl+a(home键)</p><p>移动到尾部：ctrl+e(end键)</p><p>6字符删除</p><p>删除光标前面的字符：ctrl+h(Backspace)</p><p>删除光标后面的字符：ctrl+d</p><p>光标后面的字符即光标覆盖的字符</p><p>删除光标前的所有内容：ctrl+u</p><p>删除光标后的所有内容：ctrl+k</p><h2 id="终端相关快捷键"><a href="#终端相关快捷键" class="headerlink" title="终端相关快捷键"></a>终端相关快捷键</h2><p>（终端一定要选中）</p><p>ctrl+shift+N 新建一个终端</p><p>ctrl+shift+T 在终端里新建一个标签</p><p>ctrl+D 关闭当前一个终端</p><h2 id="内建命令和外部命令对比"><a href="#内建命令和外部命令对比" class="headerlink" title="内建命令和外部命令对比"></a>内建命令和外部命令对比</h2><p>内建命令 vs 外部命令 对比总结</p><table><thead><tr><th>比较项</th><th>内建命令（Builtin Command）</th><th>外部命令（External Command）</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>由 Shell 内部直接实现的命令</td><td>是文件系统中的可执行程序（如 <code>/bin/ls</code>）</td></tr><tr><td><strong>执行速度</strong></td><td>快（不需新建进程）</td><td>较慢（需 fork 子进程执行）</td></tr><tr><td><strong>资源消耗</strong></td><td>少，执行在当前 Shell 进程中</td><td>多，执行时创建子进程</td></tr><tr><td><strong>路径查找</strong></td><td>不需要依赖 <code>PATH</code> 环境变量</td><td>需要从 <code>PATH</code> 中查找可执行文件</td></tr><tr><td><strong>是否可以替换</strong></td><td>一般不推荐重定义</td><td>可以覆盖、替换或删改（如 alias 覆盖）</td></tr><tr><td><strong>是否常驻内存</strong></td><td>是，Shell 启动时加载</td><td>否，执行时加载，执行完释放</td></tr><tr><td><strong>例子</strong></td><td><code>cd</code>, <code>echo</code>, <code>exit</code>, <code>pwd</code>, <code>type</code></td><td><code>ls</code>, <code>cp</code>, <code>gcc</code>, <code>vim</code>, <code>python</code></td></tr><tr><td><strong>查看方法</strong></td><td><code>type cd</code> → builtin</td><td><code>type ls</code> → file</td></tr></tbody></table><p>命令类型查看方法</p><p>使用type命令</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">type</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 命令名</code></pre><p>使用 -a 显示所有同名命令（包括 alias、builtin、文件）</p><p>使用 -t 显示类型（简洁）</p><h2 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h2><pre class="language-bash" data-language="bash"><code class="language-bash">命令 <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span></code></pre><table><thead><tr><th>部分</th><th>说明</th></tr></thead><tbody><tr><td><strong>命令</strong></td><td>要执行的操作，如 <code>ls</code>、<code>cp</code>、<code>mkdir</code> 等</td></tr><tr><td><strong>选项</strong></td><td>用于控制命令行为的开关，通常以 <code>-</code> 或 <code>--</code> 开头，例如 <code>-l</code>、<code>--help</code></td></tr><tr><td><strong>参数</strong></td><td>命令作用的对象，通常是文件名、目录名、用户名等</td></tr></tbody></table><p>选项类型说明</p><table><thead><tr><th>类型</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>短选项</td><td><code>-l</code></td><td>通常是一个字母，多个可组合（如 <code>-al</code>）</td></tr><tr><td>长选项</td><td><code>--help</code></td><td>更易读，通常不可组合</td></tr><tr><td>组合选项</td><td><code>-avz</code></td><td>相当于 <code>-a -v -z</code></td></tr></tbody></table><h2 id="帮助文档查看方法"><a href="#帮助文档查看方法" class="headerlink" title="帮助文档查看方法"></a>帮助文档查看方法</h2><p>如果是内建命令（可以通过之前的type命令查看）使用 help +内建命令</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">help</span> <span class="token builtin class-name">pwd</span></code></pre><p>如果是外部命令 对应命令名 –help</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">--help</span></code></pre><p><code>man</code> 是 Linux 中最常用的命令之一，全称是 <strong>manual（手册）</strong>，用于查看各种命令、函数、配置文件的使用说明。它是学习和查找 Linux 命令最权威的工具。</p><p><code>man</code> 命令基本语法：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">man</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>命令名或函数名<span class="token punctuation">]</span></code></pre><p> man 手册的 9 个部分（章节）</p><table><thead><tr><th>章节号</th><th>内容</th><th>示例</th></tr></thead><tbody><tr><td>1</td><td>用户命令（常见终端命令）</td><td><code>man ls</code></td></tr><tr><td>2</td><td>系统调用（内核提供的函数）</td><td><code>man 2 open</code></td></tr><tr><td>3</td><td>C 库函数</td><td><code>man 3 printf</code></td></tr><tr><td>4</td><td>设备文件和特殊文件</td><td><code>man 4 tty</code></td></tr><tr><td>5</td><td>配置文件格式</td><td><code>man 5 crontab</code></td></tr><tr><td>6</td><td>游戏与趣味（极少）</td><td></td></tr><tr><td>7</td><td>杂项（宏定义、协议、约定等）</td><td><code>man 7 signal</code></td></tr><tr><td>8</td><td>系统管理员命令（只能 root 执行）</td><td><code>man 8 ifconfig</code></td></tr><tr><td>9</td><td>内核开发接口（不常见）</td><td></td></tr></tbody></table><p>常用选项</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><code>-k 关键词</code></td><td>搜索相关命令（相当于 <code>apropos</code>）</td></tr><tr><td><code>-f 命令名</code></td><td>显示命令属于哪个章节（相当于 <code>whatis</code>）</td></tr><tr><td><code>-a</code></td><td>显示所有章节中匹配的 man 页</td></tr><tr><td><code>-M</code></td><td>指定手册路径</td></tr><tr><td><code>--help</code></td><td>查看 man 自身帮助信息</td></tr></tbody></table><h2 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h2><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>用于显示当前终端所在的<strong>工作目录</strong>（即当前绝对路径）。</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token punctuation">[</span>目录路径<span class="token punctuation">]</span></code></pre><p>常见用法示例</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>cd /home/user</code></td><td>切换到绝对路径 <code>/home/user</code> 目录</td></tr><tr><td><code>cd ..</code></td><td>切换到上一级目录</td></tr><tr><td><code>cd</code> 或 <code>cd ~</code></td><td>切换到当前用户的主目录</td></tr><tr><td><code>cd -</code></td><td>切换到上一次所在的目录（切换目录的“切换”）</td></tr><tr><td><code>cd ./folder</code></td><td>切换到当前目录下的子目录 <code>folder</code></td></tr></tbody></table><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>用于<strong>创建新目录</strong>的命令，创建不了已存在目录。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 目录名</code></pre><p>mkdir test 在当前目录下创建test文件夹</p><p>mkdir &#x2F;tmp&#x2F;test</p><p>mkdir file{1..100}在当前目录创建100个文件夹，file1,file2,file3…file100</p><p>mkdir “file{1..100}”在当前目录创建file{1..100}文件夹，只会创建一个。</p><p>mkdir “a b” 在当前目录创建a b一个文件夹。</p><p>mkdir a b 在当前目录创建a b两个文件夹。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code></td><td>递归创建目录（父目录不存在时自动创建）</td></tr><tr><td><code>-m MODE</code></td><td>设置新建目录的权限，如 <code>-m 755</code></td></tr><tr><td><code>-v</code></td><td>显示详细创建过程（verbose）</td></tr></tbody></table><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>用法和mkdir相同</p><p>用于<strong>删除空目录</strong>的命令</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>rmdir testdir</code></td><td>删除当前目录下的 <code>testdir</code>（需为空）</td></tr><tr><td><code>rmdir -p a/b/c</code></td><td>递归删除空目录链：先删 <code>c</code>，再删 <code>b</code>，再删 <code>a</code></td></tr><tr><td><code>rmdir ./mydir/</code></td><td>删除当前目录中的 <code>mydir</code>（需为空）</td></tr></tbody></table><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code></td><td>递归删除路径中的所有空目录（从子到父）</td></tr><tr><td><code>--ignore-fail-on-non-empty</code></td><td>删除目录时忽略非空目录导致的错误</td></tr></tbody></table><h2 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h2><p>常用的文件类型有七种：普通文件，目录文件，设备文件，管道文件，链接文件和套接字。</p><p><img src="/2025/06/20/Linux-System%20Programming/1.png" alt="1" loading="lazy"></p><p><strong>普通文件</strong> 是 Linux 中最常见的一类文件，主要用于存储用户数据。包括：</p><ul><li>文本文件（如 <code>.txt</code>, <code>.c</code>, <code>.py</code>）</li><li>二进制文件（如 可执行程序、图片、音频等）</li><li>脚本文件（如 <code>.sh</code>, <code>.py</code>，可以被解释执行）</li></ul><p>在 Linux 中，<strong>目录文件（Directory File）</strong> 是一种特殊的文件类型，用来组织和存放文件和其他目录（子目录）。<br> 它本质上是一个<strong>保存了文件名和 inode 编号之间映射关系</strong>的文件。</p><p><strong>设备文件</strong>（Device File）是 Linux 中用于访问硬件设备的接口，本质上就是一种特殊的文件，程序通过它来与硬件设备通信。</p><p>设备文件通常位于 <code>/dev</code> 目录中。</p><p>常见设备文件举例</p><table><thead><tr><th>路径</th><th>类型</th><th>功能描述</th></tr></thead><tbody><tr><td><code>/dev/sda</code></td><td>块设备</td><td>第一块硬盘</td></tr><tr><td><code>/dev/tty</code></td><td>字符设备</td><td>当前终端</td></tr><tr><td><code>/dev/null</code></td><td>字符设备</td><td>写入数据会被丢弃</td></tr><tr><td><code>/dev/zero</code></td><td>字符设备</td><td>会源源不断输出 0</td></tr><tr><td><code>/dev/random</code></td><td>字符设备</td><td>伪随机数生成器</td></tr></tbody></table><p><strong>管道文件</strong>（或称命名管道，FIFO &#x3D; First In First Out）是一种特殊文件，用于<strong>在不同进程之间传输数据</strong>。<br> 写入管道的数据会按顺序被读取，类似“排队喝水”的水管，先进先出。</p><p>管道文件与匿名管道不同之处在于它有名字，存在于文件系统中（通常创建在某个路径下），因此<strong>不同进程不必有父子关系</strong>也能通信。</p><p><strong>链接文件</strong> 是指向另一个文件的引用，常用于：</p><ul><li>创建多个路径指向同一个文件（节省空间）</li><li>为长路径或常用文件创建别名（提高效率）</li><li>实现共享与替代功能</li></ul><table><thead><tr><th>类型</th><th>描述</th><th><code>ls -l</code> 标识</th></tr></thead><tbody><tr><td><strong>软链接</strong>（符号链接）</td><td>类似 Windows 快捷方式，是一个指向目标路径的独立文件</td><td><code>l</code></td></tr><tr><td><strong>硬链接</strong></td><td>直接指向目标文件的 inode，本质上是同一个文件的另一个名字</td><td><code>-</code></td></tr></tbody></table><p>在 Linux 中，你可以使用 <code>ls -l</code> 命令来区分各种文件类型。<code>ls -l</code> 输出的每一行开头的第一个字符表示文件类型。下面是 <strong>七种常见文件类型及其 <code>ls -l</code> 显示符号</strong>：</p><p>七种常见文件类型及其标识</p><table><thead><tr><th>文件类型</th><th><code>ls -l</code> 类型字符</th><th>示例路径</th><th>含义说明</th></tr></thead><tbody><tr><td><strong>普通文件</strong></td><td><code>-</code></td><td><code>-rw-r--r-- file.txt</code></td><td>常见的文本、二进制、可执行文件等</td></tr><tr><td><strong>目录文件</strong></td><td><code>d</code></td><td><code>drwxr-xr-x dir/</code></td><td>存储文件的容器</td></tr><tr><td><strong>字符设备文件</strong></td><td><code>c</code></td><td><code>crw------- /dev/tty</code></td><td>逐字符访问设备，如终端、串口等</td></tr><tr><td><strong>块设备文件</strong></td><td><code>b</code></td><td><code>brw-rw---- /dev/sda</code></td><td>按块访问设备，如硬盘、U 盘等</td></tr><tr><td><strong>管道文件</strong></td><td><code>p</code></td><td><code>prw-r--r-- mypipe</code></td><td>用于进程间通信的 FIFO 管道</td></tr><tr><td><strong>链接文件</strong></td><td><code>l</code></td><td><code>lrwxrwxrwx link -&gt; target</code></td><td>指向其他文件的软链接</td></tr><tr><td><strong>套接字文件</strong></td><td><code>s</code></td><td><code>srwxrwxrwx socket</code></td><td>进程间网络通信接口，如 <code>/tmp/.X11-unix/X0</code></td></tr></tbody></table><h2 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h2><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code>ls</code></td><td>简单列出当前目录内容</td></tr><tr><td><code>ls -a</code></td><td>显示所有文件，包括隐藏文件（以<code>.</code>开头）</td></tr><tr><td><code>ls -l</code></td><td>以长格式列出，显示权限、类型、时间等</td></tr><tr><td><code>ls -lh</code></td><td>长格式 + 人类可读大小（如 KB, MB）</td></tr><tr><td><code>ls -lt</code></td><td>按修改时间排序，最新的在前</td></tr><tr><td><code>ls -r</code></td><td>反向排序</td></tr><tr><td><code>ls -R</code></td><td>递归列出子目录</td></tr><tr><td><code>ls -d */</code></td><td>只列出目录 ls -d只显示一个.</td></tr></tbody></table><p>ls -l命令会输出长格式</p><pre class="language-none"><code class="language-none">权限       硬链接数 拥有者 所属组  大小    修改日期      文件名drwxr-xr-x   2    user   user  4096   Jun 21 13:00  mydir</code></pre><p>对权限部分说明一下权限部分总共10个字符</p><table><thead><tr><th>位置</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>文件类型标识</td></tr><tr><td>2-4</td><td><strong>拥有者（user）</strong>权限</td></tr><tr><td>5-7</td><td><strong>同组用户（group）</strong>权限</td></tr><tr><td>8-10</td><td><strong>其他用户（others）</strong>权限</td></tr></tbody></table><p>文件类型标识（第1个字符）</p><table><thead><tr><th>字符</th><th>类型</th></tr></thead><tbody><tr><td><code>-</code></td><td>普通文件</td></tr><tr><td><code>d</code></td><td>目录</td></tr><tr><td><code>l</code></td><td>软链接</td></tr><tr><td><code>c</code></td><td>字符设备文件</td></tr><tr><td><code>b</code></td><td>块设备文件</td></tr><tr><td><code>p</code></td><td>管道（FIFO）</td></tr><tr><td><code>s</code></td><td>套接字</td></tr></tbody></table><p>权限字符说明（2-10位置）</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>r</code></td><td>读权限 (read)</td></tr><tr><td><code>w</code></td><td>写权限 (write)</td></tr><tr><td><code>x</code></td><td>执行权限 (execute)</td></tr><tr><td><code>-</code></td><td>无该权限</td></tr><tr><td><code>s</code></td><td>setuid&#x2F;setgid 位（特殊执行权限）</td></tr><tr><td><code>t</code></td><td>粘滞位（sticky bit）</td></tr></tbody></table><p>三组权限详解</p><table><thead><tr><th>组别</th><th>位置</th><th>含义</th></tr></thead><tbody><tr><td><strong>拥有者</strong></td><td>2~4 字符</td><td>拥有该文件&#x2F;目录的用户权限</td></tr><tr><td><strong>组用户</strong></td><td>5~7 字符</td><td>属于该文件组的用户权限</td></tr><tr><td><strong>其他用户</strong></td><td>8~10 字符</td><td>系统中除拥有者和组以外的所有用户权限</td></tr></tbody></table><h3 id="什么是通配符？"><a href="#什么是通配符？" class="headerlink" title="什么是通配符？"></a>什么是通配符？</h3><p>通配符是一种简化文件名匹配的符号，用于在命令中匹配多个文件或目录。它可以让你不用输入完整文件名，就能选中符合规则的文件。</p><p>常用的通配符类型</p><table><thead><tr><th>通配符</th><th>作用</th><th>例子</th><th>匹配结果示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任意数量的任意字符（包括0个）</td><td><code>ls *.txt</code></td><td>匹配所有以 <code>.txt</code> 结尾的文件</td></tr><tr><td><code>?</code></td><td>匹配任意一个单字符</td><td><code>ls file?.txt</code></td><td>匹配 <code>file1.txt</code>、<code>fileA.txt</code>，但不匹配 <code>file10.txt</code></td></tr><tr><td><code>[abc]</code></td><td>匹配括号内的任意一个字符</td><td><code>ls file[123].txt</code></td><td>匹配 <code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code></td></tr><tr><td><code>[a-z]</code></td><td>匹配指定范围内的任意一个字符</td><td><code>ls file[a-c].txt</code></td><td>匹配 <code>filea.txt</code>、<code>fileb.txt</code>、<code>filec.txt</code></td></tr><tr><td><code>[!abc]</code></td><td>匹配不在括号内的任意一个字符</td><td><code>ls file[!123].txt</code></td><td>匹配除 <code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code> 以外的文件</td></tr></tbody></table><h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p><code>touch</code> 是用来 <strong>创建空文件</strong> 或 <strong>更新已有文件的时间戳</strong> 的命令。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> file.txt</code></pre><p>如果 <code>file.txt</code> 不存在，会被创建为空文件；如果存在，文件时间被更新。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> file1.txt file2.txt file3.txt</code></pre><p>一次创建或更新多个文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> file<span class="token punctuation">&#123;</span><span class="token number">2,3</span>,4<span class="token punctuation">&#125;</span><span class="token comment">#同时创建file2,file3,file4三个空文件和mkdir file&#123;1..100&#125;用法是一样的。</span><span class="token function">touch</span> <span class="token string">"file&#123;2,3,4&#125;"</span>#创建file<span class="token punctuation">&#123;</span><span class="token number">2,3</span>,4<span class="token punctuation">&#125;</span>这一个文件。</code></pre><h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p><code>cp</code> 是 Linux 中用于 <strong>复制文件或目录</strong> 的命令。</p><table><thead><tr><th>任务</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td>复制文件</td><td><code>cp file1.txt file2.txt</code></td><td>把 <code>file1.txt</code> 内容复制为 <code>file2.txt</code></td></tr><tr><td>复制文件到目录</td><td><code>cp file1.txt /home/user/docs/</code></td><td>把 <code>file1.txt</code> 复制进目录</td></tr><tr><td>复制目录（加 <code>-r</code>）</td><td><code>cp -r dir1/ dir2/</code></td><td>递归复制整个目录 <code>dir1</code> 到 <code>dir2</code> 中</td></tr><tr><td>保留属性复制文件</td><td><code>cp -p file1.txt file2.txt</code></td><td>保留原文件的时间戳、权限等信息</td></tr><tr><td>强制覆盖目标文件</td><td><code>cp -f file1.txt file2.txt</code></td><td>如果 <code>file2.txt</code> 存在，强制覆盖</td></tr><tr><td>复制并提示</td><td><code>cp -i file1.txt file2.txt</code></td><td>有冲突时会提示确认</td></tr><tr><td>显示复制过程</td><td><code>cp -v file1.txt file2.txt</code></td><td>复制时显示详细过程（verbose 模式）</td></tr></tbody></table><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-r</code></td><td>递归复制目录（必须用于复制目录）</td></tr><tr><td><code>-i</code></td><td>覆盖文件前提示确认</td></tr><tr><td><code>-f</code></td><td>强制覆盖目标文件而不提示</td></tr><tr><td><code>-p</code></td><td>保留原文件的属性（权限、时间等）</td></tr><tr><td><code>-u</code></td><td>只在源文件较新时才复制</td></tr><tr><td><code>-v</code></td><td>显示复制过程（verbose）</td></tr><tr><td><code>-a</code></td><td>归档模式，等价于 <code>-dpR</code>，用于备份</td></tr><tr><td><code>--parents</code></td><td>保留源路径结构复制文件（适用于目录结构迁移）</td></tr></tbody></table><h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><p>是用于在 Linux 中 <strong>删除文件和目录</strong> 的命令。注意：<code>rm</code> 删除后不会进入回收站，<strong>无法轻易恢复</strong>，请务必小心使用。</p><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>删除单个文件</td><td><code>rm file.txt</code></td><td>删除文件 <code>file.txt</code></td></tr><tr><td>删除多个文件</td><td><code>rm file1.txt file2.txt</code></td><td>一次删除多个文件</td></tr><tr><td>递归删除目录及内容</td><td><code>rm -r mydir/</code></td><td>删除目录 <code>mydir</code> 及其所有子目录和文件</td></tr><tr><td>强制删除文件&#x2F;目录</td><td><code>rm -f file.txt</code> &#x2F; <code>rm -rf mydir/</code></td><td>忽略不存在的文件，且不提示确认</td></tr><tr><td>删除前确认</td><td><code>rm -i file.txt</code></td><td>删除前逐一询问确认</td></tr><tr><td>显示正在删除的文件</td><td><code>rm -v file.txt</code></td><td>显示被删除的文件名</td></tr></tbody></table><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-r</code> 或 <code>--recursive</code></td><td>递归删除目录及其内容（删除整个目录树）</td></tr><tr><td><code>-f</code> 或 <code>--force</code></td><td>强制删除，不提示，即使目标不存在也不报错</td></tr><tr><td><code>-i</code></td><td>删除前询问确认，适合新手使用以防误删</td></tr><tr><td><code>-I</code></td><td>删除多个文件或目录时才询问一次，比 <code>-i</code> 安全且不烦人</td></tr><tr><td><code>-v</code> 或 <code>--verbose</code></td><td>显示正在删除的每一个文件或目录</td></tr><tr><td><code>--preserve-root</code></td><td>默认保护根目录 <code>/</code> 不被删除（系统安全机制，防止 <code>rm -rf /</code> 误操作）</td></tr></tbody></table><h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p><strong>移动文件或目录</strong> 到新位置，<strong>重命名</strong> 文件或目录。</p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td>移动文件</td><td><code>mv a.txt /home/user/docs/</code></td><td>把 <code>a.txt</code> 移动到 <code>/home/user/docs/</code> 目录</td></tr><tr><td>重命名文件</td><td><code>mv old.txt new.txt</code></td><td>将 <code>old.txt</code> 重命名为 <code>new.txt</code></td></tr><tr><td>移动并重命名</td><td><code>mv a.txt /home/user/docs/b.txt</code></td><td>移动 <code>a.txt</code> 到新目录并改名为 <code>b.txt</code></td></tr><tr><td>移动目录</td><td><code>mv dir1/ /home/user/backup/</code></td><td>移动整个目录到新的路径</td></tr><tr><td>覆盖已有文件</td><td><code>mv -f a.txt b.txt</code></td><td>如果 <code>b.txt</code> 存在，则强制覆盖</td></tr><tr><td>覆盖前确认</td><td><code>mv -i a.txt b.txt</code></td><td>如果 <code>b.txt</code> 存在，移动前会询问是否覆盖</td></tr><tr><td>显示移动过程</td><td><code>mv -v a.txt b.txt</code></td><td>显示正在移动的内容</td></tr></tbody></table><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-f</code></td><td>强制覆盖已有目标文件，不提示</td></tr><tr><td><code>-i</code></td><td>如果目标文件存在，提示是否覆盖（interactive）</td></tr><tr><td><code>-n</code></td><td>不覆盖已有的目标文件（no-clobber）</td></tr><tr><td><code>-v</code></td><td>显示移动过程（verbose）</td></tr><tr><td><code>-u</code></td><td>仅在源文件较新或目标文件不存在时才移动</td></tr></tbody></table><h2 id="文件内容查看相关命令"><a href="#文件内容查看相关命令" class="headerlink" title="文件内容查看相关命令"></a>文件内容查看相关命令</h2><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>用于 <strong>查看、创建、合并文件</strong> 内容，常用于快速查看文本文件内容。</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-n</code></td><td>给所有行编号</td></tr><tr><td><code>-b</code></td><td>只对非空行编号</td></tr><tr><td><code>-s</code></td><td>压缩连续空白行为一行</td></tr><tr><td><code>-T</code></td><td>显示 Tab 为 <code>^I</code></td></tr><tr><td><code>-E</code></td><td>显示每行结尾的 <code>$</code>（换行符可见）</td></tr><tr><td><code>-A</code></td><td>相当于 <code>-vET</code>，显示所有不可见字符</td></tr></tbody></table><h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p>用于<strong>分页显示文件内容</strong>的命令，支持 <strong>向前&#x2F;向后翻页浏览</strong>，适合查看<strong>大型文本文件</strong>。它比 <code>cat</code> 更强大，且不会一次性加载全部内容到内存中。</p><p>使用时常用快捷键（进入 less 后）</p><table><thead><tr><th>快捷键</th><th>功能说明</th></tr></thead><tbody><tr><td><code>空格</code></td><td>向下翻一页</td></tr><tr><td><code>b</code></td><td>向上翻一页</td></tr><tr><td><code>Enter</code></td><td>向下滚动一行</td></tr><tr><td><code>k</code></td><td>向上一行（vi 风格）</td></tr><tr><td><code>j</code></td><td>向下一行</td></tr><tr><td><code>G</code></td><td>跳到文件末尾</td></tr><tr><td><code>g</code></td><td>跳到文件开头</td></tr><tr><td><code>/关键词</code></td><td>向下搜索（如 <code>/error</code>）</td></tr><tr><td><code>?关键词</code></td><td>向上搜索</td></tr><tr><td><code>n</code></td><td>重复上一次搜索</td></tr><tr><td><code>N</code></td><td>反向重复搜索</td></tr><tr><td><code>q</code></td><td>退出 less</td></tr></tbody></table><h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><p><code>head</code> 用于<strong>查看文件的前几行内容</strong>，默认显示前 10 行。适合快速预览文件开头，尤其是大型文件或日志文件。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-n N</code></td><td>显示前 N 行（如 <code>head -n 15 file.txt</code>）</td></tr><tr><td><code>-c N</code></td><td>显示前 N 个<strong>字节</strong>（如 <code>head -c 100 file.txt</code>）</td></tr><tr><td><code>-q</code></td><td>多文件时不显示文件名头部（quiet）</td></tr><tr><td><code>-v</code></td><td>总是显示文件名头部（verbose）</td></tr></tbody></table><h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>用于<strong>显示文件的最后几行内容</strong>，默认是最后 10 行。常用于：</p><ul><li>查看日志尾部；</li><li>实时监控文件内容变化（配合 <code>-f</code> 选项）；</li><li>截取文件结尾部分数据。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux常见目录&quot;&gt;&lt;a href=&quot;#Linux常见目录&quot; class=&quot;headerlink&quot; title=&quot;Linux常见目录&quot;&gt;&lt;/a&gt;Linux常见目录&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
</summary>
      
    
    
    
    <category term="计算机学习" scheme="http://yustonerain.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="http://yustonerain.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构100题</title>
    <link href="http://yustonerain.top/2025/06/02/data-structure-100.html"/>
    <id>http://yustonerain.top/2025/06/02/data-structure-100.html</id>
    <published>2025-06-02T16:02:57.000Z</published>
    <updated>2025-06-23T13:25:20.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">两数之和</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​ 给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1]</code></pre><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h3><h4 id="具体思路："><a href="#具体思路：" class="headerlink" title="具体思路："></a>具体思路：</h4><p>首先使用unordered_map，在遍历原数组时，边查边找。</p><p>如果没找到，就把当前值的值和下标存入unordered_map，以便下次寻找可以搜素以前的键值对，看是否有满足情况（target-nums[i]）的key,若有，取出对应的value(iter-&gt;second)和当前的数组下标一起返回。当然最坏的情况，遍历完了，也没有符合情况的出现。可以直接返回空。</p><h4 id="std-unordered-map的核心特性："><a href="#std-unordered-map的核心特性：" class="headerlink" title="std::unordered_map的核心特性："></a>std::unordered_map的核心特性：</h4><p><strong>1. 基于哈希表实现（Hash Table）</strong></p><ul><li><code>unordered_map</code> 通过哈希函数（<code>std::hash</code>）将键（key）映射到一个桶（bucket）中，实现<strong>常数时间复杂度（O(1)）</strong>的查找、插入和删除操作（平均情况）。</li><li>哈希冲突通过链表（或更优化的结构）解决。</li></ul><hr><ol start="2"><li><strong>键唯一（Key is Unique）</strong></li></ol><ul><li>每个键（key）在 <code>unordered_map</code> 中必须是唯一的，如果插入相同键，会覆盖原有值或插入失败（取决于操作方式）。</li></ul><hr><p><strong>3. 无序（Unordered）</strong></p><ul><li>元素的存储顺序<strong>不保证稳定性或有序性</strong>，与插入顺序无关。</li><li>如果需要有序容器，应使用 <code>std::map</code>。</li></ul><hr><p><strong>4. 自动扩容</strong></p><ul><li><code>unordered_map</code> 会根据负载因子（load factor）自动扩展桶的数量，以保持操作效率。</li><li>用户可以手动调整负载因子和桶数量（如 <code>rehash()</code> 或 <code>reserve()</code> 函数）。</li></ul><hr><p><strong>5. 允许自定义哈希函数与相等比较器</strong></p><ul><li>支持用户为自定义类型指定哈希函数（通过模板参数 <code>Hash</code> 和 <code>KeyEqual</code>）。</li></ul><pre class="language-none"><code class="language-none">cpp复制编辑std::unordered_map&lt;MyType, int, MyHash, MyEqual&gt;</code></pre><p> <strong>6. 快速访问接口</strong></p><ul><li><code>operator[]</code>：快速访问键对应的值，如果键不存在，则自动插入默认值。</li><li><code>find()</code>：返回一个迭代器，指向查找到的键值对，否则为 <code>end()</code>。</li></ul><hr><p><strong>7. 不支持排序算法</strong></p><ul><li>由于无序存储，标准排序算法（如 <code>sort</code>）不能直接应用于 <code>unordered_map</code>，但可以通过将其内容复制到 <code>vector&lt;pair&lt;&gt;&gt;</code> 后排序实现。</li></ul><hr><p><strong>8. 多线程下非线程安全</strong></p><ul><li>多线程环境下访问 <code>unordered_map</code> 必须加锁或使用线程安全容器。</li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> map<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">auto</span> iter <span class="token operator">=</span>map<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>target<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>iter<span class="token operator">!=</span>map<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span>iter<span class="token operator">-></span>second<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><ul><li>一次遍历 <code>nums</code> 数组，时间是 <code>O(n)</code>。</li><li>对于每个元素：<ul><li><code>map.find(...)</code> 查找操作的平均时间复杂度是 **O(1)**。</li><li><code>map.insert(...)</code> 插入操作的平均时间复杂度也是 **O(1)**。</li></ul></li></ul><p>因此，总体时间复杂度是：</p><p>**O(n)**（n 是数组中元素的数量）</p><h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>最多会向 <code>unordered_map</code> 中插入 <code>n</code> 个元素（每个 <code>nums[i]</code> 和其索引 <code>i</code>）。</li><li>所以空间复杂度与 <code>nums</code> 的大小成正比。</li></ul><p>**O(n)**（额外使用了哈希表来存储 n 个键值对）</p><h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: strs &#x3D; [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: strs &#x3D; [&quot;&quot;]输出: [[&quot;&quot;]]</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: strs &#x3D; [&quot;a&quot;]输出: [[&quot;a&quot;]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="具体思路：-1"><a href="#具体思路：-1" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​首先使用std::unordered_map结构，当然不用再介绍了。这个题的意思是把那些排序之后相同的单词放在一个组合。</p><p>所以我们可以先使用unordered_map&lt;string,vector<string>&gt;存储键值对，键就是排序之后的单词，毕竟排序之后都一样。</string></p><p>键对应的值就是对应的单词（排序相同的单词），最后再遍历这个unordered_map，输出结果。</p><h4 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//做这道题首先对于字母异位词 排序之后是相同的，所以可以用一个哈希表，键存储排序后的结果，值为结果集</span>        std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> record<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            string temp<span class="token operator">=</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>temp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            record<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>record<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>record<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>it<span class="token operator">-></span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>假设：</p><ul><li><code>n</code> 是字符串数组 <code>strs</code> 的长度。</li><li><code>k</code> 是每个字符串的平均长度。</li></ul><ol><li>遍历 <code>strs</code> 中的每个字符串，共 <code>n</code> 次。</li><li>对每个字符串排序：<code>O(k log k)</code></li><li>哈希表插入&#x2F;查找键值对：<code>O(1)</code> 平均时间。</li></ol><p>所以总时间复杂度为：</p><p><strong>O(n * k log k)</strong></p><h4 id="空间复杂度：-1"><a href="#空间复杂度：-1" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>哈希表 <code>record</code> 最多存 <code>n</code> 个键，每个键存一个 <code>vector&lt;string&gt;</code>，整体字符串内容不变，只是重新组织。</li><li>排序后的中间变量 <code>temp</code> 的开销为 <code>O(k)</code>，共用一次。</li><li>最终结果 <code>ans</code> 存储所有原字符串内容。</li></ul><p>所以额外空间主要包括：</p><ol><li>哈希表键（排序后的字符串）：最多 <code>n</code> 个，每个长度为 <code>k</code>：<code>O(n * k)</code></li><li>哈希表值（字符串集合）：整体还是输入的字符串，只是重新组织，<strong>不算重复存储</strong></li><li>排序的临时变量（重复使用）：忽略不计</li></ol><p>因此总空间复杂度为：</p><p><strong>O(n * k)</strong></p><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]输出：9</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,0,1,2]输出：3</code></pre><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-2"><a href="#具体思路：-2" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​首先将数组存入unordered_set中避免重复，为什么用unordered_set，因为找元素它是O(1)。</p><p>接下来遍历unordered_set，先判断当前元素有没有前一个连续的元素（例子：当前元素为5，查是否有4），有则跳过，没有则进行下一步，并且这个节点是作为开始节点。</p><p>然后先保存当前节点的值和连续序列的长度（这个时候为1），然后循环查找连续序列，最后获得连续序列的长度，再和历史最长连续序</p><p>列比较，更新历史最长连续序列。遍历完unordered_set，返回历史最长连续序列即可。</p><h4 id="std-unordered-set的特性："><a href="#std-unordered-set的特性：" class="headerlink" title="std::unordered_set的特性："></a>std::unordered_set的特性：</h4><p><code>std::unordered_set</code> 是 C++ 标准库中提供的 <strong>无序集合容器</strong>，它内部基于哈希表实现，主要用于快速判断一个元素是否存在，并确保元素唯一。下面是它的详细特性：</p><hr><p><strong>1. 元素唯一（Unique Elements）</strong></p><ul><li>它是一个 <strong>集合（set）</strong>，<strong>不允许重复元素</strong>。</li><li>插入相同元素将失败，已有的不会被替换。</li></ul><hr><p><strong>2. 基于哈希表（Hash Table）</strong></p><ul><li>内部使用哈希表存储元素。</li><li>插入、查找、删除的**平均时间复杂度是 O(1)**，非常高效。</li><li>如果发生大量哈希冲突，最坏情况会退化为 O(n)，但 STL 默认哈希函数表现良好，一般不会发生。</li></ul><hr><p><strong>3. 元素无序（Unordered）</strong></p><ul><li>和 <code>std::set</code>（基于红黑树，有序）不同，<code>unordered_set</code> 中的元素<strong>存储顺序不固定</strong>。</li><li>遍历时元素的顺序是哈希桶顺序，<strong>不可预测</strong>。</li></ul><hr><p><strong>4. 可自定义哈希函数（支持自定义类型）</strong></p><ul><li>可以为自定义类型提供哈希函数和等价比较函数。</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unordered_set<span class="token operator">&lt;</span>MyType<span class="token punctuation">,</span> MyHash<span class="token punctuation">,</span> MyEqual<span class="token operator">></span></code></pre><hr><p><strong>5. 常用操作和函数</strong></p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>insert(val)</code></td><td>插入元素，若已存在则不插入</td></tr><tr><td><code>erase(val)</code></td><td>删除元素</td></tr><tr><td><code>find(val)</code></td><td>查找元素，返回迭代器</td></tr><tr><td><code>count(val)</code></td><td>判断元素是否存在（返回 0 或 1）</td></tr><tr><td><code>size()</code></td><td>元素个数</td></tr><tr><td><code>empty()</code></td><td>是否为空</td></tr><tr><td><code>clear()</code></td><td>清空所有元素</td></tr><tr><td><code>begin()</code>, <code>end()</code></td><td>返回迭代器（可用于范围遍历）</td></tr></tbody></table><hr><p><strong>5.与 <code>std::set</code> 的区别</strong></p><table><thead><tr><th>特性</th><th><code>std::set</code>（有序）</th><th align="center"><code>std::unordered_set</code>（无序）</th></tr></thead><tbody><tr><td>底层结构</td><td>红黑树（平衡 BST）</td><td align="center">哈希表</td></tr><tr><td>元素是否有序</td><td>是</td><td align="center">否</td></tr><tr><td>查找&#x2F;插入效率</td><td><code>O(log n)</code></td><td align="center">平均 <code>O(1)</code></td></tr><tr><td>内存使用</td><td>较少</td><td align="center">较多（需额外存哈希结构）</td></tr><tr><td>自定义排序</td><td>支持</td><td align="center">不支持</td></tr></tbody></table><h4 id="代码块：-1"><a href="#代码块：-1" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> num_set<span class="token punctuation">;</span>        <span class="token comment">//使用unordered_set存储nums的所有值</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>num<span class="token operator">:</span>nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            num_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> longSum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>num<span class="token operator">:</span>num_set<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//上述遍历用nums和num_set有什么区别，在leetcode一个能过一个不能过</span>            <span class="token comment">//以遍历的每个元素为起点，满足才进行下一步操作</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>num_set<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>num<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//满足条件后，存储当前节点的信息</span>                <span class="token keyword">int</span> currentNum<span class="token operator">=</span>num<span class="token punctuation">;</span>                <span class="token keyword">int</span> currentSum<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">//寻找该节点的最长连续序列</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>num_set<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>currentNum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    currentNum<span class="token operator">=</span>currentNum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                    currentSum<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">//最后与longSum比较，更新历史最长连续序列</span>                longSum<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>currentSum<span class="token punctuation">,</span>longSum<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> longSum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="编写代码产生的问题："><a href="#编写代码产生的问题：" class="headerlink" title="编写代码产生的问题："></a>编写代码产生的问题：</h4><p>上述遍历用nums和num_set有什么区别，在leetcode一个能过一个不能过</p><p><strong>遍历 <code>num_set</code>：</strong></p><ul><li>每个元素最多只被作为“起点”处理一次。</li><li>例如：对于序列 <code>[100, 101, 102, 103]</code>，只有 <code>100</code> 会进入 while 循环处理。</li><li>其他如 <code>101</code>、<code>102</code> 在 <code>if (!num_set.count(num - 1))</code> 时会被跳过（因为 <code>100</code> 已经处理了它们）。</li><li>所以是 <strong>O(n)</strong> 时间复杂度。</li></ul><p><strong>遍历 <code>nums</code>：</strong></p><ul><li><code>nums</code> 可能包含重复值，也可能无序。</li><li>比如你在 <code>nums</code> 中遇到 <code>102</code>，它不是起点，但你仍会试图查找连续数字，造成<strong>重复计算</strong>。</li><li>重复调用 <code>count()</code>，浪费性能，导致 <strong>超时</strong> 或 <strong>错误结果</strong>（重复统计）。</li></ul><h4 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>设输入数组 <code>nums</code> 的长度为 <code>n</code>。</p><ol><li><code>unordered_set</code> 插入 <code>n</code> 个元素：**O(n)**（平均时间，插入是 O(1)）。</li><li>第二个循环遍历 <code>num_set</code> 中的每个元素，<strong>每个连续序列只处理一次</strong>。</li></ol><pre class="language-none"><code class="language-none">if (!num_set.count(num - 1))</code></pre><ul><li>这个判断确保每个序列的起点只会被处理一次。</li><li>例如序列 <code>[100, 101, 102, 103]</code> 只会从 <code>100</code> 开始处理一次，不会在遍历到 <code>101</code> 时重复处理。</li></ul><p>因此：</p><p>**总时间复杂度：O(n)**（哈希表操作均为 O(1) 平均时间）</p><h4 id="空间复杂度：-2"><a href="#空间复杂度：-2" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>使用了一个 <code>unordered_set</code> 存储 <code>n</code> 个整数，占用 O(n) 的空间。</li><li>其他变量如 <code>currentNum</code>, <code>currentSum</code> 等为常数空间。</li></ul><p>因此：</p><p><strong>总空间复杂度：O(n)</strong></p><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">移动零</a></h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: nums &#x3D; [0]输出: [0]</code></pre><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-3"><a href="#具体思路：-3" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​我们可以采用双指针的方法，先left,right同时指向起始点，right到最后位置结束。当right找到非零节点，与left进行值交换，left只有交换结束才left++;这样最后非零节点都在前面，0都在末尾。</p><h4 id="代码块：-2"><a href="#代码块：-2" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>right<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><ul><li><code>right</code> 从 <code>0</code> 遍历到 <code>n-1</code>，每个元素访问一次。</li><li>最多发生 <code>n</code> 次 <code>swap</code> 操作（每个非零元素最多被交换一次）。</li><li>所以：</li></ul><p><strong>总时间复杂度：O(n)</strong></p><h4 id="空间复杂度：-3"><a href="#空间复杂度：-3" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>只使用了常量级别的辅助变量 <code>left</code> 和 <code>right</code>。</li><li>所有操作都在原数组上进行，<strong>原地修改</strong>，没有开辟额外数组。</li></ul><p><strong>总空间复杂度：O(1)</strong></p><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a></h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [1,1]输出：1</code></pre><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-4"><a href="#具体思路：-4" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​我们采用双指针的方式求解。这个题目的是求解柱子之间的最大面积。我们可以采用将两个指针放在两端，如果左边的柱子高度大于或等于右边的柱子高度，我们先算出容器对应的面积（高度以低柱子为准）。算出后更新历史最大面积。执行完，将右边的柱子向左移动。同时，还有一种情况，左边的柱子高度小于右边的柱子高度，先算出容器对应的面积（高度以低柱子为准）。算出后更新历史最大面积。执行完，将左边的柱子向右移动。直到当前的左柱子和右柱子重合。</p><h4 id="代码块：-3"><a href="#代码块：-3" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//采用双指针的方式求解</span>        <span class="token keyword">int</span> left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right<span class="token operator">=</span>height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">>=</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">*</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">*</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-4"><a href="#时间复杂度：-4" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>时间复杂度：<code>O(n)</code></p><ul><li>解释：使用的是<strong>双指针</strong>方法，从两端向中间遍历整个数组，每一次迭代都会<strong>移动左指针或右指针之一</strong>，因此总共最多移动 <code>n-1</code> 次。</li><li>所以时间复杂度是 **线性的 O(n)**，其中 <code>n</code> 是 <code>height</code> 数组的长度。</li></ul><h4 id="空间复杂度：-4"><a href="#空间复杂度：-4" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(1)</code></p><ul><li>解释：只使用了常数个额外变量（如 <code>ans</code>, <code>left</code>, <code>right</code>, <code>h</code>, <code>w</code>），不依赖于输入数据的大小。</li><li>因此空间复杂度是 **常数级 O(1)**。</li></ul><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><a href="https://leetcode.cn/problems/3sum/">三数之和</a></h2><h3 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。</code></pre><p><strong>示例 3：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 </code></pre><h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-5"><a href="#具体思路：-5" class="headerlink" title="具体思路："></a>具体思路：</h4><p>​这题的目标是在在整数数组中，找到所有三个数满足和为零，最后结果不可以重复。这个题我们可以先定下一个值，剩下两个值用双指针法遍历，找到符合结果的。还有一些细节，还要考虑不能重复的问题，对于这个问题，我们可以先排序（升序）这个数组，从小到大定第一个值，首先如果这第一个值大于0，这个可以结束了，这个数组就不会存在符合条件的三元组。当然如果当前元素与上一个元素相同，也跳过，这样执行，首先我想的是定第一个元素，当当前元素和下一个元素相同直接跳过，后来发现，[-1,-1,2]这种情况没有考虑。当然那你为甚么还是要写当前元素与上一个元素相同，也跳过，我完全可以不管嘛，那不行，我的思路是当第一个元素是-1时，这一次直接找出所有符合第一个元素是-1的情况，要不然会十分混乱，所以我会说如果当前元素与上一个元素相同，也跳过。因为上一个元素已经找完了第一个元素为-1的三元组了，当避免找完-1还会再出现，我们用了排序。这样第一个元素的逻辑就结束了，接下来找剩下两个，用双指针，左指针指向当前元素的下一个元素，右指针指向末尾元素。我们是要找到所有符合情况，当三元组的值大于0，将右指针左移。当三元组的值小于0，将左指针右移。当三元组的值等于0，将三元组的值加入结果集。接下来再判断找到的左元素是否与后面的元素重复（因为是排序的，相同的元素就在身边）。跳过这些元素，找到的右元素是否与后面的元素重复（因为是排序的，相同的元素就在身边）。跳过这些元素。只要左指针和右指针没有重合，就一直找，找完符合情况的三元组。</p><h4 id="代码块：-4"><a href="#代码块：-4" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">threeSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token comment">//先升序排序</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//遍历排序后的数组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//先定第一个元素</span>            <span class="token comment">//第一个元素大于0,因为是升序排序，后面都大于零，那没有满足条件的结果了</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment">//如果上一个元素相同，跳过当前，用下一个</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">//采用双指针定剩下两个</span>            <span class="token keyword">int</span> left<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> right<span class="token operator">=</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> right<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> left<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//下面判断是否有相同的，避免重复</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>left<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>right<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right<span class="token operator">--</span><span class="token punctuation">;</span>                    left<span class="token operator">++</span><span class="token punctuation">;</span>                    right<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-5"><a href="#时间复杂度：-5" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p> 时间复杂度：<code>O(n^2)</code></p><p>详细分析：</p><ol><li><p>外层循环遍历数组中的每个数作为固定值 <code>nums[i]</code>，这部分是 <code>O(n)</code>。</p></li><li><p>内层使用双指针 <code>left</code> 和 <code>right</code> 来查找另外两个数，最坏情况下每次都需要遍历一次剩余数组，即 <code>O(n)</code>。</p></li><li><p>所以总的时间复杂度是：</p><p>O(n^2)</p></li></ol><p>去重操作的影响：</p><ul><li>去重操作使用的是 <code>while(left &lt; right &amp;&amp; nums[left] == nums[left + 1])</code> 这类逻辑，在最坏情况下最多也只是跳过相同元素，不改变主导复杂度。</li></ul><h4 id="空间复杂度：-5"><a href="#空间复杂度：-5" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(1)</code>（不计输出）</p><p>解释：</p><ul><li>如果<strong>不考虑返回结果 <code>ans</code> 所占用的空间</strong>（即题目允许将返回值空间复杂度忽略），则使用的额外空间为：<ul><li>排序使用的可能是原地排序（如 <code>std::sort</code>），**空间复杂度为常数级 <code>O(1)</code>**。</li><li>其他仅使用了一些指针和变量，都是常数级空间。</li></ul></li><li>如果 <strong>将返回结果的空间也算入</strong>，最坏情况是 <code>O(k)</code>，其中 <code>k</code> 是满足条件的三元组个数。</li></ul><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></h2><h3 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img" loading="lazy"></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：height &#x3D; [4,2,0,3,2,5]输出：9</code></pre><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-6"><a href="#具体思路：-6" class="headerlink" title="具体思路："></a>具体思路：</h4><p>这里采用的是动态规划解法，还有其他方法。动态规划解法，需要构造两个数组分别储存各个节点的左边最大高度和右边最大高度，便于计算当前节点所积水高度。问题在于左边和右边最大高度该如何获取。最左边的左边最大高度就是它自身，最右边的右边最大高度就是它自身，以这两个边界条件，左边最大高度就是当前节点的左边节点的左边最大高度和当前节点的高度的最大值，右边最大高度也是一样。求解出放入之前的两个数组中。已知这两个数组，可以遍历这两个数组，把当前节点的积水量算出，再累加一起，就是所求的雨水量。</p><h4 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//这题采用动态规划</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftMax</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rightMax</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        leftMax<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        rightMax<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>height<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            leftMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            rightMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>rightMax<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token operator">+=</span><span class="token function">min</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>rightMax<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-6"><a href="#时间复杂度：-6" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>时间复杂度：<code>O(n)</code></p><ul><li><p>遍历了三次数组：</p><ol><li>构造 <code>leftMax</code>：<code>O(n)</code></li><li>构造 <code>rightMax</code>：<code>O(n)</code></li><li>遍历一次计算总雨水量：<code>O(n)</code></li></ol></li><li><p>所以总时间复杂度是：</p><p>O(n)</p></li></ul><h4 id="空间复杂度：-6"><a href="#空间复杂度：-6" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(n)</code></p><ul><li>使用了两个辅助数组：<ul><li><code>leftMax</code>：大小为 <code>n</code></li><li><code>rightMax</code>：大小为 <code>n</code></li></ul></li><li>所以额外空间是 <code>2n</code>，即 <strong><code>O(n)</code> 空间复杂度</strong>。</li></ul><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h2><h3 id="题目描述：-6"><a href="#题目描述：-6" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h3 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-7"><a href="#具体思路：-7" class="headerlink" title="具体思路："></a>具体思路：</h4><p>我们使用滑动窗口和哈希表实现这个题目。哈希表存储枚举值的下标，初始值为-1，j值在没有重合的情况下，会在每次循环+1，但是如果遇到重合，j值会跑到对应的下标位置之后的位置（下标位置存储在哈希表中）。只要有重合就调整窗口。</p><h4 id="代码块：-5"><a href="#代码块：-5" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//滑动窗口和哈希表</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pos</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//j为滑动窗口的起始节点</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            j<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>pos<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pos<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="时间复杂度：-7"><a href="#时间复杂度：-7" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>时间复杂度：<code>O(n)</code></p><ul><li>其中 <code>n</code> 是字符串 <code>s</code> 的长度。</li><li>每个字符最多访问两次（一次作为右指针扩展窗口，一次作为左指针缩小窗口）。</li><li>所以整体是线性时间复杂度 <code>O(n)</code>。</li></ul><h4 id="空间复杂度：-7"><a href="#空间复杂度：-7" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>空间复杂度：<code>O(1)</code></p><ul><li>使用了一个 <code>pos</code> 数组来记录 ASCII 字符上次出现的位置，长度是固定的 128（ASCII 字符集）。</li><li>即使改成 <code>256</code>（扩展 ASCII）或 <code>100,000</code>（Unicode 范围），只要是<strong>定长的字符集</strong>，空间复杂度都是 <strong><code>O(1)</code> 常数级</strong>。</li><li>如果字符集不固定，比如用 <code>unordered_map&lt;char, int&gt;</code>，那空间复杂度是 <code>O(k)</code>，其中 <code>k</code> 是字符集大小。</li></ul><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h2><h3 id="题目描述：-7"><a href="#题目描述：-7" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>示例 1:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;cbaebabacd&quot;, p &#x3D; &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</code></pre><p> <strong>示例 2:</strong></p><pre class="language-none"><code class="language-none">输入: s &#x3D; &quot;abab&quot;, p &#x3D; &quot;ab&quot;输出: [0,1,2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</code></pre><h3 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-8"><a href="#具体思路：-8" class="headerlink" title="具体思路："></a>具体思路：</h4><p>这道题的整体思路是让我找到对应字符串的所有异位词在一个陌生的字符串里。这里要解决两个问题，首先是异位词问题，找异位词可以通过枚举法，总共26个字母，我们通过数组存储使用字母的个数，最后对比，如果数组相等，就说明是异位词。还有一个问题：在陌生字符串找到所有的异位词，并且返回索引，找异位词是一个范围问题，所以我要使用流动窗口，大小就是对应字符串的大小。在陌生字符串扫描。最后返回结果。</p><h4 id="代码块：-6"><a href="#代码块：-6" class="headerlink" title="代码块："></a>代码块：</h4><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    vector&lt;int&gt; findAnagrams(string s, string p) &#123;        &#x2F;&#x2F;首先记录两字符串的长度        int sLen&#x3D;s.size(),pLen&#x3D;p.size();        &#x2F;&#x2F;如果字符串s的长度还不比p字符串长        if(sLen&lt;pLen)&#123;            return vector&lt;int&gt;();        &#125;        &#x2F;&#x2F;记录结果        vector&lt;int&gt; ans;        &#x2F;&#x2F;记录s字符串和p字符串的字母对应的个数，枚举法        vector&lt;int&gt; sletter(26);        vector&lt;int&gt; pletter(26);        &#x2F;&#x2F;先试试索引为0的        for(int i&#x3D;0;i&lt;pLen;i++)&#123;            ++sletter[s[i]-&#39;a&#39;];            ++pletter[p[i]-&#39;a&#39;];        &#125;        &#x2F;&#x2F;如果符合，说明索引为0符合情况        if(sletter&#x3D;&#x3D;pletter)&#123;            ans.emplace_back(0);        &#125;        &#x2F;&#x2F;之后按照索引为1往后遍历，采取流动窗口,把前一次的流动窗口的第一个去掉，再往后补一个，形成新的流动窗口.        &#x2F;&#x2F;注意这里是按流动窗口为整体，上面的循环是为了形成流动窗口。        for(int i&#x3D;0;i&lt;sLen-pLen;i++)&#123;            --sletter[s[i]-&#39;a&#39;];            ++sletter[s[i+pLen]-&#39;a&#39;];            if(sletter&#x3D;&#x3D;pletter)&#123;            ans.emplace_back(i+1);        &#125;        &#125;                return ans;    &#125;&#125;;</code></pre><h4 id="时间复杂度：-8"><a href="#时间复杂度：-8" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><ul><li>初始化部分：O(p)</li><li>滑动窗口：O(n)</li></ul><p>由于通常 <code>p</code> 比 <code>n</code> 小，所以总时间复杂度是：O(n)</p><h4 id="空间复杂度：-8"><a href="#空间复杂度：-8" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><ul><li>使用了两个长度为 26 的数组：<code>sletter</code>, <code>pletter</code>；</li><li>还使用了一个结果数组 <code>ans</code>，最坏情况下长度也是 O(n)；</li></ul><p>因此：</p><p>空间复杂度是 O(1) + O(k)，其中 k 是结果中异位词的数量，通常最多为 O(n)。</p><h2 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为 K 的子数组</a></h2><h3 id="题目描述：-8"><a href="#题目描述：-8" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><p><strong>示例 1：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,1,1], k &#x3D; 2输出：2</code></pre><p><strong>示例 2：</strong></p><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,2,3], k &#x3D; 3输出：2</code></pre><h3 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h3><h4 id="具体思路：-9"><a href="#具体思路：-9" class="headerlink" title="具体思路："></a>具体思路：</h4><p>这里采取两个方法，第一种方法就是枚举法，暴力轮询。（为什莫要两种，因为我第一种leetcode超时了）。</p><p>方法二：首先通过前缀和这个点，定义 pre[i] 为 [0..i] 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：pre[i]&#x3D;pre[i−1]+nums[i]<br>那么[j..i] 这个子数组和为 k 这个条件我们可以转化为pre[i]−pre[j−1]&#x3D;&#x3D;k<br>简单移项可得符合条件的下标 j 需要满足pre[j−1]&#x3D;&#x3D;pre[i]−k<br>所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。建立以上条件，我们的问题就简化为寻找有多少个符合条件的pre[j]即可，我们建立哈希表，键是前缀和，值是前缀和重复的个数。在遍历的过程中，pre存储当前的前缀和，先不放进哈希表中，先在哈希表中查找是否有键pre-k,有的话，就取出对应的值加到count里，不管找没找到，都要将当前的前缀和存到哈希表中。这代码的逻辑是基于前缀和得出的只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。</p><h4 id="代码块：-7"><a href="#代码块：-7" class="headerlink" title="代码块："></a>代码块：</h4><p>方法一：枚举法</p><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        &#x2F;&#x2F;这题我们采用枚举法        int count&#x3D;0;&#x2F;&#x2F;返回的结果值        int n&#x3D;nums.size();        for(int start&#x3D;0;start&lt;n;++start)&#123;            int sum&#x3D;0;            for(int end&#x3D;start;end&lt;n;++end)&#123;                sum+&#x3D;nums[end];                if(sum&#x3D;&#x3D;k)&#123;                    count++;                &#125;            &#125;        &#125;        return count;    &#125;&#125;;</code></pre><p>方法二：前缀和+哈希表优化</p><pre class="language-c++" data-language="c++"><code class="language-c++">class Solution &#123;public:    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;        &#x2F;&#x2F;前缀和+哈希表优化        unordered_map&lt;int,int&gt; mp;        mp[0]&#x3D;1;&#x2F;&#x2F;初始前缀和的个数为1        int count&#x3D;0,pre&#x3D;0;&#x2F;&#x2F;count是返回结果的，pre是前缀和        for(auto &amp;temp:nums)&#123;            pre+&#x3D;temp;            if(mp.find(pre-k)!&#x3D;mp.end())&#123;                count+&#x3D;mp[pre-k];            &#125;            mp[pre]++;        &#125;        return count;    &#125;&#125;;</code></pre><h4 id="时间复杂度：-9"><a href="#时间复杂度：-9" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>方法一：</p><p>时间复杂度：<strong>O(n²)</strong></p><p>方法二：</p><p>O(n) 时间</p><h4 id="空间复杂度：-9"><a href="#空间复杂度：-9" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>方法一：</p><p>空间复杂度：<strong>O(1)</strong></p><p>方法二：</p><p>**O(n)**（最坏情况下所有前缀和都不相同，哈希表大小为 n）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot;&gt;两数之和&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;</summary>
      
    
    
    
    <category term="计算机学习" scheme="http://yustonerain.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="data structure" scheme="http://yustonerain.top/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>c++实现集群聊天服务器</title>
    <link href="http://yustonerain.top/2025/06/02/C++-chatserver.html"/>
    <id>http://yustonerain.top/2025/06/02/C++-chatserver.html</id>
    <published>2025-06-02T15:57:52.000Z</published>
    <updated>2025-06-23T13:25:20.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="json学习"><a href="#json学习" class="headerlink" title="json学习"></a>json学习</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"json.hpp"</span></span><span class="token keyword">using</span> json<span class="token operator">=</span>nlohmann<span class="token double-colon punctuation">::</span>json<span class="token punctuation">;</span></code></pre><p>使用json,要包含json的头文件 ，方便使用可以重命名nlohmann::json为json。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//json序列化示例1</span>std<span class="token double-colon punctuation">::</span>string <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    json js<span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"msg_type"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"from"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"zhang san"</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"to"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"li si"</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"hello,what are you doing now"</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string sendBuf<span class="token operator">=</span>js<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>sendBuf<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> sendBuf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>js使用很像键值对。js.dump()是 nlohmann::json库中用于将 JSON 对象序列化（转为字符串）的方法，它会把一个 json类型的变量转换成 JSON 格式的字符串。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string recvBuf<span class="token operator">=</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）</span>   json jsbuf<span class="token operator">=</span>json<span class="token double-colon punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span>recvBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>jsbuf<span class="token punctuation">[</span><span class="token string">"msg_type"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>jsbuf<span class="token punctuation">[</span><span class="token string">"from"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>jsbuf<span class="token punctuation">[</span><span class="token string">"to"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>   std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>jsbuf<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></code></pre><p>这是main函数中执行。<code>json::parse()</code> 是 <code>nlohmann::json</code> 库中用来将 <strong>JSON 字符串 → JSON 对象</strong> 的函数，也就是实现<strong>反序列化</strong>。</p><p>转化为json对象后使用对应的键可以把对应的值取出来。结果：</p><pre class="language-none"><code class="language-none">&#123;&quot;from&quot;:&quot;zhang san&quot;,&quot;msg&quot;:&quot;hello,what are you doing now&quot;,&quot;msg_type&quot;:2,&quot;to&quot;:&quot;li si&quot;&#125;2&quot;zhang san&quot;&quot;li si&quot;&quot;hello,what are you doing now&quot;</code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//json序列化示例2</span>std<span class="token double-colon punctuation">::</span>string <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    json js<span class="token punctuation">;</span>    <span class="token comment">//添加数组</span>    js<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//添加key-value</span>    js<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"zhang san"</span><span class="token punctuation">;</span>    <span class="token comment">//添加对象</span>    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"zhang san"</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"liu shuo"</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token string">"hello china"</span><span class="token punctuation">;</span>    <span class="token comment">//上面等同下面这句一次性添加数组对象</span>    js<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token string">"zhang san"</span><span class="token punctuation">,</span><span class="token string">"hello world"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token string">"liu shuo"</span><span class="token punctuation">,</span><span class="token string">"hello china"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>js<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> js<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>json还可以放数组，还可以嵌套json语句。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string recvBuf<span class="token operator">=</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）</span>    json jsbuf<span class="token operator">=</span>json<span class="token double-colon punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span>recvBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>jsbuf<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">auto</span> arr<span class="token operator">=</span>jsbuf<span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">auto</span> msgjs<span class="token operator">=</span>jsbuf<span class="token punctuation">[</span><span class="token string">"msg"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>msgjs<span class="token punctuation">[</span><span class="token string">"zhang san"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>msgjs<span class="token punctuation">[</span><span class="token string">"liu shuo"</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span></code></pre><p>“id”存储的是一个数组，取出来还可以作为数组使用。“msg”存储的值还可以是json语句，并且可以进入再取里面的值。</p><p>结果：</p><pre class="language-none"><code class="language-none">&#123;&quot;id&quot;:[1,2,3,4,5],&quot;msg&quot;:&#123;&quot;liu shuo&quot;:&quot;hello china&quot;,&quot;zhang san&quot;:&quot;hello world&quot;&#125;,&quot;name&quot;:&quot;zhang san&quot;&#125;[1,2,3,4,5]3&quot;hello world&quot;&quot;hello china&quot;</code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//json序列化示例3</span>std<span class="token double-colon punctuation">::</span>string <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    json js<span class="token punctuation">;</span>    <span class="token comment">//直接序列化一个vector容器</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"list"</span><span class="token punctuation">]</span><span class="token operator">=</span>vec<span class="token punctuation">;</span>    <span class="token comment">//直接序列化一个map容器</span>    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> m<span class="token punctuation">;</span>    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"黄山"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"华山"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"泰山"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    js<span class="token punctuation">[</span><span class="token string">"path"</span><span class="token punctuation">]</span> <span class="token operator">=</span>m<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>string sendBuf <span class="token operator">=</span>js<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//json数据对象->序列化json字符串</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>sendBuf<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> sendBuf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>还可以序列化容器。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string recvBuf<span class="token operator">=</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）</span>    json jsbuf<span class="token operator">=</span>json<span class="token double-colon punctuation">::</span><span class="token function">parse</span><span class="token punctuation">(</span>recvBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec <span class="token operator">=</span>jsbuf<span class="token punctuation">[</span><span class="token string">"list"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//js对象里面的数组类型，直接放入vector容器当中</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>v<span class="token operator">:</span>vec<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>v<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> mymap<span class="token operator">=</span>jsbuf<span class="token punctuation">[</span><span class="token string">"path"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>p<span class="token operator">:</span>mymap<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>p<span class="token punctuation">.</span>first<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>p<span class="token punctuation">.</span>second<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span>std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><p>结果：</p><pre class="language-none"><code class="language-none">&#123;&quot;list&quot;:[1,2,5],&quot;path&quot;:[[1,&quot;黄山&quot;],[2,&quot;华山&quot;],[3,&quot;泰山&quot;]]&#125;1 2 5 1 黄山2 华山3 泰山</code></pre><h2 id="muduo网络库学习"><a href="#muduo网络库学习" class="headerlink" title="muduo网络库学习"></a>muduo网络库学习</h2><p><strong>muduo</strong> 是一个现代 C++ 的非阻塞 I&#x2F;O 网络库，采用 <strong>Reactor 模式 + 多线程 + epoll + 定时器 + 高效缓冲区 + 智能指针设计</strong>，在性能和工程性方面都表现非常优秀。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*muduo网络库给用户提供了两个主要的类TcpServer :用于编写服务器程序的TcpClient :用于编写客户端程序的epoll+线程池好处：能够把网络I/O的代码和业务代码区分开了业务代码 :用户的连接和断开 用户的可读写事件*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;muduo/net/TcpServer.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;muduo/net/EventLoop.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> muduo<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> muduo<span class="token double-colon punctuation">::</span>net<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> placeholders<span class="token punctuation">;</span><span class="token comment">/*基于muduo网络库开发服务器程序1.组合TcpServer对象2.创建EventLoop事件循环对象的指针3.明确TcpServer构造函数需要什么参数，输出ChatServer的构造函数4.在当前服务器类的构造函数当中，注册处理连接的回调函数和处理读写事件的回调函数5.设置合适的服务端线程数量，muduo库会自己分配I/O线程和worker线程*/</span><span class="token keyword">class</span> <span class="token class-name">ChatServer</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">ChatServer</span><span class="token punctuation">(</span>EventLoop<span class="token operator">*</span> loop<span class="token punctuation">,</span><span class="token comment">//事件循环</span>            <span class="token keyword">const</span> InetAddress<span class="token operator">&amp;</span> listenAddr<span class="token punctuation">,</span><span class="token comment">//ip+port</span>            <span class="token keyword">const</span> string<span class="token operator">&amp;</span> nameArg<span class="token punctuation">)</span><span class="token comment">//服务器的名字</span>        <span class="token operator">:</span><span class="token function">_server</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span>listenAddr<span class="token punctuation">,</span>nameArg<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">_loop</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//给服务器注册用户连接的创建和断开回调</span>            _server<span class="token punctuation">.</span><span class="token function">setConnectionCallback</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ChatServer<span class="token double-colon punctuation">::</span>onConnection<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">//给服务器注册用户读写事件回调</span>            _server<span class="token punctuation">.</span><span class="token function">setMessageCallback</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ChatServer<span class="token double-colon punctuation">::</span>onMessage<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span>_1<span class="token punctuation">,</span>_2<span class="token punctuation">,</span>_3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//设置服务器端的线程数量 1个I/o线程 3个worker线程</span>            _server<span class="token punctuation">.</span><span class="token function">setThreadNum</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//开启事件循环</span>        <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            _server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">//专门处理用户的连接创建和断开</span>    <span class="token keyword">void</span> <span class="token function">onConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr<span class="token operator">&amp;</span>conn<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>conn<span class="token operator">-></span><span class="token function">connected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span>conn<span class="token operator">-></span><span class="token function">peerAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"->"</span><span class="token operator">&lt;&lt;</span>            conn<span class="token operator">-></span><span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"state:online"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token comment">//对方关闭连接或断开</span>            cout<span class="token operator">&lt;&lt;</span>conn<span class="token operator">-></span><span class="token function">peerAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"->"</span><span class="token operator">&lt;&lt;</span>            conn<span class="token operator">-></span><span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toIpPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">"state:offline"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            conn<span class="token operator">-></span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//close(fd)//关闭连接</span>            <span class="token comment">// _loop->quit();通常用于程序结束或手动控制关闭 Muduo</span>            <span class="token comment">//loop->quit() 使loop.loop()不再阻塞。</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//专门处理用户的读写事件</span>    <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr<span class="token operator">&amp;</span>conn<span class="token punctuation">,</span><span class="token comment">//连接</span>                            Buffer<span class="token operator">*</span> buffer<span class="token punctuation">,</span><span class="token comment">//缓冲区</span>                            Timestamp time<span class="token punctuation">)</span><span class="token comment">//接受数据的时间信息</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//是一个指向 muduo::net::Buffer 对象的指针，用于暂存客户端发送的数据。</span><span class="token comment">//Muduo 采用 非阻塞、事件驱动的方式，当客户端发送数据时，数据先被读入 Buffer 中，之后由用户注册的回调函数（例如 onMessage）来处理。</span>        <span class="token comment">//retrieveAllAsString()把缓冲区中的所有可读数据提取为一个 std::string，然后清空缓冲区。</span>        string buf<span class="token operator">=</span>buffer<span class="token operator">-></span><span class="token function">retrieveAllAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"recv data:"</span> <span class="token operator">&lt;&lt;</span>buf<span class="token operator">&lt;&lt;</span><span class="token string">"time:"</span><span class="token operator">&lt;&lt;</span>time<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        conn<span class="token operator">-></span><span class="token function">send</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//原封不动发回去                        </span>    <span class="token punctuation">&#125;</span>    muduo<span class="token double-colon punctuation">::</span>net<span class="token double-colon punctuation">::</span>TcpServer _server<span class="token punctuation">;</span>    muduo<span class="token double-colon punctuation">::</span>net<span class="token double-colon punctuation">::</span>EventLoop <span class="token operator">*</span>_loop<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    EventLoop loop<span class="token punctuation">;</span><span class="token comment">//epoll</span>    InetAddress <span class="token function">addr</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ChatServer <span class="token function">server</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token punctuation">,</span>addr<span class="token punctuation">,</span><span class="token string">"ChatServer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//listenfd epoll_ctl->epoll</span>    loop<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//epoll wait以阻塞方式等待新用户连接，已连接用户的读写事件等</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>先将bind函数讲清楚，</p><p>基本格式</p><pre class="language-none"><code class="language-none">std::bind(&amp;类名::成员函数, 对象指针, 占位符参数...)</code></pre><p>所以：</p><pre class="language-none"><code class="language-none">std::bind(&amp;ChatServer::onConnection, this, _1)</code></pre><p>意思是：</p><p>把当前对象（<code>this</code>）的 <code>onConnection</code> 成员函数绑定起来，形成一个可调用对象，并接受一个参数 <code>_1</code>。</p><p>分解解释</p><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><code>&amp;ChatServer::onConnection</code></td><td>指向 <code>ChatServer</code> 类的成员函数 <code>onConnection</code> 的指针</td></tr><tr><td><code>this</code></td><td>当前对象的指针，告诉 <code>bind</code> 这个函数是哪个对象的方法（即调用 this-&gt;onConnection）</td></tr><tr><td><code>_1</code></td><td>占位符，代表回调传入的第一个参数，实际调用时会被替换</td></tr><tr><td></td><td></td></tr></tbody></table><p>最终生成一个 <code>std::function&lt;void(const TcpConnectionPtr&amp;)&gt;</code> 类型的函数对象。</p><h2 id="CMakeList-txt学习"><a href="#CMakeList-txt学习" class="headerlink" title="CMakeList.txt学习"></a>CMakeList.txt学习</h2><p>主CMakeList.txt</p><pre class="language-none"><code class="language-none">cmake_minimum_required(VERSION 3.10)project(chat)#配置编译选项set(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)#配置最终的可执行文件输出的路径set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;bin)#配置头文件搜索路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include&#x2F;server)#加载子目录add_subdirectory(src)</code></pre><p>src文件夹下的CMakeList.txt</p><pre class="language-none"><code class="language-none">add_subdirectory(server)</code></pre><p>src文件夹下的server文件夹下的CMakeList.txt</p><pre class="language-none"><code class="language-none">#定义了SRC_LIST变量，包含了当前目录下的所有源文件aux_source_directory(. SRC_LIST) #获取当前目录下所有源文件#指定生成可执行文件add_executable(ChatServer $&#123;SRC_LIST&#125;)#指定可执行文件需要链接的库target_link_libraries(ChatServer muduo_net muduo_base pthread) #链接muduo库和pthread库</code></pre><h3 id="项目常见的cmake指令使用步骤"><a href="#项目常见的cmake指令使用步骤" class="headerlink" title="项目常见的cmake指令使用步骤"></a>项目常见的cmake指令使用步骤</h3><pre class="language-none"><code class="language-none">mkdir buildcd buildcmake ..make         # 如果你使用的是 Unix&#x2F;Linux&#x2F;macOS，或者是 MinGW</code></pre><p>解释：</p><ul><li><code>mkdir build</code>：创建构建目录（推荐 out-of-source build）</li><li><code>cd build</code>：进入构建目录</li><li><code>cmake ..</code>：执行 CMake，读取上一级目录的 <code>CMakeLists.txt</code>，生成构建系统（默认是 Makefile）</li><li><code>make</code>：使用生成的 Makefile 编译项目</li></ul><h2 id="集群聊天服务器"><a href="#集群聊天服务器" class="headerlink" title="集群聊天服务器"></a>集群聊天服务器</h2><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p><img src="/2025/06/02/C++-chatserver/1.png" alt="1" loading="lazy"></p><p>bin文件夹编译完成后的 <code>.exe</code>（Windows）或无扩展的可执行文件。</p><p>build文件夹通常用于存放 <strong>构建过程中产生的所有中间文件</strong>，它是整个编译流程的“临时工作区”。</p><p>include文件夹存放头文件（Header Files），src文件夹是 C++ 项目中最常见也最核心的目录之一，用于存放 <strong>源代码实现文件（source files）</strong>，主要是 <code>.cpp</code> 文件（也包括 <code>.c</code>, <code>.cc</code>, <code>.cxx</code> 等）。</p><p>test文件夹在 C++ 项目中用于存放<strong>测试代码</strong>，主要用于验证项目功能是否正确，确保每个模块在修改后仍然可以正常工作。</p><p>thirdparty文件夹在 C++ 项目中用于存放<strong>第三方依赖库的源码或接口文件</strong>。在这里存储了json.hpp文件。</p><h3 id="CMakeLists-txt文件存放和使用"><a href="#CMakeLists-txt文件存放和使用" class="headerlink" title="CMakeLists.txt文件存放和使用"></a>CMakeLists.txt文件存放和使用</h3><p>CMakeLists.txt文件放在了主目录，src文件夹里，src&#x2F;server文件夹里，接下来分别说明对应文件夹中CMakeLists.txt的作用。</p><p>主目录文件夹</p><pre class="language-none"><code class="language-none">cmake_minimum_required(VERSION 3.10)project(chat)#配置编译选项set(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)#配置最终的可执行文件输出的路径set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;bin)#配置头文件搜索路径include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include&#x2F;server)include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include&#x2F;server&#x2F;db)include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;thirdparty)#加载子目录add_subdirectory(src)</code></pre><p>主目录 <code>CMakeLists.txt</code> 的作用概括：</p><ol><li><strong>设置项目基本信息</strong>：指定 CMake 最低版本和项目名称。</li><li><strong>配置全局编译选项</strong>：例如添加调试信息（<code>-g</code>）以便调试。</li><li><strong>设置可执行文件输出路径</strong>：统一将程序输出到 <code>bin/</code> 目录。</li><li><strong>配置头文件搜索路径</strong>：包括项目头文件目录和第三方库目录，便于代码引用。</li><li><strong>组织子目录构建</strong>：通过 <code>add_subdirectory(src)</code> 加载 <code>src</code> 子目录，交由其继续组织源码编译。</li></ol><p>src文件夹</p><pre class="language-none"><code class="language-none">add_subdirectory(server)</code></pre><p><code>add_subdirectory(server)</code> 把 <code>server</code> 子目录纳入构建流程，交由其内部的 <code>CMakeLists.txt</code> 具体定义编译规则，是模块化项目管理的关键步骤。</p><p>src&#x2F;server文件夹</p><pre class="language-none"><code class="language-none">#定义了SRC_LIST变量，包含了当前目录下的所有源文件aux_source_directory(. SRC_LIST) #获取当前目录下所有源文件aux_source_directory(.&#x2F;db DB_LIST)#获取db文件下的所有源文件#指定生成可执行文件add_executable(ChatServer $&#123;SRC_LIST&#125; $&#123;DB_LIST&#125;)#指定可执行文件需要链接的库target_link_libraries(ChatServer muduo_net muduo_base mysqlclient pthread) #链接muduo库和pthread库</code></pre><p><code>src/server/CMakeLists.txt</code> 的作用概括：</p><ol><li><strong>收集源文件</strong>：自动获取当前目录和 <code>db</code> 子目录下的所有 <code>.cpp</code> 文件。</li><li><strong>生成可执行程序</strong>：将源文件编译为 <code>ChatServer</code> 可执行文件。</li><li><strong>链接依赖库</strong>：链接 Muduo 网络库、MySQL 客户端库和 pthread 线程库。</li></ol><h3 id="thirdparty文件夹（第三方库）json-hpp"><a href="#thirdparty文件夹（第三方库）json-hpp" class="headerlink" title="thirdparty文件夹（第三方库）json.hpp"></a>thirdparty文件夹（第三方库）json.hpp</h3><p>聊天服务器项目中，<code>json.hpp</code> 负责处理客户端与服务端之间的 JSON 数据格式，承担消息的 <strong>解析、构建与传输格式化</strong>，是通信协议的关键组件。</p><h3 id="include-server-chatserver-hpp-聊天服务器的主类"><a href="#include-server-chatserver-hpp-聊天服务器的主类" class="headerlink" title="include&#x2F;server&#x2F;chatserver.hpp 聊天服务器的主类"></a>include&#x2F;server&#x2F;chatserver.hpp 聊天服务器的主类</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CHATSERVER_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CHATSERVER_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;muduo/net/TcpServer.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;muduo/net/EventLoop.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> muduo<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> muduo<span class="token double-colon punctuation">::</span>net<span class="token punctuation">;</span><span class="token comment">//聊天服务器的主类</span><span class="token keyword">class</span> <span class="token class-name">ChatServer</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">//初始化聊天服务器队对象</span>    <span class="token function">ChatServer</span><span class="token punctuation">(</span>EventLoop<span class="token operator">*</span> loop<span class="token punctuation">,</span>            <span class="token keyword">const</span> InetAddress<span class="token operator">&amp;</span> listenAddr<span class="token punctuation">,</span>            <span class="token keyword">const</span> string<span class="token operator">&amp;</span> nameArg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//启动服务</span>    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">//上报连接相关信息的回调函数</span>    <span class="token keyword">void</span> <span class="token function">onConnection</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr<span class="token operator">&amp;</span> conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//上报读写事件的回调函数</span>    <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token keyword">const</span> TcpConnectionPtr<span class="token operator">&amp;</span> conn<span class="token punctuation">,</span>            Buffer<span class="token operator">*</span> buffer<span class="token punctuation">,</span>            Timestamp time<span class="token punctuation">)</span><span class="token punctuation">;</span>    TcpServer _server<span class="token punctuation">;</span><span class="token comment">//组合的muduo库，实现服务器功能的类对象</span>    EventLoop <span class="token operator">*</span>_loop<span class="token punctuation">;</span><span class="token comment">//指向事件循环的指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre><p><code>ChatServer.h</code> 作用及结构概括</p><ol><li><strong>类功能</strong></li></ol><p>定义了聊天服务器的主类 <code>ChatServer</code>，负责网络服务的初始化、启动和事件处理。</p><ol start="2"><li><strong>成员变量</strong></li></ol><ul><li><code>_server</code>：<code>muduo::net::TcpServer</code> 对象，负责网络连接管理和服务端监听。</li><li><code>_loop</code>：<code>muduo::net::EventLoop</code> 指针，负责事件循环和调度。</li></ul><ol start="3"><li><strong>核心接口</strong></li></ol><ul><li>构造函数 <code>ChatServer(EventLoop*, const InetAddress&amp;, const string&amp;)</code>：初始化服务器监听地址、名称和事件循环。</li><li><code>start()</code>：启动服务器监听，进入事件循环。</li></ul><ol start="4"><li><strong>回调函数</strong>（私有）</li></ol><ul><li><code>onConnection()</code>：处理客户端连接和断开事件。</li><li><code>onMessage()</code>：处理客户端消息接收事件，进行消息读写。</li></ul><p><code>ChatServer</code> 类是整个聊天项目的网络核心，利用 Muduo 库提供的 TCP 服务器功能，封装了网络事件的注册与处理，负责服务器端的网络通信逻辑。</p><h3 id="src-server-chatserver-cpp"><a href="#src-server-chatserver-cpp" class="headerlink" title="src&#x2F;server&#x2F;chatserver.cpp"></a>src&#x2F;server&#x2F;chatserver.cpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;chatserver.hpp&quot;#include &lt;string&gt;#include &quot;chatservice.hpp&quot;#include &lt;functional&gt;#include &quot;json.hpp&quot;using json &#x3D;nlohmann::json;&#x2F;&#x2F;初始化聊天服务器队对象ChatServer::ChatServer(EventLoop* loop,            const InetAddress&amp; listenAddr,            const string&amp; nameArg)    : _server(loop, listenAddr, nameArg),      _loop(loop)&#123;    &#x2F;&#x2F;注册连接回调    _server.setConnectionCallback(        std::bind(&amp;ChatServer::onConnection, this, std::placeholders::_1));    &#x2F;&#x2F;注册消息回调    _server.setMessageCallback(        std::bind(&amp;ChatServer::onMessage, this, std::placeholders::_1,                  std::placeholders::_2, std::placeholders::_3));    &#x2F;&#x2F;设置线程数量    _server.setThreadNum(4);&#125;&#x2F;&#x2F;启动服务void ChatServer::start()&#123;    _server.start();&#125;&#x2F;&#x2F;上报连接相关信息的回调函数void ChatServer::onConnection(const TcpConnectionPtr&amp; conn)&#123;    &#x2F;&#x2F;客户端断开连接    if(!conn-&gt;connected())&#123;        conn-&gt;shutdown();    &#125;&#125;    &#x2F;&#x2F;上报读写事件的回调函数void ChatServer::onMessage(const TcpConnectionPtr&amp; conn,            Buffer* buffer,            Timestamp time)&#123;    string buf&#x3D;buffer-&gt;retrieveAllAsString();    &#x2F;&#x2F;数据的反序列化    json js&#x3D;json::parse(buf);    &#x2F;&#x2F;达到的目的:完全解耦网络模块的代码和业务模块的代码    &#x2F;&#x2F;通过js[&quot;msgid&quot;] 获取&#x3D;》业务handler&#x3D;&gt;conn js time    auto msgHandler&#x3D;ChatService::instance()-&gt;getHandler(js[&quot;msgid&quot;].get&lt;int&gt;());    &#x2F;&#x2F;回调消息绑定好的事件处理器，来执行相应的业务处理    msgHandler(conn,js,time);    &#125;</code></pre><p>ChatServer.cpp 作用与关键点概括</p><ol><li><strong>构造函数初始化</strong></li></ol><ul><li>初始化 Muduo 的 TCP 服务器对象 <code>_server</code> 和事件循环 <code>_loop</code>。</li><li>注册回调函数：<ul><li><code>onConnection</code> 处理连接建立与断开；</li><li><code>onMessage</code> 处理客户端消息。</li></ul></li><li>设置线程数为4，支持多线程处理网络事件。</li></ul><ol start="2"><li><strong>启动服务</strong></li></ol><ul><li><code>start()</code> 调用 Muduo 的 <code>_server.start()</code> 启动监听和事件循环。</li></ul><ol start="3"><li><strong>连接回调 <code>onConnection</code></strong></li></ol><ul><li>判断客户端是否断开连接，断开时调用 <code>conn-&gt;shutdown()</code> 关闭连接。</li></ul><ol start="4"><li><strong>消息回调 <code>onMessage</code></strong></li></ol><ul><li>将网络缓冲区中的数据读取为字符串。</li><li>使用 <code>json.hpp</code> 将字符串反序列化成 JSON 对象。</li><li>通过消息中的 <code>&quot;msgid&quot;</code> 字段，调用业务层 <code>ChatService</code> 获取对应的消息处理函数（回调）。</li><li>执行该消息处理函数，完成具体的业务逻辑处理。</li></ul><hr><p>作用总结</p><p>这段代码实现了聊天服务器的核心网络处理逻辑，做到：</p><ul><li><strong>网络层与业务层解耦</strong>：网络部分只负责收发和解析数据，业务处理由 <code>ChatService</code> 中注册的处理器完成。</li><li><strong>灵活消息分发</strong>：根据 JSON 中的 <code>msgid</code> 动态调用对应业务处理函数，实现消息驱动机制。</li><li><strong>高效异步处理</strong>：基于 Muduo 多线程事件循环模型，支持高并发网络请求。</li></ul><h3 id="include-server-chatservice-hpp-聊天服务器业务类"><a href="#include-server-chatservice-hpp-聊天服务器业务类" class="headerlink" title="include&#x2F;server&#x2F;chatservice.hpp 聊天服务器业务类"></a>include&#x2F;server&#x2F;chatservice.hpp 聊天服务器业务类</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef CHATSERVICE_H#define CHATSERVICE_H#include &lt;muduo&#x2F;net&#x2F;TcpConnection.h&gt;#include &lt;unordered_map&gt;#include &lt;functional&gt;#include &quot;json.hpp&quot;using namespace std;using namespace muduo;using namespace muduo::net;using json &#x3D;nlohmann::json;&#x2F;&#x2F;表示处理消息的事件回调方法类型using MsgHandler &#x3D; std::function&lt;void(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&gt;;&#x2F;&#x2F;聊天服务器业务类class ChatService&#123;public:    &#x2F;&#x2F;获取单例对象的接口函数    static ChatService * instance();    &#x2F;&#x2F;处理登录业务    void login(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);    &#x2F;&#x2F;处理注册业务    void reg(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);    &#x2F;&#x2F;获取消息对应的处理器    MsgHandler getHandler(int msgid);private:    ChatService();    &#x2F;&#x2F;存储消息id和其对应的业务处理方法    unordered_map&lt;int,MsgHandler&gt; _msgHandlerMap;&#125;;#endif</code></pre><p>ChatService.h 作用与结构概括</p><ol><li><strong>类功能</strong></li></ol><ul><li>负责处理聊天服务器的核心业务逻辑，如登录、注册等。</li><li>管理消息 ID 与对应的处理函数的映射，实现消息的动态分发。</li></ul><ol start="2"><li><strong>核心类型</strong></li></ol><ul><li><code>MsgHandler</code>：消息处理函数类型，参数包括 TCP 连接指针、JSON 消息对象和时间戳。</li></ul><ol start="3"><li><strong>接口函数</strong></li></ol><ul><li><code>static ChatService* instance()</code>：单例模式，获取业务服务唯一实例。</li><li><code>void login(...)</code>：处理登录业务逻辑。</li><li><code>void reg(...)</code>：处理注册业务逻辑。</li><li><code>MsgHandler getHandler(int msgid)</code>：根据消息 ID 获取对应的消息处理函数。</li></ul><ol start="4"><li><strong>成员变量</strong></li></ol><ul><li><code>_msgHandlerMap</code>：存储消息 ID 与处理函数的映射，支持根据消息类型快速调用相应业务处理器。</li></ul><h3 id="src-server-chatservice-cpp"><a href="#src-server-chatservice-cpp" class="headerlink" title="src&#x2F;server&#x2F;chatservice.cpp"></a>src&#x2F;server&#x2F;chatservice.cpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;chatservice.hpp&quot;#include &quot;public.hpp&quot;#include &lt;string&gt;#include &lt;muduo&#x2F;base&#x2F;Logging.h&gt;using namespace muduo;using namespace std;&#x2F;&#x2F;获取单例对象的接口函数&#x2F;&#x2F;在cpp文件就不需要写static了ChatService * ChatService::instance()&#123;    static ChatService service;    return &service;&#125;&#x2F;&#x2F;注册消息以及对应的Handler回调操作 ChatService::ChatService()&#123;    &#x2F;&#x2F;注册业务    _msgHandlerMap.insert(&#123;LOGIN_MSG,std::bind(&amp;ChatService::login,this,_1,_2,_3)&#125;);    _msgHandlerMap.insert(&#123;REG_MSG,std::bind(&amp;ChatService::reg,this,_1,_2,_3)&#125;); &#125;&#x2F;&#x2F;获取消息对应的处理器 MsgHandler ChatService::getHandler(int msgid)&#123;    &#x2F;&#x2F;记录错误日志，msgid没有对应的事件处理回调    auto it &#x3D;_msgHandlerMap.find(msgid);    if(it &#x3D;&#x3D;_msgHandlerMap.end())&#123;        &#x2F;&#x2F;返回一个默认的处理器，空操作        return [&#x3D;](const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;            LOG_ERROR&lt;&lt;&quot;msgid:&quot;&lt;&lt; msgid &lt;&lt;&quot;can not find handler!&quot;;        &#125;;    &#125;    else&#123;        return _msgHandlerMap[msgid];    &#125;&#125;&#x2F;&#x2F;处理登录业务void ChatService::login(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    LOG_INFO &lt;&lt;&quot;do login service!!!!&quot;;&#125;&#x2F;&#x2F;处理注册业务void ChatService::reg(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    LOG_INFO&lt;&lt;&quot;do reg service!!!&quot;;&#125;</code></pre><p>ChatService.cpp 作用和关键点</p><ol><li><strong>单例模式实现</strong></li></ol><ul><li><code>instance()</code> 函数内部静态变量实现线程安全的单例模式，保证 <code>ChatService</code> 只有一个实例。</li></ul><ol start="2"><li><strong>构造函数注册消息处理函数</strong></li></ol><ul><li>在构造函数中通过 <code>_msgHandlerMap.insert</code> 将消息 ID（<code>LOGIN_MSG</code>、<code>REG_MSG</code>）绑定到成员函数 <code>login</code> 和 <code>reg</code> 的回调。</li><li>使用 <code>std::bind</code> 绑定成员函数和 <code>this</code> 指针，方便后续调用。</li></ul><ol start="3"><li><strong>动态消息处理函数获取</strong></li></ol><ul><li><code>getHandler(int msgid)</code> 根据传入的消息 ID 返回对应的处理函数。</li><li>如果消息 ID 未注册，返回一个默认空操作的 lambda，同时写错误日志，保证系统健壮性。</li></ul><ol start="4"><li><strong>业务处理函数示例</strong></li></ol><ul><li><code>login()</code> 和 <code>reg()</code> 目前仅打印日志，代表登录和注册的业务处理接口，后续可以扩展具体业务逻辑。</li></ul><h3 id="include-public-hpp"><a href="#include-public-hpp" class="headerlink" title="include&#x2F;public.hpp"></a>include&#x2F;public.hpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef PUBLIC_H#define PUBLIC_H&#x2F;*server和client的公共文件*&#x2F;enum EnMsgType&#123;    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息    REG_MSG&#x2F;&#x2F;注册消息&#125;;#endif</code></pre><p>public.h 作用简述</p><ul><li><strong>共享消息类型定义</strong><ul><li>定义了枚举类型 <code>EnMsgType</code>，用于区分不同的消息类型。</li><li>目前包含两种消息：<ul><li><code>LOGIN_MSG = 1</code>：登录消息</li><li><code>REG_MSG</code>：注册消息</li></ul></li></ul></li><li><strong>作用</strong><ul><li>服务端和客户端都包含这个头文件，保证双方对消息类型有统一的理解和对应关系，方便通信协议的设计与实现。</li></ul></li></ul><h3 id="src-server-main-cpp"><a href="#src-server-main-cpp" class="headerlink" title="src&#x2F;server&#x2F;main.cpp"></a>src&#x2F;server&#x2F;main.cpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;chatserver.hpp&quot;#include &lt;iostream&gt;using namespace std;int main()&#123;    EventLoop loop;    InetAddress addr(&quot;127.0.0.1&quot;,6000);    ChatServer server(&amp;loop, addr, &quot;ChatServer&quot;);    server.start();    &#x2F;&#x2F;开启事件循环    loop.loop();    return 0;&#125;</code></pre><p><strong>启动聊天服务器</strong>：<br> 创建事件循环和服务器监听地址，初始化 <code>ChatServer</code> 对象，启动服务器后进入事件循环，开始接受和处理客户端连接与消息。</p><h3 id="include-server-db-db-h-数据库操作类"><a href="#include-server-db-db-h-数据库操作类" class="headerlink" title="include&#x2F;server&#x2F;db&#x2F;db.h 数据库操作类"></a>include&#x2F;server&#x2F;db&#x2F;db.h 数据库操作类</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef DB_H#define DB_H#include&lt;mysql&#x2F;mysql.h&gt;#include&lt;string&gt;using namespace std;&#x2F;&#x2F; 数据库操作类class MySQL &#123; public: &#x2F;&#x2F; 初始化数据库连接MySQL();&#x2F;&#x2F; 释放数据库连接资源~MySQL();&#x2F;&#x2F; 连接数据库bool connect();&#x2F;&#x2F; 更新操作bool update(string sql);&#x2F;&#x2F; 查询操作MYSQL_RES* query(string sql);&#x2F;&#x2F;获取连接MYSQL * getConnection();private:    MYSQL *_conn;&#125;;#endif</code></pre><p><strong>MySQL 数据库操作类说明</strong></p><p><strong>类功能</strong></p><p>封装对 MySQL 数据库的连接、查询和更新操作，方便上层业务调用。</p><p><strong>主要成员函数</strong></p><ul><li>**构造函数 <code>MySQL()</code>**：初始化数据库连接相关资源。</li><li>**析构函数 <code>~MySQL()</code>**：释放数据库连接资源。</li><li>**<code>bool connect()</code>**：连接数据库，返回连接是否成功。</li><li>**<code>bool update(string sql)</code>**：执行更新类 SQL 语句（如 INSERT、UPDATE、DELETE）。</li><li>**<code>MYSQL_RES* query(string sql)</code>**：执行查询类 SQL 语句，返回结果集指针。</li><li>**<code>MYSQL* getConnection()</code>**：获取底层 MySQL 连接对象，便于其他操作。</li></ul><p><strong>成员变量</strong></p><ul><li>**<code>MYSQL *_conn</code>**：指向 MySQL 连接句柄的指针。</li></ul><h3 id="src-server-db-db-cpp"><a href="#src-server-db-db-cpp" class="headerlink" title="src&#x2F;server&#x2F;db&#x2F;db.cpp"></a>src&#x2F;server&#x2F;db&#x2F;db.cpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;db.h&quot;#include &lt;muduo&#x2F;base&#x2F;Logging.h&gt;&#x2F;&#x2F; 数据库配置信息static string server &#x3D; &quot;127.0.0.1&quot;;static string user &#x3D; &quot;root&quot;;static string password &#x3D; &quot;123456&quot;;static string dbname &#x3D; &quot;chat&quot;;&#x2F;&#x2F; 初始化数据库连接MySQL::MySQL()&#123;    _conn &#x3D; mysql_init(nullptr);&#125;&#x2F;&#x2F; 释放数据库连接资源MySQL::~MySQL()&#123;    if (_conn !&#x3D; nullptr)    mysql_close(_conn);&#125;&#x2F;&#x2F; 连接数据库bool MySQL::connect()&#123;    MYSQL *p &#x3D; mysql_real_connect(_conn, server.c_str(), user.c_str(),password.c_str(), dbname.c_str(), 3306, nullptr, 0);    if (p !&#x3D; nullptr)    &#123;        &#x2F;&#x2F;C和C++代码默认的编码字符是ASCII,如果不设置，从MySQL上拉下来的中文显示？        mysql_query(_conn, &quot;set names gbk&quot;);        LOG_INFO &lt;&lt; &quot;connect mysql success!&quot;;    &#125;else&#123;        LOG_INFO &lt;&lt; &quot;connect mysql failed!&quot;;    &#125;    return p;&#125;&#x2F;&#x2F; 更新操作bool MySQL::update(string sql)&#123;    if (mysql_query(_conn, sql.c_str()))    &#123;        LOG_INFO &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;:&quot;                &lt;&lt; sql &lt;&lt; &quot;更新失败!&quot;;            return false;    &#125;    return true;&#125;&#x2F;&#x2F; 查询操作MYSQL_RES* MySQL::query(string sql)&#123;    if (mysql_query(_conn, sql.c_str()))        &#123;            LOG_INFO &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;:&quot;                &lt;&lt; sql &lt;&lt; &quot;查询失败!&quot;;            return nullptr;        &#125;    return mysql_use_result(_conn);&#125;&#x2F;&#x2F;获取连接MYSQL * MySQL::getConnection()&#123;    return _conn;&#125;</code></pre><p><strong>MySQL 类实现功能简述</strong></p><ol><li><strong>初始化连接</strong><ul><li>构造函数 <code>MySQL()</code> 调用 <code>mysql_init</code> 初始化 MySQL 连接对象。</li></ul></li><li><strong>释放连接资源</strong><ul><li>析构函数 <code>~MySQL()</code> 关闭数据库连接，释放资源。</li></ul></li><li><strong>连接数据库</strong><ul><li><code>connect()</code> 使用 <code>mysql_real_connect</code> 连接到数据库。</li><li>成功连接后设置字符集为 <code>gbk</code>，防止中文乱码。</li><li>通过日志打印连接成功或失败信息。</li></ul></li><li><strong>执行更新操作</strong><ul><li><code>update(string sql)</code> 执行 SQL 更新语句（如 INSERT、UPDATE、DELETE）。</li><li>失败时打印错误日志，返回 <code>false</code>。</li></ul></li><li><strong>执行查询操作</strong><ul><li><code>query(string sql)</code> 执行 SQL 查询语句。</li><li>返回查询结果指针，失败时返回 <code>nullptr</code>。</li></ul></li><li><strong>获取底层连接</strong><ul><li><code>getConnection()</code> 返回当前的 MySQL 连接指针，方便其他数据库操作调用。</li></ul></li></ol><h3 id="include-server-user-hpp-数据库中user表对应的类"><a href="#include-server-user-hpp-数据库中user表对应的类" class="headerlink" title="include&#x2F;server&#x2F;user.hpp 数据库中user表对应的类"></a>include&#x2F;server&#x2F;user.hpp 数据库中user表对应的类</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef USER_H#define USER_H#include&lt;string&gt;using namespace std;&#x2F;&#x2F;User表的ORM类class User&#123;    public:        User(int id&#x3D;1,string name&#x3D;&quot;&quot;,string pwd&#x3D;&quot;&quot;,string state&#x3D;&quot;offline&quot;)&#123;            this-&gt;id&#x3D;id;            this-&gt;name&#x3D;name;            this-&gt;password&#x3D;pwd;            this-&gt;state&#x3D;state;        &#125;        void setId(int id)&#123;this-&gt;id&#x3D;id;&#125;        void setName(string name)&#123;this-&gt;name&#x3D;name;&#125;        void setPwd(string pwd)&#123;this-&gt;password&#x3D;pwd;&#125;        void setState(string state)&#123;this-&gt;state&#x3D;state;&#125;        int getId()&#123;return this-&gt;id;&#125;        string getName()&#123;return this-&gt;name;&#125;        string getPwd()&#123;return this-&gt;password;&#125;        string getState()&#123;return this-&gt;state;&#125;    private:        int id;        string name;        string password;        string state;&#125;;#endif</code></pre><p><strong><code>User</code> 类作用概括：</strong></p><ol><li><strong>ORM 映射作用</strong></li></ol><ul><li>该类是对数据库 <code>User</code> 表的一个对象化表示（Object-Relational Mapping）。</li><li>将数据库中的一条用户记录封装成一个 C++ 对象，便于在程序中操作。</li></ul><ol start="2"><li><strong>属性封装</strong></li></ol><p>类中包含如下用户信息字段：</p><ul><li><code>id</code>: 用户编号</li><li><code>name</code>: 用户名</li><li><code>password</code>: 用户密码</li><li><code>state</code>: 用户状态（如 <code>&quot;online&quot;</code> &#x2F; <code>&quot;offline&quot;</code>）</li></ul><ol start="3"><li><strong>基本接口功能</strong></li></ol><p>提供了以下功能函数：</p><ul><li>构造函数（支持默认值）</li><li><code>setXXX()</code> 设置各字段值</li><li><code>getXXX()</code> 获取各字段值</li></ul><p><strong>项目中的实际用途</strong></p><p>基于 Muduo 的聊天服务器项目中：</p><ul><li>用户数据从数据库中查询出来后，可以封装成 <code>User</code> 类对象；</li><li>在业务逻辑中传递用户信息时，使用 <code>User</code> 类便于管理；</li><li>与数据库交互模块（如 DAO 类）进行数据传递、封装与解封装；</li><li>便于将用户信息序列化为 JSON 数据发送到客户端。</li></ul><h3 id="include-server-usermodel-hpp-user表的数据操作类"><a href="#include-server-usermodel-hpp-user表的数据操作类" class="headerlink" title="include&#x2F;server&#x2F;usermodel.hpp  user表的数据操作类"></a>include&#x2F;server&#x2F;usermodel.hpp  user表的数据操作类</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef USERMODEL_H#define USERMODEL_H#include &quot;user.hpp&quot;&#x2F;&#x2F;user表的数据操作类class UserModel&#123;public:    &#x2F;&#x2F;User表的增加方法    bool insert(User &amp;user);&#125;;#endif</code></pre><p><code>#ifndef/#define/#endif</code>：防止头文件重复包含（include guard）；</p><p><code>#include &quot;user.hpp&quot;</code>：引入用户实体类定义；</p><p><code>class UserModel</code>：封装了对 <code>User</code> 表的数据库操作；</p><p><code>bool insert(User &amp;user)</code>：定义了插入用户的方法，返回是否成功。</p><h3 id="src-server-usermodel-cpp"><a href="#src-server-usermodel-cpp" class="headerlink" title="src&#x2F;server&#x2F;usermodel.cpp"></a>src&#x2F;server&#x2F;usermodel.cpp</h3><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;usermodel.hpp&quot;#include &quot;db.h&quot;#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F;User表的增加方法bool UserModel::insert(User &amp;user)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;insert into User(name,password,state) values(&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;)&quot;,        user.getName().c_str(),user.getPwd().c_str(),user.getState().c_str());    MySQL mysql;    if(mysql.connect())&#123;        if(mysql.update(sql))&#123;            &#x2F;&#x2F;获取插入成功的用户数据生成的主键id            user.setId(mysql_insert_id(mysql.getConnection()));            return true;        &#125;    &#125;    return false;&#125;</code></pre><p><code>sprintf</code> 组装 SQL；</p><p><code>MySQL</code> 是你自定义的数据库操作类，封装了 <code>connect()</code> 和 <code>update()</code>；</p><p>插入成功后，用 <code>mysql_insert_id()</code> 获取刚插入的记录主键 ID。</p><h3 id="注册业务实现"><a href="#注册业务实现" class="headerlink" title="注册业务实现"></a>注册业务实现</h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>public.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">enum EnMsgType&#123;    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息    REG_MSG,&#x2F;&#x2F;注册消息    REG_MSG_ACK &#x2F;&#x2F;注册响应消息&#125;;</code></pre><p>再加上REG_MSG_ACK 注册响应消息，告诉客户端已经收到消息。</p><p>chatservice.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">private:    ChatService();    &#x2F;&#x2F;存储消息id和其对应的业务处理方法    unordered_map&lt;int,MsgHandler&gt; _msgHandlerMap;    &#x2F;&#x2F;数据操作类对象    UserModel _userModel;</code></pre><p>在private中加入数据操作类对象UserModel _userModel，这个是自定义的对象在usermodel.hpp</p><p>chatservice.cpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">void ChatService::reg(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    string name&#x3D;js[&quot;name&quot;];    string pwd&#x3D;js[&quot;password&quot;];    User user;    user.setName(name);    user.setPwd(pwd);    bool state&#x3D;_userModel.insert(user);    if(state)&#123;        &#x2F;&#x2F;注册成功        json response;        response[&quot;msgid&quot;]&#x3D; REG_MSG_ACK;        response[&quot;errno&quot;]&#x3D;0;        response[&quot;id&quot;]&#x3D;user.getId();        conn-&gt;send(response.dump());    &#125;else&#123;        &#x2F;&#x2F;注册失败        json response;        response[&quot;msgid&quot;]&#x3D; REG_MSG_ACK;        response[&quot;errno&quot;]&#x3D;1;        conn-&gt;send(response.dump());    &#125;&#125;</code></pre><p>在ChatService类的reg函数，负责处理注册业务的。js中存储的是我们的消息以json存储的。这里面的字段例如msgid,name,password都是服务端和客户端约定好的。首先将消息中的name,和password拿出来赋值给User类对象user,注册业务，把对应的值存入数据库chat中的User表中。当数据操作类对象_userModel插入成功时，返回消息给客户端，msgid是客户端和服务端规定的消息类型，消息REG_MSG_ACK注册后的回应消息。返回的消息有消息类型和是否注册成功的标志errno(0表示成功，1表示失败)，注册失败id也不会产生，所以不用发了。最后使用json的dump()函数转换为字符串通过conn的send函数再发出去。</p><h4 id="conn是TcpConnectionPtr类型"><a href="#conn是TcpConnectionPtr类型" class="headerlink" title="conn是TcpConnectionPtr类型"></a>conn是TcpConnectionPtr类型</h4><p><code>TcpConnectionPtr</code> 是 <strong>Muduo 网络库</strong> 中定义的一个智能指针类型，指向 <code>TcpConnection</code> 对象，通常用于表示一条活跃的 TCP 连接。</p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;</code></pre><p>它的生命周期由 <code>Muduo</code> 网络库自动管理。</p><p>常见成员函数（通过 <code>TcpConnectionPtr</code> 调用）</p><ul><li><code>conn-&gt;send(data)</code>：发送数据到客户端</li><li><code>conn-&gt;shutdown()</code>：关闭连接（半关闭）</li><li><code>conn-&gt;connected()</code>：是否仍保持连接</li><li><code>conn-&gt;peerAddress()</code>：对端地址</li><li><code>conn-&gt;localAddress()</code>：本地地址</li><li><code>conn-&gt;setContext()</code> &#x2F; <code>conn-&gt;getContext()</code>：绑定上下文（可保存登录信息、用户ID等）</li></ul><h4 id="实现注册业务时出现的问题"><a href="#实现注册业务时出现的问题" class="headerlink" title="实现注册业务时出现的问题"></a>实现注册业务时出现的问题</h4><p>实现注册业务时，使用vscod远程连接Linux出现了连接数据库不上的问题。</p><pre class="language-none"><code class="language-none">20250604 13:22:35.282815Z 18893 INFO  connect mysql failed!Access denied for user &#39;root&#39;@&#39;localhost&#39; - db.cpp:29</code></pre><p>数据库拒绝了 root 用户从 localhost 的访问请求。</p><p>解决方案</p><p>1.使用Linux root用户登录mysql</p><p>2.修改root用户认证方式为密码登录</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'root'</span><span class="token variable">@'localhost'</span> IDENTIFIED <span class="token keyword">WITH</span> mysql_native_password <span class="token keyword">BY</span> <span class="token string">'123456'</span><span class="token punctuation">;</span>FLUSH <span class="token keyword">PRIVILEGES</span><span class="token punctuation">;</span><span class="token keyword">EXIT</span><span class="token punctuation">;</span></code></pre><p>第一句ALTER USER修改存在的用户 ‘root‘@’localhost’用户名为root,本地连接。IDENTIFIED WITH mysql_native_password 设置认证插件为 <code>mysql_native_password</code>（密码方式）</p><p>第二句MySQL 会将用户和权限信息缓存在内存中，这条命令强制它 重新加载所有权限表。<code>ALTER USER</code> 做的更改立即生效，而不必重启 MySQL 服务</p><p>第三句对用户权限和密码的修改完成了，退出命令行界面即可。</p><p><code>auth_socket</code> 是 MySQL 默认的一种用户认证方式，<strong>主要用于本地登录</strong>，<strong>不使用密码，而是通过操作系统身份验证</strong>。MySQL 会验证：</p><ul><li>你是否是当前 Linux 系统的 <code>root</code> 用户；</li><li>如果是，允许登录；</li><li>否则，拒绝访问，即使你输入了正确的密码也没用。</li></ul><h3 id="登录业务实现"><a href="#登录业务实现" class="headerlink" title="登录业务实现"></a>登录业务实现</h3><h4 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h4><p>public.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">enum EnMsgType&#123;    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息    LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息    REG_MSG,&#x2F;&#x2F;注册消息    REG_MSG_ACK &#x2F;&#x2F;注册响应消息&#125;;</code></pre><p>加入LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息</p><p>usermodel.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;根据用户号码查询用户信息User query(int id);&#x2F;&#x2F;更新用户的状态信息bool updateState(User user);</code></pre><p>加入这两个函数，后面会在登录业务用到</p><p>usermodel.cpp 对应函数的具体实现</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;根据用户号码查询用户信息User UserModel::query(int id)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;select * from User where id&#x3D;%d&quot;,id);    MySQL mysql;    if(mysql.connect())&#123;        MYSQL_RES* res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;&#x2F;&#x2F;查询成功            MYSQL_ROW row&#x3D;mysql_fetch_row(res);&#x2F;&#x2F;查一行            if(row!&#x3D;nullptr)&#123;                User user;                user.setId(atoi(row[0]));&#x2F;&#x2F;转换id为int，从数据库取出的都是字符串                user.setName(row[1]);&#x2F;&#x2F;用户名                user.setPwd(row[2]);&#x2F;&#x2F;密码                user.setState(row[3]);&#x2F;&#x2F;状态，以上是根据查询出的结果集取得                mysql_free_result(res);&#x2F;&#x2F;释放结果集资源                return user;            &#125;        &#125;    &#125;    return User();&#125;&#x2F;&#x2F;更新用户的状态信息bool UserModel::updateState(User user)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;update User set state &#x3D; &#39;%s&#39; where id &#x3D; %d&quot;,user.getState().c_str(),user.getId());    MySQL mysql;    if(mysql.connect())&#123;        if(mysql.update(sql))&#123;            return true;        &#125;    &#125;    return false;&#125;</code></pre><p>chatservice.cpp</p><p>实现login函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;处理登录业务 id pwdvoid ChatService::login(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int id&#x3D;js[&quot;id&quot;];    string pwd&#x3D;js[&quot;password&quot;];    User user&#x3D;_userModel.query(id);    if(user.getId()&#x3D;&#x3D;id&amp;&amp;user.getPwd()&#x3D;&#x3D;pwd)&#123;        if(user.getState()&#x3D;&#x3D;&quot;online&quot;)&#123;            &#x2F;&#x2F;该用户已经登录，不允许重复登录            json response;            response[&quot;msgid&quot;]&#x3D; LOGIN_MSG_ACK;            response[&quot;errno&quot;]&#x3D;2;            response[&quot;errmsg&quot;]&#x3D;&quot;该账号已经登录，请输入新账号&quot;;            conn-&gt;send(response.dump());        &#125;else        &#123;            &#x2F;&#x2F;登录成功，更新用户状态信息 state offline&#x3D;&gt;online            user.setState(&quot;online&quot;);            _userModel.updateState(user);            json response;            response[&quot;msgid&quot;]&#x3D; LOGIN_MSG_ACK;            response[&quot;errno&quot;]&#x3D;0;            response[&quot;id&quot;]&#x3D;user.getId();            response[&quot;name&quot;]&#x3D;user.getName();            conn-&gt;send(response.dump());        &#125;                    &#125;else&#123;        &#x2F;&#x2F;该用户不存在，登陆失败        json response;        response[&quot;msgid&quot;]&#x3D; LOGIN_MSG_ACK;        response[&quot;errno&quot;]&#x3D;1;        response[&quot;errmsg&quot;]&#x3D;&quot;用户名或者密码错误&quot;;        conn-&gt;send(response.dump());    &#125;&#125;</code></pre><h3 id="记录用户的连接信息及线程安全性"><a href="#记录用户的连接信息及线程安全性" class="headerlink" title="记录用户的连接信息及线程安全性"></a>记录用户的连接信息及线程安全性</h3><p>因为要实现用户与用户之间的消息往来，所以要实现记录上线用户的连接信息和下线的删除。</p><p>chatservice.hpp private:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;存储在线用户的通信连接 注意线程安全    unordered_map&lt;int,TcpConnectionPtr&gt; _userConnMap;</code></pre><p>那么这个值在什么时候更新，首先在登录成功时，添加连接</p><p>chatservice.cpp login函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">_userConnMap.insert(&#123;id,conn&#125;);&#x2F;&#x2F;unordered_map容器没有线程安全需要添加线程互斥操作</code></pre><p>当然插入了还不够，多个用户连接服务器，_userConnMap这个是在多线程环境下，要保证线程互斥性。</p><p>大多数 <strong>C++ STL 容器本身</strong>（如 <code>vector</code>、<code>map</code>、<code>unordered_map</code> 等）<strong>不是线程安全的</strong>。</p><p>所以我们要在对这个插入数据加锁。</p><p>chatservice.hpp private:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;记得包含头文件#include &lt;mutex&gt;&#x2F;&#x2F;定义互斥锁，保证_userConnMap的线程安全    mutex _connMutex;</code></pre><p>chatservice.cpp login函数 </p><p>还是在登录成功那里</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#123;     &#x2F;&#x2F;登录成功，记录用户连接信息     lock_guard&lt;mutex&gt; lock(_connMutex);&#x2F;&#x2F;如果不析构，得得遇到&#125;为止，都是互斥，所以加个域     _userConnMap.insert(&#123;id,conn&#125;);&#x2F;&#x2F;unordered_map容器没有线程安全需要添加线程互斥操作&#125;</code></pre><p>有人会问为什么再加一个花括号，这是为了让lock_guard的生命周期结束，这个变量的特性是构造时加锁，析构时自动解锁。</p><h3 id="客户端异常退出业务"><a href="#客户端异常退出业务" class="headerlink" title="客户端异常退出业务"></a>客户端异常退出业务</h3><p>当客户端异常退出时，我们的数据库还没有修改当前状态时在线还是下线，所以要实现这个业务</p><p>chatservice.cpp 定义公共函数clientCloseException</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;处理客户端异常退出void clientCloseException(const TcpConnectionPtr &amp;conn);</code></pre><p>chatservice.cpp 对应函数实现</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;处理客户端异常退出void ChatService::clientCloseException(const TcpConnectionPtr &amp;conn)&#123;    User user;    &#123;        lock_guard&lt;mutex&gt; lock(_connMutex);&#x2F;&#x2F;如果不析构，得得遇到&#125;为止，都是互斥，所以加个域        for(auto it&#x3D;_userConnMap.begin();it!&#x3D;_userConnMap.end();++it)&#123;            if(it-&gt;second &#x3D;&#x3D; conn)&#123;                user.setId(it-&gt;first);                &#x2F;&#x2F;从map表删除用户的连接信息                _userConnMap.erase(it);                break;            &#125;        &#125;    &#125;    &#x2F;&#x2F;更新用户的状态信息    if(user.getId()!&#x3D;-1)&#123;        user.setState(&quot;offline&quot;);        _userModel.updateState(user);    &#125;&#125;</code></pre><p>chatserver.cpp  onConnection函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">if(!conn-&gt;connected())&#123;       &#x2F;&#x2F;处理异常退出业务，state更新为offline       ChatService::instance()-&gt;clientCloseException(conn);       conn-&gt;shutdown();   &#125;</code></pre><p>在确认断开后，使用clientCloseException将state更新为offline。</p><h3 id="一对一聊天业务：在线聊天实现"><a href="#一对一聊天业务：在线聊天实现" class="headerlink" title="一对一聊天业务：在线聊天实现"></a>一对一聊天业务：在线聊天实现</h3><p>public.hpp 加入聊天消息ONE_CHAT_MSG</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;*server和client的公共文件*&#x2F;enum EnMsgType&#123;    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息    LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息    REG_MSG,&#x2F;&#x2F;注册消息    REG_MSG_ACK, &#x2F;&#x2F;注册响应消息    ONE_CHAT_MSG, &#x2F;&#x2F;聊天消息&#125;;</code></pre><p>既然注册了业务，所以还要在chatservice.cpp的构造函数，注册业务</p><pre class="language-c++" data-language="c++"><code class="language-c++">_msgHandlerMap.insert(&#123;ONE_CHAT_MSG,std::bind(&amp;ChatService::oneChat,this,_1,_2,_3)&#125;);</code></pre><p>chatservice.hpp 声明一对一聊天业务函数声明</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;一对一聊天业务    void oneChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);</code></pre><p>chatservice.cpp 声明一对一聊天业务函数声明</p><pre class="language-c++" data-language="c++"><code class="language-c++">void ChatService::oneChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int toid&#x3D;js[&quot;to&quot;];    &#123;        lock_guard&lt;mutex&gt; lock(_connMutex);        auto it&#x3D;_userConnMap.find(toid);        if(it!&#x3D;_userConnMap.end())&#123;            &#x2F;&#x2F;toid在线，转发消息            &#x2F;&#x2F;凡涉及_userConnMap注意线程安全性            &#x2F;&#x2F;服务器主动推送原消息给toid用户            it-&gt;second-&gt;send(js.dump());            return;        &#125;    &#125;    &#x2F;&#x2F;toid不在线，存储离线信息&#125;</code></pre><p>这里js里面的构成是</p><p>msgid &#x2F;&#x2F;消息类型<br>id发消息的id<br>from 发消息的name<br>to接受方的id<br>msg 要发送的消息</p><p>在线发送消息整体实现就是服务端接收到消息，之后查看接受用户是否在线，在线则调出服务端与接收端的连接，转发原消息。</p><h3 id="一对一聊天业务：离线消息"><a href="#一对一聊天业务：离线消息" class="headerlink" title="一对一聊天业务：离线消息"></a>一对一聊天业务：离线消息</h3><p>首先离线消息是存储在数据库的一张表里</p><p>这张表只有两个字段userid和message 这里就不用ORM映射构造一个类来保留，所以我们直接构造一个关于这张表的操作类OfflineMsgModel</p><p>offlinemessagemodel.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;string&gt;#include&lt;vector&gt;using namespace std;&#x2F;&#x2F;提供离线消息表的操作接口方法class OfflineMsgModel&#123;public:    &#x2F;&#x2F;存储用户的离线消息    void insert(int userid,string msg);    &#x2F;&#x2F;删除用户的离线消息    void remove(int userid);    &#x2F;&#x2F;查询用户的离线消息    vector&lt;string&gt; query(int userid);&#125;;</code></pre><p>offlinemessagemodel.cpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;offlinemessagemodel.hpp&quot;#include &quot;db.h&quot;&#x2F;&#x2F; 存储用户的离线消息void OfflineMsgModel::insert(int userid, string msg)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;insert into offlineMessage values(%d,&#39;%s&#39;)&quot;,userid,msg.c_str());    MySQL mysql;    if(mysql.connect())&#123;        mysql.update(sql);    &#125;&#125;&#x2F;&#x2F; 删除用户的离线消息void  OfflineMsgModel::remove(int userid)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;delete from offlineMessage where userid&#x3D;%d&quot;,userid);    MySQL mysql;    if(mysql.connect())&#123;        mysql.update(sql);    &#125;&#125;&#x2F;&#x2F; 查询用户的离线消息并返回对应id的消息数组vector&lt;string&gt;  OfflineMsgModel::query(int userid)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;select message from offlineMessage where userid&#x3D;%d&quot;,userid);    MySQL mysql;    vector&lt;string&gt; vec;       if(mysql.connect())&#123;        MYSQL_RES* res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;&#x2F;&#x2F;查询成功             &#x2F;&#x2F;把userid用户的所有离线消息放入vec中返回             &#x2F;&#x2F;查多行             MYSQL_ROW row;             while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;                vec.push_back(row[0]);             &#125;             mysql_free_result(res);             return vec;        &#125;    &#125;    return vec;&#125;</code></pre><p>构造好对应的数据操作类，要在chatservice类实现功能</p><p>chatservice.hpp 添加对应类的声明</p><pre class="language-c++" data-language="c++"><code class="language-c++">OfflineMsgModel _offlineMsgModel;</code></pre><p>chatservice.cpp</p><p>首先在用户登录成功后，要查看离线表中是否有属于它的离线消息，所以在login函数中登录成功板块还要添加</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;查询该用户是否有离线消息            vector&lt;string&gt; vec&#x3D;_offlineMsgModel.query(id);            if(!vec.empty())&#123;                response[&quot;offlinemsg&quot;]&#x3D;vec;                &#x2F;&#x2F;读取该用户的离线消息后，把该用户的所有离线消息删除掉                _offlineMsgModel.remove(id);            &#125;</code></pre><p>首先查询对应id是否有离线消息存在，存到vector数组中，如果不为空的话，response添加offlinemsg字段存储离线消息，并且在服务端删除属于接收端的离线消息，做完这些转发给接收端。</p><p>还有存储离线消息在onechat函数中对应的接收端不在线，存储离线消息在服务端。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;toid不在线，存储离线信息    _offlineMsgModel.insert(toid,js.dump());</code></pre><p>这样一对一的聊天业务就算实现了。</p><h3 id="服务器异常退出问题解决（ctrl-c退出）"><a href="#服务器异常退出问题解决（ctrl-c退出）" class="headerlink" title="服务器异常退出问题解决（ctrl+c退出）"></a>服务器异常退出问题解决（ctrl+c退出）</h3><p>这里遇到的问题是服务器异常退出，User表中用户们的在线状态并没有改变，所以我们要将其改变。</p><p>因为这里数据库的操作，所以在usermodel.cpp UserModel类实现resetState函数，记得在hpp文件声明</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;重置用户的状态信息void UserModel::resetState()&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&quot;update User set state &#x3D; &#39;offline&#39; where state &#x3D; &#39;online&#39;&quot;;    MySQL mysql;    if(mysql.connect())&#123;        mysql.update(sql);    &#125;&#125;</code></pre><p>这个函数就在chatservice.cpp中ChatService类的reset新函数调用</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;服务器异常，业务重置方法void ChatService::reset()&#123;    &#x2F;&#x2F;把online状态的用户，设置成offline    _userModel.resetState();&#125;</code></pre><p>最后在main.cpp实现这一功能</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;处理服务器ctrl+c结束后，重置user的状态信息void resetHandler(int)&#123;    ChatService::instance()-&gt;reset();    exit(0);&#125;</code></pre><p>在main函数添加对应的信号</p><pre class="language-c++" data-language="c++"><code class="language-c++">int main()&#123;    signal(SIGINT,resetHandler);    EventLoop loop;    InetAddress addr(&quot;127.0.0.1&quot;,6000);    ChatServer server(&amp;loop, addr, &quot;ChatServer&quot;);    server.start();    &#x2F;&#x2F;开启事件循环    loop.loop();    return 0;&#125;</code></pre><p>重点：signal(SIGINT,resetHandler);</p><p>注册信号处理函数</p><ul><li><strong><code>SIGINT</code></strong> 是一个信号，表示 <strong>中断信号</strong>，通常在终端按下 <code>Ctrl+C</code> 时触发。</li><li><strong><code>resetHandler</code></strong> 是你定义的函数，用来在收到这个信号时执行一些清理逻辑。它的参数类型必须是 <code>int</code>，因为它接受信号编号</li></ul><p>当然signal(SIGINT,resetHandler);这句话也不能随便放，得放在服务端启动前。</p><p>SIGINT 信号是：</p><p>Interrupt Signal（中断信号），编号是 2，表示用户希望中断（终止）正在运行的程序。</p><p>常见触发方式：</p><ul><li>当你在 终端&#x2F;命令行里运行一个程序时，按下 Ctrl + C，操作系统就会向该程序发送一个 SIGINT 信号。</li></ul><p>举个例子：</p><pre class="language-none"><code class="language-none">bash复制编辑$ .&#x2F;chat_server# 运行中...# 你按下 Ctrl+C</code></pre><p>这时，系统向 <code>chat_server</code> 进程发送 <code>SIGINT</code> 信号：</p><ul><li>如果你没处理这个信号，程序会<strong>直接终止</strong>；</li><li>如果你写了 <code>signal(SIGINT, resetHandler);</code>，就会先执行 <code>resetHandler()</code>，再退出。</li></ul><p>背后原理：</p><ul><li>Linux&#x2F;Unix 中，信号（signal）是一种<strong>异步通知机制</strong>，用于通知进程发生了某种事件。</li><li><code>SIGINT</code> 是一种 <strong>软件信号</strong>，由终端驱动程序发送给前台进程组。</li></ul><p>常见信号对比：</p><table><thead><tr><th>信号名</th><th>编号</th><th>含义</th><th>默认行为</th></tr></thead><tbody><tr><td><code>SIGINT</code></td><td>2</td><td>终端中断（Ctrl+C）</td><td>终止进程</td></tr><tr><td><code>SIGTERM</code></td><td>15</td><td>程序终止（系统或用户发送）</td><td>终止进程</td></tr><tr><td><code>SIGKILL</code></td><td>9</td><td>强制终止（不能捕获）</td><td>立即终止进程</td></tr><tr><td><code>SIGQUIT</code></td><td>3</td><td>退出（Ctrl+\）并生成 core dump</td><td>终止+生成转储文件</td></tr><tr><td><code>SIGSEGV</code></td><td>11</td><td>段错误（访问非法内存）</td><td>终止进程</td></tr></tbody></table><p>总结一句话：SIGINT 是终端用户通过 Ctrl+C 发出的“中断信号”，默认会终止程序，但你可以捕获它，在程序退出前做一些清理处理。</p><h3 id="添加好友业务代码"><a href="#添加好友业务代码" class="headerlink" title="添加好友业务代码"></a>添加好友业务代码</h3><p>public.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">enum EnMsgType&#123;    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息    LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息    REG_MSG,&#x2F;&#x2F;注册消息    REG_MSG_ACK, &#x2F;&#x2F;注册响应消息    ONE_CHAT_MSG, &#x2F;&#x2F;聊天消息    ADD_FRIEND_MSG,&#x2F;&#x2F;添加好友消息&#125;;</code></pre><p>添加ADD_FRIEND_MSG,&#x2F;&#x2F;添加好友消息</p><p>添加好友在数据库中对应的一张Friend表，其中字段是userid和friendid,所以我们实现一个操控Friend表的model类</p><p>friendmodel.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef FRIENDMODEL_H#define FRIENDMODEL_H#include &quot;user.hpp&quot;#include&lt;vector&gt;using namespace std;&#x2F;&#x2F;维护好友信息的操作接口方法class FriendModel&#123;public:    &#x2F;&#x2F;添加好友关系    void insert(int userid,int friendid);    &#x2F;&#x2F;返回用户好友列表 friendid    vector&lt;User&gt; query(int userid);&#125;;#endif</code></pre><p>friendmodel.cpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &quot;friendmodel.hpp&quot;#include &quot;db.h&quot;&#x2F;&#x2F;添加好友关系void FriendModel::insert(int userid,int friendid)&#123;    &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;insert into Friend values(%d,%d)&quot;,userid,friendid);    MySQL mysql;    if(mysql.connect())&#123;        mysql.update(sql);    &#125;&#125;&#x2F;&#x2F;返回用户好友列表 friendidvector&lt;User&gt; FriendModel::query(int userid)&#123;     &#x2F;&#x2F;1 组装sql语句    char sql[1024] &#x3D;&#123;0&#125;;    sprintf(sql,&quot;select a.id,a.name,a.state from User a inner join Friend b on b.friendid&#x3D;a.id where b.userid&#x3D;%d&quot;,userid);    MySQL mysql;    vector&lt;User&gt; vec;       if(mysql.connect())&#123;        MYSQL_RES* res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;&#x2F;&#x2F;查询成功             &#x2F;&#x2F;把userid用户的所有离线消息放入vec中返回             &#x2F;&#x2F;查多行             MYSQL_ROW row;             while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;                User user;                user.setId(atoi(row[0]));                user.setName(row[1]);                user.setState(row[2]);                vec.push_back(user);             &#125;             mysql_free_result(res);             return vec;        &#125;    &#125;    return vec;&#125;</code></pre><p>insert函数实现的是将好友关系加到数据库中。query返回的是从数据库中返回的好友数据。</p><p>当然还有一个业务绑定</p><p>首先在chatservice.hpp声明一个FriendModel对象</p><pre class="language-c++" data-language="c++"><code class="language-c++">FriendModel _friendModel;</code></pre><p>在ChatService的构造函数实现绑定</p><pre class="language-c++" data-language="c++"><code class="language-c++">_msgHandlerMap.insert(&#123;ADD_FRIEND_MSG,std::bind(&amp;ChatService::addFriend,this,_1,_2,_3)&#125;);</code></pre><p>在chatservice.hpp声明一个addFriend的函数</p><p>addFriend函数实现:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;添加好友业务 msgid id friendidvoid ChatService::addFriend(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int userid&#x3D;js[&quot;id&quot;];    int friendid&#x3D;js[&quot;friendid&quot;];    &#x2F;&#x2F;存储好友信息    _friendModel.insert(userid,friendid);&#125;</code></pre><p>这里收到的json消息格式为</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span><span class="token property">"msgid"</span><span class="token operator">:</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token property">"friendid"</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">&#125;</span></code></pre><p>还有一个问题，在用户登录时，也要好友信息的显示，所以在用户登陆成功时，服务端也要把好友信息发给用户端。</p><p>所以在服务端登录的回复信息这里需要加上好友信息</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;查询该用户的好友信息并返回            vector&lt;User&gt; userVec&#x3D;_friendModel.query(id);            if(!userVec.empty())&#123;               vector&lt;string&gt; vec2;               for(User &amp;user:userVec)&#123;                json js;                js[&quot;id&quot;]&#x3D;user.getId();                js[&quot;name&quot;]&#x3D;user.getName();                js[&quot;state&quot;]&#x3D;user.getState();                vec2.push_back(js.dump());               &#125;               response[&quot;friends&quot;]&#x3D;vec2;            &#125;</code></pre><p>这里添加好友的业务就实现了。</p><h3 id="群组业务"><a href="#群组业务" class="headerlink" title="群组业务"></a>群组业务</h3><p>首先要实现群组业务，我在数据库有两张表实现群组业务AllGroup和GroupUser</p><p>AllGroup的数据结构：</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">-----------+--------------+------+-----+---------+----------------+</span><span class="token operator">|</span> Field     <span class="token operator">|</span> <span class="token keyword">Type</span>         <span class="token operator">|</span> <span class="token boolean">Null</span> <span class="token operator">|</span> <span class="token keyword">Key</span> <span class="token operator">|</span> <span class="token keyword">Default</span> <span class="token operator">|</span> Extra          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------+--------------+------+-----+---------+----------------+</span><span class="token operator">|</span> id        <span class="token operator">|</span> <span class="token keyword">int</span>          <span class="token operator">|</span> <span class="token keyword">NO</span>   <span class="token operator">|</span> PRI <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token keyword">auto_increment</span> <span class="token operator">|</span><span class="token operator">|</span> groupname <span class="token operator">|</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>  <span class="token operator">|</span> <span class="token keyword">NO</span>   <span class="token operator">|</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>                <span class="token operator">|</span><span class="token operator">|</span> groupdesc <span class="token operator">|</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span> <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span>         <span class="token operator">|</span>                <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">-----------+--------------+------+-----+---------+----------------+</span></code></pre><p>GroupUSer的数据结构</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">------------+--------------------------+------+-----+---------+-------+</span><span class="token operator">|</span> Field      <span class="token operator">|</span> <span class="token keyword">Type</span>                     <span class="token operator">|</span> <span class="token boolean">Null</span> <span class="token operator">|</span> <span class="token keyword">Key</span> <span class="token operator">|</span> <span class="token keyword">Default</span> <span class="token operator">|</span> Extra <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------+--------------------------+------+-----+---------+-------+</span><span class="token operator">|</span> groupid    <span class="token operator">|</span> <span class="token keyword">int</span>                      <span class="token operator">|</span> <span class="token keyword">NO</span>   <span class="token operator">|</span> PRI <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">|</span> userid     <span class="token operator">|</span> <span class="token keyword">int</span>                      <span class="token operator">|</span> <span class="token keyword">NO</span>   <span class="token operator">|</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">|</span> groupprole <span class="token operator">|</span> <span class="token keyword">enum</span><span class="token punctuation">(</span><span class="token string">'creator'</span><span class="token punctuation">,</span><span class="token string">'normal'</span><span class="token punctuation">)</span> <span class="token operator">|</span> YES  <span class="token operator">|</span>     <span class="token operator">|</span> normal  <span class="token operator">|</span>       <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">------------+--------------------------+------+-----+---------+-------+</span></code></pre><p>groupuser.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef GROUPUSER_H#define GROUPUSER_H#include &quot;user.hpp&quot;&#x2F;&#x2F;群组用户，多了个role角色信息，从User类直接继承，复用User的其他信息&#x2F;&#x2F;对应的GroupUser表，但是光是这张表的不够，还要联表查询，所以继承User类。class GroupUser:public User&#123;public:    void setRole(string role)&#123;this-&gt;role&#x3D;role;&#125;    string getRole()&#123;return this-&gt;role;&#125;private:    string role;&#125;;#endif</code></pre><p>GroupUser类对象是记录关于组成员的详细信息的类，所以继承User。</p><p>group.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef GROUP_H#define GROUP_H#include&lt;vector&gt;#include&lt;string&gt;#include &quot;groupuser.hpp&quot;using namespace std;&#x2F;&#x2F;AllGroup表的ORM类但也不完全是还加了储存组用户的数组class Group&#123;public:    Group(int id&#x3D;-1,string name &#x3D;&quot;&quot;,string desc&#x3D;&quot;&quot;)&#123;        this-&gt;id&#x3D;id;        this-&gt;name&#x3D;name;        this-&gt;desc&#x3D;desc;    &#125;    void setId(int id)&#123;        this-&gt;id&#x3D;id;    &#125;    void setName(string name)&#123;        this-&gt;name&#x3D;name;    &#125;    void setDesc(string desc)&#123;this-&gt;desc&#x3D;desc;&#125;    int getId()&#123;        return this-&gt;id;    &#125;    string getName()&#123;        return this-&gt;name;    &#125;    string getDesc()&#123;        return this-&gt;desc;    &#125;    vector&lt;GroupUser&gt; &amp;getUsers() &#123;return this-&gt;users;&#125;private:    int id;&#x2F;&#x2F;组id    string name;&#x2F;&#x2F;组名    string desc;&#x2F;&#x2F;组功能描述    vector&lt;GroupUser&gt; users;&#x2F;&#x2F;组员的详细信息&#125;;#endif</code></pre><p>Group类对象是AllGroup表的ORM类，但也不完全，这个类还添加了存储组成员详细信息的结构vector<GroupUser> users;</GroupUser></p><p>因为这两张表的关联系很大，所以我们第一这个群组业务的数据操作接口。</p><p>groupmodel.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef GROUPMODEL_H#define GROUPMODEL_H#include &quot;group.hpp&quot;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;&#x2F;&#x2F;维护群组信息的操作接口方法class GroupModel&#123;public:    &#x2F;&#x2F;创建群组    bool createGroup(Group &amp;group);    &#x2F;&#x2F;加入群组    void addGroup(int userid,int groupid,string role);    &#x2F;&#x2F;查询用户所在群组消息    vector&lt;Group&gt; queryGroups(int userid);    &#x2F;&#x2F;根据指定的groupid查询群组用户id列表，除userid自己，主要用户群聊业务给群组其他成员群发消息。    vector&lt;int&gt; queryGroupUsers(int userid,int groupid);&#125;;#endif</code></pre><p>对应函数实现</p><p>创建群组createGroup函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 创建群组bool GroupModel::createGroup(Group &amp;group)&#123;    &#x2F;&#x2F;1.组装sql语句    char sql[1024]&#x3D;&#123;0&#125;;    sprintf(sql,&quot;insert into AllGroup(groupname,groupdesc) values(&#39;%s&#39;,&#39;%s&#39;)&quot;,group.getName().c_str(),group.getDesc().c_str());    MySQL mysql;    if(mysql.connect())&#123;        if(mysql.update(sql))&#123;            group.setId(mysql_insert_id(mysql.getConnection()));            return true;        &#125;    &#125;    return false;&#125;</code></pre><p>将组名和组介绍存到AllGroup表中。</p><p>加入群组addGroup函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 加入群组void GroupModel::addGroup(int userid, int groupid, string role)&#123;    &#x2F;&#x2F;1.组装sql语句    char sql[1024]&#x3D;&#123;0&#125;;    sprintf(sql,&quot;insert into GroupUser values(%d,%d,&#39;%s&#39;)&quot;,groupid,userid,role.c_str());    MySQL mysql;    if(mysql.connect())&#123;       mysql.update(sql);    &#125;&#125;</code></pre><p>&#x2F;&#x2F; 查询用户所在群组信息queryGroups</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 查询用户所在群组消息vector&lt;Group&gt; GroupModel::queryGroups(int userid)&#123;    &#x2F;&#x2F; 1.先根据userid在GroupUser表中查询该用户所属的群组消息    &#x2F;&#x2F; 2.再根据群组消息，查询属于该群组的所有用户的userid,并且和User表进行多表联合查询，查出用户的详细信息    char sql[1024]&#x3D;&#123;0&#125;;    sprintf(sql,&quot;select a.id,a.groupname,a.groupdesc from AllGroup a inner join GroupUser b on a.id&#x3D;b.groupid where b.userid&#x3D;%d&quot;,userid);    vector&lt;Group&gt; groupVec;    MySQL mysql;    if(mysql.connect())&#123;        MYSQL_RES *res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;            MYSQL_ROW row;            &#x2F;&#x2F;查出userid所有的群组消息            while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;                Group group;                group.setId(atoi(row[0]));                group.setName(row[1]);                group.setDesc(row[2]);                groupVec.push_back(group);            &#125;            mysql_free_result(res);        &#125;    &#125;    &#x2F;&#x2F;查询群组的用户信息    for(Group &amp;group:groupVec)&#123;        sprintf(sql,&quot;select a.id,a.name,a.state,b.grouprole from User a inner join GroupUser b on b.userid&#x3D;a.id where b.groupid&#x3D;%d&quot;,group.getId());        MYSQL_RES *res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;            MYSQL_ROW row;            while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;                GroupUser user;                user.setId(atoi(row[0]));                user.setName(row[1]);                user.setState(row[2]);                user.setRole(row[3]);                group.getUsers().push_back(user);            &#125;            mysql_free_result(res);        &#125;    &#125;    return groupVec;&#125;</code></pre><p>根据指定的groupid查询群组用户id列表，除userid自己。queryGroupUsers函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 根据指定的groupid查询群组用户id列表，除userid自己，主要用户群聊业务给群组其他成员群发消息。vector&lt;int&gt; GroupModel::queryGroupUsers(int userid, int groupid)&#123;    char sql[1024]&#x3D;&#123;0&#125;;    sprintf(sql,&quot;select userid from GroupUser where groupid&#x3D;%d and userid!&#x3D;%d&quot;,groupid,userid);    vector&lt;int&gt; idVec;    MySQL mysql;    if(mysql.connect())&#123;        MYSQL_RES *res&#x3D;mysql.query(sql);        if(res!&#x3D;nullptr)&#123;            MYSQL_ROW row;            while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;                idVec.push_back(atoi(row[0]));            &#125;            mysql_free_result(res);        &#125;    &#125;    return idVec;&#125;</code></pre><p>完成这些在业务类使用这些功能</p><p>首先在public.hpp更新消息类型：</p><pre class="language-c++" data-language="c++"><code class="language-c++">CREATE_GROUP_MSG,&#x2F;&#x2F;创建群组    ADD_GROUP_MSG,&#x2F;&#x2F;加入群组    GROUP_CHAT_MSG,&#x2F;&#x2F;群聊天</code></pre><p>在业务类ChatService中添加对应的数据操作类对象：</p><pre class="language-c++" data-language="c++"><code class="language-c++">GroupModel _groupModel;</code></pre><p>加入功能实现函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建群组业务    void createGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);    &#x2F;&#x2F;加入群组业务    void addGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);    &#x2F;&#x2F;群组聊天业务    void groupChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);</code></pre><p>创建群组业务:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建群组业务void ChatService::createGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int userid&#x3D;js[&quot;id&quot;];    string name&#x3D;js[&quot;groupname&quot;];    string desc&#x3D;js[&quot;groupdesc&quot;];    &#x2F;&#x2F;存储新创建的群组消息    Group group(-1,name,desc);    if(_groupModel.createGroup(group))&#123;        &#x2F;&#x2F;存储群组创建人消息        _groupModel.addGroup(userid,group.getId(),&quot;creator&quot;);    &#125;&#125;</code></pre><p>加入群组业务:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;加入群组业务void ChatService::addGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int userid&#x3D;js[&quot;id&quot;];    int groupid&#x3D;js[&quot;groupid&quot;];    _groupModel.addGroup(userid,groupid,&quot;normal&quot;);&#125;</code></pre><p>群组聊天业务:</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;群组聊天业务void ChatService::groupChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int userid&#x3D;js[&quot;id&quot;];    int groupid&#x3D;js[&quot;groupid&quot;];    vector&lt;int&gt; useridVec&#x3D;_groupModel.queryGroupUsers(userid,groupid);    lock_guard&lt;mutex&gt; lock(_connMutex);    for(int id:useridVec)&#123;                auto it&#x3D;_userConnMap.find(id);        if(it!&#x3D;_userConnMap.end())&#123;            &#x2F;&#x2F;转发群消息            it-&gt;second-&gt;send(js.dump());        &#125;else&#123;            &#x2F;&#x2F;存储离线群消息            _offlineMsgModel.insert(id,js.dump());        &#125;    &#125;&#125;</code></pre><p>还要在构造函数绑定消息对应函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;群组业务注册    _msgHandlerMap.insert(&#123;CREATE_GROUP_MSG,std::bind(&amp;ChatService::createGroup,this,_1,_2,_3)&#125;);    _msgHandlerMap.insert(&#123;ADD_GROUP_MSG,std::bind(&amp;ChatService::addGroup,this,_1,_2,_3)&#125;);    _msgHandlerMap.insert(&#123;GROUP_CHAT_MSG,std::bind(&amp;ChatService::groupChat,this,_1,_2,_3)&#125;);</code></pre><p>当然在用户登录成功时，还要把群组的信息发给客户端。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;查询用户的群组信息            vector&lt;Group&gt; groupuserVec&#x3D;_groupModel.queryGroups(id);            if(!groupuserVec.empty())&#123;                &#x2F;&#x2F;group:[&#123;groupid:[xxx,xxx,xxx,xxx]&#125;]                vector&lt;string&gt; groupV;                for(Group &amp;group:groupuserVec)&#123;                    json grpjson;                    grpjson[&quot;id&quot;]&#x3D;group.getId();                    grpjson[&quot;groupname&quot;]&#x3D;group.getName();                    grpjson[&quot;groupdesc&quot;]&#x3D;group.getDesc();                    vector&lt;string&gt; userV;                    for(GroupUser &amp;user:group.getUsers())&#123;                        json js;                        js[&quot;id&quot;]&#x3D;user.getId();                        js[&quot;name&quot;]&#x3D;user.getName();                        js[&quot;state&quot;]&#x3D;user.getState();                        js[&quot;role&quot;]&#x3D;user.getRole();                        userV.push_back(js.dump());                    &#125;                    grpjson[&quot;users&quot;]&#x3D;userV;                    groupV.push_back(grpjson.dump());                &#125;                response[&quot;groups&quot;]&#x3D;groupV;            &#125;</code></pre><p>群组业务就完成了。</p><h3 id="客户端开发-首页面开发"><a href="#客户端开发-首页面开发" class="headerlink" title="客户端开发-首页面开发"></a>客户端开发-首页面开发</h3><p>首先在src&#x2F;client编写CMakeLists.txt和main.cpp</p><p>CMakeLists.txt</p><pre class="language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#定义了一个SRC_LIST变量，包含了该目录下所有的源文件</span><span class="token keyword">aux_source_directory</span><span class="token punctuation">(</span>. SRC_LIST<span class="token punctuation">)</span><span class="token comment">#指定生成可执行文件</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>ChatClient <span class="token punctuation">$&#123;</span>SRC_LIST<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">#指定可执行文件链接时所需要依赖的库文件</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>ChatClient pthread<span class="token punctuation">)</span></code></pre><p>main.cpp编写我们的客户端程序</p><p>首先保存的变量</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;记录当前系统登录的用户信息User g_currentUser;&#x2F;&#x2F;记录当前登录用户的好友列表信息vector&lt;User&gt; g_currentUserFriendList;&#x2F;&#x2F;记录当前登录用户的群组列表信息vector&lt;Group&gt; g_currentUserGroupList;</code></pre><p>目前的函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;显示当前登录成功用户的基本信息void showCurrentUserData();&#x2F;&#x2F;接受线程void readTaskHandler(int clientfd);&#x2F;&#x2F;获取系统时间(聊天信息需要添加时间信息)string getCurrentTime();&#x2F;&#x2F;主聊天页面程序void mainMenu();</code></pre><p>主线程main函数</p><p>int main(int argc,char **argv) </p><p>参数说明：</p><ul><li><code>int argc</code>：Argument Count，命令行参数的数量（包括程序本身的名称）。</li><li><code>char **argv</code>：Argument Vector，命令行参数的数组。<code>argv[0]</code> 是程序的名字，<code>argv[1]</code> 到 <code>argv[argc-1]</code> 是你在命令行中输入的其他参数。</li></ul><p>在命令行运行.&#x2F;ChatClient 127.0.0.1 6000即可运行</p><h4 id="客户端和服务端的连接"><a href="#客户端和服务端的连接" class="headerlink" title="客户端和服务端的连接"></a>客户端和服务端的连接</h4><p>首先客户端和服务端的连接代码：</p><pre class="language-c++" data-language="c++"><code class="language-c++">if(argc&lt;3)&#123;    cerr&lt;&lt;&quot;command invalid!example:.&#x2F;ChatClient 127.0.0.1 6000&quot;&lt;&lt;endl;    exit(-1);&#x2F;&#x2F;异常退出 exit(0)是正常退出&#125;&#x2F;&#x2F;解析通过命令行参数传递的ip和portchar *ip&#x3D;argv[1];uint16_t port&#x3D;atoi(argv[2]);&#x2F;&#x2F;创建client端的socketint clientfd&#x3D;socket(AF_INET,SOCK_STREAM,0);if(-1&#x3D;&#x3D;clientfd)&#123;    cerr&lt;&lt;&quot;socket create error&quot;&lt;&lt;endl;    exit(-1);&#125;&#x2F;&#x2F;填写client需要连接的server信息ip+portsockaddr_in server;memset(&amp;server,0,sizeof(sockaddr_in));server.sin_family&#x3D;AF_INET;server.sin_port&#x3D;htons(port);server.sin_addr.s_addr&#x3D;inet_addr(ip);&#x2F;&#x2F;client和server进行连接if(-1&#x3D;&#x3D;connect(clientfd,(sockaddr *)&amp;server,sizeof(sockaddr_in)))&#123;    cerr &lt;&lt;&quot;connect server error&quot;&lt;&lt;endl;    close(clientfd);    exit(-1);&#125;</code></pre><p>对其中的函数解释：</p><pre class="language-c++" data-language="c++"><code class="language-c++">int clientfd&#x3D;socket(AF_INET,SOCK_STREAM,0);</code></pre><p>socket函数功能：创建一个 TCP 套接字（socket）</p><p>其中的socket函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;sys&#x2F;socket.h&gt;</code></pre><p> 各个参数含义：</p><pre class="language-c++" data-language="c++"><code class="language-c++">socket(int domain, int type, int protocol)</code></pre><ol><li><code>AF_INET</code>（地址族）</li></ol><ul><li>指定使用 <strong>IPv4</strong> 地址（Internet Protocol version 4）。</li><li>如果是 <code>AF_INET6</code>，那就是 IPv6。</li></ul><ol start="2"><li><code>SOCK_STREAM</code>（套接字类型）</li></ol><ul><li>表示使用的是 <strong>面向连接的、可靠的、基于字节流</strong> 的通信方式。</li><li>通常对应 <strong>TCP</strong> 协议。</li></ul><ol start="3"><li><code>0</code>（协议编号）</li></ol><ul><li>填 <code>0</code> 表示让系统根据前两个参数自动选择合适的协议。</li><li>对于 <code>AF_INET + SOCK_STREAM</code>，系统会自动选择 <strong>TCP</strong> 协议。</li></ul><p>返回值：</p><ul><li>成功时返回一个非负整数（<strong>文件描述符</strong>，也就是 <code>clientfd</code>），用于后续的读写操作。</li><li>失败时返回 <code>-1</code>，常见原因包括：系统资源耗尽、参数错误等。</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">sockaddr_in server;</code></pre><p><code>sockaddr_in</code> 是 C&#x2F;C++ 中专门用来表示 <strong>IPv4 网络地址</strong> 的结构体。</p><p>对应的头文件：</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;netinet&#x2F;in.h&gt;</code></pre><pre class="language-c++" data-language="c++"><code class="language-c++">memset(&amp;server,0,sizeof(sockaddr_in));</code></pre><p>把 <code>server</code> 结构体从首地址开始，连续 <code>sizeof(server)</code> 个字节都设置为 <code>0</code>。</p><p>memset函数用法</p><pre class="language-c++" data-language="c++"><code class="language-c++">void *memset(void *ptr, int value, size_t num);</code></pre><p> 参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>ptr</code></td><td>指向要被设置的内存的指针</td></tr><tr><td><code>value</code></td><td>要设置的值（会被转换为 <code>unsigned char</code> 类型）</td></tr><tr><td><code>num</code></td><td>要设置的字节数</td></tr></tbody></table><pre class="language-c++" data-language="c++"><code class="language-c++">server.sin_family&#x3D;AF_INET;server.sin_port&#x3D;htons(port);server.sin_addr.s_addr&#x3D;inet_addr(ip);</code></pre><pre class="language-c++" data-language="c++"><code class="language-c++">server.sin_family &#x3D; AF_INET;</code></pre><ul><li>表示使用的地址类型是 <strong>IPv4</strong>。</li><li><code>AF_INET</code> 是 <strong>Address Family Internet</strong> 的缩写。</li><li>这是 <code>sockaddr_in</code> 中的 <code>sin_family</code> 字段，必须设置为 <code>AF_INET</code>，否则系统无法识别地址格式。</li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">server.sin_port &#x3D; htons(port);</code></pre><ul><li>设置端口号，例如：6000。</li><li><code>htons()</code> 是 <strong>Host to Network Short</strong> 的缩写：h<ul><li>它把本地主机的字节序（可能是小端）转换为网络字节序（大端）。</li><li>因为 TCP&#x2F;IP 协议使用大端字节序进行数据传输。</li></ul></li><li><code>port</code> 是你从命令行传进来的端口号字符串转成的整数。</li></ul><p>htons函数头文件：</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;netinet&#x2F;in.h&gt;</code></pre><p> 端口必须转换成网络字节序，否则客户端连接服务器时会出错！</p><pre class="language-c++" data-language="c++"><code class="language-c++">server.sin_addr.s_addr &#x3D; inet_addr(ip);</code></pre><ul><li>设置 IP 地址。</li><li><code>inet_addr()</code> 函数把点分十进制的 IP 字符串（如 <code>&quot;127.0.0.1&quot;</code>）转换成 32 位的二进制整数。</li><li>转换后的结果赋值给 <code>sin_addr.s_addr</code>，用于 socket 连接。</li></ul><p>inet_addr函数头文件：</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;arpa&#x2F;inet.h&gt;</code></pre><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;client和server进行连接    if(-1&#x3D;&#x3D;connect(clientfd,(sockaddr *)&amp;server,sizeof(sockaddr_in)))&#123;        cerr &lt;&lt;&quot;connect server error&quot;&lt;&lt;endl;        close(clientfd);&#x2F;&#x2F;释放socket资源        exit(-1);    &#125;</code></pre><p><code>connect()</code> 函数详解：</p><pre class="language-c++" data-language="c++"><code class="language-c++">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>sockfd</code></td><td>用 <code>socket()</code> 创建的套接字文件描述符（即 <code>clientfd</code>）</td></tr><tr><td><code>addr</code></td><td>服务器地址结构指针（需要强转成 <code>sockaddr*</code> 类型）</td></tr><tr><td><code>addrlen</code></td><td><code>addr</code> 结构体的大小，通常是 <code>sizeof(sockaddr_in)</code></td></tr></tbody></table><h4 id="客户端业务实现"><a href="#客户端业务实现" class="headerlink" title="客户端业务实现"></a>客户端业务实现</h4><p>首先在一个死循环中实现循环选择：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;显示首页面菜单 登录,注册，退出       cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;       cout&lt;&lt;&quot;1. login&quot;&lt;&lt;endl;       cout&lt;&lt;&quot;2. register&quot;&lt;&lt;endl;       cout&lt;&lt;&quot;3. quit&quot;&lt;&lt;endl;       cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;       cout&lt;&lt; &quot;choice:&quot;;       int choice&#x3D;0;       cin&gt;&gt;choice;       cin.get();&#x2F;&#x2F;读掉缓冲区残留的回车</code></pre><p>使用switch语句实现不断选择。</p><h5 id="首先登录业务："><a href="#首先登录业务：" class="headerlink" title="首先登录业务："></a>首先登录业务：</h5><pre class="language-c++" data-language="c++"><code class="language-c++">case 1:&#x2F;&#x2F;login业务            &#123;                int id&#x3D;0;                char pwd[50]&#x3D;&#123;0&#125;;                cout&lt;&lt; &quot;userid:&quot;;                cin&gt;&gt; id;                cin.get();&#x2F;&#x2F;读掉缓冲区残留的回车                cout&lt;&lt;&quot;user password:&quot;;                cin.getline(pwd,50);                json js;                js[&quot;msgid&quot;]&#x3D;LOGIN_MSG;                js[&quot;id&quot;]&#x3D;id;                js[&quot;password&quot;]&#x3D;pwd;                string request &#x3D;js.dump();                int len&#x3D;send(clientfd,request.c_str(),strlen(request.c_str())+1,0);                if(len&#x3D;&#x3D;-1)&#123;                    cerr&lt;&lt;&quot;send login msg error:&quot;&lt;&lt;request&lt;&lt;endl;                &#125;else&#123;                    char buffer[1024]&#x3D;&#123;0&#125;;                    len&#x3D;recv(clientfd,buffer,1024,0);                    if(len&#x3D;&#x3D;-1)&#123;                        cerr &lt;&lt;&quot;recv login response error&quot;&lt;&lt;endl;                    &#125;else&#123;                        json responsejs&#x3D;json::parse(buffer);                        if(responsejs[&quot;errno&quot;]!&#x3D;0)&#123;                            cerr&lt;&lt;responsejs[&quot;errmsg&quot;]&lt;&lt;endl;                        &#125;                        else&#123;&#x2F;&#x2F;登录成功                            &#x2F;&#x2F;记录当前用户的id和name                            g_currentUser.setId(responsejs[&quot;id&quot;]);                            g_currentUser.setName(responsejs[&quot;name&quot;]);                            &#x2F;&#x2F;记录当前用户的好友列表信息                            if(responsejs.contains(&quot;friends&quot;))&#123;&#x2F;&#x2F;看是否包含friends这个键                                vector&lt;string&gt; vec&#x3D;responsejs[&quot;friends&quot;];                                for(string &amp;str:vec)&#123;                                    json js&#x3D;json::parse(str);                                    User user;                                    user.setId(js[&quot;id&quot;]);                                    user.setName(js[&quot;name&quot;]);                                    user.setState(js[&quot;state&quot;]);                                    g_currentUserFriendList.push_back(user);                                &#125;                            &#125;                            &#x2F;&#x2F;记录当前用户的群组列表信息                            if(responsejs.contains(&quot;groups&quot;))&#123;                                vector&lt;string&gt; vec1&#x3D;responsejs[&quot;groups&quot;];                                for(string &amp;groupstr:vec1)&#123;                                    json grpjs&#x3D;json::parse(groupstr);                                    Group group;                                    group.setId(grpjs[&quot;id&quot;]);                                    group.setName(grpjs[&quot;groupname&quot;]);                                    group.setDesc(grpjs[&quot;groupdesc&quot;]);                                    vector&lt;string&gt; vec2&#x3D;grpjs[&quot;users&quot;];                                    for(string &amp;userstr:vec2)&#123;                                        GroupUser user;                                        json js&#x3D;json::parse(userstr);                                        user.setId(js[&quot;id&quot;]);                                        user.setName(js[&quot;name&quot;]);                                        user.setState(js[&quot;state&quot;]);                                        user.setRole(js[&quot;role&quot;]);                                        group.getUsers().push_back(user);                                    &#125;                                    g_currentUserGroupList.push_back(group);                                &#125;                            &#125;                            &#x2F;&#x2F;显示登录用户的基本信息                            showCurrentUserData();                            &#x2F;&#x2F;显示当前用户的离线消息 个人聊天消息或者群组消息                            if(responsejs.contains(&quot;offlinemsg&quot;))&#123;                                vector&lt;string&gt; vec&#x3D;responsejs[&quot;offlinemsg&quot;];                                for(string &amp;str:vec)&#123;                                    json js&#x3D;json::parse(str);                                    &#x2F;&#x2F;time +[id]+name+&quot;said: &quot;+xxx                                    cout&lt;&lt;js[&quot;time&quot;]&lt;&lt;&quot;[&quot;&lt;&lt;js[&quot;id&quot;]&lt;&lt;&quot;]&quot;&lt;&lt;js[&quot;name&quot;]&lt;&lt;&quot; said &quot;&lt;&lt;js[&quot;msg&quot;]&lt;&lt;endl;                                &#125;                            &#125;                            &#x2F;&#x2F;登录成功，启动接受线程负责接受数据                            std::thread readTask(readTaskHandler,clientfd);                            readTask.detach();                            &#x2F;&#x2F;进入聊天主菜单页面                            mainMenu();                        &#125;                    &#125;                &#125;            &#125;            break;</code></pre><p>这里解释一些函数</p><pre class="language-c++" data-language="c++"><code class="language-c++">int len&#x3D;send(clientfd,request.c_str(),strlen(request.c_str())+1,0);</code></pre><p>通过 <code>send()</code> 函数将字符串 <code>request</code> 的内容发送到套接字 <code>clientfd</code> 所代表的对端。</p><p>各参数详解：</p><pre class="language-c++" data-language="c++"><code class="language-c++">send(socket, buffer, length, flags)</code></pre><ul><li><code>clientfd</code>：套接字描述符，表示要发送数据的目标。</li><li><code>request.c_str()</code>：将 <code>std::string</code> 类型的 <code>request</code> 转为 C 风格的字符串（返回 <code>const char*</code> 指针）。c++</li><li><code>strlen(request.c_str()) + 1</code>：表示发送的数据长度，<code>+1</code> 是为了包括字符串末尾的 <code>\0</code>（空字符终止符），这是为了让接收方知道字符串结束。</li><li><code>0</code>：表示不使用额外的标志（默认行为）。</li></ul><p>关于返回值：</p><table><thead><tr><th>返回值 <code>len</code></th><th>意义说明</th></tr></thead><tbody><tr><td>&gt; 0</td><td>成功发送了 <code>len</code> 字节的数据</td></tr><tr><td>&#x3D;&#x3D; 0</td><td>TCP 连接被优雅关闭（几乎不会出现在 <code>send()</code>，常出现在 <code>recv()</code>）</td></tr><tr><td>&#x3D;&#x3D; -1</td><td>发送失败，需检查 <code>errno</code> 查看错误原因</td></tr></tbody></table><pre class="language-c++" data-language="c++"><code class="language-c++">len&#x3D;recv(clientfd,buffer,1024,0);</code></pre><p><strong>从 <code>clientfd</code> 套接字接收最多 1024 字节的数据，存入 <code>buffer</code> 缓冲区中</strong>。</p><p>各参数详解：</p><pre class="language-c++" data-language="c++"><code class="language-c++">recv(socket, buffer, length, flags)</code></pre><ul><li><code>clientfd</code>：连接的套接字描述符（已连接的对端）。</li><li><code>buffer</code>：用于存放接收数据的内存区域（<code>char buffer[1024];</code> 或 <code>char* buffer = new char[1024];</code>）。</li><li><code>1024</code>：最多接收 1024 字节（防止缓冲区溢出）。</li><li><code>0</code>：标志位，通常设置为 0（表示默认阻塞接收）。</li></ul><p>返回值说明（关键点）：</p><table><thead><tr><th>返回值 <code>len</code></th><th>意义说明</th></tr></thead><tbody><tr><td>&gt; 0</td><td>实际接收到的数据字节数（并不一定等于 1024）</td></tr><tr><td>&#x3D;&#x3D; 0</td><td><strong>连接已关闭</strong>（对方调用了 <code>close()</code>）</td></tr><tr><td>&#x3D;&#x3D; -1</td><td><strong>接收失败</strong>，可通过 <code>errno</code> 查看错误原因</td></tr></tbody></table><p>注意recv() 并不会自动在 buffer 的末尾添加 ‘\0‘</p><p>所以我们定义buffer:保证末尾有’\0‘</p><pre class="language-c++" data-language="c++"><code class="language-c++">char buffer[1024]&#x3D;&#123;0&#125;;</code></pre><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;登录成功，启动接受线程负责接受数据                            std::thread readTask(readTaskHandler,clientfd);                            readTask.detach();</code></pre><p>创建了一个<strong>新线程</strong>，并立刻将它<strong>分离（detach）</strong>，用来异步执行函数 <code>readTaskHandler(clientfd)</code>。</p><p>分析每一行作用：</p><ol><li><code>std::thread readTask(readTaskHandler, clientfd);</code></li></ol><ul><li>创建一个线程对象 <code>readTask</code>，该线程会立即开始运行 <code>readTaskHandler(clientfd)</code>。</li><li>通常用于处理客户端请求，比如接收数据、解析消息等。</li></ul><ol start="2"><li><code>readTask.detach();</code></li></ol><ul><li>将线程<strong>分离</strong>，让它独立运行。</li><li><strong>主线程不再管理这个子线程</strong>，也无法调用 <code>join()</code> 等待它。</li><li>线程资源会在线程函数执行完毕后由系统自动回收。</li></ul><p> detach 的 <strong>优点与风险</strong>：</p><p>优点：</p><ul><li>简单，<strong>不阻塞主线程</strong>，不需要显式 <code>join()</code>。</li><li>适合执行时间短、无需主线程等待的任务（比如客户端的消息监听）。</li></ul><p>风险：</p><ol><li><strong>无法再追踪或管理线程</strong>：你不能再 join 或获取其返回状态。</li><li><strong>容易引发悬空引用或资源泄漏问题</strong>：<ul><li>如果 <code>readTaskHandler()</code> 里访问了已经销毁的变量，会崩。</li><li>比如使用了传进来的 <code>clientfd</code> 后，主线程先关闭了它。</li></ul></li><li><strong>调试困难</strong>：detach 后的线程出错更难排查。</li></ol><h5 id="注册业务："><a href="#注册业务：" class="headerlink" title="注册业务："></a>注册业务：</h5><pre class="language-c++" data-language="c++"><code class="language-c++">case 2:&#x2F;&#x2F;register业务            &#123;                char name[50]&#x3D;&#123;0&#125;;                char pwd[50]&#x3D;&#123;0&#125;;                cout&lt;&lt; &quot;username:&quot;;                cin.getline(name,50);                cout&lt;&lt;&quot;user password:&quot;;                cin.getline(pwd,50);                json js;                js[&quot;msgid&quot;]&#x3D;REG_MSG;                js[&quot;name&quot;]&#x3D;name;                js[&quot;password&quot;]&#x3D;pwd;                string request&#x3D;js.dump();                int len&#x3D;send(clientfd,request.c_str(),strlen(request.c_str())+1,0);                if(len&#x3D;&#x3D;-1)&#123;                    cerr &lt;&lt;&quot;send reg msg error:&quot;&lt;&lt;request&lt;&lt;endl;                &#125;else&#123;                    char buffer[1024]&#x3D;&#123;0&#125;;                    len&#x3D;recv(clientfd,buffer,1024,0);                    if(len&#x3D;&#x3D;-1)&#123;                        cerr&lt;&lt;&quot;recv reg response error&quot;&lt;&lt;endl;                    &#125;else&#123;                        json responsejs&#x3D;json::parse(buffer);                        if(0!&#x3D;responsejs[&quot;errno&quot;])&#123;&#x2F;&#x2F;注册失败                            cerr&lt;&lt;name&lt;&lt;&quot;is already exist,register error!&quot;&lt;&lt;endl;                        &#125;else&#123;&#x2F;&#x2F;注册成功                            cout&lt;&lt;name&lt;&lt;&quot;register success,userid is &quot;&lt;&lt;responsejs[&quot;id&quot;]&lt;&lt;&quot;, do not forget it!&quot;&lt;&lt;endl;                        &#125;                    &#125;                &#125;            &#125;            break;</code></pre><h5 id="退出业务："><a href="#退出业务：" class="headerlink" title="退出业务："></a>退出业务：</h5><pre class="language-c++" data-language="c++"><code class="language-c++">case 3:&#x2F;&#x2F;quit 业务           &#123;               close(clientfd);&#x2F;&#x2F;释放连接，不要重复关闭               exit(0);           &#125;</code></pre><h5 id="聊天主界面业务："><a href="#聊天主界面业务：" class="headerlink" title="聊天主界面业务："></a>聊天主界面业务：</h5><p>首先在登录业务实现，登录成功又该何去何从，所以聊天主界面业务，首先在登录业务有几个函数，还没有实现，实现一下：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;显示登录用户的基本信息showCurrentUserData();</code></pre><p>具体实现：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;显示当前登录成功用户的基本信息void showCurrentUserData()&#123;    cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;login user&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;    cout&lt;&lt;&quot;current login user &#x3D;&gt;id:&quot;&lt;&lt;g_currentUser.getId()&lt;&lt;&quot;name:&quot;&lt;&lt;g_currentUser.getName()&lt;&lt;endl;    cout&lt;&lt;&quot;-------------------------friend list------------------------------&quot;&lt;&lt;endl;    if(!g_currentUserFriendList.empty())&#123;        for(User &amp;user:g_currentUserFriendList)&#123;            cout&lt;&lt;user.getId()&lt;&lt;&quot; &quot;&lt;&lt;user.getName()&lt;&lt;&quot; &quot;&lt;&lt;user.getState() &lt;&lt;endl;        &#125;    &#125;    cout&lt;&lt;&quot;--------------------------group list-------------------------------&quot;&lt;&lt;endl;    if(!g_currentUserGroupList.empty())&#123;        for(Group &amp;group:g_currentUserGroupList)&#123;            cout&lt;&lt;group.getId()&lt;&lt;&quot; &quot;&lt;&lt;group.getName()&lt;&lt;&quot; &quot;&lt;&lt;group.getDesc()&lt;&lt;endl;            for(GroupUser &amp;user:group.getUsers())&#123;                cout&lt;&lt;user.getId()&lt;&lt;&quot; &quot;&lt;&lt;user.getName()&lt;&lt;&quot; &quot;&lt;&lt;user.getState()&lt;&lt;user.getRole()&lt;&lt;endl;            &#125;        &#125;    &#125;    cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;&#125;</code></pre><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;登录成功，启动接受线程负责接受数据std::thread readTask(readTaskHandler,clientfd);readTask.detach();</code></pre><p>其中readTaskHandler的实现：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;接受线程void readTaskHandler(int clientfd)&#123;    for(;;)&#123;        char buffer[1024]&#x3D;&#123;0&#125;;        int len &#x3D;recv(clientfd,buffer,1024,0);        if(-1&#x3D;&#x3D;len||0&#x3D;&#x3D;len)&#123;            close(clientfd);            exit(-1);        &#125;        &#x2F;&#x2F;接收ChatServer转发的数据，反序列化生成json数据对象        json js&#x3D;json::parse(buffer);        if(ONE_CHAT_MSG&#x3D;&#x3D;js[&quot;msgid&quot;])&#123;            cout&lt;&lt;js[&quot;time&quot;].get&lt;string&gt;()&lt;&lt;&quot;[&quot;&lt;&lt;js[&quot;id&quot;]&lt;&lt;&quot;]&quot;&lt;&lt;js[&quot;name&quot;].get&lt;string&gt;()&lt;&lt; &quot; said: &quot;&lt;&lt;js[&quot;msg&quot;].get&lt;string&gt;()&lt;&lt;endl;            continue;        &#125;    &#125;&#125;</code></pre><p>这个函数是用来接受服务端发来的消息的。主线程是发消息的。但是当前就实现了关于一对一聊天的接受消息。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;进入聊天主菜单页面 mainMenu(clientfd);</code></pre><p>进入聊天主菜单页面实现具体的业务：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;主聊天页面程序void mainMenu(int clientfd)&#123;    help();    char buffer[1024]&#x3D;&#123;0&#125;;    for(;;)&#123;        cin.getline(buffer,1024);        string commandbuf(buffer);        string command;        int idx&#x3D;commandbuf.find(&quot;:&quot;);        if(idx&#x3D;&#x3D;-1)&#123;            command&#x3D;commandbuf;        &#125;        else&#123;            command&#x3D;commandbuf.substr(0,idx);        &#125;        auto it&#x3D;commandHandlerMap.find(command);        if(it&#x3D;&#x3D;commandHandlerMap.end())&#123;            cerr&lt;&lt; &quot;invalid input command!&quot;&lt;&lt;endl;            continue;        &#125;        &#x2F;&#x2F;调用相应命令的事件处理回调，mainMenu对修改封闭，添加新功能不需要修改该函数        it-&gt;second(clientfd,commandbuf.substr(idx+1,commandbuf.size()-idx));&#x2F;&#x2F;调用命令处理方法    &#125;&#125;</code></pre><p>这个函数实现进入主页面使用对应的指令使用对应的功能。接下来说说其中的变量commandHandlerMap。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;注册系统支持的客户端命令处理unordered_map&lt;string,function&lt;void(int,string)&gt;&gt;commandHandlerMap&#x3D;&#123;    &#123;&quot;help&quot;,help&#125;,    &#123;&quot;chat&quot;,chat&#125;,    &#123;&quot;addfriend&quot;,addfriend&#125;,    &#123;&quot;creategroup&quot;,creategroup&#125;,    &#123;&quot;addgroup&quot;,addgroup&#125;,    &#123;&quot;groupchat&quot;,groupchat&#125;,    &#123;&quot;loginout&quot;,loginout&#125;&#125;;</code></pre><p>通过哈希表绑定对应的字符串和对应函数的实现。</p><p>当然在实现这些功能时得要有一个文字说明，这就是help功能。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;help&quot; command handlervoid help(int fd,string str)&#123;    cout&lt;&lt; &quot;show command lists:&quot;&lt;&lt;endl;    for(auto&amp;p:commandMap)&#123;        cout&lt;&lt;p.first&lt;&lt;&quot; : &quot;&lt;&lt;p.second&lt;&lt;endl;    &#125;    cout&lt;&lt;endl;&#125;</code></pre><p>这有个细节，因为后续用户如果还想要再次使用help功能，所以把他放在commandHandlerMap中，但是help()函数不满足function&lt;void(int,string)&gt;,所以我们在声明的时候赋初始值，这样就可以直接help()实现了。在其中commandMap也是自己定义提示用户如何使用这些功能。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;系统支持的客户端命令列表unordered_map&lt;string,string&gt; commandMap&#x3D;&#123;    &#123;&quot;help&quot;,&quot;显示所有支持的命令，格式help&quot;&#125;,    &#123;&quot;chat&quot;,&quot;一对一聊天，格式chat:friendid:message&quot;&#125;,    &#123;&quot;addfriend&quot;,&quot;添加好友，格式addfriend:friendid&quot;&#125;,    &#123;&quot;creategroup&quot;,&quot;创建群组，格式creategroup:groupname:groupdesc&quot;&#125;,    &#123;&quot;addgroup&quot;,&quot;加入群组，格式addgroup:groupid&quot;&#125;,    &#123;&quot;groupchat&quot;,&quot;群聊，格式groupchat:groupid:message&quot;&#125;,    &#123;&quot;loginout&quot;,&quot;注销，格式loginout&quot;&#125;&#125;;</code></pre><p>由commandHandlerMap知道要实现的功能。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;调用相应命令的事件处理回调，mainMenu对修改封闭，添加新功能不需要修改该函数it-&gt;second(clientfd,commandbuf.substr(idx+1,commandbuf.size()-idx));&#x2F;&#x2F;调用命令处理方法</code></pre><p>这样就可以把具体实现的内容封装到每一个函数中，所以接下来聚集每个实现的函数。</p><h6 id="chat功能实现："><a href="#chat功能实现：" class="headerlink" title="chat功能实现："></a>chat功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;chat&quot; command handlervoid chat(int clientfd,string str)&#123;    int idx&#x3D;str.find(&quot;:&quot;);&#x2F;&#x2F;friendid:message    if(idx&#x3D;&#x3D;-1)&#123;        cerr&lt;&lt;&quot;chat command invalid!&quot;&lt;&lt;endl;        return;    &#125;    int friendid&#x3D;atoi(str.substr(0,idx).c_str());    string message&#x3D;str.substr(idx+1,str.size()-idx);    json js;    js[&quot;msgid&quot;]&#x3D;ONE_CHAT_MSG;    js[&quot;id&quot;]&#x3D;g_currentUser.getId();    js[&quot;name&quot;]&#x3D;g_currentUser.getName();    js[&quot;msg&quot;] &#x3D; message;    js[&quot;toid&quot;]&#x3D;friendid;    js[&quot;time&quot;]&#x3D;getCurrentTime();    string buffer&#x3D;js.dump();    int len&#x3D;send(clientfd,buffer.c_str(),strlen(buffer.c_str())+1,0);    if(len&#x3D;&#x3D;-1)&#123;        cerr&lt;&lt;&quot;send chat msg error:&quot;&lt;&lt;buffer&lt;&lt;endl;    &#125;&#125;</code></pre><p>还要实现getCurrentTime函数：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;获取系统时间(聊天信息需要添加时间信息)string getCurrentTime()&#123;    auto tt &#x3D; std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());    struct tm *ptm &#x3D; localtime(&amp;tt);    char date[60] &#x3D; &#123;0&#125;;    sprintf(date, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,            (int)ptm-&gt;tm_year + 1900, (int)ptm-&gt;tm_mon + 1, (int)ptm-&gt;tm_mday,            (int)ptm-&gt;tm_hour, (int)ptm-&gt;tm_min, (int)ptm-&gt;tm_sec);    return std::string(date);&#125;</code></pre><h6 id="addfriend功能实现："><a href="#addfriend功能实现：" class="headerlink" title="addfriend功能实现："></a>addfriend功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;addfriend&quot; command handlervoid addfriend(int clienfd,string str)&#123;    int friendid&#x3D;atoi(str.c_str());    json js;    js[&quot;msgid&quot;]&#x3D;ADD_FRIEND_MSG;    js[&quot;id&quot;]&#x3D;g_currentUser.getId();    js[&quot;friendid&quot;]&#x3D;friendid;    string buffer&#x3D;js.dump();    int len&#x3D;send(clienfd,buffer.c_str(),strlen(buffer.c_str())+1,0);    if(len&#x3D;&#x3D;-1)&#123;        cerr&lt;&lt;&quot;send addfriend msg error-&gt;&quot;&lt;&lt;buffer&lt;&lt;endl;    &#125;&#125;</code></pre><h6 id="creategroup功能实现："><a href="#creategroup功能实现：" class="headerlink" title="creategroup功能实现："></a>creategroup功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;creategroup&quot; command handlervoid creategroup(int clientfd, string str)&#123;    int idx &#x3D; str.find(&quot;:&quot;);    if (idx &#x3D;&#x3D; -1)    &#123;        cerr &lt;&lt; &quot;creategroup command invalid!&quot; &lt;&lt; endl;        return;    &#125;    string groupname &#x3D; str.substr(0, idx);    string groupdesc &#x3D; str.substr(idx + 1, str.size() - idx);    json js;    js[&quot;msgid&quot;] &#x3D; CREATE_GROUP_MSG;    js[&quot;id&quot;] &#x3D; g_currentUser.getId();    js[&quot;groupname&quot;] &#x3D; groupname;    js[&quot;groupdesc&quot;] &#x3D; groupdesc;    string buffer &#x3D; js.dump();    int len &#x3D; send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0);    if (len &#x3D;&#x3D; -1)    &#123;        cerr &lt;&lt; &quot;send creategroup msg error:&quot; &lt;&lt; buffer &lt;&lt; endl;    &#125;&#125;</code></pre><h6 id="addgroup功能实现："><a href="#addgroup功能实现：" class="headerlink" title="addgroup功能实现："></a>addgroup功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;addgroup&quot; command handlervoid addgroup(int clientfd, string str)&#123;    int groupid &#x3D; atoi(str.c_str());    json js;    js[&quot;msgid&quot;] &#x3D; ADD_GROUP_MSG;    js[&quot;id&quot;] &#x3D; g_currentUser.getId();    js[&quot;groupid&quot;] &#x3D; groupid;    string buffer &#x3D; js.dump();    int len &#x3D; send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0);    if (len &#x3D;&#x3D; -1)    &#123;        cerr &lt;&lt; &quot;send addgroup msg error:&quot; &lt;&lt; buffer &lt;&lt; endl;    &#125;&#125;</code></pre><h6 id="groupchat功能实现："><a href="#groupchat功能实现：" class="headerlink" title="groupchat功能实现："></a>groupchat功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;groupchat&quot; command handlervoid groupchat(int clientfd, string str)&#123;    int idx &#x3D; str.find(&quot;:&quot;);    if (idx &#x3D;&#x3D; -1)    &#123;        cerr &lt;&lt; &quot;groupchat command invalid!&quot; &lt;&lt; endl;        return;    &#125;    int groupid &#x3D; atoi(str.substr(0, idx).c_str());    string message &#x3D; str.substr(idx + 1, str.size() - idx);    json js;    js[&quot;msgid&quot;] &#x3D; GROUP_CHAT_MSG;    js[&quot;id&quot;] &#x3D; g_currentUser.getId();    js[&quot;name&quot;] &#x3D; g_currentUser.getName();    js[&quot;groupid&quot;] &#x3D; groupid;    js[&quot;msg&quot;] &#x3D; message;    js[&quot;time&quot;] &#x3D; getCurrentTime();    string buffer &#x3D; js.dump();    int len &#x3D; send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0);    if (len &#x3D;&#x3D; -1)    &#123;        cerr &lt;&lt; &quot;send groupchat msg error:&quot; &lt;&lt; buffer &lt;&lt; endl;    &#125;&#125;</code></pre><p>实现群聊功能后，需要在接受线程实现解析返回的信息，并且输出。服务端在这里是直接将消息转发。所以如下实现：</p><pre class="language-c++" data-language="c++"><code class="language-c++">if (GROUP_CHAT_MSG &#x3D;&#x3D; msgtype)&#123;cout &lt;&lt; &quot;群消息[&quot; &lt;&lt; js[&quot;groupid&quot;] &lt;&lt; &quot;]:&quot; &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;            continue; &#125;</code></pre><p>当然离线消息同时也要输出群组消息.</p><pre class="language-c++" data-language="c++"><code class="language-c++">if (ONE_CHAT_MSG &#x3D;&#x3D; js[&quot;msgid&quot;].get&lt;int&gt;())                                &#123;                                    cout &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;                                &#125;else&#123;                                    cout &lt;&lt; &quot;群消息[&quot; &lt;&lt; js[&quot;groupid&quot;] &lt;&lt; &quot;]:&quot; &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;                                &#125;</code></pre><p>else部分即为离线群组消息。</p><h6 id="loginout功能实现："><a href="#loginout功能实现：" class="headerlink" title="loginout功能实现："></a>loginout功能实现：</h6><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;&quot;login out&quot; command handlervoid loginout(int clientfd, string str)&#123;    json js;    js[&quot;msgid&quot;]&#x3D;LOGINOUT_MSG;    js[&quot;id&quot;]&#x3D;g_currentUser.getId();    string buffer&#x3D;js.dump();    int len&#x3D;send(clientfd,buffer.c_str(),strlen(buffer.c_str())+1,0);    if(len&#x3D;&#x3D;-1)&#123;        cerr&lt;&lt;&quot;send loginout msg error:&quot;&lt;&lt;buffer&lt;&lt;endl;    &#125;else&#123;        isMainMenuRunning&#x3D;false;    &#125;&#125;</code></pre><p>首先这个函数实现需要在public.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">LOGINOUT_MSG,&#x2F;&#x2F;注销消息</code></pre><p>在服务器端做出对应的函数：（记得在构造函数注册注销业务）</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;处理注销业务void ChatService::loginout(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;    int userid&#x3D;js[&quot;id&quot;];    &#123;        lock_guard&lt;mutex&gt; lock(_connMutex);        auto it&#x3D;_userConnMap.find(userid);        if(it!&#x3D;_userConnMap.end())&#123;            _userConnMap.erase(it);        &#125;    &#125;    &#x2F;&#x2F;更新用户的状态信息    User user(userid,&quot;&quot;,&quot;&quot;,&quot;offline&quot;);    _userModel.updateState(user);&#125;</code></pre><p>将_userConnMap对应的id的连接删去，并且更新用户的状态。</p><p>isMainMenuRunning是一个全局变量，用来确保loginout后会回到首页。所以默认值为false。当进入主菜单界面时，变为true。这样mainMenu函数就会退出循环，运行结束，进入首页的循环。</p><p>当然这里就出现了一个问题就是loginoutr退出但是程序没有退出，很多全局变量还保留着上一次的值，这就会在输出这些变量时会把上一次登录的用户信息都输出。所以在登录成功时，记得将对应变量初始化清空，再进行赋值。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 记录当前登录用户的好友列表信息vector&lt;User&gt; g_currentUserFriendList;&#x2F;&#x2F; 记录当前登录用户的群组列表信息vector&lt;Group&gt; g_currentUserGroupList;</code></pre><p>这两个变量在登录成功后，会进行赋值，记得在赋值前，初始化，清空。</p><p>这里还有一个问题，每次登录成功都会创造一个线程，当我在loginout后再次登录，又创造了一个新线程。所以要保证只有一个线程实现接受。所以在登录成功部分修改：</p><pre class="language-c++" data-language="c++"><code class="language-c++"> &#x2F;&#x2F; 登录成功，启动接受线程负责接受数据 ,该线程只启动一次static int readthreadnumber&#x3D;0;if(readthreadnumber&#x3D;&#x3D;0)&#123;std::thread readTask(readTaskHandler, clientfd); &#x2F;&#x2F; 在Linux pthread_createreadTask.detach();readthreadnumber++;                               &#x2F;&#x2F; Linux pthread_detach&#125;</code></pre><h3 id="引入负载均衡器："><a href="#引入负载均衡器：" class="headerlink" title="引入负载均衡器："></a>引入负载均衡器：</h3><p>以上我们基本完成了客户端和服务端的开发，由于是一个聊天服务器，要考虑一台服务器同时可以多少用户在线。我借用muduo模型创建 1个主线程（accept连接）+ 4个子线程（处理连接和事件）总共 5个线程，用于服务端 I&#x2F;O。主线程用于 accept 新连接4 个 <code>EventLoop</code> 子线程处理客户端连接的 I&#x2F;O 事件（读写、消息分发等）</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设置线程数量_server.setThreadNum(4);</code></pre><h4 id="操作系统的限制"><a href="#操作系统的限制" class="headerlink" title="操作系统的限制"></a><strong>操作系统的限制</strong></h4><p>操作系统对单个进程的文件描述符数量有限制，每个客户端连接通常占用一个文件描述符（socket）。</p><ul><li><strong>Linux默认值</strong>（可以用 <code>ulimit -n</code> 查看）：通常是 <strong>1024</strong>，也就是说一个进程默认最多只能同时处理约1000个客户端连接。</li></ul><h4 id="实际可支持的并发连接数（估算）："><a href="#实际可支持的并发连接数（估算）：" class="headerlink" title="实际可支持的并发连接数（估算）："></a>实际可支持的并发连接数（估算）：</h4><table><thead><tr><th>类型</th><th>数量</th></tr></thead><tbody><tr><td>Idle连接（不活跃）</td><td>40,000 ~ 100,000（受内核和 FD 限制）</td></tr><tr><td>活跃连接（频繁收发消息）</td><td>10,000 ~ 20,000（实际取决于业务逻辑复杂度）</td></tr></tbody></table><p>这是<strong>单进程、多线程、epoll</strong> 架构下的典型并发能力，非常高效。</p><h4 id="什么是-Idle连接（不活跃连接）？"><a href="#什么是-Idle连接（不活跃连接）？" class="headerlink" title="什么是 Idle连接（不活跃连接）？"></a>什么是 <strong>Idle连接（不活跃连接）</strong>？</h4><p><strong>Idle（空闲）连接</strong> 是指：</p><p>客户端虽然 <strong>已经建立了连接</strong>，但 <strong>长时间没有发送或接收任何数据</strong>，也就是说：</p><ul><li><strong>连接处于打开状态（TCP连接存在）</strong></li><li>但没有发生 <strong>读写事件</strong></li><li>占用资源极少（仅占用文件描述符、少量内存）</li></ul><h4 id="为什么要区分-Idle-与-活跃连接？"><a href="#为什么要区分-Idle-与-活跃连接？" class="headerlink" title="为什么要区分 Idle 与 活跃连接？"></a>为什么要区分 Idle 与 活跃连接？</h4><ol><li><strong>资源占用不同</strong></li></ol><ul><li>Idle 连接不产生消息，不触发回调，服务器处理负担极低</li><li>活跃连接需要处理消息、业务逻辑，负担高</li></ul><ol start="2"><li><strong>并发能力的评估</strong></li></ol><ul><li>很多高并发服务器说能支持“10万连接”，指的是 <strong>Idle连接数量</strong></li><li>真正活跃（消息频繁）的连接，一般几千~上万就会达到服务器上限</li></ul><ol start="3"><li><strong>是否需要清理 Idle连接</strong></li></ol><ul><li>有些服务器会设置 <strong>心跳&#x2F;超时机制</strong>，长时间不活跃的连接会被断开，防止资源泄漏或恶意占用</li></ul><p>我们还要提高并发量，就要引入<strong>负载均衡器</strong>的概念。</p><h4 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h4><p><strong>负载均衡器（Load Balancer）</strong> 是一个把大量客户端请求 <strong>均匀分发</strong> 给多个后端服务器的组件，以提高系统的 <strong>吞吐能力、稳定性和可用性</strong>。</p><h5 id="为什么需要它？"><a href="#为什么需要它？" class="headerlink" title="为什么需要它？"></a>为什么需要它？</h5><p>在高并发系统中，如果所有请求都打到一个服务器上，容易导致：</p><ul><li>响应慢</li><li>连接超时</li><li>服务宕机</li></ul><p>使用负载均衡器可以：</p><ul><li><strong>水平扩展</strong>服务器（多个 Muduo 实例）</li><li><strong>分担压力</strong></li><li>实现高可用（某个服务器挂了不影响整体）</li></ul><h5 id="按协议层划分（TCP-HTTP）"><a href="#按协议层划分（TCP-HTTP）" class="headerlink" title="按协议层划分（TCP&#x2F;HTTP）"></a>按协议层划分（TCP&#x2F;HTTP）</h5><table><thead><tr><th>类型</th><th>层级</th><th>说明</th><th>常用代表</th></tr></thead><tbody><tr><td><strong>四层负载均衡（L4）</strong></td><td>TCP&#x2F;UDP</td><td>基于 IP、端口、协议</td><td>LVS、HAProxy、Nginx Stream、Keepalived</td></tr><tr><td><strong>七层负载均衡（L7）</strong></td><td>HTTP、HTTPS</td><td>基于 URL、Header、Cookie</td><td>Nginx、HAProxy、Traefik、Envoy、Kong</td></tr></tbody></table><h5 id="常见软件负载均衡器对比"><a href="#常见软件负载均衡器对比" class="headerlink" title="常见软件负载均衡器对比"></a>常见软件负载均衡器对比</h5><table><thead><tr><th>名称</th><th>协议支持</th><th>类型</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td><strong>LVS</strong></td><td>L4 (TCP&#x2F;UDP)</td><td>内核模块</td><td>性能极高、稳定、复杂配置</td><td>超高并发、基础设施层</td></tr><tr><td><strong>HAProxy</strong></td><td>L4 + L7</td><td>用户态</td><td>灵活、高性能、支持健康检查、监控完备</td><td>Web、API 网关、数据库代理</td></tr><tr><td><strong>Nginx</strong></td><td>L7 (也支持 L4)</td><td>用户态</td><td>配置简单，静态资源支持好</td><td>Web服务器、轻量级反代</td></tr><tr><td><strong>Traefik</strong></td><td>L7</td><td>云原生</td><td>自动发现服务（K8s、Docker）、面向微服务</td><td>DevOps、容器化</td></tr><tr><td><strong>Envoy</strong></td><td>L4 + L7</td><td>云原生</td><td>微服务架构核心组件、支持 gRPC、动态配置</td><td>Istio、Service Mesh</td></tr><tr><td><strong>Kong</strong></td><td>L7 API网关</td><td>插件丰富</td><td>基于 Nginx，提供限流、安全等扩展能力</td><td>企业 API 管理</td></tr><tr><td><strong>Keepalived</strong></td><td>L4</td><td>高可用</td><td>常与 LVS 配合，提供主备切换</td><td>双主结构、高可用架构</td></tr><tr><td><strong>OpenResty</strong></td><td>L7</td><td>基于 Nginx</td><td>支持 Lua，适合做复杂业务逻辑</td><td>高定制需求</td></tr><tr><td><strong>Caddy</strong></td><td>L7</td><td>自动 TLS</td><td>HTTPS 自动配置简单</td><td>个人、低门槛网站部署</td></tr></tbody></table><p>我们这里要使用的是Nginx 的 TCP 负载均衡模块（即 stream 模块）</p><p><img src="/2025/06/02/C++-chatserver/2.png" alt="2" loading="lazy"></p><p>这是负载均衡器在本项目发挥的作用图。</p><p>Nginx 默认是 HTTP 层负载均衡（七层），但它的 <strong><code>stream</code> 模块</strong> 支持四层（TCP&#x2F;UDP）负载均衡，非常适合。</p><p>说白了，通过多台后台服务器提高并发量。但也面临着如何处理跨服务器通信的问题。</p><h3 id="引入服务器中间件（redis）"><a href="#引入服务器中间件（redis）" class="headerlink" title="引入服务器中间件（redis）"></a>引入服务器中间件（redis）</h3><p><strong>Redis（Remote Dictionary Server）</strong> 是一个<strong>开源</strong>的、基于内存的<strong>键值对存储（Key-Value Store）数据库</strong>，支持丰富的数据结构，<strong>读写极快</strong>，非常适合用作缓存、中间件、消息队列等。</p><p>引入redis是要解决如果一个用户要和另一个用户通信，但是另一个用户在另一台服务器上，我们能从数据库中看到他在线，但是我们不能获取他的连接，所以引入中间件。这样就可以解决跨服务器通信的问题。</p><p>这里是redis在本项目的作用图：</p><p><img src="/2025/06/02/C++-chatserver/3.png" alt="3" loading="lazy"></p><h3 id="nginx项目配置"><a href="#nginx项目配置" class="headerlink" title="nginx项目配置"></a>nginx项目配置</h3><p>nginx配置编译好后，去修改&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf中修改nginx.conf文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#nginx tcp loadbalance config</span>stream <span class="token punctuation">&#123;</span>        upstream MyServer <span class="token punctuation">&#123;</span>                server <span class="token number">127.0</span>.0.1:6000 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">max_fails</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span>30s<span class="token punctuation">;</span>                server <span class="token number">127.0</span>.0.1:6002 <span class="token assign-left variable">weight</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">max_fails</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">fail_timeout</span><span class="token operator">=</span>30s<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        server <span class="token punctuation">&#123;</span>                proxy_connect_timeout 1s<span class="token punctuation">;</span>                <span class="token comment">#proxy_timeout 3s; # 可以根据需要开启，控制代理的读写超时</span>                listen <span class="token number">8000</span><span class="token punctuation">;</span>                proxy_pass MyServer<span class="token punctuation">;</span>                tcp_nodelay on<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span></code></pre><p>在events和http领域之间加入上述代码。这一段代码就是加入**<code>stream</code> 模块** 。</p><p>说明</p><ul><li>**stream{}**：用于 TCP&#x2F;UDP 负载均衡。</li><li><strong>upstream MyServer</strong>：定义了两个后端服务器，权重相等。</li><li><strong>max_fails&#x3D;3 fail_timeout&#x3D;30s</strong>：3次失败后，30秒内认为该节点不可用。</li><li><strong>listen 8000</strong>：监听本机 8000 端口。</li><li><strong>proxy_connect_timeout 1s</strong>：连接超时时间为1秒。</li><li><strong>proxy_pass MyServer</strong>：请求转发到 MyServer 负载均衡组。</li><li><strong>tcp_nodelay on</strong>：开启 TCP_NODELAY，减少延迟。</li></ul><p>这样就实现了多个客户端只需要向一个ip+port就可以。通过nginx对多台服务器管理，这样就增加了聊天服务器的并发量。当然跨服务器通信这一问题还没有解决。</p><h3 id="Redis项目配置"><a href="#Redis项目配置" class="headerlink" title="Redis项目配置"></a>Redis项目配置</h3><p>首先在include和src建立redis文件夹，在对应的文件夹添加redis.hpp和redis.cpp。记得更新CMakeLists.txt文件。这里调用了hiredis库。hiredis是c++使用redis封装的库。</p><p>redis.hpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#ifndef REDIS_H#define REDIS_H#include &lt;hiredis&#x2F;hiredis.h&gt;#include &lt;thread&gt;#include &lt;functional&gt;using namespace std;class Redis&#123;    public:        Redis();        ~Redis();        &#x2F;&#x2F;连接redis服务器        bool connect();        &#x2F;&#x2F;向redis指定的通道channel发布消息        bool publish(int channel,string message);        &#x2F;&#x2F;向redis指定的通道subscribe订阅消息        bool subscribe(int channel);        &#x2F;&#x2F;向redis指定的通道unsubscribe取消订阅消息        bool unsubscribe(int channel);        &#x2F;&#x2F;在独立线程中接受订阅通道中的消息        void observer_channel_message();        &#x2F;&#x2F;初始化向业务层上报通道消息的回调对象        void init_notify_handler(function&lt;void(int,string)&gt; fn);    private:        &#x2F;&#x2F;hiredis同步上下文对象，负责publish消息        redisContext *_publish_context;        &#x2F;&#x2F;hiredis同步上下文对象，负责subscribe消息        redisContext * _subscribe_context;        &#x2F;&#x2F;回调操作，收到订阅的消息，给service层上报        function&lt;void (int,string)&gt; _notify_message_handler;&#125;;#endif</code></pre><p>redis.cpp</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&quot;redis.hpp&quot;#include&lt;iostream&gt;using namespace std;Redis::Redis():_publish_context(nullptr),_subscribe_context(nullptr)&#123;&#125;Redis::~Redis()&#123;    if(_publish_context!&#x3D;nullptr)&#123;        redisFree(_publish_context);    &#125;    if(_subscribe_context!&#x3D;nullptr)&#123;        redisFree(_subscribe_context);    &#125;&#125;bool Redis::connect()&#123;    &#x2F;&#x2F;负责publish发布消息的上下文连接    _publish_context&#x3D;redisConnect(&quot;127.0.0.1&quot;,6379);    if(_publish_context&#x3D;&#x3D;nullptr)&#123;        cerr&lt;&lt; &quot;connect redis failed!&quot;&lt;&lt;endl;        return false;    &#125;    &#x2F;&#x2F;负责subscribe订阅消息的上下文连接    _subscribe_context&#x3D;redisConnect(&quot;127.0.0.1&quot;,6379);    if(_subscribe_context&#x3D;&#x3D;nullptr)&#123;        cerr&lt;&lt; &quot;connect redis failed!&quot;&lt;&lt;endl;        return false;    &#125;    &#x2F;&#x2F;在单独的线程中，监听通道上的事件，有消息给业务层进行上报    thread t([&amp;]()&#123;        observer_channel_message();    &#125;);    t.detach();    cout&lt;&lt;&quot;connect redis_server success!&quot;&lt;&lt;endl;    return true;&#125;&#x2F;&#x2F;向redis指定的通道channel发布消息bool Redis::publish(int channel,string message)&#123;    redisReply *reply&#x3D;(redisReply*)redisCommand(_publish_context,&quot;PUBLISH %d %s&quot;,channel,message.c_str());    if(reply&#x3D;&#x3D;nullptr)&#123;        cerr&lt;&lt;&quot;publish command failed&quot;&lt;&lt;endl;        return false;    &#125;    freeReplyObject(reply);    return true;&#125;&#x2F;&#x2F;向redis指定的通道subscribe订阅消息bool Redis::subscribe(int channel)&#123;    &#x2F;&#x2F;subscribe命令本身会造成线程阻塞等待通道里面发生消息，这里只做订阅通道，不接受消息    &#x2F;&#x2F;通道消息的接受专门在observer_channel_message函数中的独立线程中进行    &#x2F;&#x2F;只负责发送命令，不阻塞接受redis server响应消息，否则和notifyMsg线程抢占响应资源。    if(REDIS_ERR&#x3D;&#x3D;redisAppendCommand(this-&gt;_subscribe_context,&quot;SUBSCRIBE %d&quot;,channel))&#123;        cerr&lt;&lt;&quot;subscribe command failed!&quot;&lt;&lt;endl;        return false;    &#125;    &#x2F;&#x2F;redisBufferWrite 可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1）    int done&#x3D;0;    while(!done)&#123;        if(REDIS_ERR&#x3D;&#x3D;redisBufferWrite(this-&gt;_subscribe_context,&amp;done))&#123;            cerr&lt;&lt;&quot;subscribe command failed!&quot;&lt;&lt;endl;            return false;        &#125;    &#125;    &#x2F;&#x2F;redisGetReply不执行    return true;&#125;&#x2F;&#x2F;向redis指定的通道unsubscribe取消订阅消息bool Redis::unsubscribe(int channel)&#123;    if(REDIS_ERR&#x3D;&#x3D;redisAppendCommand(this-&gt;_subscribe_context,&quot;UNSUBSCRIBE %d&quot;,channel))&#123;        cerr&lt;&lt;&quot;unsubscribe command failed!&quot;&lt;&lt;endl;        return false;    &#125;    &#x2F;&#x2F;redisBufferWrite 可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1）    int done&#x3D;0;    while(!done)&#123;        if(REDIS_ERR&#x3D;&#x3D;redisBufferWrite(this-&gt;_subscribe_context,&amp;done))&#123;            cerr&lt;&lt;&quot;unsubscribe command failed!&quot;&lt;&lt;endl;            return false;        &#125;    &#125;    return true;&#125;&#x2F;&#x2F;在独立线程中接受订阅通道中的消息void Redis::observer_channel_message()&#123;    redisReply *reply&#x3D;nullptr;    while(REDIS_OK&#x3D;&#x3D;redisGetReply(this-&gt;_subscribe_context,(void**)&amp;reply))&#123;        &#x2F;&#x2F;订阅收到的消息是一个带三元组的数组        if(reply!&#x3D;nullptr&amp;&amp;reply-&gt;element[2]!&#x3D;nullptr&amp;&amp;reply-&gt;element[2]-&gt;str!&#x3D;nullptr)&#123;            &#x2F;&#x2F;给业务层上报通道上发生的消息            _notify_message_handler(atoi(reply-&gt;element[1]-&gt;str),reply-&gt;element[2]-&gt;str);        &#125;        freeReplyObject(reply);    &#125;    cerr&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;observer_channel_message quit &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;&#125;&#x2F;&#x2F;初始化向业务层上报通道消息的回调对象void Redis::init_notify_handler(function&lt;void(int,string)&gt; fn)&#123;    this-&gt;_notify_message_handler&#x3D;fn;&#125;</code></pre><p>这里需要注意的点就是关于订阅和发布，发布publish直接用redisCommand函数即可，因为这个命令直接执行本身不会堵塞（服务器会很快给出回复）。但是subscribe不一样，他直接执行会卡在那里，一直等待消息进入通道里（服务器不会很快回复）。所以我们这里使用redisAppendCommand<code>+</code>redisBufferWrite这两个函数一起，不用再等待响应。所以我们单开一个线程来接受通道里的消息。</p><p>总结对比</p><table><thead><tr><th>功能</th><th><code>redisCommand</code></th><th><code>redisAppendCommand</code> + <code>redisBufferWrite</code></th></tr></thead><tbody><tr><td>用法</td><td>直接发送+等待响应</td><td>仅发送命令到 Redis，不等待响应</td></tr><tr><td>是否阻塞</td><td>会阻塞直到响应</td><td>不会阻塞</td></tr><tr><td>适用场景</td><td>普通命令（GET&#x2F;SET）</td><td>发布订阅等需要后台线程响应的命令</td></tr></tbody></table><p>所以我们把监听逻辑放到线程里。</p><p>注意：</p><p>Redis 的订阅-发布机制设计：</p><ul><li><strong>订阅连接会被阻塞监听消息，不允许执行其他命令。</strong></li><li>如果同一个连接既用来订阅又用来发布，订阅时会阻塞导致发布失败或延迟。</li><li>所以一般建议<strong>发布和订阅使用独立的连接</strong>，保证各自的流畅性和响应效率。</li></ul><h3 id="解决跨服务器通信问题"><a href="#解决跨服务器通信问题" class="headerlink" title="解决跨服务器通信问题"></a>解决跨服务器通信问题</h3><p>我们已经配置好redis,并且封装了对应的redis类。接下来在业务类实现加入redis。</p><p>在对应的ChatService类声明私有变量。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;redis操作对象 Redis _redis;</code></pre><p>在ChatService类的构造函数，实现redis连接并且加入回调函数。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;连接redis服务器if(_redis.connect())&#123;&#x2F;&#x2F;设置上报消息的回调_redis.init_notify_handler(std::bind(&amp;ChatService::handleRedisSubscribeMessage,this,_1,_2));&#125;</code></pre><p>handleRedisSubscribeMessage函数是从redis消息队列中获取订阅的消息（在另一个线程执行）</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;从redis消息队列中获取订阅的消息void ChatService::handleRedisSubscribeMessage(int userid,string msg)&#123;    lock_guard&lt;mutex&gt; lock(_connMutex);    auto it&#x3D;_userConnMap.find(userid);    if(it!&#x3D;_userConnMap.end())&#123;        it-&gt;second-&gt;send(msg);        return;    &#125;    &#x2F;&#x2F;存储该用户的离线消息    _offlineMsgModel.insert(userid,msg);&#125;</code></pre><p>从redis返回的userid和message是当前服务器订阅的通道返回的消息，所以当前userid一定在当前服务器的_userConnMap中，当然也存在一种情况，发消息给redis时，还在线，redis传给对应的服务器时，该用户下线了，所以也要存储该用户的离线消息。</p><p>接着还要在登录功能和注销功能做修改</p><p>在登录成功后：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;id用户登录成功后，向redis订阅channel(id)_redis.subscribe(id);</code></pre><p>要向redis订阅消息，有向当前用户发送的消息会向在redis通道存储，之后会向当前用户输送。</p><p>在注销（退出）后：</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;用户注销，相当于下线，在redis中取消订阅通道_redis.unsubscribe(userid);</code></pre><p>关闭掉订阅通道。当然还有客户端异常退出时，也要关闭订阅</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;客户端关闭，相当于下线，在redis中取消订阅通道_redis.unsubscribe(user.getId());</code></pre><p>最后对一对一聊天和群聊功能做修改。</p><p>一对一聊天，当查到目标用户没有在_userConnMap中，说明目标用户不在当前服务器上或者不在线，所以接下来去数据库查看目标用户是否在线，若在线，则向redis对应的通道发布消息。不在线则存储连线消息。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;查询toid是否在线（可能在其他服务器上）User user&#x3D;_userModel.query(toid);if(user.getState()&#x3D;&#x3D;&quot;online&quot;)&#123;_redis.publish(toid,js.dump());return;&#125;</code></pre><p>群聊，当查到目标用户没有在_userConnMap中，说明目标用户不在当前服务器上或者不在线，所以接下来去数据库查看目标用户是否在线，若在线，则向redis对应的通道发布消息。不在线则存储连线消息。</p><pre class="language-c++" data-language="c++"><code class="language-c++">auto it&#x3D;_userConnMap.find(id);if(it!&#x3D;_userConnMap.end())&#123;            &#x2F;&#x2F;转发群消息            it-&gt;second-&gt;send(js.dump());        &#125;else&#123;            &#x2F;&#x2F;查询id是否在线            User user&#x3D;_userModel.query(id);            if(user.getState()&#x3D;&#x3D;&quot;online&quot;)&#123;                _redis.publish(id,js.dump());            &#125;else&#123;                &#x2F;&#x2F;存储离线群消息                _offlineMsgModel.insert(id,js.dump());            &#125;                    &#125;</code></pre><p>至此解决跨服务器通信问题。</p><h3 id="解决登录注销后再次登录会阻塞的问题"><a href="#解决登录注销后再次登录会阻塞的问题" class="headerlink" title="解决登录注销后再次登录会阻塞的问题"></a>解决登录注销后再次登录会阻塞的问题</h3><p>在登录后注销退出后，在进行登录会一直卡住，没有关于用户的信息展示和指令展示，核查发现是主线程在执行recv,接受线程也在recv同一个socket,所以这里我们引入</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 用于读写线程的通信sem_t rwem;&#x2F;&#x2F; 记录登录状态atomic_bool g_isLoginSuccess&#123;false&#125;;</code></pre><p><code>sem_t</code> 是 POSIX 信号量类型（semaphore），用于线程之间同步或通信。</p><p><code>tomic_bool</code> 是 C++ 的原子变量类型之一，用于线程安全地读写布尔值，防止并发条件竞争。</p><p>一、信号量 <code>sem_t</code> 的初始化</p><p>在使用前，<strong>必须初始化</strong>。常用的是 <code>sem_init</code>：</p><pre class="language-c++" data-language="c++"><code class="language-c++">sem_t rwem;sem_init(&amp;rwem, 0, 0);</code></pre><p>参数解释：</p><pre class="language-c++" data-language="c++"><code class="language-c++">int sem_init(sem_t *sem, int pshared, unsigned int value);</code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>sem</code></td><td>指向信号量的指针</td></tr><tr><td><code>pshared=0</code></td><td>表示是线程之间使用（同一进程）</td></tr><tr><td><code>value=0</code></td><td>初始值为 0（表示“没有资源”）</td></tr></tbody></table><p> 通常设为 0，表示线程必须等待 <code>sem_post()</code> 才能继续。</p><p>二、sem_post 和 sem_wait 的配合逻辑</p><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td><code>sem_post(&amp;rwem)</code></td><td>给信号量加1，表示“有资源了”或“可以继续了”</td></tr><tr><td><code>sem_wait(&amp;rwem)</code></td><td>阻塞等待信号量值&gt;0，然后减1，表示“我来用这个资源”</td></tr></tbody></table><p>总体步骤：</p><table><thead><tr><th>步骤</th><th>函数</th><th>示例</th></tr></thead><tbody><tr><td>初始化</td><td><code>sem_init(&amp;rwem, 0, 0);</code></td><td>启动阶段</td></tr><tr><td>发送信号（通知）</td><td><code>sem_post(&amp;rwem);</code></td><td>接收线程收到数据时</td></tr><tr><td>等待信号</td><td><code>sem_wait(&amp;rwem);</code></td><td>处理线程等待数据</td></tr><tr><td>销毁</td><td><code>sem_destroy(&amp;rwem);</code></td><td>程序结束或退出登录时</td></tr></tbody></table><p>由于登录成功和注册成功的消息的收取是在主线程进行的，其他信息的收取是在另一个进程中，所以我要修改代码，把登录和注册的回复消息由接受进程收取。</p><p>首先在客户端main函数中连接服务器端成功后，插入</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 初始化读写线程通信用的信号量sem_init(&amp;rwem, 0, 0);&#x2F;&#x2F; 连接服务器成功，启动接受线程std::thread readTask(readTaskHandler, clientfd); &#x2F;&#x2F; 在Linux pthread_createreadTask.detach();</code></pre><p>在登录时向服务端发送登录消息后，插入</p><pre class="language-c++" data-language="c++"><code class="language-c++">sem_wait(&amp;rwem); &#x2F;&#x2F; 等待信号量，由子线程处理完登录的响应消息后，通知这里g_isLoginSuccess &#x3D; false;</code></pre><p>sem_wait(&amp;rwem); 是为了<strong>接受线程</strong>消息处理好后会sem_post(&amp;rewm)，主线程接受到信号进行往下走。</p><p>g_isLoginSuccess时为了确认登录是否成功，如不成功，就进入首页面，成功进主菜单页面。</p><pre class="language-c++" data-language="c++"><code class="language-c++">if (g_isLoginSuccess)            &#123;                &#x2F;&#x2F; 进入聊天主菜单页面                isMainMenuRunning &#x3D; true;                mainMenu(clientfd);            &#125;</code></pre><p>注册就只需要等待信号就可以了</p><pre class="language-c++" data-language="c++"><code class="language-c++">sem_wait(&amp;rwem); &#x2F;&#x2F; 等待信号量，由子线程处理完注册的响应消息后，通知这里</code></pre><p>在退出业务记得把信号回收</p><pre class="language-c++" data-language="c++"><code class="language-c++">sem_destroy(&amp;rwem);</code></pre><p>在接受线程里</p><pre class="language-c++" data-language="c++"><code class="language-c++">if (LOGIN_MSG_ACK &#x3D;&#x3D; msgtype)        &#123;            doLoginResponse(js); &#x2F;&#x2F; 处理登录响应的业务逻辑            sem_post(&amp;rwem);     &#x2F;&#x2F; 通知主线程，登录结果处理完成            continue;        &#125;        if (REG_MSG_ACK &#x3D;&#x3D; msgtype)        &#123;            doRegResponse(js);            sem_post(&amp;rwem); &#x2F;&#x2F; 通知主线程，注册结果处理完成            continue;        &#125;</code></pre><p>当收到对应业务的消息，就执行对应逻辑。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 处理登录响应的业务void doLoginResponse(json &amp;responsejs)&#123;    if (responsejs[&quot;errno&quot;] !&#x3D; 0)    &#123;        cerr &lt;&lt; responsejs[&quot;errmsg&quot;] &lt;&lt; endl;        g_isLoginSuccess &#x3D; false;    &#125;    else    &#123; &#x2F;&#x2F; 登录成功        &#x2F;&#x2F; 记录当前用户的id和name        g_currentUser.setId(responsejs[&quot;id&quot;]);        g_currentUser.setName(responsejs[&quot;name&quot;]);        &#x2F;&#x2F; 记录当前用户的好友列表信息        if (responsejs.contains(&quot;friends&quot;))        &#123;            &#x2F;&#x2F; 初始化            g_currentUserFriendList.clear();            &#x2F;&#x2F; 看是否包含friends这个键            vector&lt;string&gt; vec &#x3D; responsejs[&quot;friends&quot;];            for (string &amp;str : vec)            &#123;                json js &#x3D; json::parse(str);                User user;                user.setId(js[&quot;id&quot;]);                user.setName(js[&quot;name&quot;]);                user.setState(js[&quot;state&quot;]);                g_currentUserFriendList.push_back(user);            &#125;        &#125;        &#x2F;&#x2F; 记录当前用户的群组列表信息        if (responsejs.contains(&quot;groups&quot;))        &#123;            &#x2F;&#x2F; 初始化            g_currentUserGroupList.clear();            vector&lt;string&gt; vec1 &#x3D; responsejs[&quot;groups&quot;];            for (string &amp;groupstr : vec1)            &#123;                json grpjs &#x3D; json::parse(groupstr);                Group group;                group.setId(grpjs[&quot;id&quot;]);                group.setName(grpjs[&quot;groupname&quot;]);                group.setDesc(grpjs[&quot;groupdesc&quot;]);                vector&lt;string&gt; vec2 &#x3D; grpjs[&quot;users&quot;];                for (string &amp;userstr : vec2)                &#123;                    GroupUser user;                    json js &#x3D; json::parse(userstr);                    user.setId(js[&quot;id&quot;]);                    user.setName(js[&quot;name&quot;]);                    user.setState(js[&quot;state&quot;]);                    user.setRole(js[&quot;role&quot;]);                    group.getUsers().push_back(user);                &#125;                g_currentUserGroupList.push_back(group);            &#125;        &#125;        &#x2F;&#x2F; 显示登录用户的基本信息        showCurrentUserData();        &#x2F;&#x2F; 显示当前用户的离线消息 个人聊天消息或者群组消息        if (responsejs.contains(&quot;offlinemsg&quot;))        &#123;            vector&lt;string&gt; vec &#x3D; responsejs[&quot;offlinemsg&quot;];            for (string &amp;str : vec)            &#123;                json js &#x3D; json::parse(str);                &#x2F;&#x2F; time +[id]+name+&quot;said: &quot;+xxx                if (ONE_CHAT_MSG &#x3D;&#x3D; js[&quot;msgid&quot;].get&lt;int&gt;())                &#123;                    cout &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;                &#125;                else                &#123;                    cout &lt;&lt; &quot;群消息[&quot; &lt;&lt; js[&quot;groupid&quot;] &lt;&lt; &quot;]:&quot; &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;                &#125;            &#125;        &#125;        g_isLoginSuccess &#x3D; true;    &#125;&#125;</code></pre><p>当然，在登陆成功后记得把g_isLoginSuccess置为true。</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 处理注册响应的业务void doRegResponse(json &amp;responsejs)&#123;    if (0 !&#x3D; responsejs[&quot;errno&quot;])    &#123; &#x2F;&#x2F; 注册失败        cerr &lt;&lt;&quot;name is already exist,register error!&quot; &lt;&lt; endl;    &#125;    else    &#123; &#x2F;&#x2F; 注册成功        cout &lt;&lt;&quot;name register success,userid is &quot; &lt;&lt; responsejs[&quot;id&quot;] &lt;&lt; &quot;, do not forget it!&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><p>这样就把这个问题解决了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;json学习&quot;&gt;&lt;a href=&quot;#json学习&quot; class=&quot;headerlink&quot; title=&quot;json学习&quot;&gt;&lt;/a&gt;json学习&lt;/h2&gt;&lt;pre class=&quot;language-cpp&quot; data-language=&quot;cpp&quot;&gt;&lt;code class</summary>
      
    
    
    
    <category term="项目" scheme="http://yustonerain.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="C++" scheme="http://yustonerain.top/tags/C/"/>
    
  </entry>
  
</feed>
