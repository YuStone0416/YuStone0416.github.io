---
title: Linux网络编程
date: 2025-07-16 22:54:16
tags: Linux
urlname: Linux-Network Programming
categories: 计算机学习
updated: 2025-07-16 21:26:16
---

## 网络基础

### **mac地址**（6个字节 48位）

标记网卡的id,；理论上这个id全球唯一

**mac地址一般用来标识主机的id,这个id是物理地址，不会改变。**

### **ip地址，ipv4(4个字节，32位)，ipv6(16个字节，128位)**

IP地址是标识主机的id,这个id是虚拟的，会改变。

一个IP将其分为子网id和主机id

**子网id和主机id需要和子网掩码一起来看，**

![1](1.png)

ping命令用来测试两台主机的网络联通性（windows和Linux都适用）。

Linux下设置ip命令

```bash
ifconfig ens33 192.168.131.133 netmask 255.255.255.0
```

### **桥接模式（Bridged Networking）**

桥接模式是将虚拟机/容器的网络**桥接到物理网卡**上，使其就像是局域网中的一台独立主机。

工作原理：

虚拟机通过虚拟网桥（Bridge）连接到宿主机的物理网卡，相当于直接插入交换机，与宿主机处于**同一物理局域网**中。

网络特点：

- 虚拟机可获得**与宿主机同网段的IP地址**（例如通过 DHCP）
- 可以被局域网中其他设备访问（可 ping 通）
- 能访问局域网和外网

优点：

- 网络透明，虚拟机像一台真实的独立主机
- 易于与其他局域网设备通信

缺点：

- 需要宿主网络支持（如局域网允许多个 IP）
- 有可能增加网络冲突和安全风险

### **NAT 模式（网络地址转换）**

NAT 模式是虚拟机/容器通过宿主机的网络连接上网，**共享宿主机的 IP**。

工作原理：

宿主机充当“路由器”，将虚拟机的私有 IP 转换为宿主的公网 IP，进行地址转换。

网络特点：

- 虚拟机使用**私有 IP 地址（如 192.168.xx.xx）**
- 能访问外网，但外部主机**无法主动访问虚拟机**
- 类似家庭内的多台设备通过路由器上网

优点：

- 设置简单，几乎无须额外配置
- 安全性高，外部无法直接访问虚拟机

缺点：

- 虚拟机不能被外部主机主动访问（除非端口转发）
- 网络透明度低，不适合复杂网络测试

### 端口（port）

**作用：用来标识应用程序（进程）**

**port:两个字节 0-65535**

**0-1023 知名端口**

**自定义端口1024-65535（避免冲突）**

**一个应用可以有多个端口，一个端口只能有一个应用程序。**

### OSI七层模型

为了使各种不同的计算机之间可以互联，ARPANet指定了一套计算机通信协议，即TCP/IP协议（族）；

为了减少协议设计的复杂性，大多数网络模型均采用分层的方式来组织。

每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽。

**物理层：双绞线（网线）接口类型，光纤的传输速率等等**

**数据链路层：mac 负责收发数据**

**网络层：ip 给两台主机提供路径选择。**

**传输层：port 区分数据递送到那个应用程序。**

**会话层：建立连接**

**表示层：解码**

**应用层：应用程序**

![2](2.png)

### TCP/IP四层模型

![3](3.png)

### 协议

**规定了数据传输的方式和格式**

**这里主要按照TCP/IP四层模型有的协议。**

**应用层协议：**

**FTP:文件传输协议**

**HTTP:超文本传输协议**

**NFS:网络文件系统**

**传输层协议：**

**TCP:传输控制协议** 头部20个字节

**UDP:用户数据报协议** 头部8个字节

**网络层：**

**IP:英特网互联协议** 头部20个字节

**ICMP:英特网控制报文协议 ping命令就是这个协议**
**IGMP：英特网组管理协议**

**链路层：**

**ARP:地址解析协议 通过ip找mac地址**

**RARP:反向地址解析协议 通过mac找ip**

**硬件接口：mac头** 头部14个字节

目的mac地址为ff:ff:ff:ff:ff:ff 局域网内其他主机无条件接受。（常在ARP协议上使用）

![4](4.png)

### 网络设计模式

**B/S browser/server**

**C/S client/server**

C/S 性能较好 客户端容易篡改数据 开发周期较长

B/S 性能低 客户端安全 开发周期短

### TCP三次握手

tcp建立连接的过程 **SYN是请求建立连接的标识，ACK就是确认。**

![9](9.png)

**mss:最大报文长度，一般出现在三次握手的前两次，用来告知对方传送数据的最大长度。**

**MTU:最大传输单元 由网卡限制**

### TCP四次挥手

tcp断开连接，这个哪一方发起断开都可以，就以客户端申请断开为例子，三次握手一定是客户端发起。

就是两端的某一段调用了close函数。

**FIN是请求断开连接的标识**

![10](10.png)

### 滑动窗口

**TCP报头上有一个窗口尺寸的标识，这个是说接收方告知发送方：我的接收缓冲区还能接收多少字节。**

**在ACK标识回复时会带有win剩余多少空间。**

**这样发送方就会发送以避免拥堵，因为知道接收方还剩下多少空间，接收方是把当前接收缓冲区的一块数据提取出来，才会回复给发送方ACK携带当前缓冲区大小告知对方。**

### TCP状态转换

![11](11.png)

如果想要查看TCP应用的状态

```bash
netstat -anp | grep 8000(端口)
```

### 半关闭

**主动方在FIN_WAIT_2状态之后，主动方不可以在应用层发送数据了，但是应用层还可以接受数据，这个状态叫半关闭。**

**有人就有疑惑了，那为什么在TIME_WAIT状态还能发，因为它发的是ACK,主动方不可以在应用层发送数据了，指的是应用层的协议不可以接受了，但是在底层，传输层TCP协议还是可以发出，所以ACK是可以发的**。

```c
#include <sys/socket.h>
int shutdown(int sockfd, int how);
参数：
    sockfd:需要关闭的socket的描述符
    how:允许为shutdown操作选择以下几种方式：
        SHUT_RD(0):关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被丢弃。
        SHUT_WR(1):关闭sockfd上的写功能，此选项将不允许sockfd进行写操作。进程不能再对此套接字发出写操作
        SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是SHUT_RD,然后是SHUT_WR。
```

### TCP异常断开

#### 心跳包(TCP 的 keepalive 机制)

**SO_KEEPALIVE保持连接检测对方主机是否崩溃，避免服务器永远阻塞于TCP连接的输入。设置该选项后，如果两小时内在此套接口的任一方向都没有数据交换，TCP会自动给对方发一个保持存活探测分节，这是一个对方必须响应的TCP分节。他会导致以下三种情况：**

1. **对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个。**
2. **对方已崩溃且已重新启动：以RST响应。套接口的待处理错误设置为ECONNRESET,套接口本身被关闭。**
3. **对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT,套接口本身就关闭。若ICMP错误是host unreachable(主机不可达),说明对方主机没有崩溃，但是不可达，这种情况下待处理错误设置为EHOSTUNREACH.**

**所以我们可以设置SO_KEEPALIVE属性使得我们在两小时后发现对方的TCP连接是否依然存在。**

```c
keepAlive=1;
setsockopt(listenfd,SOL_SOCKET,SO_KEEPALIVE,(void *)&keepAlive,sizeof(keepAlive));
```

**但是说真的，这个函数两小时检测一次，对于现在来说，有点太长了，所以可以自己在应用层写对应的心跳包。**

心跳包：最小粒度，携带的数据部分一定要少。

乒乓包：携带比较多的数据的心跳包。

### 端口复用

端口重新启用，谁最后启用的端口谁用。前面启用的作废，用不了了。为什莫需要端口复用呢，在server的TCP连接没有完全断开之前不允许重新监听。比如我强制退出server,再启动就不会说端口被占用了。

```c
在server代码的socket()和bind()调用之间插入如下代码：
int opt=1;
setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(opt));
```

### UDP

**TCP:传输控制协议 安全可靠 丢包重传 面向连接(电话模型)**

**UDP:用户数据报协议 不安全不可靠 丢包不重传 快 不面向连接(邮件模型)**

**tcp通信流程：**
**服务器：创建流式套接字 绑定 监听 提取 读写 关闭**

**客户端：创建流式套接字 连接 读写 关闭**

**收发数据：**

**read recv**

```c
#include <sys/socket.h>

ssize_t recv(int sockfd, void buf[.len], size_t len,
  int flags);
flags==MSG_PEEK 读数据不会删除缓冲区的数据 一般填0
```

**write send**

```c
 #include <sys/socket.h>
 ssize_t send(int sockfd,
   const void buf[.len], size_t len, int flags);//flags=1表示紧急数据 一般填0
```

**udp通信流程：**

**服务器：创建报式套接字 绑定 读写 关闭**

**客户端：创建报式套接字 读写 关闭**

**发数据：**

```c
#include <sys/socket.h>
ssize_t sendto(int sockfd,
  const void buf[.len], size_t len, int flags,
    const struct sockaddr * dest_addr, socklen_t addrlen);
dest_addr:目的地的地址信息
addrlen:结构体大小
```

**收数据：**

```c
#include <sys/socket.h>
ssize_t recvfrom(int sockfd, void buf[restrict.len], size_t len,
  int flags,
  struct sockaddr * _Nullable restrict src_addr,
  socklen_t * _Nullable restrict addrlen);
src_addr：对方的地址信息
addrlen：结构体大小地址    
```

创建报式套接字

```c
int socket(int domain,int type,int protocol);
参数：
    domain:AF_INET
    type:SOCK_DGRAM
    protocol:0
```

UDP一般是一对一的。一个套接字服务一个客户端，不像TCP,后来可以分配套接字。

### UDP服务器和客户端代码实现

```c
#include<stdio.h>
#include<sys/socket.h>
#include<stdlib.h>
#include<unistd.h>
#include<arpa/inet.h>
int main(int argc,char *argv[]){
    //创建套接字
    int fd=socket(AF_INET,SOCK_DGRAM,0);
    //绑定
    struct sockaddr_in myaddr;
    myaddr.sin_family=AF_INET;
    myaddr.sin_port=htons(8000);
    myaddr.sin_addr.s_addr=inet_addr("127.0.0.1");
    int ret=bind(fd,(struct sockaddr*)&myaddr,sizeof(myaddr));
    if(ret<0){
        perror("bind");
        return 0;
    }
    //读写
    char buf[1500]="";
    struct sockaddr_in cliaddr;
    socklen_t len=sizeof(cliaddr);
    while(1){
        int n=recvfrom(fd,buf,sizeof(buf),0,(struct sockaddr*)&cliaddr,&len);
        if(n<0){
            perror("");
            break;
        }
        else{
            printf("%s\n",buf);
            sendto(fd,buf,n,0,(struct sockaddr*)&cliaddr,len);
        }
    }
    //关闭
    close(fd);
}
```

```bash
hello
```

```bash
nc -u 127.0.0.1 8000 #这里连接服务器加上-u 表示连接的是udp
```

```c
#include<stdio.h>
#include<sys/socket.h>
#include<stdlib.h>
#include<unistd.h>
#include<arpa/inet.h>
#include<string.h>
int main(int argc,char *argv[]){
    //创建套接字
    int fd=socket(AF_INET,SOCK_DGRAM,0);
    //绑定
    struct sockaddr_in myaddr;
    myaddr.sin_family=AF_INET;
    myaddr.sin_port=htons(9000);
    myaddr.sin_addr.s_addr=inet_addr("127.0.0.1");
    int ret=bind(fd,(struct sockaddr*)&myaddr,sizeof(myaddr));
    if(ret<0){
        perror("bind");
        return 0;
    }
    //读写
    char buf[1500]="";
    struct sockaddr_in dstaddr;
    dstaddr.sin_family=AF_INET;
    dstaddr.sin_port=htons(8000);
    dstaddr.sin_addr.s_addr=inet_addr("127.0.0.1");
    int n=0;
    while(1){
        n=read(STDIN_FILENO,buf,sizeof(buf));
        sendto(fd,buf,n,0,(struct sockaddr*)&dstaddr,sizeof(dstaddr));
        memset(buf,0,sizeof(buf));
        int n=recvfrom(fd,buf,sizeof(buf),0,NULL,NULL);
        if(n<0){
            perror("");
            break;
        }
        else{
            printf("%s\n",buf);
        }
    }
    //关闭
    close(fd);
}

```

```bash
hello
hello

hhhhh
hhhhh

woshinidia
woshinidia
```

### 本地套接字通信

**unix domain socket又是一个新的IPC方式，**“本地套接字”通常指的是 **Unix 域套接字（Unix Domain Socket，UDS）**，是一种用于**同一台主机内部进程间通信（IPC）**的套接字，与 TCP/IP 套接字相比，它不经过网络协议栈，速度更快、效率更高。

**全双工**

**套接字用文件来标识，这个文件在绑定之前是不能存在的。**

**作用**：实现本地进程间通信，替代管道、共享内存等传统 IPC 手段。

**协议族**：使用 `AF_UNIX` 或 `AF_LOCAL` 而不是 `AF_INET`。

**通信方式**：支持 `SOCK_STREAM`（类似 TCP）和 `SOCK_DGRAM`（类似 UDP）。

**地址类型**：使用文件系统中的路径名作为标识（如 `/tmp/mysock`）。

本地套接字实现tcp通信

1. 创建本地套接字
2. 绑定
3. 监听
4. 提取
5. 读写
6. 关闭

创建本地套接字用于tcp通信

```c
int socket(int domain,int type,int protocol);
参数：
    domain:AF_UNIX
    type:SOCK_STREAM
    protocol:0
```

绑定

```c
#include <sys/socket.h>

int bind(int sockfd,
  const struct sockaddr * addr,
    socklen_t addrlen);
参数:
	sockfd：本地套接字
    addr：本地套接字结构体地址
struct sockaddr_un {
  sa_family_t sun_family; /* AF_UNIX */
  char sun_path[108]; /* Pathname */
};   
	addrlen:sockaddr_un大小
```

提取

```c
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr * _Nullable restrict addr,
  socklen_t * _Nullable restrict addrlen);
addr:struct sockaddr_un结构体来接
```

### 本地套接字实现tcp服务器和客户端代码实现

```c
#include<stdio.h>
#include<sys/socket.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<string.h>
#include<stdlib.h>
#include<sys/un.h>
int main(int argc,char *argv[]){
    //删除文件，文件如果先前存在会通信不了
    unlink("sock.s");
    //创建unix流式套接
    int lfd=socket(AF_UNIX,SOCK_STREAM,0);
    //绑定
    struct sockaddr_un myaddr;
    myaddr.sun_family=AF_UNIX;
    strcpy(myaddr.sun_path,"sock.s");

    bind(lfd,(struct sockaddr*)&myaddr,sizeof(myaddr));
    //监听
    listen(lfd,128);
    //提取
    struct sockaddr_un cliaddr;
    socklen_t len=sizeof(cliaddr);
    int cfd=accept(lfd,(struct sockaddr*)&cliaddr,&len);
    printf("new client file=%s\n",cliaddr.sun_path);
    //读写
    char buf[1500]="";
    while(1){
        int n=recv(cfd,buf,sizeof(buf),0);
        if(n<=0){
            break;
        }else{
            printf("%s\n",buf);
            send(cfd,buf,n,0);
        }
    }
    close(cfd);
    close(lfd);
}
```

```bash
new client file=
hellop
#使用nc连接服务器
 nc -U sock.s
```

```c
#include<stdio.h>
#include<arpa/inet.h>
#include<sys/socket.h>
#include<stdlib.h>
#include<string.h>
#include<sys/un.h>
#include<unistd.h>
int main(int argc,char *argv[]){
    unlink("sock.c");
    //创建unix流式套接字
    int cfd=socket(AF_UNIX,SOCK_STREAM,0);
    //如果不绑定就会隐式绑定
    struct sockaddr_un myaddr;
    myaddr.sun_family=AF_UNIX;
    strcpy(myaddr.sun_path,"sock.c");
    if(bind(cfd,(struct sockaddr*)&myaddr,sizeof(myaddr))<0){
        perror("");
        return 0;
    }    
    //连接
    struct sockaddr_un seraddr;
    seraddr.sun_family=AF_UNIX;
    strcpy(seraddr.sun_path,"sock.s");
    connect(cfd,(struct sockaddr *)&seraddr,sizeof(seraddr));
    //读写
    char buf[1500]="";
    while(1){
        char buf[1500]="";
        int n=read(STDIN_FILENO,buf,sizeof(buf));
        send(cfd,buf,n,0);
        memset(buf,0,sizeof(buf));
        n=recv(cfd,buf,sizeof(buf),0);
        if(n<=0){
            break;
        }
        else{
            printf("%s\n",buf);
        }
    }
    //关闭
    close(cfd);
    return 0;
}
```

```bash
hello
hello

我是你弟
我是你弟
```



## Socket编程

无名管道，命名管道，文件，信号，消息队列，共享内存只能用于本机的进程间通信。

**不同主机间进程通信方法：socket**

socket是一个伪文件。

![5](5.png)

**socket必须成对出现。**

### **大小端：**

**小端：低位存低地址，高位存高地址**

**大端：高位存低地址，低位存高地址**

**网络上走的数据都是大端的，主机的主机字节序是未知的，需要转换。**

- **协议头部：如 TCP/IP 头、DNS 头等 → 这些字段是标准协议的，必须按规定的大端（网络字节序）**
- **数据部分（Payload）：完全由你应用程序自己定义** 

网络字节序和主机字节序的转换

```c
#include<arpa/inet.h>

uint32_t htonl(uint32_t hostlong);//主机字节序转网络字节序（4个字节）转ip
uint16_t htons(uint16_t hostshort);//主机字节序转网络字节序（2个字节）转port
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
```

示例代码

```c
#include<arpa/inet.h>
#include<stdio.h>
int main(int argc,char *argv[]){
    char buf[4]={192,168,1,2};
    int num=*(int *)buf;
    int sum=htonl(num);
    unsigned char *p=&sum;
    printf("%d %d %d %d\n",*p,*(p+1),*(p+2),*(p+3));

    unsigned short a=0x0102;
    unsigned short b=htons(a);
    printf("%x\n",b);
    return 0;
}
```

```bash
2 1 168 192
201
```

说明我的电脑是小端。

### IP地址转换函数

```c
#include<arpa/inet.h>

int inet_pton(int af,const char *src,void *dst);
功能：将点分十进制串转成32位网络大端的数据
参数：af:
		AF_INET IPV4
        AF_INET6 IPV6
   	 src：点分十进制串的首地址
   	 dst:32位网络数据的首地址
返回值：
     成功：返回1
     失败：返回0
const char *inet_ntop(int af,const void *src,char *dst,socklen_t size);
功能：将32位大端的网络数据转成点分十进制串
参数：af:
		AF_INET IPV4
        AF_INET6 IPV6
   	 src：32位网络数据的首地址
   	 dst: 点分十进制串的首地址
     size:存储点分制串数组的大小 通常写16
返回值：
     存储点分制串数组的首地址。
支持IPV4和IPV6。
```

示例代码：

```c
#include<stdio.h>
#include<arpa/inet.h>

int main(int argc,char *argv[]){
    char buf[]="192.168.1.4";
    unsigned int num=0;
    inet_pton(AF_INET,buf,&num);
    unsigned char *p=(unsigned char *)&num;
    printf("%d %d %d %d\n",*p,*(p+1),*(p+2),*(p+3));
    char ip[16]="";
    inet_ntop(AF_INET,&num,ip,16);
    printf("%s\n",ip);
    return 0;
}
```

```bash
192 168 1 4
192.168.1.4
```

### ipv4套接字结构体

```c
 struct sockaddr_in {
   sa_family_t sin_family; /* address family: AF_INET */ 对应的协议（ipv4）
   in_port_t sin_port; /* port in network byte order */ 端口
   struct in_addr sin_addr; /* internet address */ ip地址
 };

 /* Internet address */
 struct in_addr {
   uint32_t s_addr; /* address in network byte order */ ip地址
 };
```

**ipv6套接字结构体太多了，这里不展示**

因为有这两种套接字结构体，所以我们要统一，方便函数编写。

**通用套接字结构体**

```c
struct sockaddr{
    sa_family_t sa_family; /* address family,AF_xxx*/
    char sa_data[14]; /*14 bytes of protocol address*/
};
```

### 网络套接字函数

tcp  特点：出错重传 每次发送数据，对方都会回ACK 可靠

#### 网络通信流程

![6](6.png)

#### 创建套接字函数socket()

```c
#include <sys/socket.h>
int socket(int domain,int type,int protocol);
功能：创建套接字
参数：domain:AF_INET
     type:SOCK_STREAM 流式套接字 用于TCP通信
     protocol:0
返回值：
     成功：返回文件描述符
     失败：返回-1
```

#### 连接服务器函数connect()

```c
#include <sys/socket.h>

int connect(int sockfd,
  const struct sockaddr * addr,
    socklen_t addrlen);
功能：连接服务器
参数：
    sockfd:socket套接字
    addr:ipv4套接字结构体地址
    addrlen:ipv4套接字结构体的长度
```

#### tcp客户端代码

```c
#include<arpa/inet.h>
#include<sys/socket.h>
#include<stdlib.h>
#include<string.h>
#include<stdio.h>
#include<unistd.h>
int main(int argc,char *argv[]){
    //创建套接字
    int sock_fd;
    sock_fd=socket(AF_INET,SOCK_STREAM,0);
    if(sock_fd==-1){
        printf("连接失败");
    }else{
        printf("连接成功");
    }
    //连接服务器
    struct sockaddr_in addr;
    addr.sin_family=AF_INET;
    addr.sin_port=htons(8000);
    inet_pton(AF_INET,"127.0.0.1",&addr.sin_addr.s_addr);  
    connect(sock_fd,(struct sockaddr *)&addr,sizeof(addr));
    //读写数据
    char buf[1024]="";
    while(1){
        int n=read(STDIN_FILENO,buf,sizeof(buf));
        write(sock_fd,buf,n);//发送数据给服务器
        n=read(sock_fd,buf,sizeof(buf));
        write(STDOUT_FILENO,buf,n);

    }
    //关闭
    close(sock_fd);
    return 0;
}
```

#### tcp服务器通信流程

![7](7.png)

对于得到一个新的连接套接字（提取连接部分），服务器是要接受多个客户端连接的，所以先连接上，再分配新的连接和客户端通信。

![8](8.png)

#### bind函数

给套接字绑定固定的端口和ip

```c
#include <sys/socket.h>

int bind(int sockfd,
  const struct sockaddr * addr,
    socklen_t addrlen);
功能：给套接字绑定固定的端口和ip
参数：
    sockfd:套接字
    addr:ipv4套接字结构体地址
    addrlen:ipv4结构体的大小
返回值：
    成功：返回0
    失败：返回-1
```

#### listen函数

```c
#include <sys/socket.h>

int listen(int sockfd, int backlog);
功能：
    监听套接字
参数：
    sockfd:套接字
    backlog:已完成连接队列和未完成连接队列之和的最大值 一般写128
```

#### accept函数

```c
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr * _Nullable restrict addr,
  socklen_t * _Nullable restrict addrlen);
功能：
    从已完成连接队列提取新的连接，如果没有新的连接，accept会阻塞。
参数：
    sockfd:套接字
    addr:获取的客户端的ip和端口信息 ipv4套接字结构体
    addrlen:ipv4套接字结构体的大小的地址
返回值：
    新的已连接套接字的文件描述符
```

#### tcp服务器代码

```c
#include<stdio.h>
#include<arpa/inet.h>
#include<sys/socket.h>
#include<unistd.h>

int main(int argc,char *argv[]){
    //创建套接字
    int lfd=socket(AF_INET,SOCK_STREAM,0);
    //绑定
    struct sockaddr_in addr;
    addr.sin_family=AF_INET;
    addr.sin_port=htons(8000);
    //addr.sin_addr.s_addr=INADDR_ANY;//绑定的是通配地址，当前主机的所有ip
    inet_pton(AF_INET,"127.0.0.1",&addr.sin_addr.s_addr);
    int ret=bind(lfd,(struct sockaddr *)&addr,sizeof(addr));
    if(ret<0){
        perror("bind");
        exit(0);
    }
    //监听
    listen(lfd,128);
    //提取
    struct sockaddr_in cliaddr;
    socklen_t len=sizeof(cliaddr);
    int cfd=accept(lfd,(struct sockaddr *)&cliaddr,&len);
    char ip[16]="";
    printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));
    //读写
    char buf[1024]="";
    while(1){
        bzero(buf,sizeof(buf));
        int n=read(STDIN_FILENO,buf,sizeof(buf));
        write(cfd,buf,n);
        int readn=read(cfd,buf,sizeof(buf));
        if(readn==0){
            printf("客户端关闭");
        }
        printf("%s\n",buf);
    }
    //关闭
    close(lfd);
    close(cfd);
    return 0;
}
```

```bash
nc 127.0.0.1 8000 #可以实现一个客户端，简易聊天
hello
world
```

```bash
new client ip=127.0.0.1 port=52486
hello
world
```

### 多进程实现并发服务器

```c
#include <stdio.h>
#include<stdlib.h>
#include <sys/socket.h>
#include <unistd.h>
#include<signal.h>
#include<sys/types.h>
#include<sys/wait.h>
#include "wrap.h"
void free_process(int sig){
    pid_t pid;
    while(1){
        pid=waitpid(-1,NULL,WNOHANG);
        if(pid<=0){//小于0 子进程全部退出 =0没有子进程退出
            break;
            printf("haha");
        }else{
            printf("child pid =%d",pid);
        }
    }
    
}
int main(int argc, char *argv[])
{
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set,SIGCHLD);
    sigprocmask(SIG_BLOCK,&set,NULL);
    // 创建套接字
    int lfd = tcp4bind(8000, NULL);
    // 监听
    Listen(lfd, 128);
    // 提取
    // 回射
    struct sockaddr_in cliaddr;
    socklen_t len = sizeof(cliaddr);
    while (1)
    {
        char ip[16] = "";
        // 提取连接
        int cfd = Accept(lfd, (struct sockaddr *)&cliaddr, &len);
        printf("new client ip=%s port=%d\n", inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, ip, 16), ntohs(cliaddr.sin_port));
        // fork创建子进程
        pid_t pid;
        pid = fork();
        if (pid < 0)
        {
            perror("fork:");
            exit(0);
        }
        else if (pid == 0)
        { // 子进程
            // 关闭lfd
            close(lfd);
            while (1)
            {
                char buf[1024] = "";
                int n = read(cfd, buf, sizeof(buf));
                if (n < 0)
                {
                    perror("read:");
                    close(cfd);
                    exit(0);
                }
                else if (n == 0)
                { // 对方关闭
                    printf("client close\n");
                    close(cfd);
                    exit(0);
                }
                else
                {
                    printf("%s\n", buf);
                    write(cfd, buf, n);
                }
            }
        }
        else
        { // 父进程
            close(cfd);
            // 回收
            //注册信号回调
            struct sigaction act;
            act.sa_flags=0;
            act.sa_handler=free_process;
            sigemptyset(&act.sa_mask);
            sigaction(SIGCHLD,&act,NULL);
            sigprocmask(SIG_UNBLOCK,&set,NULL);
        }
    }
    // 关闭
    return 0;
}
```

我这里不知道为什么在子进程结束后回调函数没有触发。

### 多线程实现并发服务器

```c
#include<stdio.h>
#include<pthread.h>
#include"wrap.h"
typedef struct c_info{
    int cfd;
    struct sockaddr_in cliaddr;
}CINFO;
void *client_fun(void *arg);
int main(int argc,char *argv[]){
    if(argc<2){
        printf("argc<2\n");
        return 0;
    }
    //如果使用pthread_join或pthread_detach()回收资源要具体的线程id,太繁琐，
    //所以在创建线程时赋予detach属性
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
    short port=atoi(argv[1]);
    int lfd=tcp4bind(port,NULL);//创建套接字 绑定
    Listen(lfd,128);
    struct sockaddr_in cliaddr;
    socklen_t len=sizeof(cliaddr);
    CINFO *info;
    while(1){
        int cfd=Accept(lfd,(struct sockaddr *)&cliaddr,&len);
        
        //printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,buf,16),ntohs(cliaddr.sin_port));
        pthread_t pthid;
        //这里如果CINFO info来用是不可以的，在多线程环境下，可能info里面的信息被覆盖，就不是原来的信息，所以放在堆区。
        info=malloc(sizeof(CINFO));
        info->cfd=cfd;
        info->cliaddr=cliaddr;
        pthread_create(&pthid,NULL,client_fun,info);
    }

    return 0;
}
void *client_fun(void *arg){
    CINFO *info=(CINFO *)arg;
    char buf[16]="";
    printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&(info->cliaddr.sin_addr.s_addr),buf,16),ntohs(info->cliaddr.sin_port));
    while(1){
        char buf[1024]="";
        int count=0;
        count=read(info->cfd,buf,sizeof(buf));
        if(count<0){
            perror("read:");
            break;
        }else if(count==0){
            printf("client close\n");
            break;
        }else{
            printf("%s\n",buf);
            write(info->cfd,buf,count);
        }
    }
    close(info->cfd);
    free(info);
}
```

## 高并发服务器

为了实现更好的并发：以下由三种方法

1. 阻塞等待：消耗资源，效率不高
2. 非阻塞忙轮询：消耗cpu
3. **多路IO转接(多路IO复用)：这种较为理想，epoll，select，poll都是 依赖 Linux 内核事件机制 实现的 I/O 多路复用模型，他们可以监听到任意socket的读写缓冲区发生了变化，应用层进而去处理。这样实现高并发。**

**多路IO转接服务器也叫做多任务IO服务器，该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，而是由内核替应用程序监视**

**windows 使用select select跨平台**

**poll 用的较少**

**epoll linux**

### select

1. select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数。
2. 解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，**select采用的是轮询模型**，会大大降低服务器响应效率，不应在select上投入更多精力。

```c
#include <sys/select.h>

typedef /* ... */ fd_set;

int select(int nfds, fd_set * _Nullable restrict readfds,
  fd_set * _Nullable restrict writefds,
  fd_set * _Nullable restrict exceptfds,
  struct timeval * _Nullable restrict timeout);
功能：监听多个文件描述符的属性变化（读，写，异常）
参数：nfds:最大文件描述符+1
    readfds:需要监听的读的文件描述符存放集合
    writefds:需要监听的写的文件描述符存放集合 NULL
    exceptfds:需要监听的异常的文件描述符存放集合 NULL
    timeout：多长时间监听一次 固定的时间，限时等待 NULL 永久监听
返回值：返回的是变化的文件描述符的个数，变化的文件描述符会在readfds保存，但是没有变化的文件描述符会被删掉。
struct timeval {
  time_t tv_sec; /* seconds */
  suseconds_t tv_usec; /* microseconds */
};
void FD_CLR(int fd, fd_set * set);//从集合删除指定文件描述符
int FD_ISSET(int fd, fd_set * set);//文件描述符是否在集合，在就返回1
void FD_SET(int fd, fd_set * set);//向集合添加文件描述符
void FD_ZERO(fd_set * set);//清空文件描述符集
```

### 基于select的并发服务器

```c
#include<stdio.h>
#include<sys/select.h>
#include<sys/types.h>
#include<unistd.h>
#include"wrap.h"
#include<sys/time.h>
#define PORT 8888
int main(int argc,char *argv[]){
    //创建套接字，绑定
    int lfd=tcp4bind(PORT,NULL);
    //监听
    Listen(lfd,128);
    int maxfd=lfd;//最大的文件描述符
    fd_set oldset,rset;
    //清空集合
    FD_ZERO(&oldset);
    FD_ZERO(&rset);
    //将lfd添加到oldset集合中
    FD_SET(lfd,&oldset);
    while(1){
        rset=oldset;
        int n=select(maxfd+1,&rset,NULL,NULL,NULL);
        if(n<0){
            perror("select:");
            break;
        }else if(n==0){
            continue;
        }else{
            //监听到了文件描述符的变化
            //lfd 代表有新的连接到来
            if(FD_ISSET(lfd,&rset)){
                struct sockaddr_in cliaddr;
                socklen_t len=sizeof(cliaddr);
                char ip[16]="";
                //提取新的连接
                int cfd=Accept(lfd,(struct sockaddr*)&cliaddr,&len);
                printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));
                //将cfd添加至oldset集合中，以下次监听
                FD_SET(cfd,&oldset);
                //更新maxfd
                if(cfd>maxfd){
                    maxfd=cfd;
                }
                //如果只有lfd变化，continue
                if(--n==0){
                    continue;
                }
            }
            //cfd  遍历lfd之后的文件描述符是否在rset集合中，如果在则cfd变化
            for(int i=lfd+1;i<=maxfd;i++){
                if(FD_ISSET(i,&rset)){
                    char buf[1500]="";
                    int ret=Read(i,buf,sizeof(buf));
                    if(ret<0){//出错，将cfd关闭，从oldset删除cfd;
                        perror("Read");
                        close(i);
                        FD_CLR(i,&oldset);
                        continue;
                    }else if(ret==0){
                        printf("client close\n");
                        close(i);
                        FD_CLR(i,&oldset);
                    }else{
                        printf("%s\n",buf);
                        Write(i,buf,ret);
                    }
                }
            }
        }
    }
}
```

```bash
new client ip=127.0.0.1 port=54938
hello

client close
```

**select的优缺点：**

**优点：跨平台**

**缺点：**

**文件描述符1024的限制 由于FD_SETSIZE的限制。只是返回变化的文件描述符的个数，具体是哪些变化，需要遍历。**

**每次都需要将需要监听的文件描述符集合由应用层拷贝到内核，也比较费时间。**

**当大量并发，少量活跃，select效率低。**

**假设现在4-1023个文件描述符需要监听，但是5-1000这些文件描述符关闭了？**

**列一个数组存储监听的文件描述符列表，文件描述符关闭就把他的值从数组覆盖掉，再确认那些文件描述符读或写，直接遍历这个数组，效率高些，但是还是很一般。**

**其实我们可以在文件描述符表把后面的文件描述符提前，让文件描述符更紧凑，这样效率更高，我们可以使用dup2函数把前面空余的文件描述符复制后面的，再把后面的关掉。**

**假设4-1023个文件描述符需要监听，但是只有5，1002发来消息：无解**

### poll

```c
#include <poll.h>
int poll(struct pollfd * fds, nfds_t nfds, int timeout);
功能：监听多个文件描述符的属性变化
参数:
	fds:监听的数组首元素地址
    nfds:数组有效元素的最大下标+1
    timeout:超时时间 -1是永久监听 >=0限时等待
数组元素：struct pollfd
struct pollfd {
  int fd; /* file descriptor */ 需要监听的文件描述符
  short events; /* requested events */ 需要监听的文件描述符什么事件 POLLIN 读事件 POLLOUT 写事件
  short revents; /* returned events */ 返回监听到的事件
};        
```

**poll相对于select的优缺点：**

**优点：**

**没有文件描述符1024的限制**

**请求和返回是分离的**

**缺点和select一样：**

**每次都需要将需要监听的文件描述符从应用层拷贝到内核**

**每次都需要将数组的元素遍历一遍才知道那一个文件描述符变化了**

**大量并发，少量活跃，效率低。**

### epoll

![12](12.png)

**红黑树的节点不只是文件描述符。**

**epoll API**

**1.创建红黑树**

```c
#include <sys/epoll.h>
int epoll_create(int size);
参数：
    size:监听的文件描述符上限，2.6版本之后写1即可会自动扩展
返回值：
    返回树的句柄
```

**2.上树 下树 修改节点**

```c
#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd,
  struct epoll_event * _Nullable event);
参数：
    epfd:树的句柄
    op:选项：EPOLL_CTL_ADD 上树 EPOLL_CTL_MOD 修改节点 EPOLL_CTL_DEL 下树
    fd:上树下树的文件描述符
    event:上树的节点
 struct epoll_event {
   uint32_t events; /* Epoll events */ 需要监听的事件 EPOLLIN　读事件　EPOLLOUT 写事件
   epoll_data_t data; /* User data variable */ 需要监听的文件描述符
 };

 union epoll_data {
   void * ptr;
   int fd;
   uint32_t u32;
   uint64_t u64;
 };

 typedef union epoll_data epoll_data_t;
```

**3.监听**

```c
#include <sys/epoll.h>
int epoll_wait(int epfd, struct epoll_event * events,
  int maxevents, int timeout);
功能：监听树上文件描述符的变化
参数：
	epfd:树的句柄
    events：接收变化节点的数组的首地址
    maxevents：数组元素的个数
    timeout：-1 永久监听 大于等于0限时等待
返回值：
    返回的是变化的文件描述符个数
```

示例代码：父子进程通过管道通信

```c
#include<stdio.h>
#include<unistd.h>
#include<string.h>
#include<sys/epoll.h>
#include <sys/types.h> 
int main(int argc,char *argv[]){
    int fd[2];
    pipe(fd);
    //创建子进程
    pid_t pid;
    pid=fork();
    if(pid<0){
        perror("fork:");
        return 1;
    }else if(pid==0){
        close(fd[0]);
        char buf[5];
        char ch='a';
        while(1){
            sleep(3);
            memset(buf,ch++,sizeof(buf));
            write(fd[1],buf,5);
        }
    }else{
        close(fd[1]);
        //创建树
        int epfd=epoll_create(1);
        //上树
        struct epoll_event ev,evs[1];
        ev.data.fd=fd[0];
        ev.events=EPOLLIN;
        epoll_ctl(epfd,EPOLL_CTL_ADD,fd[0],&ev);
        //监听
        while(1){
            int n=epoll_wait(epfd,evs,1,-1);
            if(n==1){
                char buf[128]="";
                int ret=read(fd[0],buf,sizeof(buf));
                if(ret<=0){
                    close(fd[0]);
                    epoll_ctl(epfd,EPOLL_CTL_DEL,fd[0],&ev);
                    break;
                }else{
                    printf("%s\n",buf);
                }
            }
        }
    }
    return 0;
}
```

```bash
aaaaa
bbbbb
ccccc
ddddd
eeeee
fffff
ggggg
hhhhh
```

### 基于epoll的高并发服务器

```c
#include<stdio.h>
#include"wrap.h"
#include<sys/epoll.h>

int main(int argc,char *argv[]){
    //创建套接字 绑定
    int lfd=tcp4bind(8000,NULL);
    //监听
    Listen(lfd,128);
    //创建树
    int epfd=epoll_create(1);
    //将lfd上树
    struct epoll_event ev,evs[1024];
    ev.data.fd=lfd;
    ev.events=EPOLLIN;
    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&ev);
    //while监听
    while(1){
        int nready=epoll_wait(epfd,evs,1024,-1);
        if(nready<0){
            perror("epoll_wait:");
            break;
        }else if(nready==0){
            continue;
        }else{
            for(int i=0;i<nready;i++){
                //判断lfd变化，并且是读事件变化
                if(evs[i].data.fd==lfd&&evs[i].events & EPOLLIN){
                    struct sockaddr_in cliaddr;
                    char ip[16]="";
                    socklen_t len=sizeof(cliaddr);
                    //提取新的连接
                    int cfd=Accept(lfd,(struct sockaddr*)&cliaddr,&len);
                    printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));
                    //将cfd上树
                    ev.data.fd=cfd;
                    ev.events=EPOLLIN;
                    epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&ev);
                }else if(evs[i].events & EPOLLIN)//cfd变化,而且是读事件变化
                {
                    char buf[1024]="";
                    int n=read(evs[i].data.fd,buf,sizeof(buf));
                    if(n<0){
                        perror("read:");
                        epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&evs[i]);
                    }else if(n==0){//客户端关闭
                        printf("client close");
                        close(evs[i].data.fd);
                        epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&evs[i]);
                    }else{
                        printf("%s\n",buf);
                        write(evs[i].data.fd,buf,n);
                    }
                }
            }
        }
    }
    return 0;
}
```

```bash
new client ip=127.0.0.1 port=56746
hello
```

### epoll的两种工作方式

**在电路中，存在高电平和低电平，水平触发：持续的高电平或者低电平。边沿触发：电平有高到低的一个变化 或者由低到高的变化。对于epoll_wait的水平触发 LT，边沿触发 ET,对于读缓冲区使用水平触发，epoll_wait(系统调用)触发很频繁，所以使用边沿触发。写缓冲区一般用边沿触发**



![13](13.png)



**如何使用边沿触发呢，读缓冲区默认是水平触发。我们可以在上树时，需要设置需要监听的事件，再加上个EPOLLET**

```c
ev.events=EPOLLIN | EPOLLET
```

### 基于epoll的高并发服务器(加入边沿触发和优化代码)

将cfd设置边沿触发。设置边沿触发就要非阻塞。

```c
#include <stdio.h>
#include "wrap.h"
#include <sys/epoll.h>
#include <sys/fcntl.h>
int main(int argc, char *argv[])
{
    // 创建套接字 绑定
    int lfd = tcp4bind(8000, NULL);
    // 监听
    Listen(lfd, 128);
    // 创建树
    int epfd = epoll_create(1);
    // 将lfd上树
    struct epoll_event ev, evs[1024];
    ev.data.fd = lfd;
    ev.events = EPOLLIN;
    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);
    // while监听
    while (1)
    {
        int nready = epoll_wait(epfd, evs, 1024, -1);
        printf("epoll_wait .........................\n");
        if (nready < 0)
        {
            perror("epoll_wait:\n");
            break;
        }
        else if (nready == 0)
        {
            continue;
        }
        else
        {
            for (int i = 0; i < nready; i++)
            {
                // 判断lfd变化，并且是读事件变化
                if (evs[i].data.fd == lfd && evs[i].events & EPOLLIN)
                {
                    struct sockaddr_in cliaddr;
                    char ip[16] = "";
                    socklen_t len = sizeof(cliaddr);
                    // 提取新的连接
                    int cfd = Accept(lfd, (struct sockaddr *)&cliaddr, &len);
                    printf("new client ip=%s port=%d\n", inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, ip, 16), ntohs(cliaddr.sin_port));
                    // 设置cfd为非阻塞
                    int flags = fcntl(cfd, F_GETFL); // 获取cfd的标志位
                    flags |= O_NONBLOCK;
                    fcntl(cfd, F_SETFL, flags);
                    // 将cfd上树
                    ev.data.fd = cfd;
                    ev.events = EPOLLIN | EPOLLET;
                    epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);
                }
                else if (evs[i].events & EPOLLIN) // cfd变化,而且是读事件变化
                {
                    while (1)
                    {   //使用循环读，因为cfd采用的边沿模式读，一次可能读不完需要循环读保证读完
                        //但是read循环读的话会产生阻塞，这个程序就无法监听了，所以设置cfd为非阻塞
                        char buf[4] = "";
                        //如果读一个缓冲区，缓冲区没有数据，如果是带阻塞，就阻塞等待
                        //如果是非阻塞，返回值就等于-1,并且会将errno的值置为EAGAIN
                        //所以在非阻塞这里就出现问题了，n<0,可能是出错或者没有数据，没有数据不必下树，退出循环读。出错下树
                        int n = read(evs[i].data.fd, buf, sizeof(buf));
                        if (n < 0)
                        {
                            //缓冲区读干净了，跳出读循环
                            if(errno==EAGAIN){
                                break;
                            }
                            //普通错误
                            perror("read:");
                            epoll_ctl(epfd, EPOLL_CTL_DEL, evs[i].data.fd, &evs[i]);
                            close(evs[i].data.fd);
                            break;
                        }
                        else if (n == 0)
                        { // 客户端关闭
                            printf("client close");
                            close(evs[i].data.fd);
                            epoll_ctl(epfd, EPOLL_CTL_DEL, evs[i].data.fd, &evs[i]);
                            break;
                        }
                        else
                        {
                            //这里为什么不用printf了呢，因为printf输出字符串时，会去找字符串结束的\0但是网络传输收到的是没有\0(需要主动方手动添加)
                            //没有\0,printf就会出错，但是使用write函数就不会
                            write(STDOUT_FILENO,buf,n);
                            write(evs[i].data.fd, buf, n);
                        }
                    }
                }
            }
        }
    }
    return 0;
}
```

### epoll反应堆Reactor

**epoll反应堆就是把这三个东西：文件描述符 事件 回调函数封装在一起。**

**结构体来封装。**

反应堆模式（Reactor Pattern）是一种事件驱动的设计模式，用于处理并发 I/O 操作。核心思想：

- **事件驱动**：等待多个事件（如网络连接的读写事件）发生；
- **事件分发**：事件就绪时，分发给相应的处理器执行；
- **非阻塞 I/O**：避免线程阻塞，提高资源利用率。

###  线程池

**线程池，事先创建几个线程，不停取任务，如果没有任务休眠，省去了不停的创建线程销毁线程的事件和资源**

**注意：线程池 处理的单个任务所需要处理的时间必须很短。**

**一个锁**

**两个条件变量**

**循环队列**

![14](14.png)

