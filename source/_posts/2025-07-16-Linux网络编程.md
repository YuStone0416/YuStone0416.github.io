---
title: Linux网络编程
date: 2025-07-16 22:54:16
tags: Linux
urlname: Linux-Network Programming
categories: 计算机学习
updated: 2025-07-16 21:26:16
---

## 网络基础

### **mac地址**（6个字节 48位）

标记网卡的id,；理论上这个id全球唯一

**mac地址一般用来标识主机的id,这个id是物理地址，不会改变。**

### **ip地址，ipv4(4个字节，32位)，ipv6(16个字节，128位)**

IP地址是标识主机的id,这个id是虚拟的，会改变。

一个IP将其分为子网id和主机id

**子网id和主机id需要和子网掩码一起来看，**

![1](1.png)

ping命令用来测试两台主机的网络联通性（windows和Linux都适用）。

Linux下设置ip命令

```bash
ifconfig ens33 192.168.131.133 netmask 255.255.255.0
```

### **桥接模式（Bridged Networking）**

桥接模式是将虚拟机/容器的网络**桥接到物理网卡**上，使其就像是局域网中的一台独立主机。

工作原理：

虚拟机通过虚拟网桥（Bridge）连接到宿主机的物理网卡，相当于直接插入交换机，与宿主机处于**同一物理局域网**中。

网络特点：

- 虚拟机可获得**与宿主机同网段的IP地址**（例如通过 DHCP）
- 可以被局域网中其他设备访问（可 ping 通）
- 能访问局域网和外网

优点：

- 网络透明，虚拟机像一台真实的独立主机
- 易于与其他局域网设备通信

缺点：

- 需要宿主网络支持（如局域网允许多个 IP）
- 有可能增加网络冲突和安全风险

### **NAT 模式（网络地址转换）**

NAT 模式是虚拟机/容器通过宿主机的网络连接上网，**共享宿主机的 IP**。

工作原理：

宿主机充当“路由器”，将虚拟机的私有 IP 转换为宿主的公网 IP，进行地址转换。

网络特点：

- 虚拟机使用**私有 IP 地址（如 192.168.xx.xx）**
- 能访问外网，但外部主机**无法主动访问虚拟机**
- 类似家庭内的多台设备通过路由器上网

优点：

- 设置简单，几乎无须额外配置
- 安全性高，外部无法直接访问虚拟机

缺点：

- 虚拟机不能被外部主机主动访问（除非端口转发）
- 网络透明度低，不适合复杂网络测试

### 端口（port）

**作用：用来标识应用程序（进程）**

**port:两个字节 0-65535**

**0-1023 知名端口**

**自定义端口1024-65535（避免冲突）**

**一个应用可以有多个端口，一个端口只能有一个应用程序。**

### OSI七层模型

为了使各种不同的计算机之间可以互联，ARPANet指定了一套计算机通信协议，即TCP/IP协议（族）；

为了减少协议设计的复杂性，大多数网络模型均采用分层的方式来组织。

每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽。

**物理层：双绞线（网线）接口类型，光纤的传输速率等等**

**数据链路层：mac 负责收发数据**

**网络层：ip 给两台主机提供路径选择。**

**传输层：port 区分数据递送到那个应用程序。**

**会话层：建立连接**

**表示层：解码**

**应用层：应用程序**

![2](2.png)

### TCP/IP四层模型

![3](3.png)

### 协议

**规定了数据传输的方式和格式**

**这里主要按照TCP/IP四层模型有的协议。**

**应用层协议：**

**FTP:文件传输协议**

**HTTP:超文本传输协议**

**NFS:网络文件系统**

**传输层协议：**

**TCP:传输控制协议** 头部20个字节

**UDP:用户数据报协议** 头部8个字节

**网络层：**

**IP:英特网互联协议** 头部20个字节

**ICMP:英特网控制报文协议 ping命令就是这个协议**
**IGMP：英特网组管理协议**

**链路层：**

**ARP:地址解析协议 通过ip找mac地址**

**RARP:反向地址解析协议 通过mac找ip**

**硬件接口：mac头** 头部14个字节

目的mac地址为ff:ff:ff:ff:ff:ff 局域网内其他主机无条件接受。（常在ARP协议上使用）

![4](4.png)

### 网络设计模式

**B/S browser/server**

**C/S client/server**

C/S 性能较好 客户端容易篡改数据 开发周期较长

B/S 性能低 客户端安全 开发周期短

### TCP三次握手

tcp建立连接的过程 **SYN是请求建立连接的标识，ACK就是确认。**

![9](9.png)

**mss:最大报文长度，一般出现在三次握手的前两次，用来告知对方传送数据的最大长度。**

**MTU:最大传输单元 由网卡限制**

### TCP四次挥手

tcp断开连接，这个哪一方发起断开都可以，就以客户端申请断开为例子，三次握手一定是客户端发起。

就是两端的某一段调用了close函数。

**FIN是请求断开连接的标识**

![10](10.png)

### 滑动窗口

**TCP报头上有一个窗口尺寸的标识，这个是说接收方告知发送方：我的接收缓冲区还能接收多少字节。**

**在ACK标识回复时会带有win剩余多少空间。**

**这样发送方就会发送以避免拥堵，因为知道接收方还剩下多少空间，接收方是把当前接收缓冲区的一块数据提取出来，才会回复给发送方ACK携带当前缓冲区大小告知对方。**

### TCP状态转换

![11](11.png)

如果想要查看TCP应用的状态

```bash
netstat -anp | grep 8000(端口)
```

### 半关闭

**主动方在FIN_WAIT_2状态之后，主动方不可以在应用层发送数据了，但是应用层还可以接受数据，这个状态叫半关闭。**

**有人就有疑惑了，那为什么在TIME_WAIT状态还能发，因为它发的是ACK,主动方不可以在应用层发送数据了，指的是应用层的协议不可以接受了，但是在底层，传输层TCP协议还是可以发出，所以ACK是可以发的**。

```c
#include <sys/socket.h>
int shutdown(int sockfd, int how);
参数：
    sockfd:需要关闭的socket的描述符
    how:允许为shutdown操作选择以下几种方式：
        SHUT_RD(0):关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被丢弃。
        SHUT_WR(1):关闭sockfd上的写功能，此选项将不允许sockfd进行写操作。进程不能再对此套接字发出写操作
        SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是SHUT_RD,然后是SHUT_WR。
```

### TCP异常断开

#### 心跳包(TCP 的 keepalive 机制)

**SO_KEEPALIVE保持连接检测对方主机是否崩溃，避免服务器永远阻塞于TCP连接的输入。设置该选项后，如果两小时内在此套接口的任一方向都没有数据交换，TCP会自动给对方发一个保持存活探测分节，这是一个对方必须响应的TCP分节。他会导致以下三种情况：**

1. **对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个。**
2. **对方已崩溃且已重新启动：以RST响应。套接口的待处理错误设置为ECONNRESET,套接口本身被关闭。**
3. **对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT,套接口本身就关闭。若ICMP错误是host unreachable(主机不可达),说明对方主机没有崩溃，但是不可达，这种情况下待处理错误设置为EHOSTUNREACH.**

**所以我们可以设置SO_KEEPALIVE属性使得我们在两小时后发现对方的TCP连接是否依然存在。**

```c
keepAlive=1;
setsockopt(listenfd,SOL_SOCKET,SO_KEEPALIVE,(void *)&keepAlive,sizeof(keepAlive));
```

**但是说真的，这个函数两小时检测一次，对于现在来说，有点太长了，所以可以自己在应用层写对应的心跳包。**

心跳包：最小粒度，携带的数据部分一定要少。

乒乓包：携带比较多的数据的心跳包。

### 端口复用

端口重新启用，谁最后启用的端口谁用。前面启用的作废，用不了了。为什莫需要端口复用呢，在server的TCP连接没有完全断开之前不允许重新监听。比如我强制退出server,再启动就不会说端口被占用了。

```c
在server代码的socket()和bind()调用之间插入如下代码：
int opt=1;
setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(opt));
```

## Socket编程

无名管道，命名管道，文件，信号，消息队列，共享内存只能用于本机的进程间通信。

**不同主机间进程通信方法：socket**

socket是一个伪文件。

![5](5.png)

**socket必须成对出现。**

### **大小端：**

**小端：低位存低地址，高位存高地址**

**大端：高位存低地址，低位存高地址**

**网络上走的数据都是大端的，主机的主机字节序是未知的，需要转换。**

- **协议头部：如 TCP/IP 头、DNS 头等 → 这些字段是标准协议的，必须按规定的大端（网络字节序）**
- **数据部分（Payload）：完全由你应用程序自己定义** 

网络字节序和主机字节序的转换

```c
#include<arpa/inet.h>

uint32_t htonl(uint32_t hostlong);//主机字节序转网络字节序（4个字节）转ip
uint16_t htons(uint16_t hostshort);//主机字节序转网络字节序（2个字节）转port
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
```

示例代码

```c
#include<arpa/inet.h>
#include<stdio.h>
int main(int argc,char *argv[]){
    char buf[4]={192,168,1,2};
    int num=*(int *)buf;
    int sum=htonl(num);
    unsigned char *p=&sum;
    printf("%d %d %d %d\n",*p,*(p+1),*(p+2),*(p+3));

    unsigned short a=0x0102;
    unsigned short b=htons(a);
    printf("%x\n",b);
    return 0;
}
```

```bash
2 1 168 192
201
```

说明我的电脑是小端。

### IP地址转换函数

```c
#include<arpa/inet.h>

int inet_pton(int af,const char *src,void *dst);
功能：将点分十进制串转成32位网络大端的数据
参数：af:
		AF_INET IPV4
        AF_INET6 IPV6
   	 src：点分十进制串的首地址
   	 dst:32位网络数据的首地址
返回值：
     成功：返回1
     失败：返回0
const char *inet_ntop(int af,const void *src,char *dst,socklen_t size);
功能：将32位大端的网络数据转成点分十进制串
参数：af:
		AF_INET IPV4
        AF_INET6 IPV6
   	 src：32位网络数据的首地址
   	 dst: 点分十进制串的首地址
     size:存储点分制串数组的大小 通常写16
返回值：
     存储点分制串数组的首地址。
支持IPV4和IPV6。
```

示例代码：

```c
#include<stdio.h>
#include<arpa/inet.h>

int main(int argc,char *argv[]){
    char buf[]="192.168.1.4";
    unsigned int num=0;
    inet_pton(AF_INET,buf,&num);
    unsigned char *p=(unsigned char *)&num;
    printf("%d %d %d %d\n",*p,*(p+1),*(p+2),*(p+3));
    char ip[16]="";
    inet_ntop(AF_INET,&num,ip,16);
    printf("%s\n",ip);
    return 0;
}
```

```bash
192 168 1 4
192.168.1.4
```

### ipv4套接字结构体

```c
 struct sockaddr_in {
   sa_family_t sin_family; /* address family: AF_INET */ 对应的协议（ipv4）
   in_port_t sin_port; /* port in network byte order */ 端口
   struct in_addr sin_addr; /* internet address */ ip地址
 };

 /* Internet address */
 struct in_addr {
   uint32_t s_addr; /* address in network byte order */ ip地址
 };
```

**ipv6套接字结构体太多了，这里不展示**

因为有这两种套接字结构体，所以我们要统一，方便函数编写。

**通用套接字结构体**

```c
struct sockaddr{
    sa_family_t sa_family; /* address family,AF_xxx*/
    char sa_data[14]; /*14 bytes of protocol address*/
};
```

### 网络套接字函数

tcp  特点：出错重传 每次发送数据，对方都会回ACK 可靠

#### 网络通信流程

![6](6.png)

#### 创建套接字函数socket()

```c
#include <sys/socket.h>
int socket(int domain,int type,int protocol);
功能：创建套接字
参数：domain:AF_INET
     type:SOCK_STREAM 流式套接字 用于TCP通信
     protocol:0
返回值：
     成功：返回文件描述符
     失败：返回-1
```

#### 连接服务器函数connect()

```c
#include <sys/socket.h>

int connect(int sockfd,
  const struct sockaddr * addr,
    socklen_t addrlen);
功能：连接服务器
参数：
    sockfd:socket套接字
    addr:ipv4套接字结构体地址
    addrlen:ipv4套接字结构体的长度
```

#### tcp客户端代码

```c
#include<arpa/inet.h>
#include<sys/socket.h>
#include<stdlib.h>
#include<string.h>
#include<stdio.h>
#include<unistd.h>
int main(int argc,char *argv[]){
    //创建套接字
    int sock_fd;
    sock_fd=socket(AF_INET,SOCK_STREAM,0);
    if(sock_fd==-1){
        printf("连接失败");
    }else{
        printf("连接成功");
    }
    //连接服务器
    struct sockaddr_in addr;
    addr.sin_family=AF_INET;
    addr.sin_port=htons(8000);
    inet_pton(AF_INET,"127.0.0.1",&addr.sin_addr.s_addr);  
    connect(sock_fd,(struct sockaddr *)&addr,sizeof(addr));
    //读写数据
    char buf[1024]="";
    while(1){
        int n=read(STDIN_FILENO,buf,sizeof(buf));
        write(sock_fd,buf,n);//发送数据给服务器
        n=read(sock_fd,buf,sizeof(buf));
        write(STDOUT_FILENO,buf,n);

    }
    //关闭
    close(sock_fd);
    return 0;
}
```

#### tcp服务器通信流程

![7](7.png)

对于得到一个新的连接套接字（提取连接部分），服务器是要接受多个客户端连接的，所以先连接上，再分配新的连接和客户端通信。

![8](8.png)

#### bind函数

给套接字绑定固定的端口和ip

```c
#include <sys/socket.h>

int bind(int sockfd,
  const struct sockaddr * addr,
    socklen_t addrlen);
功能：给套接字绑定固定的端口和ip
参数：
    sockfd:套接字
    addr:ipv4套接字结构体地址
    addrlen:ipv4结构体的大小
返回值：
    成功：返回0
    失败：返回-1
```

#### listen函数

```c
#include <sys/socket.h>

int listen(int sockfd, int backlog);
功能：
    监听套接字
参数：
    sockfd:套接字
    backlog:已完成连接队列和未完成连接队列之和的最大值 一般写128
```

#### accept函数

```c
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr * _Nullable restrict addr,
  socklen_t * _Nullable restrict addrlen);
功能：
    从已完成连接队列提取新的连接，如果没有新的连接，accept会阻塞。
参数：
    sockfd:套接字
    addr:获取的客户端的ip和端口信息 ipv4套接字结构体
    addrlen:ipv4套接字结构体的大小的地址
返回值：
    新的已连接套接字的文件描述符
```

#### tcp服务器代码

```c
#include<stdio.h>
#include<arpa/inet.h>
#include<sys/socket.h>
#include<unistd.h>

int main(int argc,char *argv[]){
    //创建套接字
    int lfd=socket(AF_INET,SOCK_STREAM,0);
    //绑定
    struct sockaddr_in addr;
    addr.sin_family=AF_INET;
    addr.sin_port=htons(8000);
    //addr.sin_addr.s_addr=INADDR_ANY;//绑定的是通配地址，当前主机的所有ip
    inet_pton(AF_INET,"127.0.0.1",&addr.sin_addr.s_addr);
    int ret=bind(lfd,(struct sockaddr *)&addr,sizeof(addr));
    if(ret<0){
        perror("bind");
        exit(0);
    }
    //监听
    listen(lfd,128);
    //提取
    struct sockaddr_in cliaddr;
    socklen_t len=sizeof(cliaddr);
    int cfd=accept(lfd,(struct sockaddr *)&cliaddr,&len);
    char ip[16]="";
    printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));
    //读写
    char buf[1024]="";
    while(1){
        bzero(buf,sizeof(buf));
        int n=read(STDIN_FILENO,buf,sizeof(buf));
        write(cfd,buf,n);
        int readn=read(cfd,buf,sizeof(buf));
        if(readn==0){
            printf("客户端关闭");
        }
        printf("%s\n",buf);
    }
    //关闭
    close(lfd);
    close(cfd);
    return 0;
}
```

```bash
nc 127.0.0.1 8000 #可以实现一个客户端，简易聊天
hello
world
```

```bash
new client ip=127.0.0.1 port=52486
hello
world
```

### 多进程实现并发服务器

```c
#include <stdio.h>
#include<stdlib.h>
#include <sys/socket.h>
#include <unistd.h>
#include<signal.h>
#include<sys/types.h>
#include<sys/wait.h>
#include "wrap.h"
void free_process(int sig){
    pid_t pid;
    while(1){
        pid=waitpid(-1,NULL,WNOHANG);
        if(pid<=0){//小于0 子进程全部退出 =0没有子进程退出
            break;
            printf("haha");
        }else{
            printf("child pid =%d",pid);
        }
    }
    
}
int main(int argc, char *argv[])
{
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set,SIGCHLD);
    sigprocmask(SIG_BLOCK,&set,NULL);
    // 创建套接字
    int lfd = tcp4bind(8000, NULL);
    // 监听
    Listen(lfd, 128);
    // 提取
    // 回射
    struct sockaddr_in cliaddr;
    socklen_t len = sizeof(cliaddr);
    while (1)
    {
        char ip[16] = "";
        // 提取连接
        int cfd = Accept(lfd, (struct sockaddr *)&cliaddr, &len);
        printf("new client ip=%s port=%d\n", inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, ip, 16), ntohs(cliaddr.sin_port));
        // fork创建子进程
        pid_t pid;
        pid = fork();
        if (pid < 0)
        {
            perror("fork:");
            exit(0);
        }
        else if (pid == 0)
        { // 子进程
            // 关闭lfd
            close(lfd);
            while (1)
            {
                char buf[1024] = "";
                int n = read(cfd, buf, sizeof(buf));
                if (n < 0)
                {
                    perror("read:");
                    close(cfd);
                    exit(0);
                }
                else if (n == 0)
                { // 对方关闭
                    printf("client close\n");
                    close(cfd);
                    exit(0);
                }
                else
                {
                    printf("%s\n", buf);
                    write(cfd, buf, n);
                }
            }
        }
        else
        { // 父进程
            close(cfd);
            // 回收
            //注册信号回调
            struct sigaction act;
            act.sa_flags=0;
            act.sa_handler=free_process;
            sigemptyset(&act.sa_mask);
            sigaction(SIGCHLD,&act,NULL);
            sigprocmask(SIG_UNBLOCK,&set,NULL);
        }
    }
    // 关闭
    return 0;
}
```

我这里不知道为什么在子进程结束后回调函数没有触发。

### 多线程实现并发服务器

```c
#include<stdio.h>
#include<pthread.h>
#include"wrap.h"
typedef struct c_info{
    int cfd;
    struct sockaddr_in cliaddr;
}CINFO;
void *client_fun(void *arg);
int main(int argc,char *argv[]){
    if(argc<2){
        printf("argc<2\n");
        return 0;
    }
    //如果使用pthread_join或pthread_detach()回收资源要具体的线程id,太繁琐，
    //所以在创建线程时赋予detach属性
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
    short port=atoi(argv[1]);
    int lfd=tcp4bind(port,NULL);//创建套接字 绑定
    Listen(lfd,128);
    struct sockaddr_in cliaddr;
    socklen_t len=sizeof(cliaddr);
    CINFO *info;
    while(1){
        int cfd=Accept(lfd,(struct sockaddr *)&cliaddr,&len);
        
        //printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,buf,16),ntohs(cliaddr.sin_port));
        pthread_t pthid;
        //这里如果CINFO info来用是不可以的，在多线程环境下，可能info里面的信息被覆盖，就不是原来的信息，所以放在堆区。
        info=malloc(sizeof(CINFO));
        info->cfd=cfd;
        info->cliaddr=cliaddr;
        pthread_create(&pthid,NULL,client_fun,info);
    }

    return 0;
}
void *client_fun(void *arg){
    CINFO *info=(CINFO *)arg;
    char buf[16]="";
    printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&(info->cliaddr.sin_addr.s_addr),buf,16),ntohs(info->cliaddr.sin_port));
    while(1){
        char buf[1024]="";
        int count=0;
        count=read(info->cfd,buf,sizeof(buf));
        if(count<0){
            perror("read:");
            break;
        }else if(count==0){
            printf("client close\n");
            break;
        }else{
            printf("%s\n",buf);
            write(info->cfd,buf,count);
        }
    }
    close(info->cfd);
    free(info);
}
```

## 高并发服务器

为了实现更好的并发：以下由三种方法

1. 阻塞等待：消耗资源，效率不高
2. 非阻塞忙轮询：消耗cpu
3. **多路IO转接(多路IO复用)：这种较为理想，epoll，select，poll都是 依赖 Linux 内核事件机制 实现的 I/O 多路复用模型，他们可以监听到任意socket的读写缓冲区发生了变化，应用层进而去处理。这样实现高并发。**

**多路IO转接服务器也叫做多任务IO服务器，该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，而是由内核替应用程序监视**

**windows 使用select select跨平台**

**poll 用的较少**

**epoll linux**

### select

1. select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数。
2. 解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，**select采用的是轮询模型**，会大大降低服务器响应效率，不应在select上投入更多精力。

```c
#include <sys/select.h>

typedef /* ... */ fd_set;

int select(int nfds, fd_set * _Nullable restrict readfds,
  fd_set * _Nullable restrict writefds,
  fd_set * _Nullable restrict exceptfds,
  struct timeval * _Nullable restrict timeout);
功能：监听多个文件描述符的属性变化（读，写，异常）
参数：nfds:最大文件描述符+1
    readfds:需要监听的读的文件描述符存放集合
    writefds:需要监听的写的文件描述符存放集合 NULL
    exceptfds:需要监听的异常的文件描述符存放集合 NULL
    timeout：多长时间监听一次 固定的时间，限时等待 NULL 永久监听
返回值：返回的是变化的文件描述符的个数，变化的文件描述符会在readfds保存，但是没有变化的文件描述符会被删掉。
struct timeval {
  time_t tv_sec; /* seconds */
  suseconds_t tv_usec; /* microseconds */
};
void FD_CLR(int fd, fd_set * set);//从集合删除指定文件描述符
int FD_ISSET(int fd, fd_set * set);//文件描述符是否在集合，在就返回1
void FD_SET(int fd, fd_set * set);//向集合添加文件描述符
void FD_ZERO(fd_set * set);//清空文件描述符集
```

### 基于select的并发服务器

```c
#include<stdio.h>
#include<sys/select.h>
#include<sys/types.h>
#include<unistd.h>
#include"wrap.h"
#include<sys/time.h>
#define PORT 8888
int main(int argc,char *argv[]){
    //创建套接字，绑定
    int lfd=tcp4bind(PORT,NULL);
    //监听
    Listen(lfd,128);
    int maxfd=lfd;//最大的文件描述符
    fd_set oldset,rset;
    //清空集合
    FD_ZERO(&oldset);
    FD_ZERO(&rset);
    //将lfd添加到oldset集合中
    FD_SET(lfd,&oldset);
    while(1){
        rset=oldset;
        int n=select(maxfd+1,&rset,NULL,NULL,NULL);
        if(n<0){
            perror("select:");
            break;
        }else if(n==0){
            continue;
        }else{
            //监听到了文件描述符的变化
            //lfd 代表有新的连接到来
            if(FD_ISSET(lfd,&rset)){
                struct sockaddr_in cliaddr;
                socklen_t len=sizeof(cliaddr);
                char ip[16]="";
                //提取新的连接
                int cfd=Accept(lfd,(struct sockaddr*)&cliaddr,&len);
                printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port));
                //将cfd添加至oldset集合中，以下次监听
                FD_SET(cfd,&oldset);
                //更新maxfd
                if(cfd>maxfd){
                    maxfd=cfd;
                }
                //如果只有lfd变化，continue
                if(--n==0){
                    continue;
                }
            }
            //cfd  遍历lfd之后的文件描述符是否在rset集合中，如果在则cfd变化
            for(int i=lfd+1;i<=maxfd;i++){
                if(FD_ISSET(i,&rset)){
                    char buf[1500]="";
                    int ret=Read(i,buf,sizeof(buf));
                    if(ret<0){//出错，将cfd关闭，从oldset删除cfd;
                        perror("Read");
                        close(i);
                        FD_CLR(i,&oldset);
                        continue;
                    }else if(ret==0){
                        printf("client close\n");
                        close(i);
                        FD_CLR(i,&oldset);
                    }else{
                        printf("%s\n",buf);
                        Write(i,buf,ret);
                    }
                }
            }
        }
    }
}
```

```bash
new client ip=127.0.0.1 port=54938
hello

client close
```

**select的优缺点：**

**优点：跨平台**

**缺点：**

**文件描述符1024的限制 由于FD_SETSIZE的限制。只是返回变化的文件描述符的个数，具体是哪些变化，需要遍历。**

**每次都需要将需要监听的文件描述符集合由应用层拷贝到内核，也比较费时间。**

**当大量并发，少量活跃，select效率低。**

**假设现在4-1023个文件描述符需要监听，但是5-1000这些文件描述符关闭了？**

**列一个数组存储监听的文件描述符列表，文件描述符关闭就把他的值从数组覆盖掉，再确认那些文件描述符读或写，直接遍历这个数组，效率高些，但是还是很一般。**

**其实我们可以在文件描述符表把后面的文件描述符提前，让文件描述符更紧凑，这样效率更高，我们可以使用dup2函数把前面空余的文件描述符复制后面的，再把后面的关掉。**

**假设4-1023个文件描述符需要监听，但是只有5，1002发来消息：无解**

