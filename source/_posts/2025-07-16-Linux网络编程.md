---
title: Linux网络编程
date: 2025-07-16 22:54:16
tags: Linux
urlname: Linux-Network Programming
categories: 计算机学习
updated: 2025-07-16 21:26:16
---

## 网络基础

### **mac地址**（6个字节 48位）

标记网卡的id,；理论上这个id全球唯一

**mac地址一般用来标识主机的id,这个id是物理地址，不会改变。**

### **ip地址，ipv4(4个字节，32位)，ipv6(16个字节，128位)**

IP地址是标识主机的id,这个id是虚拟的，会改变。

一个IP将其分为子网id和主机id

**子网id和主机id需要和子网掩码一起来看，**

![1](1.png)

ping命令用来测试两台主机的网络联通性（windows和Linux都适用）。

Linux下设置ip命令

```bash
ifconfig ens33 192.168.131.133 netmask 255.255.255.0
```

### **桥接模式（Bridged Networking）**

桥接模式是将虚拟机/容器的网络**桥接到物理网卡**上，使其就像是局域网中的一台独立主机。

工作原理：

虚拟机通过虚拟网桥（Bridge）连接到宿主机的物理网卡，相当于直接插入交换机，与宿主机处于**同一物理局域网**中。

网络特点：

- 虚拟机可获得**与宿主机同网段的IP地址**（例如通过 DHCP）
- 可以被局域网中其他设备访问（可 ping 通）
- 能访问局域网和外网

优点：

- 网络透明，虚拟机像一台真实的独立主机
- 易于与其他局域网设备通信

缺点：

- 需要宿主网络支持（如局域网允许多个 IP）
- 有可能增加网络冲突和安全风险

### **NAT 模式（网络地址转换）**

NAT 模式是虚拟机/容器通过宿主机的网络连接上网，**共享宿主机的 IP**。

工作原理：

宿主机充当“路由器”，将虚拟机的私有 IP 转换为宿主的公网 IP，进行地址转换。

网络特点：

- 虚拟机使用**私有 IP 地址（如 192.168.xx.xx）**
- 能访问外网，但外部主机**无法主动访问虚拟机**
- 类似家庭内的多台设备通过路由器上网

优点：

- 设置简单，几乎无须额外配置
- 安全性高，外部无法直接访问虚拟机

缺点：

- 虚拟机不能被外部主机主动访问（除非端口转发）
- 网络透明度低，不适合复杂网络测试

### 端口（port）

**作用：用来标识应用程序（进程）**

**port:两个字节 0-65535**

**0-1023 知名端口**

**自定义端口1024-65535（避免冲突）**

**一个应用可以有多个端口，一个端口只能有一个应用程序。**

### OSI七层模型

为了使各种不同的计算机之间可以互联，ARPANet指定了一套计算机通信协议，即TCP/IP协议（族）；

为了减少协议设计的复杂性，大多数网络模型均采用分层的方式来组织。

每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽。

**物理层：双绞线（网线）接口类型，光纤的传输速率等等**

**数据链路层：mac 负责收发数据**

**网络层：ip 给两台主机提供路径选择。**

**传输层：port 区分数据递送到那个应用程序。**

**会话层：建立连接**

**表示层：解码**

**应用层：应用程序**

![2](2.png)

### TCP/IP四层模型

![3](3.png)

### 协议

**规定了数据传输的方式和格式**

**这里主要按照TCP/IP四层模型有的协议。**

**应用层协议：**

**FTP:文件传输协议**

**HTTP:超文本传输协议**

**NFS:网络文件系统**

**传输层协议：**

**TCP:传输控制协议** 头部20个字节

**UDP:用户数据报协议** 头部8个字节

**网络层：**

**IP:英特网互联协议** 头部20个字节

**ICMP:英特网控制报文协议 ping命令就是这个协议**
**IGMP：英特网组管理协议**

**链路层：**

**ARP:地址解析协议 通过ip找mac地址**

**RARP:反向地址解析协议 通过mac找ip**

**硬件接口：mac头** 头部14个字节

目的mac地址为ff:ff:ff:ff:ff:ff 局域网内其他主机无条件接受。（常在ARP协议上使用）

![4](4.png)

### 网络设计模式

**B/S browser/server**

**C/S client/server**

C/S 性能较好 客户端容易篡改数据 开发周期较长

B/S 性能低 客户端安全 开发周期短

## Socket编程

无名管道，命名管道，文件，信号，消息队列，共享内存只能用于本机的进程间通信。

**不同主机间进程通信方法：socket**

socket是一个伪文件。

![5](5.png)

**socket必须成对出现。**

### **大小端：**

**小端：低位存低地址，高位存高地址**

**大端：高位存低地址，低位存高地址**

**网络上走的数据都是大端的，主机的主机字节序是未知的，需要转换。**

- **协议头部：如 TCP/IP 头、DNS 头等 → 这些字段是标准协议的，必须按规定的大端（网络字节序）**
- **数据部分（Payload）：完全由你应用程序自己定义** 

网络字节序和主机字节序的转换

```c
#include<arpa/inet.h>

uint32_t htonl(uint32_t hostlong);//主机字节序转网络字节序（4个字节）转ip
uint16_t htons(uint16_t hostshort);//主机字节序转网络字节序（2个字节）转port
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
```

示例代码

```c
#include<arpa/inet.h>
#include<stdio.h>
int main(int argc,char *argv[]){
    char buf[4]={192,168,1,2};
    int num=*(int *)buf;
    int sum=htonl(num);
    unsigned char *p=&sum;
    printf("%d %d %d %d\n",*p,*(p+1),*(p+2),*(p+3));

    unsigned short a=0x0102;
    unsigned short b=htons(a);
    printf("%x\n",b);
    return 0;
}
```

```bash
2 1 168 192
201
```

说明我的电脑是小端。

### IP地址转换函数

```c
#include<arpa/inet.h>

int inet_pton(int af,const char *src,void *dst);
功能：将点分十进制串转成32位网络大端的数据
参数：af:
		AF_INET IPV4
        AF_INET6 IPV6
   	 src：点分十进制串的首地址
   	 dst:32位网络数据的首地址
返回值：
     成功：返回1
     失败：返回0
const char *inet_ntop(int af,const void *src,char *dst,socklen_t size);
功能：将32位大端的网络数据转成点分十进制串
参数：af:
		AF_INET IPV4
        AF_INET6 IPV6
   	 src：32位网络数据的首地址
   	 dst: 点分十进制串的首地址
     size:存储点分制串数组的大小 通常写16
返回值：
     存储点分制串数组的首地址。
支持IPV4和IPV6。
```

示例代码：

```c
#include<stdio.h>
#include<arpa/inet.h>

int main(int argc,char *argv[]){
    char buf[]="192.168.1.4";
    unsigned int num=0;
    inet_pton(AF_INET,buf,&num);
    unsigned char *p=(unsigned char *)&num;
    printf("%d %d %d %d\n",*p,*(p+1),*(p+2),*(p+3));
    char ip[16]="";
    inet_ntop(AF_INET,&num,ip,16);
    printf("%s\n",ip);
    return 0;
}
```

```bash
192 168 1 4
192.168.1.4
```

### ipv4套接字结构体

```c
 struct sockaddr_in {
   sa_family_t sin_family; /* address family: AF_INET */ 对应的协议（ipv4）
   in_port_t sin_port; /* port in network byte order */ 端口
   struct in_addr sin_addr; /* internet address */ ip地址
 };

 /* Internet address */
 struct in_addr {
   uint32_t s_addr; /* address in network byte order */ ip地址
 };
```

**ipv6套接字结构体太多了，这里不展示**

因为有这两种套接字结构体，所以我们要统一，方便函数编写。

**通用套接字结构体**

```c
struct sockaddr{
    sa_family_t sa_family; /* address family,AF_xxx*/
    char sa_data[14]; /*14 bytes of protocol address*/
};
```

### 网络套接字函数

tcp  特点：出错重传 每次发送数据，对方都会回ACK 可靠

#### 网络通信流程

![6](6.png)

#### 创建套接字函数socket()

```c
#include <sys/socket.h>
int socket(int domain,int type,int protocol);
功能：创建套接字
参数：domain:AF_INET
     type:SOCK_STREAM 流式套接字 用于TCP通信
     protocol:0
返回值：
     成功：返回文件描述符
     失败：返回-1
```

#### 连接服务器函数connect()

```c
#include <sys/socket.h>

int connect(int sockfd,
  const struct sockaddr * addr,
    socklen_t addrlen);
功能：连接服务器
参数：
    sockfd:socket套接字
    addr:ipv4套接字结构体地址
    addrlen:ipv4套接字结构体的长度
```

#### tcp客户端代码

```c
#include<arpa/inet.h>
#include<sys/socket.h>
#include<stdio.h>
#include<unistd.h>
int main(int argc,char *argv[]){
    //创建套接字
    int sock_fd;
    sock_fd=socket(AF_INET,SOCK_STREAM,0);
    if(sock_fd==-1){
        printf("连接失败");
    }else{
        printf("连接成功");
    }
    //连接服务器
    struct sockaddr_in addr;
    addr.sin_family=AF_INET;
    addr.sin_port=htons(12345);
    inet_pton(AF_INET,"192.168.149.1",&addr.sin_addr.s_addr);  
    connect(sock_fd,(struct sockaddr *)&addr,sizeof(addr));
    //读写数据
    char buf[1024]="";
    while(1){
        int n=read(STDIN_FILENO,buf,sizeof(buf));
        write(sock_fd,buf,n);//发送数据给服务器
        n=read(sock_fd,buf,sizeof(buf));
        write(STDOUT_FILENO,buf,sizeof(buf));

    }
    //关闭
    close(sock_fd);
    return 0;
}
```

#### tcp服务器通信流程

![7](7.png)

对于得到一个新的连接套接字（提取连接部分），服务器是要接受多个客户端连接的，所以先连接上，再分配新的连接和客户端通信。

![8](8.png)

#### bind函数

给套接字绑定固定的端口和ip

```c
#include <sys/socket.h>

int bind(int sockfd,
  const struct sockaddr * addr,
    socklen_t addrlen);
功能：给套接字绑定固定的端口和ip
参数：
    sockfd:套接字
    addr:ipv4套接字结构体地址
    addrlen:ipv4结构体的大小
返回值：
    成功：返回0
    失败：返回-1
```

#### listen函数

```c
#include <sys/socket.h>

int listen(int sockfd, int backlog);
功能：
    监听套接字
参数：
    sockfd:套接字
    backlog:已完成连接队列和未完成连接队列之和的最大值 一般写128
```

#### accept函数

```c
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr * _Nullable restrict addr,
  socklen_t * _Nullable restrict addrlen);
功能：
    从已完成连接队列提取新的连接，如果没有新的连接，accept会阻塞。
参数：
    sockfd:套接字
    addr:获取的客户端的ip和端口信息 ipv4套接字结构体
    addrlen:ipv4套接字结构体的大小的地址
返回值：
    新的已连接套接字的文件描述符
```

#### tcp服务器代码

```c

```

