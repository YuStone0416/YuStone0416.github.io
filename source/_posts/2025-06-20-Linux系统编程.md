---
title: Linux系统编程
date: 2025-06-20 21:26:00
comments: true
tags: Linux
urlname: Linux-System Programming
categories: 计算机学习
updated: 2025-06-28 21:26:00
---

## Linux常见目录

| 目录        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| `/`         | 根目录，所有目录的起点，Linux 文件系统的顶级目录             |
| `/bin`      | 存放常用的二进制可执行文件（如 `ls`、`cp`、`mv` 等），普通用户和系统都可使用 |
| `/sbin`     | 系统管理命令，只有 root 用户可用（如 `reboot`、`ifconfig`）  |
| `/etc`      | 配置文件目录（如 `/etc/passwd`、`/etc/fstab`、`/etc/ssh/sshd_config`） |
| `/home`     | 普通用户的家目录（如 `/home/user1`）                         |
| `/root`     | 超级用户（root）的家目录                                     |
| `/lib`      | 核心共享库和驱动模块，供 `/bin` 和 `/sbin` 下的程序使用      |
| `/usr`      | 存放用户应用程序和文件，子目录中包括 `/usr/bin`、`/usr/lib` 等 |
| `/usr/bin`  | 普通用户使用的应用程序（非基本命令）                         |
| `/usr/sbin` | 非系统引导时使用的系统管理员命令                             |
| `/var`      | 可变数据，如日志文件 `/var/log`、邮件、缓存、锁等            |
| `/tmp`      | 临时文件，系统重启后可能会被清空                             |
| `/opt`      | 第三方软件安装目录（如 Chrome、VMware 等）                   |
| `/dev`      | 设备文件（如硬盘 `/dev/sda`，终端 `/dev/tty`）               |
| `/proc`     | 虚拟文件系统，内核和进程信息（如 `/proc/cpuinfo`、`/proc/meminfo`） |
| `/sys`      | 另一种虚拟文件系统，提供与内核、设备驱动的交互接口           |
| `/boot`     | 存放启动相关文件，如内核、grub 等（如 `/boot/vmlinuz-*`）    |
| `/media`    | 可移动媒体挂载点（如 U 盘、光盘）                            |
| `/mnt`      | 临时挂载点，一般管理员手动挂载文件系统用                     |
| `/run`      | 系统运行时临时文件（如 PID、Socket）                         |
| `/srv`      | 提供服务的数据目录（如 Web 服务、FTP 服务的数据）            |

## Bash解析器常用快捷键

1.tap键

补齐命令，补齐路径，显示当前目录下的所有目录

2.清屏 clear

3.中断进程 ctrl+c

4 遍历输入的历史命令箭头上（ctrl+p）箭头下(ctrl+n)

5 光标相关操作

光标左移： ctrl+b（箭头左）

光标右移： ctrl+f(箭头右)

移动到头部: ctrl+a(home键)

移动到尾部：ctrl+e(end键)

6字符删除

删除光标前面的字符：ctrl+h(Backspace)

删除光标后面的字符：ctrl+d

光标后面的字符即光标覆盖的字符

删除光标前的所有内容：ctrl+u

删除光标后的所有内容：ctrl+k

## 终端相关快捷键

（终端一定要选中）

ctrl+shift+N 新建一个终端

ctrl+shift+T 在终端里新建一个标签

ctrl+D 关闭当前一个终端

## 内建命令和外部命令对比

内建命令 vs 外部命令 对比总结

| 比较项           | 内建命令（Builtin Command）         | 外部命令（External Command）             |
| ---------------- | ----------------------------------- | ---------------------------------------- |
| **定义**         | 由 Shell 内部直接实现的命令         | 是文件系统中的可执行程序（如 `/bin/ls`） |
| **执行速度**     | 快（不需新建进程）                  | 较慢（需 fork 子进程执行）               |
| **资源消耗**     | 少，执行在当前 Shell 进程中         | 多，执行时创建子进程                     |
| **路径查找**     | 不需要依赖 `PATH` 环境变量          | 需要从 `PATH` 中查找可执行文件           |
| **是否可以替换** | 一般不推荐重定义                    | 可以覆盖、替换或删改（如 alias 覆盖）    |
| **是否常驻内存** | 是，Shell 启动时加载                | 否，执行时加载，执行完释放               |
| **例子**         | `cd`, `echo`, `exit`, `pwd`, `type` | `ls`, `cp`, `gcc`, `vim`, `python`       |
| **查看方法**     | `type cd` → builtin                 | `type ls` → file                         |

命令类型查看方法

使用type命令

```bash
type [选项] 命令名
```

使用 -a 显示所有同名命令（包括 alias、builtin、文件）

使用 -t 显示类型（简洁）

## Linux命令格式

```bash
命令 [选项] [参数]
```

| 部分     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| **命令** | 要执行的操作，如 `ls`、`cp`、`mkdir` 等                      |
| **选项** | 用于控制命令行为的开关，通常以 `-` 或 `--` 开头，例如 `-l`、`--help` |
| **参数** | 命令作用的对象，通常是文件名、目录名、用户名等               |

选项类型说明

| 类型     | 示例     | 说明                                   |
| -------- | -------- | -------------------------------------- |
| 短选项   | `-l`     | 通常是一个字母，多个可组合（如 `-al`） |
| 长选项   | `--help` | 更易读，通常不可组合                   |
| 组合选项 | `-avz`   | 相当于 `-a -v -z`                      |

## 帮助文档查看方法

如果是内建命令（可以通过之前的type命令查看）使用 help +内建命令

```bash
help pwd
```

如果是外部命令 对应命令名 --help

```bash
ls --help
```

`man` 是 Linux 中最常用的命令之一，全称是 **manual（手册）**，用于查看各种命令、函数、配置文件的使用说明。它是学习和查找 Linux 命令最权威的工具。

`man` 命令基本语法：

```bash
man [选项] [命令名或函数名]
```

 man 手册的 9 个部分（章节）

| 章节号 | 内容                             | 示例             |
| ------ | -------------------------------- | ---------------- |
| 1      | 用户命令（常见终端命令）         | `man ls`         |
| 2      | 系统调用（内核提供的函数）       | `man 2 open`     |
| 3      | C 库函数                         | `man 3 printf`   |
| 4      | 设备文件和特殊文件               | `man 4 tty`      |
| 5      | 配置文件格式                     | `man 5 crontab`  |
| 6      | 游戏与趣味（极少）               |                  |
| 7      | 杂项（宏定义、协议、约定等）     | `man 7 signal`   |
| 8      | 系统管理员命令（只能 root 执行） | `man 8 ifconfig` |
| 9      | 内核开发接口（不常见）           |                  |

常用选项

| 选项        | 作用                                    |
| ----------- | --------------------------------------- |
| `-k 关键词` | 搜索相关命令（相当于 `apropos`）        |
| `-f 命令名` | 显示命令属于哪个章节（相当于 `whatis`） |
| `-a`        | 显示所有章节中匹配的 man 页             |
| `-M`        | 指定手册路径                            |
| `--help`    | 查看 man 自身帮助信息                   |

## 目录相关命令

### pwd

用于显示当前终端所在的**工作目录**（即当前绝对路径）。

### cd

```bash
cd [目录路径]
```

常见用法示例

| 命令            | 说明                                       |
| --------------- | ------------------------------------------ |
| `cd /home/user` | 切换到绝对路径 `/home/user` 目录           |
| `cd ..`         | 切换到上一级目录                           |
| `cd` 或 `cd ~`  | 切换到当前用户的主目录                     |
| `cd -`          | 切换到上一次所在的目录（切换目录的“切换”） |
| `cd ./folder`   | 切换到当前目录下的子目录 `folder`          |

### mkdir

用于**创建新目录**的命令，创建不了已存在目录。

```bash
mkdir [选项] 目录名
```

mkdir test 在当前目录下创建test文件夹

mkdir /tmp/test

mkdir file{1..100}在当前目录创建100个文件夹，file1,file2,file3...file100

mkdir "file{1..100}"在当前目录创建file{1..100}文件夹，只会创建一个。

mkdir "a b" 在当前目录创建a b一个文件夹。

mkdir a b 在当前目录创建a b两个文件夹。

| 选项      | 说明                                   |
| --------- | -------------------------------------- |
| `-p`      | 递归创建目录（父目录不存在时自动创建） |
| `-m MODE` | 设置新建目录的权限，如 `-m 755`        |
| `-v`      | 显示详细创建过程（verbose）            |

### rmdir

用法和mkdir相同

用于**删除空目录**的命令

| 命令             | 说明                                           |
| ---------------- | ---------------------------------------------- |
| `rmdir testdir`  | 删除当前目录下的 `testdir`（需为空）           |
| `rmdir -p a/b/c` | 递归删除空目录链：先删 `c`，再删 `b`，再删 `a` |
| `rmdir ./mydir/` | 删除当前目录中的 `mydir`（需为空）             |

| 选项                         | 说明                                   |
| ---------------------------- | -------------------------------------- |
| `-p`                         | 递归删除路径中的所有空目录（从子到父） |
| `--ignore-fail-on-non-empty` | 删除目录时忽略非空目录导致的错误       |

## Linux文件类型

常用的文件类型有七种：普通文件，目录文件，设备文件，管道文件，链接文件和套接字。

![1](1.png)

**普通文件** 是 Linux 中最常见的一类文件，主要用于存储用户数据。包括：

- 文本文件（如 `.txt`, `.c`, `.py`）
- 二进制文件（如 可执行程序、图片、音频等）
- 脚本文件（如 `.sh`, `.py`，可以被解释执行）

在 Linux 中，**目录文件（Directory File）** 是一种特殊的文件类型，用来组织和存放文件和其他目录（子目录）。
 它本质上是一个**保存了文件名和 inode 编号之间映射关系**的文件。

**设备文件**（Device File）是 Linux 中用于访问硬件设备的接口，本质上就是一种特殊的文件，程序通过它来与硬件设备通信。

设备文件通常位于 `/dev` 目录中。

常见设备文件举例

| 路径          | 类型     | 功能描述         |
| ------------- | -------- | ---------------- |
| `/dev/sda`    | 块设备   | 第一块硬盘       |
| `/dev/tty`    | 字符设备 | 当前终端         |
| `/dev/null`   | 字符设备 | 写入数据会被丢弃 |
| `/dev/zero`   | 字符设备 | 会源源不断输出 0 |
| `/dev/random` | 字符设备 | 伪随机数生成器   |

**管道文件**（或称命名管道，FIFO = First In First Out）是一种特殊文件，用于**在不同进程之间传输数据**。
 写入管道的数据会按顺序被读取，类似“排队喝水”的水管，先进先出。

管道文件与匿名管道不同之处在于它有名字，存在于文件系统中（通常创建在某个路径下），因此**不同进程不必有父子关系**也能通信。

**链接文件** 是指向另一个文件的引用，常用于：

- 创建多个路径指向同一个文件（节省空间）
- 为长路径或常用文件创建别名（提高效率）
- 实现共享与替代功能

| 类型                   | 描述                                                     | `ls -l` 标识 |
| ---------------------- | -------------------------------------------------------- | ------------ |
| **软链接**（符号链接） | 类似 Windows 快捷方式，是一个指向目标路径的独立文件      | `l`          |
| **硬链接**             | 直接指向目标文件的 inode，本质上是同一个文件的另一个名字 | `-`          |

在 Linux 中，你可以使用 `ls -l` 命令来区分各种文件类型。`ls -l` 输出的每一行开头的第一个字符表示文件类型。下面是 **七种常见文件类型及其 `ls -l` 显示符号**：

七种常见文件类型及其标识

| 文件类型         | `ls -l` 类型字符 | 示例路径                    | 含义说明                                   |
| ---------------- | ---------------- | --------------------------- | ------------------------------------------ |
| **普通文件**     | `-`              | `-rw-r--r-- file.txt`       | 常见的文本、二进制、可执行文件等           |
| **目录文件**     | `d`              | `drwxr-xr-x dir/`           | 存储文件的容器                             |
| **字符设备文件** | `c`              | `crw------- /dev/tty`       | 逐字符访问设备，如终端、串口等             |
| **块设备文件**   | `b`              | `brw-rw---- /dev/sda`       | 按块访问设备，如硬盘、U 盘等               |
| **管道文件**     | `p`              | `prw-r--r-- mypipe`         | 用于进程间通信的 FIFO 管道                 |
| **链接文件**     | `l`              | `lrwxrwxrwx link -> target` | 指向其他文件的软链接                       |
| **套接字文件**   | `s`              | `srwxrwxrwx socket`         | 进程间网络通信接口，如 `/tmp/.X11-unix/X0` |

## 文件相关命令

### ls命令

| 命令       | 含义                                    |
| ---------- | --------------------------------------- |
| `ls`       | 简单列出当前目录内容                    |
| `ls -a`    | 显示所有文件，包括隐藏文件（以`.`开头） |
| `ls -l`    | 以长格式列出，显示权限、类型、时间等    |
| `ls -lh`   | 长格式 + 人类可读大小（如 KB, MB）      |
| `ls -lt`   | 按修改时间排序，最新的在前              |
| `ls -r`    | 反向排序                                |
| `ls -R`    | 递归列出子目录                          |
| `ls -d */` | 只列出目录 ls -d只显示一个.             |

ls -l命令会输出长格式

```
权限       硬链接数 拥有者 所属组  大小    修改日期      文件名
drwxr-xr-x   2    user   user  4096   Jun 21 13:00  mydir
```

对权限部分说明一下权限部分总共10个字符

| 位置 | 含义                       |
| ---- | -------------------------- |
| 1    | 文件类型标识               |
| 2-4  | **拥有者（user）**权限     |
| 5-7  | **同组用户（group）**权限  |
| 8-10 | **其他用户（others）**权限 |

文件类型标识（第1个字符）

| 字符 | 类型         |
| ---- | ------------ |
| `-`  | 普通文件     |
| `d`  | 目录         |
| `l`  | 软链接       |
| `c`  | 字符设备文件 |
| `b`  | 块设备文件   |
| `p`  | 管道（FIFO） |
| `s`  | 套接字       |

权限字符说明（2-10位置）

| 字符 | 含义                             |
| ---- | -------------------------------- |
| `r`  | 读权限 (read)                    |
| `w`  | 写权限 (write)                   |
| `x`  | 执行权限 (execute)               |
| `-`  | 无该权限                         |
| `s`  | setuid/setgid 位（特殊执行权限） |
| `t`  | 粘滞位（sticky bit）             |

三组权限详解

| 组别         | 位置      | 含义                                 |
| ------------ | --------- | ------------------------------------ |
| **拥有者**   | 2~4 字符  | 拥有该文件/目录的用户权限            |
| **组用户**   | 5~7 字符  | 属于该文件组的用户权限               |
| **其他用户** | 8~10 字符 | 系统中除拥有者和组以外的所有用户权限 |

###  什么是通配符？

通配符是一种简化文件名匹配的符号，用于在命令中匹配多个文件或目录。它可以让你不用输入完整文件名，就能选中符合规则的文件。

常用的通配符类型

| 通配符   | 作用                              | 例子                | 匹配结果示例                                            |
| -------- | --------------------------------- | ------------------- | ------------------------------------------------------- |
| `*`      | 匹配任意数量的任意字符（包括0个） | `ls *.txt`          | 匹配所有以 `.txt` 结尾的文件                            |
| `?`      | 匹配任意一个单字符                | `ls file?.txt`      | 匹配 `file1.txt`、`fileA.txt`，但不匹配 `file10.txt`    |
| `[abc]`  | 匹配括号内的任意一个字符          | `ls file[123].txt`  | 匹配 `file1.txt`、`file2.txt`、`file3.txt`              |
| `[a-z]`  | 匹配指定范围内的任意一个字符      | `ls file[a-c].txt`  | 匹配 `filea.txt`、`fileb.txt`、`filec.txt`              |
| `[!abc]` | 匹配不在括号内的任意一个字符      | `ls file[!123].txt` | 匹配除 `file1.txt`、`file2.txt`、`file3.txt` 以外的文件 |

### touch命令

`touch` 是用来 **创建空文件** 或 **更新已有文件的时间戳** 的命令。

```bash
touch file.txt
```

如果 `file.txt` 不存在，会被创建为空文件；如果存在，文件时间被更新。

```bash
touch file1.txt file2.txt file3.txt
```

一次创建或更新多个文件。

```bash
touch file{2,3,4}#同时创建file2,file3,file4三个空文件和mkdir file{1..100}用法是一样的。
touch "file{2,3,4}"#创建file{2,3,4}这一个文件。
```

### cp命令

`cp` 是 Linux 中用于 **复制文件或目录** 的命令。

| 任务                | 命令示例                        | 说明                                  |
| ------------------- | ------------------------------- | ------------------------------------- |
| 复制文件            | `cp file1.txt file2.txt`        | 把 `file1.txt` 内容复制为 `file2.txt` |
| 复制文件到目录      | `cp file1.txt /home/user/docs/` | 把 `file1.txt` 复制进目录             |
| 复制目录（加 `-r`） | `cp -r dir1/ dir2/`             | 递归复制整个目录 `dir1` 到 `dir2` 中  |
| 保留属性复制文件    | `cp -p file1.txt file2.txt`     | 保留原文件的时间戳、权限等信息        |
| 强制覆盖目标文件    | `cp -f file1.txt file2.txt`     | 如果 `file2.txt` 存在，强制覆盖       |
| 复制并提示          | `cp -i file1.txt file2.txt`     | 有冲突时会提示确认                    |
| 显示复制过程        | `cp -v file1.txt file2.txt`     | 复制时显示详细过程（verbose 模式）    |

| 选项        | 含义                                         |
| ----------- | -------------------------------------------- |
| `-r`        | 递归复制目录（必须用于复制目录）             |
| `-i`        | 覆盖文件前提示确认                           |
| `-f`        | 强制覆盖目标文件而不提示                     |
| `-p`        | 保留原文件的属性（权限、时间等）             |
| `-u`        | 只在源文件较新时才复制                       |
| `-v`        | 显示复制过程（verbose）                      |
| `-a`        | 归档模式，等价于 `-dpR`，用于备份            |
| `--parents` | 保留源路径结构复制文件（适用于目录结构迁移） |

### rm命令

是用于在 Linux 中 **删除文件和目录** 的命令。注意：`rm` 删除后不会进入回收站，**无法轻易恢复**，请务必小心使用。

| 功能               | 命令                               | 说明                                  |
| ------------------ | ---------------------------------- | ------------------------------------- |
| 删除单个文件       | `rm file.txt`                      | 删除文件 `file.txt`                   |
| 删除多个文件       | `rm file1.txt file2.txt`           | 一次删除多个文件                      |
| 递归删除目录及内容 | `rm -r mydir/`                     | 删除目录 `mydir` 及其所有子目录和文件 |
| 强制删除文件/目录  | `rm -f file.txt` / `rm -rf mydir/` | 忽略不存在的文件，且不提示确认        |
| 删除前确认         | `rm -i file.txt`                   | 删除前逐一询问确认                    |
| 显示正在删除的文件 | `rm -v file.txt`                   | 显示被删除的文件名                    |

| 选项                  | 含义                                                         |
| --------------------- | ------------------------------------------------------------ |
| `-r` 或 `--recursive` | 递归删除目录及其内容（删除整个目录树）                       |
| `-f` 或 `--force`     | 强制删除，不提示，即使目标不存在也不报错                     |
| `-i`                  | 删除前询问确认，适合新手使用以防误删                         |
| `-I`                  | 删除多个文件或目录时才询问一次，比 `-i` 安全且不烦人         |
| `-v` 或 `--verbose`   | 显示正在删除的每一个文件或目录                               |
| `--preserve-root`     | 默认保护根目录 `/` 不被删除（系统安全机制，防止 `rm -rf /` 误操作） |

### mv命令

**移动文件或目录** 到新位置，**重命名** 文件或目录。

| 功能         | 命令示例                         | 说明                                      |
| ------------ | -------------------------------- | ----------------------------------------- |
| 移动文件     | `mv a.txt /home/user/docs/`      | 把 `a.txt` 移动到 `/home/user/docs/` 目录 |
| 重命名文件   | `mv old.txt new.txt`             | 将 `old.txt` 重命名为 `new.txt`           |
| 移动并重命名 | `mv a.txt /home/user/docs/b.txt` | 移动 `a.txt` 到新目录并改名为 `b.txt`     |
| 移动目录     | `mv dir1/ /home/user/backup/`    | 移动整个目录到新的路径                    |
| 覆盖已有文件 | `mv -f a.txt b.txt`              | 如果 `b.txt` 存在，则强制覆盖             |
| 覆盖前确认   | `mv -i a.txt b.txt`              | 如果 `b.txt` 存在，移动前会询问是否覆盖   |
| 显示移动过程 | `mv -v a.txt b.txt`              | 显示正在移动的内容                        |

| 选项 | 含义                                          |
| ---- | --------------------------------------------- |
| `-f` | 强制覆盖已有目标文件，不提示                  |
| `-i` | 如果目标文件存在，提示是否覆盖（interactive） |
| `-n` | 不覆盖已有的目标文件（no-clobber）            |
| `-v` | 显示移动过程（verbose）                       |
| `-u` | 仅在源文件较新或目标文件不存在时才移动        |

## 文件内容查看相关命令

### cat命令

用于 **查看、创建、合并文件** 内容，常用于快速查看文本文件内容。

| 选项 | 含义                              |
| ---- | --------------------------------- |
| `-n` | 给所有行编号                      |
| `-b` | 只对非空行编号                    |
| `-s` | 压缩连续空白行为一行              |
| `-T` | 显示 Tab 为 `^I`                  |
| `-E` | 显示每行结尾的 `$`（换行符可见）  |
| `-A` | 相当于 `-vET`，显示所有不可见字符 |

### less命令

用于**分页显示文件内容**的命令，支持 **向前/向后翻页浏览**，适合查看**大型文本文件**。它比 `cat` 更强大，且不会一次性加载全部内容到内存中。

使用时常用快捷键（进入 less 后）

| 快捷键    | 功能说明                |
| --------- | ----------------------- |
| `空格`    | 向下翻一页              |
| `b`       | 向上翻一页              |
| `Enter`   | 向下滚动一行            |
| `k`       | 向上一行（vi 风格）     |
| `j`       | 向下一行                |
| `G`       | 跳到文件末尾            |
| `g`       | 跳到文件开头            |
| `/关键词` | 向下搜索（如 `/error`） |
| `?关键词` | 向上搜索                |
| `n`       | 重复上一次搜索          |
| `N`       | 反向重复搜索            |
| `q`       | 退出 less               |

### head命令

`head` 用于**查看文件的前几行内容**，默认显示前 10 行。适合快速预览文件开头，尤其是大型文件或日志文件。

| 选项   | 说明                                             |
| ------ | ------------------------------------------------ |
| `-n N` | 显示前 N 行（如 `head -n 15 file.txt`）          |
| `-c N` | 显示前 N 个**字节**（如 `head -c 100 file.txt`） |
| `-q`   | 多文件时不显示文件名头部（quiet）                |
| `-v`   | 总是显示文件名头部（verbose）                    |

### tail命令

用于**显示文件的最后几行内容**，默认是最后 10 行。常用于：

- 查看日志尾部；
- 实时监控文件内容变化（配合 `-f` 选项）；
- 截取文件结尾部分数据。

```bash
tail /etc/passwd #默认显示后十行
tail -n 30 文件名 #显示后30行内容
tail -c 30 文件名 #显示后30个字符
```

## du和df命令

### du命令

查看**目录或文件占用的磁盘空间**，会考虑磁盘块对齐、文件系统元数据、软链接等因素。

| 参数            | 含义                                       |
| --------------- | ------------------------------------------ |
| `-h`            | 以**人类可读的方式**显示（如 KB、MB）      |
| `-s`            | 显示指定文件/目录占用的数据块              |
| `-a`            | 显示所有文件和目录的大小（默认只显示目录） |
| `--max-depth=N` | 显示目录深度（限制递归层数）               |

```bash
du -sh 文件名/目录
```

| 项目     | `ls -l`                    | `du -sh`                         |
| -------- | -------------------------- | -------------------------------- |
| 显示内容 | 文件本身大小（内容字节数） | 实际磁盘占用（包含对齐和元数据） |
| 对目录   | 显示目录结构本身大小       | 显示目录下所有内容实际占用       |
| 单位     | 字节（Bytes）              | 自动转换为 KB/MB/GB              |
| 应用场景 | 看文件大小/属性            | 查哪些文件/目录占空间最多        |

```bash
echo "hello" > file.txt
ls -l file.txt      # 显示 6 bytes
du -sh file.txt     # 显示 4.0K
```

### df命令

查看**整个磁盘的使用情况**

```bash
df -h # 显示所有文件系统的使用情况（人类可读格式）
df -h /home # 查看 /home 所在分区的磁盘使用情况
```

## 查找相关命令

### find

`find` 是 Linux 中功能非常强大的文件搜索命令，它可以根据名称、类型、时间、大小、权限等多种条件在目录中递归查找文件，还可以执行删除、移动、打印等操作。

```bash
find [搜索路径] [搜索条件] [处理动作]
```

按文件名查询：使用参数 -name

```bash
find ./ -name "*.txt" #查找当前路径下符合后缀是。txt的文件
```

按文件大小查询：使用参数 -size

```bash
find ./ -size +100k
```

+100k 表示大于100k的文件

-100k表示小于100k的文件

100k 表示等于100k的文件

大小方面：k小写，M大写

查询大小范围

```bash
find ./ -size +50k -size -100k
```

按文件类型查询：使用参数 -type

```bash
find ./ -type f #查询当前的普通文件
```

| 类型代号 | 含义               | 示例                                                         |
| -------- | ------------------ | ------------------------------------------------------------ |
| `f`      | 普通文件           | `find . -type f` 查找所有普通文件（这里不是-，要和ls -l的文件类型区分） |
| `d`      | 目录               | `find . -type d` 查找所有目录                                |
| `l`      | 符号链接（软链接） | `find . -type l` 查找所有软链接                              |
| `c`      | 字符设备文件       | `/dev/null` 等                                               |
| `b`      | 块设备文件         | 硬盘等块设备                                                 |
| `s`      | 套接字文件         | Socket 类型文件                                              |
| `p`      | 命名管道（FIFO）   | 通信用的特殊文件                                             |

### grep

`grep` 是 Linux 中非常常用的文本搜索工具，用于**在文件或标准输出中查找匹配的字符串**，功能强大，灵活，适合日志分析、配置文件搜索、编程辅助等场景。

```bash
grep [选项] "模式" [文件]
```

| 选项           | 含义说明                             |
| -------------- | ------------------------------------ |
| `-n`           | 显示匹配行的行号                     |
| `-i`           | 忽略大小写                           |
| `-v`           | 反向匹配（即显示不包含该字符串的行） |
| `-r` or `-R`   | 递归搜索目录下的所有文件             |
| `-l`           | 只列出匹配的文件名                   |
| `-c`           | 统计匹配的行数                       |
| `--color=auto` | 高亮显示匹配的内容                   |

```bash
grep -i "root" /etc/passwd #不分大小写，在passwd查找root
grep -w "hello" /etc/passwd #在passwd查找完全匹配hello单词的行
grep -r "u_char" ./  #递归搜索当前目录下的符合u_char的行
grep -i "hello" /etc/passwd --color=auto #在/etc/passwd文件中找hello并且忽略大小写，然后高亮显示匹配的关键字
```

## 管道

管道（|）一个命令的输出可以通过管道作为另一个命令的输入。

```bash
ifconfig | grep "ens33" #在ifconfig输出的文字查找存在ens33的行
```

## 压缩包管理

### tar

把一系列文件归档到一个文件，也可以把档案文件解开以恢复数据。

```bash
tar [选项] -f [文件名.tar] [要打包或解压的文件/目录]#f必须放到选项的最后
```

```bash
tar -cvf sysctl.tar sysctl #打包文件，但是不压缩
tar -xvf sysctl.tar #解包文件
tar -tvf sysctl.tar #查看压缩文件内容
```

### gzip

**对单个文件进行压缩或解压**，压缩率高、速度快，默认生成 `.gz` 文件。

tar和gzip命令结合使用实现文件打包，压缩。

tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般为xxx.tar.gz。

gzip单独使用，只可以对文件压缩和解压，不可以对目录。

```bash
gzip test1 test2 #不保留源文件压缩。 
```

tar和gzip结合对目录压缩

```bash
tar -czvf sysctl.tar.gz sysctl #打包和压缩文件
tar -xzvf sysctl.tar.gz #解包和解压文件
tar -xzvf sysctl.tar.gz -C /temp #解包和解压文件到temp目录
```

### bzip2

和gzip一样和tar结合。

```bash
tar -cjvf test.tar.bz2 test #生成一个bz2压缩包
tar -xjvf share.tar.bz2 #解压
```

### zip和unzip

通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。

```bash
zip [选项] 目标文件（没有扩展名）源文件/目录
unzip -d 解压后目录文件 压缩文件 #-d解压到指定目录
```

## 文件权限管理

访问权限说明：

读权限（r）

对文件而言，具有读取文件内容的权限；对目录而言，具有浏览目录的权限。

写权限（w）

对文件而言，具有新增，修改文件内容的权限；对目录而言，具有删除，移动目录内文件的权限。

可执行权限（x）

对文件而言，具有执行文件的权限；对目录而言，该用户具有进入目录的权限。

通常。Unix/Linux系统只允许文件的属主（所有者）或root用户改变文件的读写权限。

### chmod

`chmod`（**change mode**）是 Linux/Unix 系统中用于**修改文件或目录权限**的命令。它支持两种权限设置方式：**数字方式**和**符号方式**。

```bash
chmod [选项] 模式 文件名
```

符号方式：

```bash
chmod u/g/o/a +/-/= rwx 文件 #+添加权限 -撤销权限 =设定权限 u/g/o对应的是拥有者，同属组，其他。
chomd o+w a #向a的其他用户添加写权限
chomd u=rw,g=r,o=r a#把a的拥有者权限为re,同属组权限为r,其他用户权限为r。
```

数字方式：

```bash
#由于rwx通过二进制来区分 rwx就是111，十进制为7
#rwx   7
#rw-   6
#r--   4
#r-x   5
chomd 777 a#把a的对应用户的权限变为rwx.
```

### chown

`chown` 是 Linux/Unix 中用于更改文件或目录 **所属用户（owner）** 和 **所属用户组（group）** 的命令。

```bash
chown [选项] [新用户][:[新用户组]] 文件/目录
```

`新用户`：新的文件拥有者

`新用户组`：新的用户组（可选）

需要 `sudo` 权限（普通用户只能修改自己拥有的文件）

```bash
#把文件所有者修改为root用户
sudo chown root a
#把文件所属者改为yustone,所属组改为root
sudo chown yustone:root a
```

## 软件安装和卸载

### 使用包管理器安装和卸载

Ubuntu / Debian 系列

安装

```bash
sudo apt update          # 更新软件源
sudo apt install 软件名  # 安装软件
```

卸载

```bash
sudo apt remove 软件名           # 删除程序但保留配置文件
sudo apt purge 软件名            # 连配置文件一并删除
```

离线软件包安装：

```bash
sudo dpkg -i package.deb
```

离线软件包卸载：

```bash
sudo dpkg -r 软件名
```

使用 Snap 安装（跨平台容器化安装方式）

```bash
sudo snap install 软件名
```

使用 Snap 卸载（跨平台容器化安装方式）

```bash
sudo snap remove 软件名
```

从源代码编译安装

```bash
./configure
make
sudo make install
```

## 重定向

主要是把命令输出的内容（之前是屏幕）输入到文件里。

```bash
ls /etc/passwd > output.txt #标准正确输出重定向到output.txt（这里是覆盖原文件）
ls /etc/passwd >> output.txt #标准正确输出追加重定向到output.txt(这里是追加)
llll 2> error.txt #标准错误输出重定向到error.txt(这里是覆盖原文件)
llll 2>> error.txt #标准错误输出追加重定向到error.txt
lll 2> /dev/null #标准错误输出重定向到黑洞
ls ddddd /etc/passwd &> /dev/null #标准正确输出和标准错误输出全部重定向到黑洞。
ls ddddd /etc/passwd &>> output.txt #标准正确输出和标准错误输出以追加的方式全部重定向到output.txt.
```

## 其他命令

### tree

tree以树状形式查看指定目录内容。

```bash
tree 目录
```

### ln

ln命令主要用于创建链接文件。

链接文件分为软链接和硬链接：

硬链接只能链接普通文件，不能链接目录。软链接不占用磁盘空间，源文件删除则链接失效。

```bash
ln 源文件 链接文件 #硬链接
ln -s 源文件 链接文件 #软链接
```

如果没有-s选项代表建立一个硬链接文件，两个文件占用同一块的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s比较常用。如果软链接文件和源文件不在同一目录，源文件最好使用绝对路径，不要使用相对路径。软链接文件存储的是目标文件的路径。

## vim

`vim` 是一款强大的 **文本编辑器**，常用于 **Linux / Unix 系统编程、脚本编辑、配置文件修改等场景**。它是 `vi` 的增强版本，具有更强的功能，比如语法高亮、代码折叠、多窗口、多标签支持等。

### vim的三种模式

**普通模式**（Normal Mode）

**默认启动模式**，你一打开 Vim 就是在这个模式。

**作用**：浏览、复制、剪切、粘贴、删除、移动光标、跳转、执行命令等。

常用命令：

| 命令       | 说明                                      |
| ---------- | ----------------------------------------- |
| `h`/`l`    | 左/右移动光标                             |
| `j`/`k`    | 下/上移动光标                             |
| `[n]dd`    | 删除当前行开始的n行（准确说是剪切）       |
| [n]x       | 删除光标后n个字符                         |
| [n]X       | 删除光标前n个字符                         |
| `[n]yy`    | 复制从当前行开始的n行                     |
| `p`        | 粘贴                                      |
| `u`        | 撤销前一个命令                            |
| `Ctrl + r` | 还原（恢复）                              |
| `:`        | 进入命令模式                              |
| `i`、`a`   | 进入插入模式                              |
| mG/mgg     | 到指定行，m为目标行数                     |
| /字符串    | 从当前光标位置向下查找（n,N查找内容切换） |
| ?字符串    | 从当前光标位置向上查找（n,N查找内容切换） |

**插入模式**（Insert Mode）

**按 `i`、`a`、`o` 等从普通模式进入插入模式。**

**作用**：输入文字、写代码、编辑内容。

常用进入方式：

| 命令 | 含义                       |
| ---- | -------------------------- |
| `i`  | 在光标前插入               |
| `a`  | 在光标后插入               |
| `o`  | 在当前行下方新开一行并插入 |
| `I`  | 跳到行首插入               |
| `A`  | 跳到行尾插入               |

**退出插入模式**：按 `Esc` 返回普通模式。

**命令模式**（Command-Line Mode）

**按 `:` 从普通模式进入命令模式。**

用于输入各种操作命令，如保存、退出、查找、替换等。

常用命令：

| 命令             | 功能                                   |
| ---------------- | -------------------------------------- |
| `:w`             | 保存                                   |
| `:q`             | 退出                                   |
| `:wq` 或 `ZZ`    | 保存并退出                             |
| `:q!`            | 强制退出（不保存）                     |
| `:x`             | 等同于 `:wq`                           |
| `:/关键字`       | 向下查找关键字                         |
| `:s/旧/新/g`     | 当前行替换所有匹配项                   |
| :1,10s/abc/123/g | 把第一行到第十行之间的abc全部替换为123 |
| `:%s/旧/新/g`    | 全文替换所有匹配项                     |
| :w filename      | 保存到指定文件（绝对路径）             |
| :sp 文件名       | 当前文件和另一个文件水平分屏           |
| :vsp 文件名      | 当前文件和另一个文件垂直分屏           |
| ctrl+w+w         | 在多个窗口切换光标                     |

## gcc编译器

GCC（**GNU Compiler Collection**）是由 GNU 项目开发的一组编译器，最初是为了 C 语言开发的，现在支持多种编程语言

gcc编译器从拿到一个c源文件到生成一个可执行文件，中间一共经历了四个步骤：

![2](2.png)

```bash
gcc -E hello.c -o hello.i
gcc -S hello.i -o hello.s
gcc -c hello.s -o hello.o
gcc hello.o -o hello
./hello #执行
gcc 源文件 -o 可执行文件 #一步到位
gcc hello.c -o hello
./hello
```

| 选项              | 含义                                          |
| ----------------- | --------------------------------------------- |
| `-o`              | 指定输出文件名                                |
| `-Wall`           | 打开所有警告信息                              |
| `-g`              | 生成调试信息，用于 GDB 调试                   |
| `-O0/-O1/-O2/-O3` | 优化等级（0 表示无优化）                      |
| `-c`              | 只编译不链接，生成 `.o` 目标文件              |
| `-I`              | 添加头文件搜索路径                            |
| `-L`              | 添加库文件搜索路径                            |
| `-l`              | 链接指定的库（例如 `-lm` 表示链接 `math` 库） |
| -v/--version      | 查看gcc版本号                                 |
| -D                | 编译时定义宏                                  |

```bash
gcc -Wall test.c #显示所有的警告信息
gcc -Wall -Werror test.c #把警告信息当作错误处理
gcc tmp.c -DDEBUG #可以用来区分测试版和发布版,DEBUG是定义的宏
```

## 静态链接和动态链接

静态链接：由链接器在**链接**时把**库的内容加入到可执行程序中。**

优点：对运行环境的依赖较小，具有较好的兼容性。

缺点：生成的程序比较大，在装入内存消耗更多的时间。库函数有了更新，必须重新编译。

动态链接：链接器在**链接时仅仅建立和所需库函数的链接关系，在程序运行时才将所需资源调入可执行程序**。

优点：在需要的时候才会调入对应的资源函数。简化程序的升级，有着较小的程序体积，实现进程间的资源共享（避免重复拷贝）

缺点：依赖动态库，不能独立运行，动态库依赖版本问题严重。

### 静态和动态编译对比

我们编写的应用程序大量用到了库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入-static参数。

```bash
gcc test.c -o test
gcc -static test.c -o test
```

静态编译是要比动态编译程序大的多。

## 静态库和动态库

静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。按照习惯，一般以".a"作为文件后缀名。静态库的命名一般分为三个部分：前缀：lib,库名称：自己定义。后缀：.a。最终静态库的名字为libxxx.a

### 静态库制作：

![3](3.png)

```bash
gcc -c add.c -o add.o #-c是只编译不链接输出.o文件
gcc -c sub.c -o sub.o
gcc -c mul.c -o mul.o
gcc -c div.c -o dic.o
ar -rcs libtest.a add.o sub.o mul.o div.o#使用打包工具ar将准备好的.o文件打包为.a文件libtest.a
```

在使用ar工具需要添加参数：rcs 

r更新，c创建，s建立索引

### 静态库使用：

静态库制作完成之后，需要将.a文件和头文件一起发布给用户。假设测试文件是main.c,静态库文件为libtest.a，头文件为head.h

编译命令：

```bash
gcc main.c -L./ -I./ -ltest -o main#注意这里链接库的名字
```

-L：表示要连接的库所在目录。

-ltest:指定链接时需要的库，去掉前缀和后缀

-I(这里是大写的i):表示要连接的头文件目录

### 动态库制作

共享库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。

动态库在程序运行时才被载入，也解决了静态库对程序的更新，部署和发布的再次编译的问题，用户只需要更新动态库即可，增量更新。

一般以".so"作为文件后缀名。共享库的命名一般分为三个部分：前缀lib,库名称:自己定义，后缀：.so。所以最终的动态库的名字应该为：libxxx.so。

```bash
#生成目标文件，此时要加编译选项：-fPIC(fpic)参数-fPIC创建与地址无关的编译程序（pic,position independent code）,是为了能在多个应用程序间共享。
gcc -fPIC -c add.c
gcc -fPIC -c sub.c
gcc -fPIC -c mul.c
gcc -fPIC -c div.c
#生成共享库，此时要加链接器选项：-shared(指定生成动态链接库)
gcc -shared add.o sub.o mul.o div.o -o libtest.so
#通过nm命令查看对应的函数
nm libtest.so | grep "add"
#通过ldd命令查看可执行文件依赖的动态库
ldd test
```

### 动态库使用

引用动态库编译成可执行文件（和静态库一样）

```bash
gcc main.c -L./ -I./ -ltest -o main#注意这里链接库的名字
```

这一步是可以过的，但是到了，执行main时发现找不到对应文件。第一种就是把libtest.so复制到/lib里（需要sudo,这个方法不推荐，最好不要动Linux原本文件，覆盖了就不好玩了。）

```bash
gcc main.c -I./ -ltest -o main#注意这里链接库的名字,执行可执行文件就可以执行了，这种方法不推荐
```

### 动态库加载失败问题解决

当系统加载可执行代码，能够知道其所依赖的库的名字，但还需要知道其绝对路径。此时就需要系统动态载入器（dynamic linker/loader）。对于elf格式的可执行程序，是由ld-linux.so*来完成，他先后搜索elf文件的DT_RPATH段—环境变量LD_LIBRARY_PATH—/etc/ld.so.cache文件列表—/lib/,/usr/lib目录找到库文件后将其载入内存。

拷贝自己制作的共享库到/lib或者/usr/lib(不能是/lib64目录)

临时设置LD_LIBRARY_PATH(只在当前终端生效):

```bash
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径#在原环境变量追加新的变量，库路径为绝对路径。
```

永久设置:把export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径这段话，设置到~/.bashrc 

```bash
source ~/.bashrc #让配置文件生效
```

除了以上三种还有两种将其添加到/etc/ld.so.conf,这里只需要添加绝对路径，然后sudo ldconfig -v使路径生效。

还有使用符号链接，但一定要使用绝对路径。

```bash
sudo ln -s 库文件的绝对路径 /lib/库文件
```

## GDB调试器

GDB主要完成下面四个功能：

1.启动程序，可以按照你的自定义的要求随心所欲的运行程序。

2.可让被调试的程序在你指定的断点停住。

3.当程序被停住时，可以检查此时你的程序中所发生的事。

4.动态的改变你程序的执行环境。

### 生成调试信息

一般来说GDB主要调试的是C/C++的程序，要调试C/C++的程序，首先在编译时，我们必须把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的-g参数可以做到这一点。

```bash
gcc -g hello.c -o hello
g++ -g hello.c -o hello
```

### 启动GDB

启动gdb:**gdb program**

program也就是你的执行文件，一般在当前目录下。

设置启动参数:启动后设置

```bash
set args #可指定运行参数
set args 10 20 30 40 "hello world"
show args #命令可以查看设置好的运行参数
```

**启动程序：**

run:程序开始执行，如果有断点，停在第一个断点处。

start:程序向下执行一行。

n:执行下一步。

### 显示源代码

用list（也可直接打l）命令来打印程序的源代码。默认打印10行。

```bash
list function#显示函数名为function的函数的源码
set listsize count #设置一次显示源码的行数默认是10行
show listsize #查看当前listsize的设置
```

### 断点操作

简单断点:

break设置断点，可以简写为b

```bash
b 10 #设置断点，在源程序第十行
b func #设置断点，在func函数入口处
```

多文件设置断点

```bash
break filename:linenum #在源文件filename的linenum行处停住
break filename:function #在源文件filename的function函数的入口处停住
break class::function或者function(type,type) #在类class的function函数入口处停住
break namespace::class::function #在名称空间为namespace的类class的function函数的入口处停住。
```

查询所有断点

```bash
info b
info break
i break
i b
```

### 条件断点

一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。

设置一个条件断点：

```bash
b test.c:8 if Value == 5 #对test.c文件的当变量Value满足为5时，在test.c文件的第8行产生断点
```

### 维护断点

delete 范围 删除指定的断点，其简写命令为d。如果不指定断点号，则表示删除所有的断点。

```bash
d 10-12 #删除编号为10-12的断点。编号可以使用i b命令查看
```

比删除更好的一种方法时disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可。

```bash
disable 断点编号 #使指定断点无效，简写命令是dis。如果什么都不指定，表示disable所有的停止点。
enable 断点编号 #使无效断点生效，简写命令是ena。如果什么都不指定，表示enable所有的停止点
```

### 调试代码

```bash
run #运行程序，可简写为r。程序开始执行，如果有断点，停在第一个断点处。
next #单步跟踪，函数调用当作一条简单语句执行，可简写为n。
step #单步跟踪，函数调用进入被调用函数体内，可简写为s。
finish #退出进入的函数
until #在一个循环体单步跟踪时，这个命令可以运行程序直到退出循环体，可简写为u。
continue #继续运行程序，停在下一个断点的位置，可简写为c。
quit #退出gdb,可简写为q。
```

### 数据查看

```bash
#查看运行时的数据
#print打印变量，字符串，表达式等的值，可简写为p。
p count #打印count的值
```

### 自动显示

可以设置一些自动显示的变量，当程序停住时，或在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display

```bash
display 变量名 #在run启动程序后，使用该命令。
info display #查看display设置的自动显示的信息（可以看到对应变量名的编号）
undisplay num #info display是显示的编号 使对应编号的自动显示功能失效。
delete display dnums #删除自动显示，dnums意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围的编号，可以用减号表示。
disable display dnums
enable display dnums
disable和enable#不删除自动显示的设置，而只是让其失效和恢复。
```

### 查看修改变量的值

```bash
ptype width #查看变量width的类型
p width #打印变量width的值 p是print命令的缩写。
set var width=47 #将变量var值设置为47。在改变程序变量取值时，最好都使用set var格式的GDB命令。
```

## 自动化编译工具Makefile

make是个命令工具。

```bash
sudo apt install make #下载make命令
```

### Makefile语法规则

一条规则：

```bash
目标：依赖文件列表
<Tab>命令列表
```

```makefile
all:test1 test2
	echo "hello all"
	
test1:
	echo "hello test1"

test2:
	echo "hello test2"
#总共三条规则
#执行结果：make -f 1.mk
echo "hello test1"
hello test1
echo "hello test2"
hello test2
echo "hello all"
hello all
```

Makefile基本规则三要素：

目标:

​	通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作的名称。

依赖文件：

​	用来输入从而产生目标的文件。

​	一个目标通常有几个依赖文件（可以没有）

命令：

​	make执行的动作，一个规则可以含几个命令（可以没有）

​	有多个命令，每个命令占一行。

### make命令格式

```bash
make [-f file][options][targets]
[-f file]:
make默认在工作目录中寻找为GNUmakefile,makefile,Makefile的文件作为makefile输入文件。
-f可以指定以上名字以外的文件作为makefile输入文件。
[options]:
-v 显示make工具的版本
-w 在处理makefile之前和之后显示工作路径
-C dir 读取makefile之前改变工作路径至dir目录
-n 只打印要执行的命令但不执行
-s 执行但不显示执行的命令
[targets]:
若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个规则
指定了make工具要实现的目标，目标可以是一个或多个（多个目标用空格隔开）
make test1 -f 1.mk #就会执行目标为test1对应的语句。
```

### Makefile示例

测试程序：test.c add.c sub.c mul.c div.c add.h sub.h mul.h div.h

```makefile
#最简单的Makefile(首先vim Makefile)
test:test.c add.c sub.c mul.c div.c
	gcc test.c add.c sub.c mul.c div.c -o test
```

缺点：效率低，修改一个文件，所有文件都要重新编译。

```makefile
test:test.o add.o sub.o mul.o div.o 
	gcc test.o add.o sub.o mul.o div.o -o test
add.o:add.c
	gcc -c add.c -o add.o
sub.o:sub.c
	gcc -c sub.c -o sub.o
mul.o:mul.c
	gcc -c mul.c -o mul.o
div.o:div.c
	gcc -c div.c -o div.o
test.o:test.c
	gcc -c test.c -o test.o
```

这样，下次编译，他只会编译你修改的文件，最后再链接，这样是比较高效的。

### Makefile中的变量

在Makefile中使用变量有点类似c语言的宏定义，使用该变量相当于内容替换，使用变量可以使Makefile易于维护。如果.o文件很多，难道我们要一个一个打吗，这也未免太麻烦，还可能漏打。

#### 自定义变量

定义变量：

```makefile
变量名=变量值
```

引用变量：

```makefile
$(变量名)或${变量名}
```

makefile的变量名：

makefile变量名可以以数字开头。

变量是大小写敏感的。

变量一般在makefile的头部定义

变量几乎可在makefile的任何地方使用

```makefile
OBJS = test.o add.o sub.o mul.o div.o
test:$(OBJS)
	gcc $(OBJS) -o test
add.o:add.c
	gcc -c add.c -o add.o
sub.o:sub.c
	gcc -c sub.c -o sub.o
mul.o:mul.c
	gcc -c mul.c -o mul.o
div.o:div.c
	gcc -c div.c -o div.o
test.o:test.c
	gcc -c test.c -o test.o
```

除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户使用，我们可以直接对其进行赋值。

```makefile
CC=gcc
CPPFLAGS:
CFLAGS:
LDFLAGS:
```

