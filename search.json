[{"title":"MYSQL learning","path":"/2025/07/25/MYSQLlearning/","content":"MySQL基础MySQL介绍 关系型数据库(有行有列) SQLite(进程内的db) NOSQL(非关系数据库)键值对（key-value）:redis leveldb rocksdb 大数据分析列式数据库 Hbase 大家熟悉的关系型数据库还有SQL Server,Oracle,MySQL,MariaDB,DB2 MySQL区别于其他关系型数据库最大的一个特点就是支持插件式的存储引擎，支持如InnoDB,MyISAM,Memory等 MySQL设计成CS模型 MySQL的服务器模型采用的是IO复用+可伸缩的线程池，是实现网络服务器的经典模型。用的是select+线程池。这里为什么不设计成epoll+线程池，或者更高效的模型，用select,因为网络IO快，但是MySQL还需要把数据存储到磁盘，磁盘IO速度是比较慢的，所以速度匹配即可，没必要做那么快。 Windows下MySQL安装目录中有一个my.ini文件，可以做一些配置调优。在data文件夹中，每建立一个数据库会有一个文件夹与其对应。 Linux下mysql的配置文件 etcmy.cnf，没有可以自己创建 #在root用户下netstat -tanp #查看mysql是否启动,这个命令主要显示当前系统的所有 TCP 连接及其状态，并显示对应的进程信息。service mysql start #启动mysql MySQL数据类型MySQL数据类型定义了数据的大小范围，因此使用时选择合适的类型，不仅会降低表占用的磁盘空间，间接减少了磁盘IO的次数，提高了表的访问效率，而且索引的效率也和数据的类型息息相关。 整数类型（Integer Types） 类型 大小（字节） 范围（有符号） 范围（无符号） 描述 TINYINT 1 -128 到 127 0 到 255 很小的整数 SMALLINT 2 -32,768 到 32,767 0 到 65,535 小整数 MEDIUMINT 3 -8,388,608 到 8,388,607 0 到 16,777,215 中等大小的整数 INT 或 INTEGER 4 -2,147,483,648 到 2,147,483,647 0 到 4,294,967,295 常用整数类型 BIGINT 8 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 0 到 18,446,744,073,709,551,615 大整数 可加上 UNSIGNED 修饰符来存储更大的非负整数 age INT(9)：整型占用内存的大小是固定的，和具体的类型是强相关的。(M)只是代表整数显示的宽度 浮点与定点类型（Floating-Point and Fixed-Point Types）推荐DECIMAL,FLOAT和DOUBLE数据越界不会报错，DECIMAL会报错 类型 描述 范围和精度 FLOAT(M,D) 单精度浮点数 近似值，4字节，M是总位数，D是小数位数 7位精度 DOUBLE(M,D) 或 REAL(M,D) 双精度浮点数 近似值，8字节，M是总位数，D是小数位数 15位精度 DECIMAL(M,D) 或 NUMERIC(M,D) 定点数 精确值，适合存储货币等对精度要求高的场景 M: 精度（总位数），D: 小数位数 DECIMAL 使用字符串进行存储，防止浮点误差 如果 M 和 D 不指定，MySQL 默认为 DECIMAL(10,0) 字符型类型 类型 最大长度 是否定长 是否可设默认值 特点说明 典型用途 CHAR(M) 最多 255 字符 ✅ ✅ 固定长度，右侧自动补空格 固定长度：手机号、身份证 VARCHAR(M) 取决于字符集（如 utf8mb4 最多 21844） ❌ ✅ 变长字符串，节省空间，需额外1-2字节 姓名、标题、备注 TINYTEXT 255 字节 ❌ ❌ 极短文本，不能设默认值 简短评论、小段文字 TEXT 64 KB ❌ ❌ 常用文本类型，不能设默认值 文章正文、用户简介 MEDIUMTEXT 16 MB ❌ ❌ 中大型文本 博文、报告内容 LONGTEXT 4 GB ❌ ❌ 超大文本 大文档、日志 类型 最大长度 特点说明 用途举例 BINARY(M) 最多 255 字节 类似 CHAR，存储二进制数据，定长 加密哈希、固定密钥存储 VARBINARY(M) 最多 65535 字节 类似 VARCHAR，变长二进制字符串 二进制令牌、签名 TINYBLOB 255 字节 与 TINYTEXT 类似，但用于二进制数据 小图标、缩略图 BLOB 64 KB 与 TEXT 类似，用于二进制内容 图像、音频、文件 MEDIUMBLOB 16 MB 中等大小二进制对象 视频、音频中等资源 LONGBLOB 4 GB 超大二进制对象 文件存储、大附件 日期和时间类型 类型 占用空间 范围格式 精度 用途示例 DATE 3 字节 1000-01-01 到 9999-12-31 到“日” 出生日期、订单日期 TIME 3 字节 -838:59:59 到 838:59:59 到“秒” 持续时间、工时 DATETIME 8 字节 1000-01-01 00:00:00 到 9999-12-31 23:59:59 到“秒” 记录某一精确时刻 TIMESTAMP 4 字节 1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 到“秒” 创建时间、修改时间 YEAR 1 字节 1901 到 2155 到“年” 出厂年份、学年 枚举与集合类型（可存储预定义字符串） 类型 特点说明 示例用途 ENUM(...) 从固定字符串列表中选一个值，实际存储为整数索引（1字节） 性别、状态（如 男,女、启用,禁用） SET(...) 可多选，存储为位图（1~8字节），最多支持 64 个选项 标签、用户权限、兴趣爱好 MySQL运算符算数运算符 运算符 含义 示例 结果 + 加法 5 + 3 8 - 减法 5 - 3 2 * 乘法 5 * 3 15 / 除法 5 / 2 2.5 DIV 整除 5 DIV 2 2 % 取模（余数） 5 % 2 或 5 MOD 2 1 MOD 同 % 5 MOD 3 2 逻辑运算符 运算符 名称 示例 说明 AND 逻辑与 age 18 AND gender = M 两个条件都为真，结果才为真 OR 逻辑或 score 90 OR grade = A 至少一个条件为真，结果为真 NOT 逻辑非 NOT (age 18) 取反，原来为真变为假，反之亦然 XOR 逻辑异或 TRUE XOR FALSE 仅当两个值不同，结果才为真 ! 逻辑非（简写） !is_deleted 等价于 NOT is_deleted 与（MySQL兼容） a 5 b 10 等价于 AND 逻辑或 比较运算符 运算符 含义 示例 结果 = 等于 age = 18 true 或 false != 或 不等于 name != Tom true 或 false 大于 score 60 true 或 false 小于 score 60 true 或 false = 大于等于 score = 90 true 或 false = 小于等于 score = 100 true 或 false = 安全等于（支持 NULL） a = NULL true if both NULL IS NULL 判断是否为 NULL birthday IS NULL true 或 false IS NOT NULL 非 NULL email IS NOT NULL true 或 false BETWEEN ... AND ... 在区间内 score BETWEEN 60 AND 90 含头尾：60 ≤ score ≤ 90 NOT BETWEEN ... AND ... 不在区间 age NOT BETWEEN 18 AND 25 true 或 false IN (...) 属于集合 city IN (Beijing, Shanghai) 是否存在于集合中 NOT IN (...) 不属于集合 status NOT IN (A, B) true 或 false LIKE 模糊匹配（单行） name LIKE J% J开头的字符串 NOT LIKE 非匹配 email NOT LIKE %.com 不以.com结尾 REGEXP 或 RLIKE 正则匹配 name REGEXP ^A.* 匹配正则表达式 MySQL常用函数 分类 函数名 功能描述 示例 示例结果 字符串函数 CONCAT(str1, str2, ...) 字符串连接 CONCAT(Hello, World) HelloWorld LENGTH(str) 字节长度（utf8中一个汉字3字节） LENGTH(abc) 3 CHAR_LENGTH(str) 字符长度（汉字算1个字符） CHAR_LENGTH(你好) 2 UPPER(str) 转大写 UPPER(abc) ABC LOWER(str) 转小写 LOWER(ABC) abc REPLACE(str, from_str, to_str) 字符串替换 REPLACE(abcabc, a, x) xbcxbc SUBSTRING(str, pos, len) 截取字符串 SUBSTRING(abcdef, 2, 3) bcd TRIM(str) 去除字符串首尾空格 TRIM( abc ) abc 数值函数 ABS(n) 绝对值 ABS(-10) 10 ROUND(n, d) 四舍五入到小数点后 d 位 ROUND(3.14159, 2) 3.14 CEIL(n) 向上取整 CEIL(2.3) 3 FLOOR(n) 向下取整 FLOOR(2.7) 2 MOD(a, b) 取模 MOD(10, 3) 1 RAND() 生成0到1之间随机数 RAND() 0.123456789（示例） TRUNCATE(n, d) 截断数字到小数点后 d 位 TRUNCATE(3.4567, 2) 3.45 日期时间函数 NOW() 当前日期时间 NOW() 2025-07-25 20:30:00 CURDATE() 当前日期 CURDATE() 2025-07-25 CURTIME() 当前时间 CURTIME() 20:30:00 DATE_FORMAT(date, fmt) 格式化日期 DATE_FORMAT(NOW(), %Y-%m-%d) 2025-07-25 DATEDIFF(a, b) 计算日期差（a - b）天数 DATEDIFF(2025-08-01, 2025-07-25) 7 TIMESTAMPDIFF(unit, a, b) 计算两时间差，单位可选 TIMESTAMPDIFF(DAY, 2025-07-25, 2025-08-01) 7 ADDDATE(date, n) 日期加n天 ADDDATE(2025-07-25, 5) 2025-07-30 SUBDATE(date, n) 日期减n天 SUBDATE(2025-07-25, 5) 2025-07-20 聚合函数 COUNT(*) 统计行数 SELECT COUNT(*) FROM users 100 SUM(col) 求和 SUM(price) 12345.67 AVG(col) 平均值 AVG(score) 87.5 MAX(col) 最大值 MAX(age) 60 MIN(col) 最小值 MIN(created_at) 2020-01-01 条件判断函数 IF(expr, a, b) 条件判断，类似三元运算符 IF(score 60, 及格, 不及格) 及格 IFNULL(expr, val) 如果 expr 为 NULL，返回 val IFNULL(name, 未知) 未知 NULLIF(a, b) 若 a b，则返回 NULL，否则 a NULLIF(1,1) → NULL NULL CASE WHEN ... THEN ... ELSE ... END 多条件判断 参见下方示例 MySQL完整性约束主键约束primary key(唯一且不为空) 自增键约束auto_increment(整型自增) 唯一键约束unique(不可以重复但是可以为空) 非空约束not null 默认值约束default 外键约束foreign key CREATE TABLE USER(id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT COMMENT 用户的主键id,nickname varchar(50) UNIQUE NOT NULL COMMENT 用户的昵称,age TINYINT UNSIGNED NOT NULL DEFAULT 18,sex ENUM(male,female)); +----------+-----------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-----------------------+------+-----+---------+----------------+| id | int unsigned | NO | PRI | NULL | auto_increment || nickname | varchar(50) | NO | UNI | NULL | || age | tinyint unsigned | NO | | 18 | || sex | enum(male,female) | YES | | NULL | |+----------+-----------------------+------+-----+---------+----------------+4 rows in set (0.03 sec) 关系型数据库表设计好的设计减少数据冗余。 一对一关系在子表中增加一列，关联父表的主键 用户User表：父表uid name age sex1000\tzhang\t20 M1020\tliu 21 W2010 Wang\t22 M身份信息Info 子表uid cardid addrinfo1020 112233 aaa2010 334455 bbb1000\t556677 ccc 一对多在子表中增加一列，关联父表的主键 电商系统：用户User,商品Product,订单Order用户和商品：没有关系用户和订单：一对多的关系 User为父表 Order为子表 在子表中增加一列，关联父表的主键商品和订单：多对多的关系User: uid name age sex1000\tzhang\t20 M1020\tliu 21 W2010 Wang\t22 MProduct:pid pname\tprice\tamount1 手机 600 1002 笔记本 2000\t503 电池 10 200Order:orderid uid pid number money\ttotalprice\taddrinfoO1000 1000\t1 1 600 4640 海定区O1000 1000\t2 2 4000\t4640 海定区O1000 1000\t3 5 40 4640 海定区O2000 2010\t2 1 2000\t2000 平谷区 多对多增加一个中间表 电商系统：用户User,商品Product,订单Order用户和商品：没有关系用户和订单：一对多的关系 User为父表 Order为子表 在子表中增加一列，关联父表的主键商品和订单：多对多的关系 User: uid name age sex1000\tzhang\t20 M1020\tliu 21 W2010 Wang\t22 MProduct:pid pname\tprice\tamount1 手机 600 1002 笔记本 2000\t503 电池 10 200Order:orderid uid pid number money\ttotalprice\taddrinfoO1000 1000\t1 1 600 4640 海定区O1000 1000\t2 2 4000\t4640 海定区O1000 1000\t3 5 40 4640 海定区O2000 2010\t2 1 2000\t2000 平谷区商品和订单：多对多的关系 发现Order表太过冗余了，所以增加一个中间表订单内容表OrderList:orderid pid number\tmoneyO1000 1 1 600O1000 2 2 4000O1000 3 4 40O2000 2 1 2000这里中间表可以orderid,pid为联合主键。所以Order表改变Order:orderid uid totalprice\taddrinfoO1000 1000 4640 海定区O2000 2010 2000 平谷区 关系型数据库范式应用数据库范式可以带来许多好处，最重要的到处归结为三点： 减少数据冗余(这是最主要的好处，其他好处都是由此而附带的) 消除异常(插入异常，更新异常，删除异常) 让数据组织的更加和谐 但是数据库范式绝对不是越高越好，范式越高，意味着表越多，多表联合查询的机率就越大，SQL的效率就越低。 第一范式（1NF）每一列保持原子特性 列都是基本数据项，不能够再进行分割，否则设计成一对多的实体关系。例如表中的地址字段，可以再细分为省，市，区等不可再分割的字段。不符合第一范式不能称作关系型数据库。 第二范式（2NF）属性完全依赖于主键，主要针对联合主键 非主属性完全依赖于主关键字，如果不是完全依赖主键，应该拆分成新的实体，设计成一对多的实体关系。 例如：选课关系表为SelectCourse(学号，姓名，年龄，课程名称，成绩，学分),(学号，课程名称)是联合主键，但是学分字段只和课程名称有关，和学号无关，相当于只依赖联合主键的其中一个字段，不符合第二范式。姓名，年龄不符合第二范式 所以这里需要拆分学生表学号 姓名 年龄课程表课程id\t课程名称\t学分中间表：选课情况学号 课程id 成绩 第三范式（3NF）属性不依赖于其他非主属性 示例：学生关系表为Student(学号，姓名，年龄，所在学院，学院地点，学院电话)，学号是主键，但是学院电话只依赖于所在学院，并不依赖于主键学号，所以不符合第三范式，应该把学院专门设计成一张表，学生表和学院表，两个是一对多的关系。 一般关系型数据库满足第三范式就可以了。 BC范式（BCNF）每个表中只有一个候选键 第四范式（4NF）消除表中的多值依赖 MySQL核心SQL结构化查询语句SQLSQL是结构化查询语言，它是关系型数据库的通用语言。 SQL主要可以划分三个类别： DDL语句：数据定义语言，这些语句定义了不同的数据库，表，列，索引等数据库对象的定义。通常的语句关键字主要包括create,drop,alter等。 DML语句：数据操纵语句，用于添加，删除，更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括insert,delete,update和select等。 DCL语句：数据控制语句，用于控制不同的许可和访问级别的语句。这些语句定义了数据库，表，字段，用户的访问权限和安全级别。主要的语句关键字包括grant,revoke等。 库操作#查询数据库show databases;#创建数据库create database ChatDB;#删除数据库drop database ChatDB;#选择数据库use ChatDB; 表操作查看表 show tables; 创建表 create table user( id int unsigned primary key not null auto_increment, name varchar(50) unique not null, age tinyint not null, sex enum(M,W) not null)engine=INNODB default charset=utf8; 查看表结构 desc user; 查看建表sql show create table user\\G 删除表 drop table user; CRUD操作insert增加insert into user(nickname,name,age,sex) values(fixbug,zhangsan,22,M);insert into user(nickname,name,age,sex) values(666,li si,21,W),(888,gao yang,20,M); 这里有个问题：就是一次全插入和多次插入最后结果都是相同的，那么他们有什么区别。 由上图，多次插入会导致tcp连接次数增多，消耗资源。 update修改update user set age=23 where name=zhangsan;update user set age=age+1 where id=3; delete删除delete from user where age=23;delete from user where age between 20 and 22;delete from user; select查询select * from user;select id,nickname,name,age,sex from user;select id,name from user;select id,nickname,name,age,sex from user where sex=M and age=20 and age=25;select id,nickname,name,age,sex from user where sex=M and age between 20 and 25;select id,nickname,name,age,sex from user where sex=W or age=22; 去重distinct select distinct name from user; 空值查询 is [not] null select * from user where name is null; union合并查询 把两个结果合并起来，union默认去重，不用修饰distinct，all表示显示所有重复值。 select country from websites union all select country from apps order by country; 带in子查询 [不]包含这些元素 [not] in(元素1，元素2，…，元素3) select * from user where id in(10,20,30,40,50);select * from user where id not in(10,20,30,40,50);select * from user where id in(select stu_id from grade where average=60.0); 分页查询 select id,nickname,name,age,sex from user limit 10;select id,nickname,name,age,sex from user limit 2000,10#偏移2000，再取10个 explain select * from user where name=zhangsan;explain:查看SQL语句的执行计划(但是MySQL的自身优化检测不到，可能体现的数据不对)，主键会注册主键索引，唯一键会注册索引，通过索引查询，直接查到（查一次），不需要遍历去查。如果通过没有注册索引的字段去查询的话，就可能变成整表查询（查很多次）。 select id,nickname,name,age,sex from user limit 10;#没有设计limit 10，它是查完整表返回结果，设计了limit 10 查到10个符合条件的数据就返回。所以这就可以利用这个特性在通过一些非注册索引的字段查找时，可以通过limit,提高查询速度。select * from t_user where email =1000001@fixbug.com;+---------+--------------------+----------+| id | email | password |+---------+--------------------+----------+| 1000001 | 1000001@fixbug.com | 1000001 |+---------+--------------------+----------+1 row in set (0.66 sec)mysql select * from t_user where email =1000001@fixbug.com limit 1;+---------+--------------------+----------+| id | email | password |+---------+--------------------+----------+| 1000001 | 1000001@fixbug.com | 1000001 |+---------+--------------------+----------+1 row in set (0.33 sec) 分页查询优化select * from t_user limit 1000000,20;+---------+--------------------+----------+| id | email | password |+---------+--------------------+----------+| 1000001 | 1000001@fixbug.com | 1000001 || 1000002 | 1000002@fixbug.com | 1000002 || 1000003 | 1000003@fixbug.com | 1000003 || 1000004 | 1000004@fixbug.com | 1000004 || 1000005 | 1000005@fixbug.com | 1000005 || 1000006 | 1000006@fixbug.com | 1000006 || 1000007 | 1000007@fixbug.com | 1000007 || 1000008 | 1000008@fixbug.com | 1000008 || 1000009 | 1000009@fixbug.com | 1000009 || 1000010 | 1000010@fixbug.com | 1000010 || 1000011 | 1000011@fixbug.com | 1000011 || 1000012 | 1000012@fixbug.com | 1000012 || 1000013 | 1000013@fixbug.com | 1000013 || 1000014 | 1000014@fixbug.com | 1000014 || 1000015 | 1000015@fixbug.com | 1000015 || 1000016 | 1000016@fixbug.com | 1000016 || 1000017 | 1000017@fixbug.com | 1000017 || 1000018 | 1000018@fixbug.com | 1000018 || 1000019 | 1000019@fixbug.com | 1000019 || 1000020 | 1000020@fixbug.com | 1000020 |+---------+--------------------+----------+20 rows in set (0.27 sec)select * from t_user where id1000000 limit 20;+---------+--------------------+----------+| id | email | password |+---------+--------------------+----------+| 1000001 | 1000001@fixbug.com | 1000001 || 1000002 | 1000002@fixbug.com | 1000002 || 1000003 | 1000003@fixbug.com | 1000003 || 1000004 | 1000004@fixbug.com | 1000004 || 1000005 | 1000005@fixbug.com | 1000005 || 1000006 | 1000006@fixbug.com | 1000006 || 1000007 | 1000007@fixbug.com | 1000007 || 1000008 | 1000008@fixbug.com | 1000008 || 1000009 | 1000009@fixbug.com | 1000009 || 1000010 | 1000010@fixbug.com | 1000010 || 1000011 | 1000011@fixbug.com | 1000011 || 1000012 | 1000012@fixbug.com | 1000012 || 1000013 | 1000013@fixbug.com | 1000013 || 1000014 | 1000014@fixbug.com | 1000014 || 1000015 | 1000015@fixbug.com | 1000015 || 1000016 | 1000016@fixbug.com | 1000016 || 1000017 | 1000017@fixbug.com | 1000017 || 1000018 | 1000018@fixbug.com | 1000018 || 1000019 | 1000019@fixbug.com | 1000019 || 1000020 | 1000020@fixbug.com | 1000020 |+---------+--------------------+----------+20 rows in set (0.00 sec)可以看出明显的效率不同select * from t_user limit 1000000,20;通过limit偏移，是会扫表的，所以耗费效率，所以我们要通过有索引的字段来约束条件，他就不会扫前面的，因为索引。这样效率也提高了select * from t_user where id1000000 limit 20;id的取值一般为上一页最后一条数据的id值 排序order by select id,nickname,name,age,sex from user where sex=M and age=20 and age=25 order by age asc;(默认为升序)select id,nickname,name,age,sex from user where sex=M and age=20 and age=25 order by age desc;(降序)select id,nickname,name,age,sex from user where sex=M and age=20 and age=25 order by name,age asc;(先按name升序，当name相同时，再按age升序) 分组group by select sex from user group by sex;select count(id) as number,sex from user group by sex;select count(id),age from user group by age having age20;select age,sex,count(*) from user group by age,sex; group by后面再筛选就不能用where,要使用having。 在使用 ORDER BY 和 GROUP BY 时，建议对相关字段建立索引。 如果排序或分组字段没有索引，MySQL 在执行过程中通常会采用 filesort 或创建临时表，这会导致性能下降。通过 EXPLAIN 分析语句时，可以在 Extra 字段看到 Using filesort，这意味着： MySQL 首先会读取满足条件的数据； 将其加载到内存或临时表中； 然后在内存或磁盘上进行排序； 最终返回排序后的结果。 由于这涉及额外的 CPU 和磁盘 IO 操作，效率会显著降低，尤其是在数据量较大时。因此，在 ORDER BY 或 GROUP BY 中应尽量使用已经建立索引的字段，以提升查询性能。 连接查询 内连接查询#on a.uid=c.uid 区分大表和小表，按照（where过滤后）数据量来区分，小表永远是整表扫描，然后去大表搜索。所以大表建索引才是最有效的#从student小表中取出所有的a.uid，然后拿着这些uid去exame大表搜素。#对于inner join内连接，过滤条件写在where的后面和on连接条件里面(会优化成where去过滤)，效果一样的。select a.uid,a.name,a.age,a.sex,c.score from student a inner join exame c on a.uid=c.uid where c.uid=1 and c.cid=2;select a.uid,a.name,a.age,a.sex,b.cid,b.cname,b.credit,c.score from exame cinner join student a on c.uid=a.uidinner join course b on c.cid=b.cidwhere c.uid=1 and c.cid=2; 内连接查询解决单张表的limit分页偏移量的消耗，这个问题可以采用有索引的字段来约束条件来使分页偏移量的消耗消失。 select * from t_user where id1000000 limit 20; 可是如果我们不知道这个id的值要取多少，偏移量必须写。又该如何提升效率。可以利用临时表存储所需信息的id，再通过这张表和原表inner join进而查出更多的信息。 select id,email,password from t_user limit 1500000,10;+---------+--------------------+----------+| id | email | password |+---------+--------------------+----------+| 1500001 | 1500001@fixbug.com | 1500001 || 1500002 | 1500002@fixbug.com | 1500002 || 1500003 | 1500003@fixbug.com | 1500003 || 1500004 | 1500004@fixbug.com | 1500004 || 1500005 | 1500005@fixbug.com | 1500005 || 1500006 | 1500006@fixbug.com | 1500006 || 1500007 | 1500007@fixbug.com | 1500007 || 1500008 | 1500008@fixbug.com | 1500008 || 1500009 | 1500009@fixbug.com | 1500009 || 1500010 | 1500010@fixbug.com | 1500010 |+---------+--------------------+----------+10 rows in set (0.71 sec)这是正常查的select id from t_user limit 1500000,10;+---------+| id |+---------+| 1500001 || 1500002 || 1500003 || 1500004 || 1500005 || 1500006 || 1500007 || 1500008 || 1500009 || 1500010 |+---------+10 rows in set (0.20 sec)#我们发现查单个字段效率会提高#所以我们建立临时表（小表）存储带索引的字段，再通过inner join查出相同的结果select a.id,a.email,a.password from t_user a inner join (select id from t_user limit 1500000,10) b on a.id=b.id;+---------+--------------------+----------+| id | email | password |+---------+--------------------+----------+| 1500001 | 1500001@fixbug.com | 1500001 || 1500002 | 1500002@fixbug.com | 1500002 || 1500003 | 1500003@fixbug.com | 1500003 || 1500004 | 1500004@fixbug.com | 1500004 || 1500005 | 1500005@fixbug.com | 1500005 || 1500006 | 1500006@fixbug.com | 1500006 || 1500007 | 1500007@fixbug.com | 1500007 || 1500008 | 1500008@fixbug.com | 1500008 || 1500009 | 1500009@fixbug.com | 1500009 || 1500010 | 1500010@fixbug.com | 1500010 |+---------+--------------------+----------+10 rows in set (0.18 sec)#肉眼可见的效率提高了。 外连接查询左连接查询 #把left这边的表所有的数据显示出来，在右表中不存在相应数据，则显示NULL，这里就不存在大小表的区分了，左表整表扫描。select a.* from User a left join orderlist b on a.uid=b.uid where a.orderid is null; 右连接查询 #把right这边的表所有的数据显示出来，在左表中不存在相应数据，则显示NULL，这里就不存在大小表的区分了，右表整表扫描。select a.* from User a right join orderlist b on a.uid=b.uid where b.orderid is null; #外连接经常用于查找某个用户没有，不存在#查找没有考试的学生select * from student where uid not in (select distinct uid from exame);#select distinct uid from exame 会产生一张中间表存储结果供外面的sql来查询#not in对于索引的命中并不高#可以看出用上述方法效率不是很高select a.* from student a left join exame b on a.uid=b.uid where b.cid is null;#这样也可以实现效果 select a.* from student a left join exame b on a.uid=b.uid where b.cid=3;select a.* from student a inner join exame b on a.uid=b.uid where b.cid=3;#上述两句效果是一样的，为什么呢，这时候我们用explain查看左连接，先查b表，再查a表，这就和左连接的查表顺序不符，和内连接相符。#原因在于where筛选数据后b为小表，所以又成了内连接了。所以在外连接查找时，where不要跟具体的筛选，放在on后，where后跟判断null.select a.* from student a left join exame b on a.uid=b.uid and b.cid=3 where b.cid is null;#带有一定条件的查询某个用户没有做什么要像上述写的。 MySQL存储引擎一张表，MySQL一般如何存储表的结构，数据，索引存储引擎直接影响上面内容的存储方式 MyISAM不支持事务，也不支持外键，索引采用非聚集索引，其优势是访问的速度快，对事务完整性没有要求，以select,insert为主的应用基本上都可以使用这个引擎来创建表。MyISAM的表在磁盘上存储三个文件，其文件名都和表名相同，扩展名分别是： .frm(存储表定义) .MYD(MYData，存储数据) .MYI(MYIndex，存储索引) InnoDB存储引擎提供了具有提交，回滚和崩溃恢复能力的事务安全，支持自动增长列，外键等功能，索引采用聚集索引，索引和数据存储在同一个文件，所以InnoDB的表在磁盘上有两个文件，其文件名都和表名相同，扩展名分别是： .frm(存储表定义) .ibd(存储数据和索引) MEMORY存储引擎使用存在内存中的内容创建表。每个MEMORY表实际只对应一个磁盘文件，格式是.frm(表结构定义)。MEMORY类型的表访问非常快，因为它的数据是放在内存中的，并且默认使用HASH索引（不适合做范围查询），但是一旦服务关闭，表中的数据就会丢失掉。 各存储引擎区别MySQL 存储引擎对比 特性存储引擎 InnoDB MyISAM Memory 🔒 锁机制 ✅ 行级锁 + 表级锁混合（默认行锁，支持多版本并发控制 MVCC） ❌ 仅支持表级锁，写入或更新时整个表被锁定 ❌ 仅支持表级锁 🌳 B-树索引 ✅ 支持，聚簇索引（主键）存储数据，辅助索引存主键 ✅ 支持，非聚簇索引，索引与数据分离 ✅ 支持（基于哈希或 B-Tree，可设置） 🔗 哈希索引 ⚠️ 不支持（只有 Adaptive Hash Index，InnoDB 内部使用） ❌ 不支持 ✅ 默认使用哈希索引，也支持 BTree（可配置） 🔐 外键支持 ✅ 支持（定义级联删除、更新等外键约束） ❌ 不支持 ❌ 不支持 🔁 事务支持 ✅ 支持完整事务（ACID），回滚、提交、一致性恢复 ❌ 不支持事务机制 ❌ 不支持事务 📚 索引缓存 ✅ 支持（通过 Buffer Pool 缓存索引和数据） ✅ 支持（只缓存索引，不缓存数据） ❌ 不缓存索引（数据在内存中，系统重启即失） 💾 数据缓存 ✅ 支持（Buffer Pool 中同时缓存数据和索引） ❌ 不支持数据缓存（每次查询都需从磁盘读取数据） ✅ 所有数据在内存中，速度极快 锁机制：表示数据库在并发请求访问的时候，多个事务在操作时，并发操作的粒度。 B-树索引和哈希索引：主要是加速SQL的查询速度。 外键：子表的字段依赖父表的主键，设置两张表的依赖关系。 事务：多个SQL语句，保证他们共同执行的原子操作，要么成功，要么失败，不能只成功一部分，失败需回滚事务。 索引缓存和数据缓存：和MySQL Server的查询缓存相关，在没有对数据和索引做修改之前，重复查询可以不用进行磁盘IO(数据库的性能提升，目的是为了减少磁盘IO操作来提升数据库访问效率)，读取上一次内存中查询的缓存即可。 MySQL索引当表中的数据量到达几十万甚至上百万的时候，SQL查询所花费的时间会很长，导致业务超时出错，此时就需要用索引来加速SQL查询。 由于索引也是需要存储索引文件的，因此对索引的使用也会涉及磁盘IO操作。如果索引创建过多，使用不当，会造成SQL查询时，进行大量无用的磁盘IO操作，降低了SQL的查询效率，适得其反，所以掌握良好得索引创建原则非常重要。 索引分类索引是创建在表上的，是对数据库表一列或者多列的值进行排序的一种结果。索引的核心是提高查询的速度。 物理上(聚集索引非聚集索引)逻辑上(以下六种) 索引的优点：提高查询效率 索引的缺点：索引并非越多越好，过多的索引会导致CPU使用率居高不下，由于数据的改变，会造成索引文件的改动，过多的磁盘IO造成CPU负荷太重。 普通索引：没有任何限制条件，可以给任何类型的字段创建普通索引。(创建新表已创建表，数量是不限的，一张表的一次sql查询只能用一个索引 where a1 and b’M’只用其中一个) 唯一性索引：使用UNIQUE修饰的字段，值不能够重复，主键索引就隶属于唯一性索引。 主键索引：使用Primary Key修饰的字段会自动创建索引。 单列索引：在一个字段上创建索引 多列索引：在表的多个字段上创建索引（多列索引必须使用到第一个列，才能使用到多列索引，否则索引用不上） 全文索引：使用FULLTEXT参数可以设置全文索引，只支持CHAR,VARCHAR和TEXT类型的字段上，常用于数据量较大的字符串类型上，可以提高查询速度。(线上项目支持专门的搜索功能，给后台服务器增加专门的搜索引擎支持快速高效的搜索 elasticsearch简称es C++开源的搜索引擎 搜狗的workflow,所以最好不要部署到mysql里) 索引创建和删除注意： 经常作为where条件过滤的字段考虑添加索引 字符串创建索引时，尽量规定索引的长度，而不能让索引值的长度key_len过长 索引字段涉及类型强转，mysql函数调用，表达式计算等，索引就用不上了（索引失效）。 select * from t_user where password=1000000;select * from t_user where password=1000000;password是个varchar类型，加了索引，上面两句的耗时量不同。 #创建表的时候指定索引字段：CREATE TABLE index1(id INT, name VARCHAR(20), sex ENUM(male,female), INDEX(id));#在已经创建的表上添加索引：添加索引。后续用这个字段查，索引一定会用到吗，不一定，如果使用索引所消耗的数据量和扫表的数据量差不多的话，会优化成直接扫表。不用索引CREATE [UNIQUE]INDEX 索引名 ON 表名（属性名（length）[ASC|DESC]）;length为索引的长度,一般在给字符串字段加索引时写明长度create index pwdidx on t_user(password);#删除索引DROP INDEX 索引名 ON 表名; 索引的执行过程explain查看执行计划EXPLAIN SELECT * FROM user WHERE id = 1; EXPLAIN 关键字段详细说明表格 字段名 详细解释 id 表示查询中每个 SELECT 子句的唯一标识符。 数值越大，优先级越高，越早执行。常见于子查询和联合查询中。 select_type 表示查询的类型（即 SELECT 的种类）： 🔹 SIMPLE：简单查询，没有子查询或 UNION 🔹 PRIMARY：最外层的主查询 🔹 SUBQUERY：SELECT 在 WHERE 中嵌套 🔹 DERIVED：FROM 子句中的子查询（派生表）🔹UNION：UNION 中的第二个及以后查询 🔹 DEPENDENT SUBQUERY：依赖外层查询结果的子查询 table 当前访问的表名或别名，若为临时表，则会显示 derivedN 或 unionN partitions 如果使用了分区表，显示所访问的分区。无分区则为 NULL type（访问类型） 🔥 评估索引使用效率的核心字段，从优到劣如下： 1. system（表只有一行） 2. const（通过主键或唯一索引查询常量） 3. eq_ref（唯一索引 + 连接） 4. ref（普通索引 + 连接） 5. range（范围查询，如 、BETWEEN） 6. index（全索引扫描） 7. ALL（全表扫描 ⚠️ 需优化） possible_keys 显示可能用于查询的索引列表。 不一定表示最终用到了。 如果是 NULL，说明没有可用索引。 key 实际使用的索引名称。 为 NULL 则表示未使用任何索引。 key_len 实际使用的索引长度（单位是字节）， 由字段类型、字符集等决定。 ⚠️ 并不等于整个索引长度，仅表示此次查询使用了其中多少部分。 ref 显示哪个字段或常量被用来与索引中的列进行比较： 如：const（常量）、func（函数）、table.column（表字段）等 rows MySQL 预计需要读取的记录行数（不是返回行数），越少越好。 是估算值，不一定准确。 filtered 表示通过 WHERE 条件过滤后，预估保留的记录百分比。 值为百分比形式，100 表示全部通过。 Extra 显示额外的执行细节，非常重要： 🔹 Using index：覆盖索引，无需回表 🔹 Using where：使用了 WHERE 过滤条件 🔹 Using temporary：使用了临时表（如GROUP BY） 🔹 Using filesort：需要额外排序（ORDER BY） 🔹 Using index condition：使用了 Index Condition Pushdown（ICP） 🔹 Impossible WHERE：WHERE 条件永远不成立 索引的底层实现原理数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘块（对应索引树的节点），索引树越低，越矮胖，磁盘IO次数就少。 MySQL支持两种索引，一种是B-树索引，一种是哈希索引，大家知道，B-树和哈希表在查询时的效率是非常高的。 这里主要讨论MySQL InnoDB的存储引擎，基于B-树(但实际上MySQL采用的是B+树结构)的索引结构。 B-树是一种m阶平衡树，叶子节点都在同一层，由于每个节点存储的数据量比较大，索引整个B-树的层数是非常低的，基本不超过三层。 由于磁盘的读取也是按照block块操作的(内存是按page页面操作的)，因此B-树的节点大小一般设置为和磁盘块大小一致，这样一个B-树节点，就可以通过一次磁盘IO把一个磁盘块的数据全部存储下来，所以当使用B-树存储索引的时候，磁盘IO的操作次数是最少的(MySQL的读写效率，主要集中在磁盘IO)。 为什么MySQL(MyISAM和InnoDB)索引底层选择B+树而不是B树呢？ 索引+数据内容分散在不同的节点上，离根节点近，搜索就快；离根节点远，搜索就慢！花费的磁盘IO次数不平均，每一行数据花费的时间也不平均。 每一个非叶子节点，不仅仅要存储索引(key),还要存储索引值所在的那一行的data数据。一个节点所能存放的索引key值的个数，比只能存储key值的节点的个数要少的多！！！ 这棵树不方便做范围搜索，整表遍历看起来也不方便。 有上面的三个原因，由B+树来构建索引。 1.每一个非叶子节点，只存放key,不存储data!好处就是一个节点存放的key值更多，B+树在理论上来说，层数会更低一些，搜索的效率会更好一些。2.叶子节点上存储了所有的索引值+数据data:搜索每一个索引对应的值data,都需要跑到叶子节点上，这样每一行记录搜索的时间是非常平均的。3.叶子节点被串在一个链表当中，形成了一个有序的链表，如果要进行索引树的搜索整表搜索，直接遍历叶子节点的有序链表即可！或者做范围查询的时候，直接遍历叶子节点的有序链表即可！ InnoDB的主键和二级索引树 select * from student where age=20 order by name;如果只给age添加索引，行不行？还有什么没考虑到吗？如果只给age加索引，oder by name 会触发using filesort十分消耗资源，order by可以在name上加索引，但是一次sql,只能使用一次索引。所以我们这里要使用联合索引(多列索引)key:age+name 在B+树的链表中先按age排序，再按name排序；age相同，按name进行排序！！！多列索引必须使用到第一个列，才能使用到多列索引，否则索引用不上 MyISAM的主键和二级索引树 哈希索引 InnoDB自适应哈希索引这个数据结构和哈希索引的数据结构是一样的。InnoDB存储引擎检测到同样的二级索引不断被使用，有回表，(使用等值搜索)，那么底层会根据这个二级索引优化，在内存上根据二级索引树（B+树）上的二级索引值，在内存上构建一个哈希索引，来加强搜索。毕竟等值查询的效率是O(1);但是自适应哈希索引本身的数据维护也是需要耗费性能的，并不是说自适应哈希索引在任何情况下都会提升二级索引的查询性能！根据参数指标，来具体分析是否打开或者关闭自适应哈希索引。show engine innodb status\\G 能看到两个比较重要的信息：1.RW_latch等到的线程数量(自适应哈希索引默认分配8个分区)，同一个分区等待的线程数量过多，会造成自适应哈希索引搜索的效率低可以关闭自适应哈希索引2.走自适应哈希索引搜索的效率（低）和二级索引树搜索的效率（高）可以关闭自适应哈希索引 SQL和索引的优化问题，如何切入？ explain 分析sql 项目》很多业务》各种各样的sql 千条，万条 流程：从什么地方能够获取哪些运行时间长，耗性能的sql;然后再用explain去使用它。 1.可以使用慢查询日志slow_query_log，设置合理的，业务可以接受的慢查询时间！！ 2.压测执行各种业务。 3.查看慢查询日志，找出所有执行耗时的sql。 4.用explain分析这些耗时的sql 慢查询日志MySQL可以设置慢查询日志，当SQL执行的时间超过我们设定的时间，那么这些SQL就会被记录在慢查询日志当中，然后我们通过查看日志，用explain分析这些SQL的执行计划，来判断为什么效率低下，是没有使用到索引？还是索引本身创建的有问题？或者是索引使用到了，但是由于表的数据量太大，花费的时间就是很长，那么此时我们可以把表分为n个小表，比如订单表按年份分成多个小表。 慢查询日志相关参数如下： show variables like %slow_query%;+---------------------+---------------------------------------------------------+| Variable_name | Value |+---------------------+---------------------------------------------------------+| slow_query_log | OFF || slow_query_log_file | /var/lib/mysql/yustone-VMware-Virtual-Platform-slow.log |+---------------------+---------------------------------------------------------+2 rows in set (0.27 sec) 打开慢查询 set global slow_query_log=ON; 慢查询日志记录了包含所以执行时间超过参数long_query_time(单位：秒)所设置值的SQL语句的日志，在MySQL上用命令可以查看。如下： show variables like long%;+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.01 sec) 这个值是可以修改的，如下： set long_query_time=1;Query OK, 0 rows affected (0.00 sec) 修改完成后，执行sql后可以去对应文件varlibmysqlyustone-VMware-Virtual-Platform-slow.log查看。 MySQL事务事务概念一个事务是由一条或者多条对数据库操作的SQL语句所组成的一个不可分割的单元，只有当事务中的所有操作都正常执行完了，整个事务才会被提交到数据库；如果有部分事务处理失败，那么事务就要回退到最初的状态，因此，事务要么全部执行成功要么全部失败。 事务是一组SQL语句的执行，要么全部成功，要么全部失败，不能出现部分成功，部分失败的结果。保证事务执行的原子操作。 事务的所有SQL语句全部执行成功，才能提交(commit)事务，把结果写回磁盘。 事务执行过程中，有的SQL出现错误，那么事务必须要回滚(rollback)到最初的状态。 ACID特性每一个事务必须满足下面的4个特性： 事务的原子性(Atomic): 事务是一个不可分割的整体，事务必须具有原子特性，及当数据修改时，要么全执行，要么全不执行，即不允许事务部分的完成。 事务的一致性(Consistency): 一个事务执行之前和执行之后，数据库数据必须保持一致性状态。数据库的一致性状态必须由用户来负责，由并发控制机制实现。就拿网上购物来说，你只有让商品出库，又让商品进入顾客的购物车才能构成一个完整的事务。 事务的隔离性(Isolation): 当两个或者多个事务并发执行时，为了保证数据的安全性，将一个事务内部的操作与其他事务的操作隔离起来，不被其他正在执行的事务所看到，使得并发执行的各个事务之间不能互相影响。 事务的持久性(Durability): 事务完成(commit)以后，DBMS保证它对数据库中的数据的修改是永久性的(可能出现内存把数据写回磁盘时出现断电)，即使数据库因为故障出错，也应该能够恢复数据！（利用redo log:重做日志 保证数据库的永久性） 事务的ACID特性：ACD:是由mysql的redo log和undo log机制来保证的。I:隔离性，是由mysql事务的锁机制来实现保证的。 事务并发存在的问题事务处理不经隔离，并发执行事务时通常会发生以下的问题： 脏读（Dirty Read）:一个事务读取了另一个事务未提交的数据。例如当事务A和事务B并发执行时，当事务A更新后，事务B查询读取到A尚未提交的数据，此时事务A回滚，则事务B读到的数据就是无效的脏数据。（事务B读取了事务A尚未提交的数据）。（杜绝） 不可重复读（NonRepeatable Read）:一个事务的操作导致另一个事务前后两次读到不同的数据。例如当事务A和事务B并发执行时，当事务B查询读取数据后，事务A更新操作更改事务B查询到的数据，此时事务B再次去读该数据，发现前后两次读的数据不一样。（事务B读取了事务A已提交的数据）（看业务能不能接受） 虚读(Phantom Read) 幻读：一个事务的操作导致另一个事务前后查询的结果数据量不同。例如当事务A和事务B并发执行时，当事务B查询读取数据后，事务A新增或者删除了一条满足事务B查询条件的记录，此时事务B再去查询，发现查询到前一次不存在的记录。或者前一次查询的一些记录不见了。（事务B读取了事务A(已提交)新增加的数据或者读不到事务A删除的数据）。（看业务能不能接受） 事务的隔离级别MySQL支持的四种隔离级别是： TRANSACTION_READ_UNCOMMITTED。未提交读。说明在提交前一个事务可以看到另一个事务的变化。这样读脏数据，不可重复读和虚读都是被允许的。 TRANSACTION_READ_COMMITTED。已提交读。说明读取未提交的数据是不允许的。这个级别仍然允许不可重复读和虚读产生。 TRANSACTION_REPEATABLE_READ。可重复读。说明事务保证能够再次读取相同的数据而不会失败，都是相同的数据，但虚读仍然会出现。可以解决一部分的幻读（insertdelete）,但是解决不了update造成的幻读。 TRANSACTION_SERIALIZABLE。串行化。是最高的事务级别，他防止读脏数据，不可重复读和虚读。 MySQL默认隔离级别：可重复读,oracle的默认隔离级别：已提交读。 MySQL的事务处理命令select @@autocommit;#查看事务是自动(1)还是手动(0)set autocommit=0;#设置事务为手动(在当前会话生效) #MyISAM:不支持事务的！#InnoDB:最大的特点：支持事务，支持行锁try\tbegin;#开始一个事务\tSQL语句 commit;#提交一个事务catch(... err)\trollback;#回滚一个事务 SAVEPOINT point1;设置一个名字为point1的保存点ROLLBACK TO point1;事务回滚到保存点point1,而不是回滚到初始状态SET SESSION transaction_isolation = REPEATABLE-READ;设置事务的隔离级别SELECT @@transaction_isolation;查询事务的隔离级别 SELECT @@transaction_isolation;+-------------------------+| @@transaction_isolation |+-------------------------+| REPEATABLE-READ |+-------------------------+1 row in set (0.02 sec) MySQL的锁机制 表级锁行级锁表级锁：对整张表加锁。开销小，加锁快，不会出现死锁；锁粒度大，发生锁冲突的概率高，并发读低。 行级锁：对某行记录加锁。开销大，加锁慢，会出现死锁；锁粒度最小，发生锁冲突的概率最低，并发度高。 排它锁和共享锁排它锁（Exclusive）,又称为X锁，写锁。 共享锁（Shared）,又称为S锁，读锁。 X锁和S锁之间有以下关系： SS可以兼容，XS,SX,XX之间是互斥的 一个事务对数据对象O加了S锁，可以对O进行读取操作但不能进行更新操作。加锁期间其他事务能对O加S锁但不能加X锁。 一个事务对数据对象O加了X锁，就可以对O进行读取和更新。加锁期间其他事务不能对O加任何锁。 手动加锁：select…lock in share mode强制获取共享锁，select…for update获取排它锁 InnoDB行级锁行级锁InnoDB存储引擎支持事务处理，表支持行级锁定，并发能力更好。 InnoDB行锁是通过给索引上的索引项加锁来实现的，而不是给表的行记录加锁实现的，这就意味着只有通过索引数据，InnoDB才使用行级锁，否则InnoDB将使用表锁。 由于InnoDB的行锁实现是针对索引字段添加的锁，不是针对行记录加的锁，因此虽然访问的是InnoDB引擎下表的不同行，但是如果使用相同的索引字段值作为过滤条件，依然会发生锁冲突，只能串行进行，不能并发进行。 即使SQL中使用了索引，但是经历MySQL的优化器后，如果认为全表扫描比使用索引效率更高，此时会放弃使用索引，因此不会使用行锁，而是使用表锁，比如对一些很小的表，MySQL就不会去使用索引。 间隙锁(gap lock) 当我们用范围条件而不是相等条件检索数据，并请求共享或排它锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做间隙，InnoDB也会对这个间隙加锁，这个锁机制就是所谓的间隙锁。举例来说，假如user表中只有101条记录，其userid的值分别为1，2，100，101，下面的SQL: select * from user where userid100 for update; 是一个范围条件的检索，InnoDB不仅会对符合条件的userid值为101的记录加锁，也会对userid大于101(但是这些记录不存在)的间隙加锁，防止其他事务在表的末尾增加数据。 InnoDB使用间隙锁的目的，为了防止幻读，以满足串行化隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了userid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读。 InnoDB表级锁在绝大部分情况下都应该使用行锁，因为事务和行锁往往是选择InnoDB的理由，但个别情况下也使用表级锁； 事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间等待和锁冲突； 事务涉及多个表，比较复杂，很可能造成死锁，造成大量事务回滚。 LOCK TABLE user READ;读锁锁表LOCK TABLE user WRITE;写锁锁表事务执行。。。COMMIT/ROLLBACK;事务提交/回滚UNLOCK TABLES;本身自带提交事务，释放线程占用的所有表锁。 意向共享锁和意向排他锁意向共享锁（IS锁）:事务计划给记录加行共享锁，事务在给一行记录加共享锁前，必须先取得该表的IS锁。 意向排他锁（IX锁）:事务计划给记录加行排他锁，事务在给一行记录加排他锁前，必须先取得该表的IX锁 IS和IX之间是兼容的，没有互斥 死锁MyISAM表锁是deadlock free的，这是因为MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，即锁的粒度比较小，这就决定了在InnoDB中发生死锁是可能的。 死锁问题一般都是我们自己的应用造成的，和多线程编程的死锁情况相似，大部分都是由于我们多个线程在获取多个锁资源的时候，获取的顺序不同而导致的死锁问题。因此我们应用在对数据库的多个表作更新的时候，不同的代码段，应对这些表按相同的顺序进行更新操作，以防止锁冲突导致死锁问题。 锁的优化建议 尽量使用较低的隔离级别 设计合理的索引并尽量使用索引访问数据，使加锁更加准确，减少锁冲突的机会提高并发能力 选择合理的事务大小，小事务发生锁冲突的概率小 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表；对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响 不要申请超过实际需要的锁级别 除非必须，查询时不要显式加锁 redo log和undo log统称为事务日志。区别于binlog是MySQL Server层的日志，这两个属于存储引擎层的日志。 redo log：重做日志。 undo log: 回滚日志 redo log:\t用于记录事务操作的变化，确保事务的持久性。redo log是在事务开始后就开始记录，不管事务是否提交都会记录下来，在异常发生时（如数据持久化过程中掉电），InnoDB会使用redo log恢复到掉电前的时刻，保证数据的完整性。 innodb_log_buffer_size默认是16M,就是redo log缓冲区的大小，它随着事务开始，就开始写redo log,如果事务比较大，为了避免事务执行过程中花费过多磁盘IO,可以设置比较大的redo log缓存，节省磁盘IO。 InnoDB修改操作数据，不是直接修改磁盘上的数据，实际只是修改Buffer Pool的数据。InnoDB总是先把Buffer Pool中的数据改变记录到redo log中，用来进行崩溃后的数据恢复。优先记录redo log,然后再慢慢的将Buffer Pool的脏数据刷新到磁盘上。 innodb_log_group_home_dir指定的目录下的两个文件：ib_logfile0,ib_logfile1,该文件被称作重做日志。 buffer pool缓存池： 作用：加速读和加速写，直接操作data page,写redo log修改就算完成，有专门的线程去做把buffer pool的dirty page写入磁盘。 undo log:\t保存了事务发生之前的数据的一个版本，用于事务执行时的回滚操作，同时也是实现多版本并发控制（MVCC）下读操作的关键技术。 在创建表时，除了自己设定的字段，mysql会自动加一些字段，其中DB_TRX_ID：事务ID DB_ROLL_PTR：回滚指针 DB_ROLL_PTR：回滚指针指向修改前的数据，修改前的数据在undo log中，当然当前数据库里的数据是最新的。回滚的话，直接从undo log调就可以。 MVCC多版本并发控制MVCC是多版本并发控制，是MySQL中基于乐观锁理论实现隔离级别的方式，用于实现已提交读和可重复读隔离级别的实现，也经常称为多版本数据库。MVCC机制会生成一个数据请求时间点的一致性数据快照（Snapshot）,并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本（系统版本号和事务版本号）。 MVCC多版本并发控制中，读操作可以分为两类： 1.快照读（Snapshot read） ​\t读的是记录的可见版本，不用加锁，如select。 2.当前读（current read） ​\t读取的是记录的最新版本，并且当前读返回的记录。如insert,delete,update,select…lock in share modefor update ​\tMVCC:每一行记录实际上有多个版本，每个版本的记录除了数据本身之外，增加了其他字段 ​\tDB_TRX_ID:记录当前的事务ID。 ​\tDB_ROLL_PTR:指向undo log日志上数据的指针。 逻辑上来看，MVCC 就是为每个事务“搞出了一张表的快照”，但这张“表”并不是实际复制的，而是通过行级的历史版本 + 可见性判断规则拼出来的。 已提交读：每次执行语句的时候都重新生成一次快照（Read View）,每次select查询时。 可重复读：同一个事务开始的时候生成一个当前事务全局性的快照（Read View）,第一次select查询时。 快照内容读取原则： 版本未提交无法读取生成快照 版本已提交，但是在快照创建后提交的，无法读取 版本已提交，但是在快照创建前提交的，可以读取 当前事务内自己的更新，可以读到。 MySQL优化 MySQL日志show variables like log_%; #全局变量\t设置状态\tshow variables show status+----------------------------------------+----------------------------------------+| Variable_name | Value |+----------------------------------------+----------------------------------------+| log_bin | ON || log_bin_basename | /var/lib/mysql/binlog || log_bin_index | /var/lib/mysql/binlog.index || log_bin_trust_function_creators | OFF || log_bin_use_v1_row_events | OFF || log_error | /var/log/mysql/error.log || log_error_services | log_filter_internal; log_sink_internal || log_error_suppression_list | || log_error_verbosity | 2 || log_output | FILE || log_queries_not_using_indexes | OFF || log_raw | OFF || log_replica_updates | ON || log_slave_updates | ON || log_slow_admin_statements | OFF || log_slow_extra | OFF || log_slow_replica_statements | OFF || log_slow_slave_statements | OFF || log_statements_unsafe_for_binlog | ON || log_throttle_queries_not_using_indexes | 0 || log_timestamps | UTC |+----------------------------------------+----------------------------------------+21 rows in set (0.06 sec) 关于日志的配置需要到my.cnf去添加。 二进制日志二进制日志(BINLOG)记录了所有的DDL(数据定义语言)语句和DML(数据操纵语言)语句,但是不包括数据查询语句。语句以事件的形式保存，他描述了数据的更改过程。此日志对于灾难时的数据恢复起到极其重要的作用。 两个重要的应用场景：主从复制，数据恢复 查看binlog show binary logs;+---------------+-----------+-----------+| Log_name | File_size | Encrypted |+---------------+-----------+-----------+| binlog.000027 | 157 | No || binlog.000028 | 157 | No || binlog.000029 | 157 | No || binlog.000030 | 157 | No || binlog.000031 | 157 | No || binlog.000032 | 157 | No || binlog.000033 | 104857956 | No || binlog.000034 | 104857734 | No || binlog.000035 | 104857734 | No || binlog.000036 | 104857688 | No || binlog.000037 | 104857740 | No || binlog.000038 | 104857740 | No || binlog.000039 | 10635266 | No |+---------------+-----------+-----------+13 rows in set (0.02 sec) 通过mysqlbinlog工具(mysql原生自带的工具)可以快速解析大量的binlog日志文件。 #查看 binlog 日志内容mysqlbinlog /var/lib/mysql/mysql-bin.000001 mysql数据的恢复：过期数据的备份(data.sql)+bin-log数据恢复 #bin-log数据恢复 除了通过位置恢复还可以通过时间恢复mysqlbinlog --start-position=775 --stop-position=1410 mysql-bin.000003 | mysql -u root -p#过期数据的备份mysqldump -u root -p mytest user ~/user.sqlmysqldump -u root -p --databases db1 [db2] ~/user.sqlmysqldump -u root -p --all-databases ~/user.sqlmysql界面下还原数据source ~/user.sql或者cat ~/data.sql | mysql -u root -p 前面导出的是mysql的记录我想直接导出记录bash下mysql -u root -p -D school -e select * from user where age18 ~/user.txt SQL详细处理流程","tags":["MYSQL learning"],"categories":["MYSQL learning"]},{"title":"Linux网络编程","path":"/2025/07/16/Linux网络编程/","content":"网络基础mac地址（6个字节 48位）标记网卡的id,；理论上这个id全球唯一 mac地址一般用来标识主机的id,这个id是物理地址，不会改变。 ip地址，ipv4(4个字节，32位)，ipv6(16个字节，128位)IP地址是标识主机的id,这个id是虚拟的，会改变。 一个IP将其分为子网id和主机id 子网id和主机id需要和子网掩码一起来看， ping命令用来测试两台主机的网络联通性（windows和Linux都适用）。 Linux下设置ip命令 ifconfig ens33 192.168.131.133 netmask 255.255.255.0 桥接模式（Bridged Networking）桥接模式是将虚拟机容器的网络桥接到物理网卡上，使其就像是局域网中的一台独立主机。 工作原理： 虚拟机通过虚拟网桥（Bridge）连接到宿主机的物理网卡，相当于直接插入交换机，与宿主机处于同一物理局域网中。 网络特点： 虚拟机可获得与宿主机同网段的IP地址（例如通过 DHCP） 可以被局域网中其他设备访问（可 ping 通） 能访问局域网和外网 优点： 网络透明，虚拟机像一台真实的独立主机 易于与其他局域网设备通信 缺点： 需要宿主网络支持（如局域网允许多个 IP） 有可能增加网络冲突和安全风险 NAT 模式（网络地址转换）NAT 模式是虚拟机容器通过宿主机的网络连接上网，共享宿主机的 IP。 工作原理： 宿主机充当“路由器”，将虚拟机的私有 IP 转换为宿主的公网 IP，进行地址转换。 网络特点： 虚拟机使用私有 IP 地址（如 192.168.xx.xx） 能访问外网，但外部主机无法主动访问虚拟机 类似家庭内的多台设备通过路由器上网 优点： 设置简单，几乎无须额外配置 安全性高，外部无法直接访问虚拟机 缺点： 虚拟机不能被外部主机主动访问（除非端口转发） 网络透明度低，不适合复杂网络测试 端口（port）作用：用来标识应用程序（进程） port:两个字节 0-65535 0-1023 知名端口 自定义端口1024-65535（避免冲突） 一个应用可以有多个端口，一个端口只能有一个应用程序。 OSI七层模型为了使各种不同的计算机之间可以互联，ARPANet指定了一套计算机通信协议，即TCPIP协议（族）； 为了减少协议设计的复杂性，大多数网络模型均采用分层的方式来组织。 每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽。 物理层：双绞线（网线）接口类型，光纤的传输速率等等 数据链路层：mac 负责收发数据 网络层：ip 给两台主机提供路径选择。 传输层：port 区分数据递送到那个应用程序。 会话层：建立连接 表示层：解码 应用层：应用程序 TCPIP四层模型 协议规定了数据传输的方式和格式 这里主要按照TCPIP四层模型有的协议。 应用层协议： FTP:文件传输协议 HTTP:超文本传输协议 NFS:网络文件系统 传输层协议： TCP:传输控制协议 头部20个字节 UDP:用户数据报协议 头部8个字节 网络层： IP:英特网互联协议 头部20个字节 ICMP:英特网控制报文协议 ping命令就是这个协议IGMP：英特网组管理协议 链路层： ARP:地址解析协议 通过ip找mac地址 RARP:反向地址解析协议 通过mac找ip 硬件接口：mac头 头部14个字节 目的mac地址为ff:ff:ff:ff:ff:ff 局域网内其他主机无条件接受。（常在ARP协议上使用） 网络设计模式BS browserserver CS clientserver CS 性能较好 客户端容易篡改数据 开发周期较长 BS 性能低 客户端安全 开发周期短 TCP三次握手tcp建立连接的过程 SYN是请求建立连接的标识，ACK就是确认。 mss:最大报文长度，一般出现在三次握手的前两次，用来告知对方传送数据的最大长度。 MTU:最大传输单元 由网卡限制 TCP四次挥手tcp断开连接，这个哪一方发起断开都可以，就以客户端申请断开为例子，三次握手一定是客户端发起。 就是两端的某一段调用了close函数。 FIN是请求断开连接的标识 滑动窗口TCP报头上有一个窗口尺寸的标识，这个是说接收方告知发送方：我的接收缓冲区还能接收多少字节。 在ACK标识回复时会带有win剩余多少空间。 这样发送方就会发送以避免拥堵，因为知道接收方还剩下多少空间，接收方是把当前接收缓冲区的一块数据提取出来，才会回复给发送方ACK携带当前缓冲区大小告知对方。 TCP状态转换 如果想要查看TCP应用的状态 netstat -anp | grep 8000(端口) 半关闭主动方在FIN_WAIT_2状态之后，主动方不可以在应用层发送数据了，但是应用层还可以接受数据，这个状态叫半关闭。 有人就有疑惑了，那为什么在TIME_WAIT状态还能发，因为它发的是ACK,主动方不可以在应用层发送数据了，指的是应用层的协议不可以接受了，但是在底层，传输层TCP协议还是可以发出，所以ACK是可以发的。 #include sys/socket.hint shutdown(int sockfd, int how);参数： sockfd:需要关闭的socket的描述符 how:允许为shutdown操作选择以下几种方式： SHUT_RD(0):关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被丢弃。 SHUT_WR(1):关闭sockfd上的写功能，此选项将不允许sockfd进行写操作。进程不能再对此套接字发出写操作 SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是SHUT_RD,然后是SHUT_WR。 TCP异常断开心跳包(TCP 的 keepalive 机制)SO_KEEPALIVE保持连接检测对方主机是否崩溃，避免服务器永远阻塞于TCP连接的输入。设置该选项后，如果两小时内在此套接口的任一方向都没有数据交换，TCP会自动给对方发一个保持存活探测分节，这是一个对方必须响应的TCP分节。他会导致以下三种情况： 对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个。 对方已崩溃且已重新启动：以RST响应。套接口的待处理错误设置为ECONNRESET,套接口本身被关闭。 对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。在发出第一个探测分节11分钟15秒后若仍无响应就放弃。套接口的待处理错误被置为ETIMEOUT,套接口本身就关闭。若ICMP错误是host unreachable(主机不可达),说明对方主机没有崩溃，但是不可达，这种情况下待处理错误设置为EHOSTUNREACH. 所以我们可以设置SO_KEEPALIVE属性使得我们在两小时后发现对方的TCP连接是否依然存在。 keepAlive=1;setsockopt(listenfd,SOL_SOCKET,SO_KEEPALIVE,(void *)keepAlive,sizeof(keepAlive)); 但是说真的，这个函数两小时检测一次，对于现在来说，有点太长了，所以可以自己在应用层写对应的心跳包。 心跳包：最小粒度，携带的数据部分一定要少。 乒乓包：携带比较多的数据的心跳包。 端口复用端口重新启用，谁最后启用的端口谁用。前面启用的作废，用不了了。为什莫需要端口复用呢，在server的TCP连接没有完全断开之前不允许重新监听。比如我强制退出server,再启动就不会说端口被占用了。 在server代码的socket()和bind()调用之间插入如下代码：int opt=1;setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,opt,sizeof(opt)); UDPTCP:传输控制协议 安全可靠 丢包重传 面向连接(电话模型) UDP:用户数据报协议 不安全不可靠 丢包不重传 快 不面向连接(邮件模型) tcp通信流程：服务器：创建流式套接字 绑定 监听 提取 读写 关闭 客户端：创建流式套接字 连接 读写 关闭 收发数据： read recv #include sys/socket.hssize_t recv(int sockfd, void buf[.len], size_t len, int flags);flags==MSG_PEEK 读数据不会删除缓冲区的数据 一般填0 write send #include sys/socket.hssize_t send(int sockfd, const void buf[.len], size_t len, int flags);//flags=1表示紧急数据 一般填0 udp通信流程： 服务器：创建报式套接字 绑定 读写 关闭 客户端：创建报式套接字 读写 关闭 发数据： #include sys/socket.hssize_t sendto(int sockfd, const void buf[.len], size_t len, int flags, const struct sockaddr * dest_addr, socklen_t addrlen);dest_addr:目的地的地址信息addrlen:结构体大小 收数据： #include sys/socket.hssize_t recvfrom(int sockfd, void buf[restrict.len], size_t len, int flags, struct sockaddr * _Nullable restrict src_addr, socklen_t * _Nullable restrict addrlen);src_addr：对方的地址信息addrlen：结构体大小地址 创建报式套接字 int socket(int domain,int type,int protocol);参数： domain:AF_INET type:SOCK_DGRAM protocol:0 UDP一般是一对一的。一个套接字服务一个客户端，不像TCP,后来可以分配套接字。 UDP服务器和客户端代码实现#includestdio.h#includesys/socket.h#includestdlib.h#includeunistd.h#includearpa/inet.hint main(int argc,char *argv[]) //创建套接字 int fd=socket(AF_INET,SOCK_DGRAM,0); //绑定 struct sockaddr_in myaddr; myaddr.sin_family=AF_INET; myaddr.sin_port=htons(8000); myaddr.sin_addr.s_addr=inet_addr(127.0.0.1); int ret=bind(fd,(struct sockaddr*)myaddr,sizeof(myaddr)); if(ret0) perror(bind); return 0; //读写 char buf[1500]=; struct sockaddr_in cliaddr; socklen_t len=sizeof(cliaddr); while(1) int n=recvfrom(fd,buf,sizeof(buf),0,(struct sockaddr*)cliaddr,len); if(n0) perror(); break; else printf(%s ,buf); sendto(fd,buf,n,0,(struct sockaddr*)cliaddr,len); //关闭 close(fd); hello nc -u 127.0.0.1 8000 #这里连接服务器加上-u 表示连接的是udp #includestdio.h#includesys/socket.h#includestdlib.h#includeunistd.h#includearpa/inet.h#includestring.hint main(int argc,char *argv[]) //创建套接字 int fd=socket(AF_INET,SOCK_DGRAM,0); //绑定 struct sockaddr_in myaddr; myaddr.sin_family=AF_INET; myaddr.sin_port=htons(9000); myaddr.sin_addr.s_addr=inet_addr(127.0.0.1); int ret=bind(fd,(struct sockaddr*)myaddr,sizeof(myaddr)); if(ret0) perror(bind); return 0; //读写 char buf[1500]=; struct sockaddr_in dstaddr; dstaddr.sin_family=AF_INET; dstaddr.sin_port=htons(8000); dstaddr.sin_addr.s_addr=inet_addr(127.0.0.1); int n=0; while(1) n=read(STDIN_FILENO,buf,sizeof(buf)); sendto(fd,buf,n,0,(struct sockaddr*)dstaddr,sizeof(dstaddr)); memset(buf,0,sizeof(buf)); int n=recvfrom(fd,buf,sizeof(buf),0,NULL,NULL); if(n0) perror(); break; else printf(%s ,buf); //关闭 close(fd); hellohellohhhhhhhhhhwoshinidiawoshinidia 本地套接字通信unix domain socket又是一个新的IPC方式，“本地套接字”通常指的是 Unix 域套接字（Unix Domain Socket，UDS），是一种用于同一台主机内部进程间通信（IPC）的套接字，与 TCPIP 套接字相比，它不经过网络协议栈，速度更快、效率更高。 全双工 套接字用文件来标识，这个文件在绑定之前是不能存在的。 作用：实现本地进程间通信，替代管道、共享内存等传统 IPC 手段。 协议族：使用 AF_UNIX 或 AF_LOCAL 而不是 AF_INET。 通信方式：支持 SOCK_STREAM（类似 TCP）和 SOCK_DGRAM（类似 UDP）。 地址类型：使用文件系统中的路径名作为标识（如 /tmp/mysock）。 本地套接字实现tcp通信 创建本地套接字 绑定 监听 提取 读写 关闭 创建本地套接字用于tcp通信 int socket(int domain,int type,int protocol);参数： domain:AF_UNIX type:SOCK_STREAM protocol:0 绑定 #include sys/socket.hint bind(int sockfd, const struct sockaddr * addr, socklen_t addrlen);参数:\tsockfd：本地套接字 addr：本地套接字结构体地址struct sockaddr_un sa_family_t sun_family; /* AF_UNIX */ char sun_path[108]; /* Pathname */; addrlen:sockaddr_un大小 提取 #include sys/socket.hint accept(int sockfd, struct sockaddr * _Nullable restrict addr, socklen_t * _Nullable restrict addrlen);addr:struct sockaddr_un结构体来接 本地套接字实现tcp服务器和客户端代码实现#includestdio.h#includesys/socket.h#includearpa/inet.h#includeunistd.h#includestring.h#includestdlib.h#includesys/un.hint main(int argc,char *argv[]) //删除文件，文件如果先前存在会通信不了 unlink(sock.s); //创建unix流式套接 int lfd=socket(AF_UNIX,SOCK_STREAM,0); //绑定 struct sockaddr_un myaddr; myaddr.sun_family=AF_UNIX; strcpy(myaddr.sun_path,sock.s); bind(lfd,(struct sockaddr*)myaddr,sizeof(myaddr)); //监听 listen(lfd,128); //提取 struct sockaddr_un cliaddr; socklen_t len=sizeof(cliaddr); int cfd=accept(lfd,(struct sockaddr*)cliaddr,len); printf(new client file=%s ,cliaddr.sun_path); //读写 char buf[1500]=; while(1) int n=recv(cfd,buf,sizeof(buf),0); if(n=0) break; else printf(%s ,buf); send(cfd,buf,n,0); close(cfd); close(lfd); new client file=hellop#使用nc连接服务器 nc -U sock.s #includestdio.h#includearpa/inet.h#includesys/socket.h#includestdlib.h#includestring.h#includesys/un.h#includeunistd.hint main(int argc,char *argv[]) unlink(sock.c); //创建unix流式套接字 int cfd=socket(AF_UNIX,SOCK_STREAM,0); //如果不绑定就会隐式绑定 struct sockaddr_un myaddr; myaddr.sun_family=AF_UNIX; strcpy(myaddr.sun_path,sock.c); if(bind(cfd,(struct sockaddr*)myaddr,sizeof(myaddr))0) perror(); return 0; //连接 struct sockaddr_un seraddr; seraddr.sun_family=AF_UNIX; strcpy(seraddr.sun_path,sock.s); connect(cfd,(struct sockaddr *)seraddr,sizeof(seraddr)); //读写 char buf[1500]=; while(1) char buf[1500]=; int n=read(STDIN_FILENO,buf,sizeof(buf)); send(cfd,buf,n,0); memset(buf,0,sizeof(buf)); n=recv(cfd,buf,sizeof(buf),0); if(n=0) break; else printf(%s ,buf); //关闭 close(cfd); return 0; hellohello我是你弟我是你弟 Socket编程无名管道，命名管道，文件，信号，消息队列，共享内存只能用于本机的进程间通信。 不同主机间进程通信方法：socket socket是一个伪文件。 socket必须成对出现。 大小端：小端：低位存低地址，高位存高地址 大端：高位存低地址，低位存高地址 网络上走的数据都是大端的，主机的主机字节序是未知的，需要转换。 协议头部：如 TCPIP 头、DNS 头等 → 这些字段是标准协议的，必须按规定的大端（网络字节序） 数据部分（Payload）：完全由你应用程序自己定义 网络字节序和主机字节序的转换 #includearpa/inet.huint32_t htonl(uint32_t hostlong);//主机字节序转网络字节序（4个字节）转ipuint16_t htons(uint16_t hostshort);//主机字节序转网络字节序（2个字节）转portuint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort); 示例代码 #includearpa/inet.h#includestdio.hint main(int argc,char *argv[]) char buf[4]=192,168,1,2; int num=*(int *)buf; int sum=htonl(num); unsigned char *p=sum; printf(%d %d %d %d ,*p,*(p+1),*(p+2),*(p+3)); unsigned short a=0x0102; unsigned short b=htons(a); printf(%x ,b); return 0; 2 1 168 192 说明我的电脑是小端。 IP地址转换函数#includearpa/inet.hint inet_pton(int af,const char *src,void *dst);功能：将点分十进制串转成32位网络大端的数据参数：af: AF_INET IPV4 AF_INET6 IPV6 src：点分十进制串的首地址 dst:32位网络数据的首地址返回值： 成功：返回1 失败：返回0const char *inet_ntop(int af,const void *src,char *dst,socklen_t size);功能：将32位大端的网络数据转成点分十进制串参数：af: AF_INET IPV4 AF_INET6 IPV6 src：32位网络数据的首地址 dst: 点分十进制串的首地址 size:存储点分制串数组的大小 通常写16返回值： 存储点分制串数组的首地址。支持IPV4和IPV6。 示例代码： #includestdio.h#includearpa/inet.hint main(int argc,char *argv[]) char buf[]=192.168.1.4; unsigned int num=0; inet_pton(AF_INET,buf,num); unsigned char *p=(unsigned char *)num; printf(%d %d %d %d ,*p,*(p+1),*(p+2),*(p+3)); char ip[16]=; inet_ntop(AF_INET,num,ip,16); printf(%s ,ip); return 0; 192 168 1 4192.168.1.4 ipv4套接字结构体struct sockaddr_in sa_family_t sin_family; /* address family: AF_INET */ 对应的协议（ipv4） in_port_t sin_port; /* port in network byte order */ 端口 struct in_addr sin_addr; /* internet address */ ip地址;/* Internet address */struct in_addr uint32_t s_addr; /* address in network byte order */ ip地址; ipv6套接字结构体太多了，这里不展示 因为有这两种套接字结构体，所以我们要统一，方便函数编写。 通用套接字结构体 struct sockaddr sa_family_t sa_family; /* address family,AF_xxx*/ char sa_data[14]; /*14 bytes of protocol address*/; 网络套接字函数tcp 特点：出错重传 每次发送数据，对方都会回ACK 可靠 网络通信流程 创建套接字函数socket()#include sys/socket.hint socket(int domain,int type,int protocol);功能：创建套接字参数：domain:AF_INET type:SOCK_STREAM 流式套接字 用于TCP通信 protocol:0返回值： 成功：返回文件描述符 失败：返回-1 连接服务器函数connect()#include sys/socket.hint connect(int sockfd, const struct sockaddr * addr, socklen_t addrlen);功能：连接服务器参数： sockfd:socket套接字 addr:ipv4套接字结构体地址 addrlen:ipv4套接字结构体的长度 tcp客户端代码#includearpa/inet.h#includesys/socket.h#includestdlib.h#includestring.h#includestdio.h#includeunistd.hint main(int argc,char *argv[]) //创建套接字 int sock_fd; sock_fd=socket(AF_INET,SOCK_STREAM,0); if(sock_fd==-1) printf(连接失败); else printf(连接成功); //连接服务器 struct sockaddr_in addr; addr.sin_family=AF_INET; addr.sin_port=htons(8000); inet_pton(AF_INET,127.0.0.1,addr.sin_addr.s_addr); connect(sock_fd,(struct sockaddr *)addr,sizeof(addr)); //读写数据 char buf[1024]=; while(1) int n=read(STDIN_FILENO,buf,sizeof(buf)); write(sock_fd,buf,n);//发送数据给服务器 n=read(sock_fd,buf,sizeof(buf)); write(STDOUT_FILENO,buf,n); //关闭 close(sock_fd); return 0; tcp服务器通信流程 对于得到一个新的连接套接字（提取连接部分），服务器是要接受多个客户端连接的，所以先连接上，再分配新的连接和客户端通信。 bind函数给套接字绑定固定的端口和ip #include sys/socket.hint bind(int sockfd, const struct sockaddr * addr, socklen_t addrlen);功能：给套接字绑定固定的端口和ip参数： sockfd:套接字 addr:ipv4套接字结构体地址 addrlen:ipv4结构体的大小返回值： 成功：返回0 失败：返回-1 listen函数#include sys/socket.hint listen(int sockfd, int backlog);功能： 监听套接字参数： sockfd:套接字 backlog:已完成连接队列和未完成连接队列之和的最大值 一般写128 accept函数#include sys/socket.hint accept(int sockfd, struct sockaddr * _Nullable restrict addr, socklen_t * _Nullable restrict addrlen);功能： 从已完成连接队列提取新的连接，如果没有新的连接，accept会阻塞。参数： sockfd:套接字 addr:获取的客户端的ip和端口信息 ipv4套接字结构体 addrlen:ipv4套接字结构体的大小的地址返回值： 新的已连接套接字的文件描述符 tcp服务器代码#includestdio.h#includearpa/inet.h#includesys/socket.h#includeunistd.hint main(int argc,char *argv[]) //创建套接字 int lfd=socket(AF_INET,SOCK_STREAM,0); //绑定 struct sockaddr_in addr; addr.sin_family=AF_INET; addr.sin_port=htons(8000); //addr.sin_addr.s_addr=INADDR_ANY;//绑定的是通配地址，当前主机的所有ip inet_pton(AF_INET,127.0.0.1,addr.sin_addr.s_addr); int ret=bind(lfd,(struct sockaddr *)addr,sizeof(addr)); if(ret0) perror(bind); exit(0); //监听 listen(lfd,128); //提取 struct sockaddr_in cliaddr; socklen_t len=sizeof(cliaddr); int cfd=accept(lfd,(struct sockaddr *)cliaddr,len); char ip[16]=; printf(new client ip=%s port=%d ,inet_ntop(AF_INET,cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port)); //读写 char buf[1024]=; while(1) bzero(buf,sizeof(buf)); int n=read(STDIN_FILENO,buf,sizeof(buf)); write(cfd,buf,n); int readn=read(cfd,buf,sizeof(buf)); if(readn==0) printf(客户端关闭); printf(%s ,buf); //关闭 close(lfd); close(cfd); return 0; nc 127.0.0.1 8000 #可以实现一个客户端，简易聊天helloworld new client ip=127.0.0.1 port=52486helloworld 多进程实现并发服务器#include stdio.h#includestdlib.h#include sys/socket.h#include unistd.h#includesignal.h#includesys/types.h#includesys/wait.h#include wrap.hvoid free_process(int sig) pid_t pid; while(1) pid=waitpid(-1,NULL,WNOHANG); if(pid=0)//小于0 子进程全部退出 =0没有子进程退出 break; printf(haha); else printf(child pid =%d,pid); int main(int argc, char *argv[]) sigset_t set; sigemptyset(set); sigaddset(set,SIGCHLD); sigprocmask(SIG_BLOCK,set,NULL); // 创建套接字 int lfd = tcp4bind(8000, NULL); // 监听 Listen(lfd, 128); // 提取 // 回射 struct sockaddr_in cliaddr; socklen_t len = sizeof(cliaddr); while (1) char ip[16] = ; // 提取连接 int cfd = Accept(lfd, (struct sockaddr *)cliaddr, len); printf(new client ip=%s port=%d , inet_ntop(AF_INET, cliaddr.sin_addr.s_addr, ip, 16), ntohs(cliaddr.sin_port)); // fork创建子进程 pid_t pid; pid = fork(); if (pid 0) perror(fork:); exit(0); else if (pid == 0) // 子进程 // 关闭lfd close(lfd); while (1) char buf[1024] = ; int n = read(cfd, buf, sizeof(buf)); if (n 0) perror(read:); close(cfd); exit(0); else if (n == 0) // 对方关闭 printf(client close ); close(cfd); exit(0); else printf(%s , buf); write(cfd, buf, n); else // 父进程 close(cfd); // 回收 //注册信号回调 struct sigaction act; act.sa_flags=0; act.sa_handler=free_process; sigemptyset(act.sa_mask); sigaction(SIGCHLD,act,NULL); sigprocmask(SIG_UNBLOCK,set,NULL); // 关闭 return 0; 我这里不知道为什么在子进程结束后回调函数没有触发。 多线程实现并发服务器#includestdio.h#includepthread.h#includewrap.htypedef struct c_info int cfd; struct sockaddr_in cliaddr;CINFO;void *client_fun(void *arg);int main(int argc,char *argv[]) if(argc2) printf(argc2 ); return 0; //如果使用pthread_join或pthread_detach()回收资源要具体的线程id,太繁琐， //所以在创建线程时赋予detach属性 pthread_attr_t attr; pthread_attr_init(attr); pthread_attr_setdetachstate(attr,PTHREAD_CREATE_DETACHED); short port=atoi(argv[1]); int lfd=tcp4bind(port,NULL);//创建套接字 绑定 Listen(lfd,128); struct sockaddr_in cliaddr; socklen_t len=sizeof(cliaddr); CINFO *info; while(1) int cfd=Accept(lfd,(struct sockaddr *)cliaddr,len); //printf(new client ip=%s port=%d ,inet_ntop(AF_INET,cliaddr.sin_addr.s_addr,buf,16),ntohs(cliaddr.sin_port)); pthread_t pthid; //这里如果CINFO info来用是不可以的，在多线程环境下，可能info里面的信息被覆盖，就不是原来的信息，所以放在堆区。 info=malloc(sizeof(CINFO)); info-cfd=cfd; info-cliaddr=cliaddr; pthread_create(pthid,NULL,client_fun,info); return 0;void *client_fun(void *arg) CINFO *info=(CINFO *)arg; char buf[16]=; printf(new client ip=%s port=%d ,inet_ntop(AF_INET,(info-cliaddr.sin_addr.s_addr),buf,16),ntohs(info-cliaddr.sin_port)); while(1) char buf[1024]=; int count=0; count=read(info-cfd,buf,sizeof(buf)); if(count0) perror(read:); break; else if(count==0) printf(client close ); break; else printf(%s ,buf); write(info-cfd,buf,count); close(info-cfd); free(info); 高并发服务器为了实现更好的并发：以下由三种方法 阻塞等待：消耗资源，效率不高 非阻塞忙轮询：消耗cpu 多路IO转接(多路IO复用)：这种较为理想，epoll，select，poll都是 依赖 Linux 内核事件机制 实现的 IO 多路复用模型，他们可以监听到任意socket的读写缓冲区发生了变化，应用层进而去处理。这样实现高并发。 多路IO转接服务器也叫做多任务IO服务器，该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，而是由内核替应用程序监视 windows 使用select select跨平台 poll 用的较少 epoll linux select select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数。 解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力。 #include sys/select.htypedef /* ... */ fd_set;int select(int nfds, fd_set * _Nullable restrict readfds, fd_set * _Nullable restrict writefds, fd_set * _Nullable restrict exceptfds, struct timeval * _Nullable restrict timeout);功能：监听多个文件描述符的属性变化（读，写，异常）参数：nfds:最大文件描述符+1 readfds:需要监听的读的文件描述符存放集合 writefds:需要监听的写的文件描述符存放集合 NULL exceptfds:需要监听的异常的文件描述符存放集合 NULL timeout：多长时间监听一次 固定的时间，限时等待 NULL 永久监听返回值：返回的是变化的文件描述符的个数，变化的文件描述符会在readfds保存，但是没有变化的文件描述符会被删掉。struct timeval time_t tv_sec; /* seconds */ suseconds_t tv_usec; /* microseconds */;void FD_CLR(int fd, fd_set * set);//从集合删除指定文件描述符int FD_ISSET(int fd, fd_set * set);//文件描述符是否在集合，在就返回1void FD_SET(int fd, fd_set * set);//向集合添加文件描述符void FD_ZERO(fd_set * set);//清空文件描述符集 基于select的并发服务器#includestdio.h#includesys/select.h#includesys/types.h#includeunistd.h#includewrap.h#includesys/time.h#define PORT 8888int main(int argc,char *argv[]) //创建套接字，绑定 int lfd=tcp4bind(PORT,NULL); //监听 Listen(lfd,128); int maxfd=lfd;//最大的文件描述符 fd_set oldset,rset; //清空集合 FD_ZERO(oldset); FD_ZERO(rset); //将lfd添加到oldset集合中 FD_SET(lfd,oldset); while(1) rset=oldset; int n=select(maxfd+1,rset,NULL,NULL,NULL); if(n0) perror(select:); break; else if(n==0) continue; else //监听到了文件描述符的变化 //lfd 代表有新的连接到来 if(FD_ISSET(lfd,rset)) struct sockaddr_in cliaddr; socklen_t len=sizeof(cliaddr); char ip[16]=; //提取新的连接 int cfd=Accept(lfd,(struct sockaddr*)cliaddr,len); printf(new client ip=%s port=%d ,inet_ntop(AF_INET,cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port)); //将cfd添加至oldset集合中，以下次监听 FD_SET(cfd,oldset); //更新maxfd if(cfdmaxfd) maxfd=cfd; //如果只有lfd变化，continue if(--n==0) continue; //cfd 遍历lfd之后的文件描述符是否在rset集合中，如果在则cfd变化 for(int i=lfd+1;i=maxfd;i++) if(FD_ISSET(i,rset)) char buf[1500]=; int ret=Read(i,buf,sizeof(buf)); if(ret0)//出错，将cfd关闭，从oldset删除cfd; perror(Read); close(i); FD_CLR(i,oldset); continue; else if(ret==0) printf(client close ); close(i); FD_CLR(i,oldset); else printf(%s ,buf); Write(i,buf,ret); new client ip=127.0.0.1 port=54938helloclient close select的优缺点： 优点：跨平台 缺点： 文件描述符1024的限制 由于FD_SETSIZE的限制。只是返回变化的文件描述符的个数，具体是哪些变化，需要遍历。 每次都需要将需要监听的文件描述符集合由应用层拷贝到内核，也比较费时间。 当大量并发，少量活跃，select效率低。 假设现在4-1023个文件描述符需要监听，但是5-1000这些文件描述符关闭了？ 列一个数组存储监听的文件描述符列表，文件描述符关闭就把他的值从数组覆盖掉，再确认那些文件描述符读或写，直接遍历这个数组，效率高些，但是还是很一般。 其实我们可以在文件描述符表把后面的文件描述符提前，让文件描述符更紧凑，这样效率更高，我们可以使用dup2函数把前面空余的文件描述符复制后面的，再把后面的关掉。 假设4-1023个文件描述符需要监听，但是只有5，1002发来消息：无解 poll#include poll.hint poll(struct pollfd * fds, nfds_t nfds, int timeout);功能：监听多个文件描述符的属性变化参数:\tfds:监听的数组首元素地址 nfds:数组有效元素的最大下标+1 timeout:超时时间 -1是永久监听 =0限时等待数组元素：struct pollfdstruct pollfd int fd; /* file descriptor */ 需要监听的文件描述符 short events; /* requested events */ 需要监听的文件描述符什么事件 POLLIN 读事件 POLLOUT 写事件 short revents; /* returned events */ 返回监听到的事件; poll相对于select的优缺点： 优点： 没有文件描述符1024的限制 请求和返回是分离的 缺点和select一样： 每次都需要将需要监听的文件描述符从应用层拷贝到内核 每次都需要将数组的元素遍历一遍才知道那一个文件描述符变化了 大量并发，少量活跃，效率低。 epoll 红黑树的节点不只是文件描述符。 epoll API 1.创建红黑树 #include sys/epoll.hint epoll_create(int size);参数： size:监听的文件描述符上限，2.6版本之后写1即可会自动扩展返回值： 返回树的句柄 2.上树 下树 修改节点 #include sys/epoll.hint epoll_ctl(int epfd, int op, int fd, struct epoll_event * _Nullable event);参数： epfd:树的句柄 op:选项：EPOLL_CTL_ADD 上树 EPOLL_CTL_MOD 修改节点 EPOLL_CTL_DEL 下树 fd:上树下树的文件描述符 event:上树的节点 struct epoll_event uint32_t events; /* Epoll events */ 需要监听的事件 EPOLLIN　读事件　EPOLLOUT 写事件 epoll_data_t data; /* User data variable */ 需要监听的文件描述符 ; union epoll_data void * ptr; int fd; uint32_t u32; uint64_t u64; ; typedef union epoll_data epoll_data_t; 3.监听 #include sys/epoll.hint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);功能：监听树上文件描述符的变化参数：\tepfd:树的句柄 events：接收变化节点的数组的首地址 maxevents：数组元素的个数 timeout：-1 永久监听 大于等于0限时等待返回值： 返回的是变化的文件描述符个数 示例代码：父子进程通过管道通信 #includestdio.h#includeunistd.h#includestring.h#includesys/epoll.h#include sys/types.h int main(int argc,char *argv[]) int fd[2]; pipe(fd); //创建子进程 pid_t pid; pid=fork(); if(pid0) perror(fork:); return 1; else if(pid==0) close(fd[0]); char buf[5]; char ch=a; while(1) sleep(3); memset(buf,ch++,sizeof(buf)); write(fd[1],buf,5); else close(fd[1]); //创建树 int epfd=epoll_create(1); //上树 struct epoll_event ev,evs[1]; ev.data.fd=fd[0]; ev.events=EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,fd[0],ev); //监听 while(1) int n=epoll_wait(epfd,evs,1,-1); if(n==1) char buf[128]=; int ret=read(fd[0],buf,sizeof(buf)); if(ret=0) close(fd[0]); epoll_ctl(epfd,EPOLL_CTL_DEL,fd[0],ev); break; else printf(%s ,buf); return 0; aaaaabbbbbcccccdddddeeeeefffffggggghhhhh 基于epoll的高并发服务器#includestdio.h#includewrap.h#includesys/epoll.hint main(int argc,char *argv[]) //创建套接字 绑定 int lfd=tcp4bind(8000,NULL); //监听 Listen(lfd,128); //创建树 int epfd=epoll_create(1); //将lfd上树 struct epoll_event ev,evs[1024]; ev.data.fd=lfd; ev.events=EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,ev); //while监听 while(1) int nready=epoll_wait(epfd,evs,1024,-1); if(nready0) perror(epoll_wait:); break; else if(nready==0) continue; else for(int i=0;inready;i++) //判断lfd变化，并且是读事件变化 if(evs[i].data.fd==lfdevs[i].events EPOLLIN) struct sockaddr_in cliaddr; char ip[16]=; socklen_t len=sizeof(cliaddr); //提取新的连接 int cfd=Accept(lfd,(struct sockaddr*)cliaddr,len); printf(new client ip=%s port=%d ,inet_ntop(AF_INET,cliaddr.sin_addr.s_addr,ip,16),ntohs(cliaddr.sin_port)); //将cfd上树 ev.data.fd=cfd; ev.events=EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,ev); else if(evs[i].events EPOLLIN)//cfd变化,而且是读事件变化 char buf[1024]=; int n=read(evs[i].data.fd,buf,sizeof(buf)); if(n0) perror(read:); epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,evs[i]); else if(n==0)//客户端关闭 printf(client close); close(evs[i].data.fd); epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,evs[i]); else printf(%s ,buf); write(evs[i].data.fd,buf,n); return 0; new client ip=127.0.0.1 port=56746hello epoll的两种工作方式在电路中，存在高电平和低电平，水平触发：持续的高电平或者低电平。边沿触发：电平有高到低的一个变化 或者由低到高的变化。对于epoll_wait的水平触发 LT，边沿触发 ET,对于读缓冲区使用水平触发，epoll_wait(系统调用)触发很频繁，所以使用边沿触发。写缓冲区一般用边沿触发 如何使用边沿触发呢，读缓冲区默认是水平触发。我们可以在上树时，需要设置需要监听的事件，再加上个EPOLLET ev.events=EPOLLIN | EPOLLET 基于epoll的高并发服务器(加入边沿触发和优化代码)将cfd设置边沿触发。设置边沿触发就要非阻塞。 #include stdio.h#include wrap.h#include sys/epoll.h#include sys/fcntl.hint main(int argc, char *argv[]) // 创建套接字 绑定 int lfd = tcp4bind(8000, NULL); // 监听 Listen(lfd, 128); // 创建树 int epfd = epoll_create(1); // 将lfd上树 struct epoll_event ev, evs[1024]; ev.data.fd = lfd; ev.events = EPOLLIN; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, ev); // while监听 while (1) int nready = epoll_wait(epfd, evs, 1024, -1); printf(epoll_wait ......................... ); if (nready 0) perror(epoll_wait: ); break; else if (nready == 0) continue; else for (int i = 0; i nready; i++) // 判断lfd变化，并且是读事件变化 if (evs[i].data.fd == lfd evs[i].events EPOLLIN) struct sockaddr_in cliaddr; char ip[16] = ; socklen_t len = sizeof(cliaddr); // 提取新的连接 int cfd = Accept(lfd, (struct sockaddr *)cliaddr, len); printf(new client ip=%s port=%d , inet_ntop(AF_INET, cliaddr.sin_addr.s_addr, ip, 16), ntohs(cliaddr.sin_port)); // 设置cfd为非阻塞 int flags = fcntl(cfd, F_GETFL); // 获取cfd的标志位 flags |= O_NONBLOCK; fcntl(cfd, F_SETFL, flags); // 将cfd上树 ev.data.fd = cfd; ev.events = EPOLLIN | EPOLLET; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, ev); else if (evs[i].events EPOLLIN) // cfd变化,而且是读事件变化 while (1) //使用循环读，因为cfd采用的边沿模式读，一次可能读不完需要循环读保证读完 //但是read循环读的话会产生阻塞，这个程序就无法监听了，所以设置cfd为非阻塞 char buf[4] = ; //如果读一个缓冲区，缓冲区没有数据，如果是带阻塞，就阻塞等待 //如果是非阻塞，返回值就等于-1,并且会将errno的值置为EAGAIN //所以在非阻塞这里就出现问题了，n0,可能是出错或者没有数据，没有数据不必下树，退出循环读。出错下树 int n = read(evs[i].data.fd, buf, sizeof(buf)); if (n 0) //缓冲区读干净了，跳出读循环 if(errno==EAGAIN) break; //普通错误 perror(read:); epoll_ctl(epfd, EPOLL_CTL_DEL, evs[i].data.fd, evs[i]); close(evs[i].data.fd); break; else if (n == 0) // 客户端关闭 printf(client close); close(evs[i].data.fd); epoll_ctl(epfd, EPOLL_CTL_DEL, evs[i].data.fd, evs[i]); break; else //这里为什么不用printf了呢，因为printf输出字符串时，会去找字符串结束的\\0但是网络传输收到的是没有\\0(需要主动方手动添加) //没有\\0,printf就会出错，但是使用write函数就不会 write(STDOUT_FILENO,buf,n); write(evs[i].data.fd, buf, n); return 0; epoll反应堆Reactorepoll反应堆就是把这三个东西：文件描述符 事件 回调函数封装在一起。 结构体来封装。 反应堆模式（Reactor Pattern）是一种事件驱动的设计模式，用于处理并发 IO 操作。核心思想： 事件驱动：等待多个事件（如网络连接的读写事件）发生； 事件分发：事件就绪时，分发给相应的处理器执行； 非阻塞 IO：避免线程阻塞，提高资源利用率。 线程池线程池，事先创建几个线程，不停取任务，如果没有任务休眠，省去了不停的创建线程销毁线程的事件和资源 注意：线程池 处理的单个任务所需要处理的时间必须很短。 一个锁 两个条件变量 循环队列 libeventlibevent 是一个 高性能事件通知库，用于在不同平台上进行 异步事件驱动编程，特别适合开发网络服务（如 HTTP 服务器、聊天服务等）。它封装了底层的 select、poll、epoll、kqueue 等系统调用，提供了统一、跨平台的接口。 libevent事件触发流程 libevent的使用创建event_base根节点struct event_base *event_base_new(void);返回值就是event_base根节点，因为libevent底层默认使用epoll,所以定义了一个自己封装的节点释放根节点void event_base_free(struct event_base *);循环监听int event_base_dispatch(struct event_base *base);相当于while(1)epoll_wait()//循环监听退出循环监听int event_base_loopexit(struct event_base *base,const struct timeval*tv);//等待固定时间退出int event_base_loopbreak(struct event_base *base);//立即退出 初始化上树节点struct event*event_new(struct event_base *base,evutil_socket_t fd, short events,event_callback_fn cb,void *arg);参数： base:event_base根节点 fd:上树的文件描述符 events:监听的事件 EV_TIMEOUT 超时事件 EV_READ 读事件 EV_WRITE 写事件 EV_SIGNAL 信号事件 EV_PERSIST 周期性触发 cb:回调函数 typedef void (*event_callback_fn)(evutil_socket_t fd,short events,void *arg);返回值:初始化好的节点的地址 节点上树int event_add(struct event*ev,const struct timeval *timeout);参数:\tev:上树节点的地址 timeout:NULL 永久监听 固定时间 限时等待 节点下树int event_del(struct event *ev);参数： ev:下树节点的地址 释放节点void event_free(struct event *ev); libevent编写tcp服务器代码创建套接字 绑定 监听 创建event_base根节点 初始上树节点 lfd 上树 循环监听 收尾 #includestdio.h#includewrap.h#includeevent.hvoid cfdcb(int cfd,short event,void *arg) char buf[1500]=; int n=Read(cfd,buf,sizeof(buf)); if(n=0) perror(err or close); // event_del() else printf(%s ,buf); Write(cfd,buf,n); void lfdcb(int lfd,short event,void *arg) struct event_base *base=(struct event_base *)arg; //提取新的cfd int cfd=Accept(lfd,NULL,NULL); //cfd初始化 struct event *ev=event_new(base,cfd,EV_READ|EV_PERSIST,cfdcb,NULL); //cfd上树 event_add(ev,NULL);int main() //创建套接字 //邦定 int lfd=tcp4bind(8000,NULL); //监听 Listen(lfd,128); //创建event_base根节点 struct event_base *base=event_base_new(); //初始化lfd上树节点 struct event *ev=event_new(base,lfd,EV_READ|EV_PERSIST,lfdcb,base); //上树 event_add(ev,NULL); //监听 event_base_dispatch(base);//阻塞 //收尾 event_free(ev); close(lfd); return 0; *在下树的时候有问题，下树时需要所属的struct event ev，但是回调函数也是在event_new函数执行后注册，但是那个时候ev还没有生成，所以不能依靠传参，所以我们要定义一个全局数组，数组成员是自定义结构体包含fd和ev,ev生成后放进数组里，执行读回调后，通过fd查找对应得ev下树。 还有一种就是不用定义数组，直接自定义结构体包含fd和ev传过去。结构体在传之前先malloc,直接定义会因为函数结束而被释放。之前是因为修改的是ev,传的也是ev冲突了，这下改成传的是结构体指针，改的结构体的ev,这不冲突，所以可行。 bufferevent事件普通的event事件 文件描述符 事件(底层缓冲区的读事件或者写事件)触发 回调 高级的event事件 bufferevent事件 bufferevent 封装好的一套“异步读写 + 自动缓冲 + 错误处理 + 回调触发 + 高并发”解决方案，是 libevent 最推荐用的通信组件。 不同点 核心：一个文件描述符 两个缓冲区 三个回调 bufferevent监听流程 bufferevent API创建新的节点struct bufferevent *bufferevent_socket_new( struct event_base *base, evutil_socket_t fd, int options);参数： base:event_base 根节点 fd:要初始化上树的文件描述符 options:BEV_OPT_CLOSE_ON_FREE\t在 bufferevent_free() 时自动关闭 socket（常用） BEV_OPT_THREADSAFE\t让 bufferevent 在多线程中线程安全返回值：新建节点的地址 设置节点的回调void bufferevent_setcb( struct bufferevent *bev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg);参数:\tbev:新建的节点的地址 readcb:读回调 writecb:写回调 eventcb：异常回调 cbarg：传给回调函数的参数 回调函数： typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);//读写回调\ttypedef void (*bufferevent_event_cb)(struct bufferevent *bev, short events, void *ctx);//事件回调\t事件回调 events会写明触发回调的原因 让事件使能int bufferevent_enable(struct bufferevent *bev, short events);int bufferevent_disable(struct bufferevent *bev, short events);参数： bev:新建的节点的地址 events:使生效或使失效的事件 EV_READ EV_WRITE 发送数据将数据写入 bufferevent 的输出缓冲区，异步发送（不会立即写到 socket 上）发送后会触发回调int bufferevent_write(struct bufferevent *bev, const void *data, size_t size); 接受数据size_t bufferevent_read(struct bufferevent *bev, void *data, size_t size);将从 bev 的读缓冲区中读取最多 size 字节的数据，复制到 data。同时将读到的数据从bufferevent的读缓冲区清除返回实际读取的字节数。 连接侦听器创建套接字 绑定 监听 提取struct evconnlistener *evconnlistener_new_bind( struct event_base *base, evconnlistener_cb cb, void *ctx, unsigned flags, int backlog, const struct sockaddr *sa, int socklen);参数： base：根节点 cb:提取套接字cfd（连接到来）调用的回调 回调函数： typedef void evconnlistener_cb( struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *addr, int socklen, void *ctx ); 参数： listener：连接侦听器的地址 fd：提取后的新文件描述符cfd addr:客户端的地址信息 socklen：addr的大小 ctx：evconnlistener_new_bind传给回调函数的参数 ctx:传给回调函数的参数 flags: LEV_OPT_CLOSE_ON_FREE\t关闭时自动释放（推荐） LEV_OPT_REUSEABLE\t设置 SO_REUSEADDR 端口复用（推荐） LEV_OPT_THREADSAFE\t线程安全 LEV_OPT_LEAVE_SOCKETS_BLOCKING 文件描述符为阻塞的 backlog:-1 监听队列长度自动填充 sa：绑定的地址信息 socklen：sa的大小 返回值：连接侦听器的地址 这个是用来写tcp客户端的创建套接字 连接服务器但是要先有节点struct bufferevent *bufferevent_socket_new( struct event_base *base, evutil_socket_t fd, int options);这里fd为-1. int bufferevent_socket_connect( struct bufferevent *bev, const struct sockaddr *address, int addrlen);参数： bev:新建的节点 address:服务器的地址信息 addrlen：address长度 基于hello-world.c的服务端代码/* This example program provides a trivial server program that listens for TCP connections on port 9995. When they arrive, it writes a short message to each client connection, and closes each connection once it is flushed. Where possible, it exits cleanly in response to a SIGINT (ctrl-c).*/#include string.h#include errno.h#include stdio.h#include signal.h#ifndef _WIN32#include netinet/in.h# ifdef _XOPEN_SOURCE_EXTENDED# include arpa/inet.h# endif#include sys/socket.h#endif#include event2/bufferevent.h#include event2/buffer.h#include event2/listener.h#include event2/util.h#include event2/event.hstatic const char MESSAGE[] = Hello, World! ;static const int PORT = 9995;static void listener_cb(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);static void conn_writecb(struct bufferevent *, void *);static void conn_eventcb(struct bufferevent *, short, void *);static void conn_readcb(struct bufferevent *, void *);static void signal_cb(evutil_socket_t, short, void *);intmain(int argc, char **argv)\tstruct event_base *base;//创建根节点\tstruct evconnlistener *listener;\tstruct event *signal_event;\tstruct sockaddr_in sin = 0;#ifdef _WIN32\tWSADATA wsa_data;\tWSAStartup(0x0201, wsa_data);#endif\tbase = event_base_new();\tif (!base) fprintf(stderr, Could not initialize libevent! ); return 1; sin.sin_family = AF_INET;\tsin.sin_port = htons(PORT);\t//创建连接侦听器\tlistener = evconnlistener_new_bind(base, listener_cb, (void *)base, LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1, (struct sockaddr*)sin, sizeof(sin));\tif (!listener) fprintf(stderr, Could not create a listener! ); return 1; //创建信号触发的节点\tsignal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base);\t//将信号节点上树\tif (!signal_event || event_add(signal_event, NULL)0) fprintf(stderr, Could not create/add a signal event! ); return 1; event_base_dispatch(base);//循环监听\tevconnlistener_free(listener);//释放连接侦听器\tevent_free(signal_event);//释放信号节点\tevent_base_free(base);//释放event_base根节点\tprintf(done );\treturn 0;static voidlistener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data)\tstruct event_base *base = user_data;\tstruct bufferevent *bev;\t//将fd上树\t//新建一个bufferevent节点\tbev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);\tif (!bev) fprintf(stderr, Error constructing bufferevent!); event_base_loopbreak(base); return; //设置回调\tbufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL);\tbufferevent_enable(bev, EV_WRITE | EV_READ);//设置读写事件使能\t//bufferevent_disable(bev, EV_READ);//设置读事件非使能\t//bufferevent_write(bev, MESSAGE, strlen(MESSAGE));//给cfd发送消息 hello worldstatic voidconn_readcb(struct bufferevent *bev, void *user_data)\tchar buf[1500]=;\tint n=bufferevent_read(bev,buf,sizeof(buf));\t//不用担心出错，出错会触发事件回调\tprintf(%s ,buf);\tbufferevent_write(bev, buf,n);//给cfd发送消息static voidconn_writecb(struct bufferevent *bev, void *user_data)\tstruct evbuffer *output = bufferevent_get_output(bev);//获取缓冲区类型\tif (evbuffer_get_length(output) == 0) //判断==0则应用层缓冲区为空，发送完毕 //printf(flushed answer ); //bufferevent_free(bev);//释放节点 自动关闭连接\tstatic voidconn_eventcb(struct bufferevent *bev, short events, void *user_data)\tif (events BEV_EVENT_EOF) printf(Connection closed. ); else if (events BEV_EVENT_ERROR) printf(Got an error on the connection: %s , strerror(errno));/*XXX win32*/ /* None of the other events can happen here, since we havent enabled * timeouts */\tbufferevent_free(bev);static voidsignal_cb(evutil_socket_t sig, short events, void *user_data)\tstruct event_base *base = user_data;\tstruct timeval delay = 2, 0 ;\tprintf(Caught an interrupt signal; exiting cleanly in two seconds. );\tevent_base_loopexit(base, delay);//退出循环监听 webserver服务器流程 htmlhtml 超文本标签语句(超文本标记语言) html head meta http-equiv=content-Type content=text/html;charset=utf8 title我是一个html/title body font size=7 color=redhello world/font br/ font size=7 color=redhello world/font /body /head/html HTTP协议http请求 请求行：GET /demo.html HTTP/1.1\\r 请求方式 /请求的内容 版本\\r 请求头空行\\r 数据 部分 内容示例 请求行 GET /index.html HTTP/1.1包含：方法、请求目标路径、HTTP版本号 请求头 一组键值对，每行一个，例如：Host: www.example.com``User-Agent: curl/7.81.0 空行 请求头与请求体之间必须有一个空行 请求体 （可选）提交的数据，比如表单、JSON、文件上传等 http应答 状态行：HTTP/1.1 200 OK\\r 版本 状态码 状态信息\\r 消息报头：\t文件类型（必填的）\t文件的长度（可填可不填，填了要求一定对）空行\\r 发送文件 部分 示例与说明 状态行 HTTP/1.1 200 OK包含：协议版本、状态码、状态短语 响应头 键值对形式，如：Content-Type: text/html``Content-Length: 123 空行 用于分隔响应头和响应体 响应体 实际返回的内容，如网页HTML、JSON数据、图片等（可选） 状态码 状态码 名称 含义描述 200 OK 请求成功，服务器正常返回了请求的数据。 301 Moved Permanently 资源已永久移动到新位置，浏览器会自动跳转，搜索引擎会更新索引。 302 Found 资源临时移动，原 URL 仍然有效，浏览器会自动跳转。 400 Bad Request 请求语法错误或参数无效，服务器无法理解请求。 401 Unauthorized 请求需要身份认证（未登录或 token 无效）。 403 Forbidden 已认证但没有权限访问该资源。 404 Not Found 请求的资源不存在，可能是 URL 错误或资源已删除。 500 Internal Server Error 服务器内部错误，可能是代码异常或服务器故障。 读取目录下的所有文件名 以前用readdir函数，还有一个scandir #include dirent.hstruct dirent ino_t d_ino; /* Inode number */ off_t d_off; /* Not an offset; see below */ unsigned short d_reclen; /* Length of this record */ unsigned char d_type; /* Type of file; not supported by all filesystem types */ char d_name[256]; /* Null-terminated filename */;struct dirent **mylist;int scandir(const char * restrict dirp, struct dirent ** * restrict namelist, int( * filter)(const struct dirent * ), int( * compar)(const struct dirent ** , const struct dirent ** ));参数:\tdirp：目录下的路径名 namelist：mylist地址 filter：过滤的函数入口地址 compar：排序函数入口地址 alphasort(字母排序) 返回值：读取文件的个数 webserver代码（基于epoll）#include stdio.h#include unistd.h#include stdlib.h#include string.h#include wrap.h#include sys/epoll.h#include sys/fcntl.h#include sys/stat.h#includedirent.h#includesignal.h#define PORT 8889void send_header(int cfd, int code, char *info, char *filetype, int length) // 发送状态行 char buf[1024] = ; int len = sprintf(buf, HTTP/1.1 %d %s\\r , code, info); send(cfd, buf, len, 0); // 发送消息头 len = sprintf(buf, Content-Type:%s\\r , filetype); send(cfd, buf, len, 0); if (length 0) len = sprintf(buf, Content-Length:%d\\r , length); send(cfd, buf, len, 0); // 空行 send(cfd, \\r , 2, 0);void send_file(int cfd, char *path, struct epoll_event *ev, int epfd, int flag) int fd = open(path, O_RDONLY); if (fd 0) perror(); return; char buf[1024] = ; int len = 0; while (1) len = read(fd, buf, sizeof(buf)); if (len 0) perror(); break; else if (len == 0) break; else send(cfd, buf, len, 0); //这里发送大文件时会出现无法播放的问题，写缓冲区可能满，写不进去， //写不进去，监听EPOLLOUT,将没有发送的数据保存，等写事件触发，写出去 //消息存储未发送的数据 //libevent库的bufferevent可以解决 close(fd); // 关闭cfd,下树 if (flag == 1) close(cfd); epoll_ctl(epfd, EPOLL_CTL_DEL, cfd, ev); void read_client_request(int epfd, struct epoll_event *ev) // 读取请求（先读取一行，在把其他行读取，扔掉） char buf[1024] = ; char tmp[1024] = ; int n = Readline(ev-data.fd, buf, sizeof(buf)); if (n = 0) printf(close or err ); epoll_ctl(epfd, EPOLL_CTL_DEL, ev-data.fd, ev); close(ev-data.fd); return; printf(%s , buf); int ret = 0; while ((ret = Readline(ev-data.fd, tmp, sizeof(tmp))) 0); // printf(read ok ); // 解析请求行 GET /a.txt HTTP/1.1\\r char method[256] = ; char content[256] = ; char protocol[256] = ; sscanf(buf, %[^ ] %[^ ] %[^ \\r ], method, content, protocol); printf([%s] [%s] [%s] , method, content, protocol); // 判断是否为get请求，get请求才处理 if (strcasecmp(method, get) == 0) // 这个函数比较忽略大小写 char *strfile = content + 1; //在请求阶段注意如果传过来的是中文，中文是一堆十六进制（URL编码），需要转换才能使用 //传过来后必须把按十六进制转换成十进制，一个字节一个字节的转，最后拼在一起放在字符串中即可使用 // 如果没有请求文件，默认请求工作目录 // 得到浏览器请求的文件 如果对方没有请求文件 默认请求 ./ if (*strfile == 0) strfile = ./; // 判断请求的文件在不在 // 判断文件是否存在,如果存在（发送普通文件，目录） struct stat s; if (stat(strfile, s) 0) // 文件不存在 printf(file not found ); // 先发送 报头(状态行 消息头 空行) send_header(ev-data.fd, 404, Not Found, /text/html, 0); // 发送文件 发送error.html send_file(ev-data.fd, client.c, ev, epfd,1); else // 请求的是一个普通文件 if (S_ISREG(s.st_mode)) printf(file ); // 先发送 报头(状态行 消息头 空行) send_header(ev-data.fd, 200, ok, /text/html, 0); // 发送文件 send_file(ev-data.fd, strfile, ev, epfd,1); else if (S_ISDIR(s.st_mode)) // 请求的是一个目录 printf(dir ); // 发送一个列表 网页 // 先发送 报头(状态行 消息头 空行) send_header(ev-data.fd, 200, ok, /text/html, 0); // 发送header.html send_file(ev-data.fd, dir_header.html, ev, epfd,0); //发送列表 struct dirent **mylist=NULL; int n=scandir(strfile,mylist,NULL,alphasort); char buf[1024]=; int len=0; for(int i=0;in;i++) printf(%s ,mylist[i]-d_name); if(mylist[i]-d_type==DT_DIR) len=sprintf(buf,lia href=%s/ %s/ali,mylist[i]-d_name,mylist[i]-d_name); else len=sprintf(buf,lia href=%s%s/ali,mylist[i]-d_name,mylist[i]-d_name); send(ev-data.fd,buf,len,0); free(mylist[i]); free(mylist); send_file(ev-data.fd, dir_tail.html, ev, epfd,1); int main() //忽略这个信号，为了解决在浏览器请求大文件，服务器有时会关闭的问题， //因为有的浏览器会把读端关闭，导致服务端无法写 signal(SIGPIPE,SIG_IGN); // 切换工作目录 // 获取当前目录的工作路径 char pwd_path[256] = ; char *path = getenv(PWD); strcpy(pwd_path, path); strcat(pwd_path, /web-http); // 切换工作目录 chdir(pwd_path); // 创建套接字 绑定 int lfd = tcp4bind(PORT, NULL); // 监听 Listen(lfd, 128); // 创建树 int epfd = epoll_create(1); // 将lfd上树 struct epoll_event ev, evs[1024]; ev.data.fd = lfd; ev.events = EPOLLIN; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, ev); // 循环监听 while (1) int nready = epoll_wait(epfd, evs, 1024, -1); if (nready 0) perror(); break; else for (int i = 0; i nready; i++) // 判断是否是lfd if (evs[i].data.fd == lfd evs[i].events EPOLLIN) struct sockaddr_in cliaddr; char ip[16] = ; socklen_t len = sizeof(cliaddr); int cfd = Accept(lfd, (struct sockaddr *)cliaddr, len); printf(new client ip=%s port=%d , inet_ntop(AF_INET, cliaddr.sin_addr.s_addr, ip, 16), ntohs(cliaddr.sin_port)); // 设置cfd为非阻塞 int flag = fcntl(cfd, F_GETFL); flag |= O_NONBLOCK; fcntl(cfd, F_SETFL, flag); // 上树 ev.data.fd = cfd; ev.events = EPOLLIN; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, ev); else if (evs[i].events EPOLLIN) // cfd变化 read_client_request(epfd, evs[i]); // 收尾 这个代码还有URL转码，函数没有实现。发送大文件，无法传输的问题，已写明解决方法（基于bufferevent）。 为什么服务端 send() 写不进去，错误是“写缓冲区满”，难道不是因为“客户端浏览器的读缓冲区满”吗？ 正确解释如下：send() 写的是 内核发送缓冲区 当你调用 send(fd, buf, len, 0) 时： 数据不是直接“发到浏览器”，而是先写入 服务端内核的 socket 发送缓冲区； 只有写进这个缓冲区成功，send() 才会返回你“写成功了”； 如果这个缓冲区满了，send() 就会返回 -1，并设置 errno = EAGAIN。 这就是“写缓冲区满”的真正含义 —— 是你本地操作系统的内核缓冲区满了，跟浏览器还没关系。 完结撒花","tags":["Linux Network Programming"],"categories":["Linux Network Programming"]},{"title":"mysql连接池","path":"/2025/07/03/mysql连接池/","content":"项目目的为了提高MySQL数据库(基于CS设计)的访问瓶颈，除了在服务端增加缓存服务器缓存常用的数据之外，还可增加连接池，来提高MySQL Server的访问效率，在高并发情况下，大量的TCP三次握手，MySQL Server连接认证，MySQL Server关闭连接回收资源和TCP四次挥手所耗费的性能时间也是很明显的，增加连接池就是为了减少这一部分的损耗。","tags":["mysql连接池"],"categories":["mysql连接池"]},{"title":"Linux系统编程","path":"/2025/06/20/Linux系统编程/","content":"Linux常见目录 目录 说明 / 根目录，所有目录的起点，Linux 文件系统的顶级目录 /bin 存放常用的二进制可执行文件（如 ls、cp、mv 等），普通用户和系统都可使用 /sbin 系统管理命令，只有 root 用户可用（如 reboot、ifconfig） /etc 配置文件目录（如 /etc/passwd、/etc/fstab、/etc/ssh/sshd_config） /home 普通用户的家目录（如 /home/user1） /root 超级用户（root）的家目录 /lib 核心共享库和驱动模块，供 /bin 和 /sbin 下的程序使用 /usr 存放用户应用程序和文件，子目录中包括 /usr/bin、/usr/lib 等 /usr/bin 普通用户使用的应用程序（非基本命令） /usr/sbin 非系统引导时使用的系统管理员命令 /var 可变数据，如日志文件 /var/log、邮件、缓存、锁等 /tmp 临时文件，系统重启后可能会被清空 /opt 第三方软件安装目录（如 Chrome、VMware 等） /dev 设备文件（如硬盘 /dev/sda，终端 /dev/tty） /proc 虚拟文件系统，内核和进程信息（如 /proc/cpuinfo、/proc/meminfo） /sys 另一种虚拟文件系统，提供与内核、设备驱动的交互接口 /boot 存放启动相关文件，如内核、grub 等（如 /boot/vmlinuz-*） /media 可移动媒体挂载点（如 U 盘、光盘） /mnt 临时挂载点，一般管理员手动挂载文件系统用 /run 系统运行时临时文件（如 PID、Socket） /srv 提供服务的数据目录（如 Web 服务、FTP 服务的数据） Bash解析器常用快捷键1.tap键 补齐命令，补齐路径，显示当前目录下的所有目录 2.清屏 clear 3.中断进程 ctrl+c 4 遍历输入的历史命令箭头上（ctrl+p）箭头下(ctrl+n) 5 光标相关操作 光标左移： ctrl+b（箭头左） 光标右移： ctrl+f(箭头右) 移动到头部: ctrl+a(home键) 移动到尾部：ctrl+e(end键) 6字符删除 删除光标前面的字符：ctrl+h(Backspace) 删除光标后面的字符：ctrl+d 光标后面的字符即光标覆盖的字符 删除光标前的所有内容：ctrl+u 删除光标后的所有内容：ctrl+k 终端相关快捷键（终端一定要选中） ctrl+shift+N 新建一个终端 ctrl+shift+T 在终端里新建一个标签 ctrl+D 关闭当前一个终端 内建命令和外部命令对比内建命令 vs 外部命令 对比总结 比较项 内建命令（Builtin Command） 外部命令（External Command） 定义 由 Shell 内部直接实现的命令 是文件系统中的可执行程序（如 /bin/ls） 执行速度 快（不需新建进程） 较慢（需 fork 子进程执行） 资源消耗 少，执行在当前 Shell 进程中 多，执行时创建子进程 路径查找 不需要依赖 PATH 环境变量 需要从 PATH 中查找可执行文件 是否可以替换 一般不推荐重定义 可以覆盖、替换或删改（如 alias 覆盖） 是否常驻内存 是，Shell 启动时加载 否，执行时加载，执行完释放 例子 cd, echo, exit, pwd, type ls, cp, gcc, vim, python 查看方法 type cd → builtin type ls → file 命令类型查看方法 使用type命令 type [选项] 命令名 使用 -a 显示所有同名命令（包括 alias、builtin、文件） 使用 -t 显示类型（简洁） Linux命令格式命令 [选项] [参数] 部分 说明 命令 要执行的操作，如 ls、cp、mkdir 等 选项 用于控制命令行为的开关，通常以 - 或 -- 开头，例如 -l、--help 参数 命令作用的对象，通常是文件名、目录名、用户名等 选项类型说明 类型 示例 说明 短选项 -l 通常是一个字母，多个可组合（如 -al） 长选项 --help 更易读，通常不可组合 组合选项 -avz 相当于 -a -v -z 帮助文档查看方法如果是内建命令（可以通过之前的type命令查看）使用 help +内建命令 help pwd 如果是外部命令 对应命令名 –help ls --help man 是 Linux 中最常用的命令之一，全称是 manual（手册），用于查看各种命令、函数、配置文件的使用说明。它是学习和查找 Linux 命令最权威的工具。 man 命令基本语法： man [选项] [命令名或函数名] man 手册的 9 个部分（章节） 章节号 内容 示例 1 用户命令（常见终端命令） man ls 2 系统调用（内核提供的函数） man 2 open 3 C 库函数 man 3 printf 4 设备文件和特殊文件 man 4 tty 5 配置文件格式 man 5 crontab 6 游戏与趣味（极少） 7 杂项（宏定义、协议、约定等） man 7 signal 8 系统管理员命令（只能 root 执行） man 8 ifconfig 9 内核开发接口（不常见） 常用选项 选项 作用 -k 关键词 搜索相关命令（相当于 apropos） -f 命令名 显示命令属于哪个章节（相当于 whatis） -a 显示所有章节中匹配的 man 页 -M 指定手册路径 --help 查看 man 自身帮助信息 目录相关命令pwd用于显示当前终端所在的工作目录（即当前绝对路径）。 cdcd [目录路径] 常见用法示例 命令 说明 cd /home/user 切换到绝对路径 /home/user 目录 cd .. 切换到上一级目录 cd 或 cd ~ 切换到当前用户的主目录 cd - 切换到上一次所在的目录（切换目录的“切换”） cd ./folder 切换到当前目录下的子目录 folder mkdir用于创建新目录的命令，创建不了已存在目录。 mkdir [选项] 目录名 mkdir test 在当前目录下创建test文件夹 mkdir tmptest mkdir file{1..100}在当前目录创建100个文件夹，file1,file2,file3…file100 mkdir “file{1..100}”在当前目录创建file{1..100}文件夹，只会创建一个。 mkdir “a b” 在当前目录创建a b一个文件夹。 mkdir a b 在当前目录创建a b两个文件夹。 选项 说明 -p 递归创建目录（父目录不存在时自动创建） -m MODE 设置新建目录的权限，如 -m 755 -v 显示详细创建过程（verbose） rmdir用法和mkdir相同 用于删除空目录的命令 命令 说明 rmdir testdir 删除当前目录下的 testdir（需为空） rmdir -p a/b/c 递归删除空目录链：先删 c，再删 b，再删 a rmdir ./mydir/ 删除当前目录中的 mydir（需为空） 选项 说明 -p 递归删除路径中的所有空目录（从子到父） --ignore-fail-on-non-empty 删除目录时忽略非空目录导致的错误 Linux文件类型常用的文件类型有七种：普通文件，目录文件，设备文件，管道文件，链接文件和套接字。 普通文件 是 Linux 中最常见的一类文件，主要用于存储用户数据。包括： 文本文件（如 .txt, .c, .py） 二进制文件（如 可执行程序、图片、音频等） 脚本文件（如 .sh, .py，可以被解释执行） 在 Linux 中，目录文件（Directory File） 是一种特殊的文件类型，用来组织和存放文件和其他目录（子目录）。 它本质上是一个保存了文件名和 inode 编号之间映射关系的文件。 设备文件（Device File）是 Linux 中用于访问硬件设备的接口，本质上就是一种特殊的文件，程序通过它来与硬件设备通信。 设备文件通常位于 /dev 目录中。 常见设备文件举例 路径 类型 功能描述 /dev/sda 块设备 第一块硬盘 /dev/tty 字符设备 当前终端 /dev/null 字符设备 写入数据会被丢弃 /dev/zero 字符设备 会源源不断输出 0 /dev/random 字符设备 伪随机数生成器 管道文件（或称命名管道，FIFO First In First Out）是一种特殊文件，用于在不同进程之间传输数据。 写入管道的数据会按顺序被读取，类似“排队喝水”的水管，先进先出。 管道文件与匿名管道不同之处在于它有名字，存在于文件系统中（通常创建在某个路径下），因此不同进程不必有父子关系也能通信。 链接文件 是指向另一个文件的引用，常用于： 创建多个路径指向同一个文件（节省空间） 为长路径或常用文件创建别名（提高效率） 实现共享与替代功能 类型 描述 ls -l 标识 软链接（符号链接） 类似 Windows 快捷方式，是一个指向目标路径的独立文件 l 硬链接 直接指向目标文件的 inode，本质上是同一个文件的另一个名字 - 在 Linux 中，你可以使用 ls -l 命令来区分各种文件类型。ls -l 输出的每一行开头的第一个字符表示文件类型。下面是 七种常见文件类型及其 ls -l 显示符号： 七种常见文件类型及其标识 文件类型 ls -l 类型字符 示例路径 含义说明 普通文件 - -rw-r--r-- file.txt 常见的文本、二进制、可执行文件等 目录文件 d drwxr-xr-x dir/ 存储文件的容器 字符设备文件 c crw------- /dev/tty 逐字符访问设备，如终端、串口等 块设备文件 b brw-rw---- /dev/sda 按块访问设备，如硬盘、U 盘等 管道文件 p prw-r--r-- mypipe 用于进程间通信的 FIFO 管道 链接文件 l lrwxrwxrwx link - target 指向其他文件的软链接 套接字文件 s srwxrwxrwx socket 进程间网络通信接口，如 /tmp/.X11-unix/X0 文件相关命令ls命令 命令 含义 ls 简单列出当前目录内容 ls -a 显示所有文件，包括隐藏文件（以.开头） ls -l 以长格式列出，显示权限、类型、时间等 ls -lh 长格式 + 人类可读大小（如 KB, MB） ls -lt 按修改时间排序，最新的在前 ls -r 反向排序 ls -R 递归列出子目录 ls -d */ 只列出目录 ls -d只显示一个. ls -l命令会输出长格式 权限 硬链接数 拥有者 所属组 大小 修改日期 文件名drwxr-xr-x 2 user user 4096 Jun 21 13:00 mydir 对权限部分说明一下权限部分总共10个字符 位置 含义 1 文件类型标识 2-4 拥有者（user）权限 5-7 同组用户（group）权限 8-10 其他用户（others）权限 文件类型标识（第1个字符） 字符 类型 - 普通文件 d 目录 l 软链接 c 字符设备文件 b 块设备文件 p 管道（FIFO） s 套接字 权限字符说明（2-10位置） 字符 含义 r 读权限 (read) w 写权限 (write) x 执行权限 (execute) - 无该权限 s setuidsetgid 位（特殊执行权限） t 粘滞位（sticky bit） 三组权限详解 组别 位置 含义 拥有者 2~4 字符 拥有该文件目录的用户权限 组用户 5~7 字符 属于该文件组的用户权限 其他用户 8~10 字符 系统中除拥有者和组以外的所有用户权限 什么是通配符？通配符是一种简化文件名匹配的符号，用于在命令中匹配多个文件或目录。它可以让你不用输入完整文件名，就能选中符合规则的文件。 常用的通配符类型 通配符 作用 例子 匹配结果示例 * 匹配任意数量的任意字符（包括0个） ls *.txt 匹配所有以 .txt 结尾的文件 ? 匹配任意一个单字符 ls file?.txt 匹配 file1.txt、fileA.txt，但不匹配 file10.txt [abc] 匹配括号内的任意一个字符 ls file[123].txt 匹配 file1.txt、file2.txt、file3.txt [a-z] 匹配指定范围内的任意一个字符 ls file[a-c].txt 匹配 filea.txt、fileb.txt、filec.txt [!abc] 匹配不在括号内的任意一个字符 ls file[!123].txt 匹配除 file1.txt、file2.txt、file3.txt 以外的文件 touch命令touch 是用来 创建空文件 或 更新已有文件的时间戳 的命令。 touch file.txt 如果 file.txt 不存在，会被创建为空文件；如果存在，文件时间被更新。 touch file1.txt file2.txt file3.txt 一次创建或更新多个文件。 touch file2,3,4#同时创建file2,file3,file4三个空文件和mkdir file1..100用法是一样的。touch file2,3,4#创建file2,3,4这一个文件。 cp命令cp 是 Linux 中用于 复制文件或目录 的命令。 任务 命令示例 说明 复制文件 cp file1.txt file2.txt 把 file1.txt 内容复制为 file2.txt 复制文件到目录 cp file1.txt /home/user/docs/ 把 file1.txt 复制进目录 复制目录（加 -r） cp -r dir1/ dir2/ 递归复制整个目录 dir1 到 dir2 中 保留属性复制文件 cp -p file1.txt file2.txt 保留原文件的时间戳、权限等信息 强制覆盖目标文件 cp -f file1.txt file2.txt 如果 file2.txt 存在，强制覆盖 复制并提示 cp -i file1.txt file2.txt 有冲突时会提示确认 显示复制过程 cp -v file1.txt file2.txt 复制时显示详细过程（verbose 模式） 选项 含义 -r 递归复制目录（必须用于复制目录） -i 覆盖文件前提示确认 -f 强制覆盖目标文件而不提示 -p 保留原文件的属性（权限、时间等） -u 只在源文件较新时才复制 -v 显示复制过程（verbose） -a 归档模式，等价于 -dpR，用于备份 --parents 保留源路径结构复制文件（适用于目录结构迁移） rm命令是用于在 Linux 中 删除文件和目录 的命令。注意：rm 删除后不会进入回收站，无法轻易恢复，请务必小心使用。 功能 命令 说明 删除单个文件 rm file.txt 删除文件 file.txt 删除多个文件 rm file1.txt file2.txt 一次删除多个文件 递归删除目录及内容 rm -r mydir/ 删除目录 mydir 及其所有子目录和文件 强制删除文件目录 rm -f file.txt rm -rf mydir/ 忽略不存在的文件，且不提示确认 删除前确认 rm -i file.txt 删除前逐一询问确认 显示正在删除的文件 rm -v file.txt 显示被删除的文件名 选项 含义 -r 或 --recursive 递归删除目录及其内容（删除整个目录树） -f 或 --force 强制删除，不提示，即使目标不存在也不报错 -i 删除前询问确认，适合新手使用以防误删 -I 删除多个文件或目录时才询问一次，比 -i 安全且不烦人 -v 或 --verbose 显示正在删除的每一个文件或目录 --preserve-root 默认保护根目录 / 不被删除（系统安全机制，防止 rm -rf / 误操作） mv命令移动文件或目录 到新位置，重命名 文件或目录。 功能 命令示例 说明 移动文件 mv a.txt /home/user/docs/ 把 a.txt 移动到 /home/user/docs/ 目录 重命名文件 mv old.txt new.txt 将 old.txt 重命名为 new.txt 移动并重命名 mv a.txt /home/user/docs/b.txt 移动 a.txt 到新目录并改名为 b.txt 移动目录 mv dir1/ /home/user/backup/ 移动整个目录到新的路径 覆盖已有文件 mv -f a.txt b.txt 如果 b.txt 存在，则强制覆盖 覆盖前确认 mv -i a.txt b.txt 如果 b.txt 存在，移动前会询问是否覆盖 显示移动过程 mv -v a.txt b.txt 显示正在移动的内容 选项 含义 -f 强制覆盖已有目标文件，不提示 -i 如果目标文件存在，提示是否覆盖（interactive） -n 不覆盖已有的目标文件（no-clobber） -v 显示移动过程（verbose） -u 仅在源文件较新或目标文件不存在时才移动 文件内容查看相关命令cat命令用于 查看、创建、合并文件 内容，常用于快速查看文本文件内容。 选项 含义 -n 给所有行编号 -b 只对非空行编号 -s 压缩连续空白行为一行 -T 显示 Tab 为 ^I -E 显示每行结尾的 $（换行符可见） -A 相当于 -vET，显示所有不可见字符 less命令用于分页显示文件内容的命令，支持 向前向后翻页浏览，适合查看大型文本文件。它比 cat 更强大，且不会一次性加载全部内容到内存中。 使用时常用快捷键（进入 less 后） 快捷键 功能说明 空格 向下翻一页 b 向上翻一页 Enter 向下滚动一行 k 向上一行（vi 风格） j 向下一行 G 跳到文件末尾 g 跳到文件开头 /关键词 向下搜索（如 /error） ?关键词 向上搜索 n 重复上一次搜索 N 反向重复搜索 q 退出 less head命令head 用于345 -n N 显示前 N 行（如 head -n 15 file.txt） -c N 显示前 N 个字节（如 head -c 100 file.txt） -q 多文件时不显示文件名头部（quiet） -v 总是显示文件名头部（verbose） tail命令用于显示文件的最后几行内容，默认是最后 10 行。常用于： 查看日志尾部； 实时监控文件内容变化（配合 -f 选项）； 截取文件结尾部分数据。 tail /etc/passwd #默认显示后十行tail -n 30 文件名 #显示后30行内容tail -c 30 文件名 #显示后30个字符 du和df命令du命令查看目录或文件占用的磁盘空间，会考虑磁盘块对齐、文件系统元数据、软链接等因素。 参数 含义 -h 以人类可读的方式显示（如 KB、MB） -s 显示指定文件目录占用的数据块 -a 显示所有文件和目录的大小（默认只显示目录） --max-depth=N 显示目录深度（限制递归层数） du -sh 文件名/目录 项目 ls -l du -sh 显示内容 文件本身大小（内容字节数） 实际磁盘占用（包含对齐和元数据） 对目录 显示目录结构本身大小 显示目录下所有内容实际占用 单位 字节（Bytes） 自动转换为 KBMBGB 应用场景 看文件大小属性 查哪些文件目录占空间最多 echo hello file.txtls -l file.txt # 显示 6 bytesdu -sh file.txt # 显示 4.0K df命令查看整个磁盘的使用情况 df -h # 显示所有文件系统的使用情况（人类可读格式）df -h /home # 查看 /home 所在分区的磁盘使用情况 查找相关命令findfind 是 Linux 中功能非常强大的文件搜索命令，它可以根据名称、类型、时间、大小、权限等多种条件在目录中递归查找文件，还可以执行删除、移动、打印等操作。 find [搜索路径] [搜索条件] [处理动作] 按文件名查询：使用参数 -name find ./ -name *.txt #查找当前路径下符合后缀是。txt的文件 按文件大小查询：使用参数 -size find ./ -size +100k +100k 表示大于100k的文件 -100k表示小于100k的文件 100k 表示等于100k的文件 大小方面：k小写，M大写 查询大小范围 find ./ -size +50k -size -100k 按文件类型查询：使用参数 -type find ./ -type f #查询当前的普通文件 类型代号 含义 示例 f 普通文件 find . -type f 查找所有普通文件（这里不是-，要和ls -l的文件类型区分） d 目录 find . -type d 查找所有目录 l 符号链接（软链接） find . -type l 查找所有软链接 c 字符设备文件 /dev/null 等 b 块设备文件 硬盘等块设备 s 套接字文件 Socket 类型文件 p 命名管道（FIFO） 通信用的特殊文件 grepgrep 是 Linux 中非常常用的文本搜索工具，用于在文件或标准输出中查找匹配的字符串，功能强大，灵活，适合日志分析、配置文件搜索、编程辅助等场景。 grep [选项] 模式 [文件] 选项 含义说明 -n 显示匹配行的行号 -i 忽略大小写 -v 反向匹配（即显示不包含该字符串的行） -r or -R 递归搜索目录下的所有文件 -l 只列出匹配的文件名 -c 统计匹配的行数 --color=auto 高亮显示匹配的内容 grep -i root /etc/passwd #不分大小写，在passwd查找rootgrep -w hello /etc/passwd #在passwd查找完全匹配hello单词的行grep -r u_char ./ #递归搜索当前目录下的符合u_char的行grep -i hello /etc/passwd --color=auto #在/etc/passwd文件中找hello并且忽略大小写，然后高亮显示匹配的关键字 管道管道（|）一个命令的输出可以通过管道作为另一个命令的输入。 ifconfig | grep ens33 #在ifconfig输出的文字查找存在ens33的行 压缩包管理tar把一系列文件归档到一个文件，也可以把档案文件解开以恢复数据。 tar [选项] -f [文件名.tar] [要打包或解压的文件/目录]#f必须放到选项的最后 tar -cvf sysctl.tar sysctl #打包文件，但是不压缩tar -xvf sysctl.tar #解包文件tar -tvf sysctl.tar #查看压缩文件内容 gzip对单个文件进行压缩或解压，压缩率高、速度快，默认生成 .gz 文件。 tar和gzip命令结合使用实现文件打包，压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般为xxx.tar.gz。 gzip单独使用，只可以对文件压缩和解压，不可以对目录。 gzip test1 test2 #不保留源文件压缩。 tar和gzip结合对目录压缩 tar -czvf sysctl.tar.gz sysctl #打包和压缩文件tar -xzvf sysctl.tar.gz #解包和解压文件tar -xzvf sysctl.tar.gz -C /temp #解包和解压文件到temp目录 bzip2和gzip一样和tar结合。 tar -cjvf test.tar.bz2 test #生成一个bz2压缩包tar -xjvf share.tar.bz2 #解压 zip和unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 zip [选项] 目标文件（没有扩展名）源文件/目录unzip -d 解压后目录文件 压缩文件 #-d解压到指定目录 文件权限管理访问权限说明： 读权限（r） 对文件而言，具有读取文件内容的权限；对目录而言，具有浏览目录的权限。 写权限（w） 对文件而言，具有新增，修改文件内容的权限；对目录而言，具有删除，移动目录内文件的权限。 可执行权限（x） 对文件而言，具有执行文件的权限；对目录而言，该用户具有进入目录的权限。 通常。UnixLinux系统只允许文件的属主（所有者）或root用户改变文件的读写权限。 chmodchmod（change mode）是 LinuxUnix 系统中用于修改文件或目录权限的命令。它支持两种权限设置方式：数字方式和符号方式。 chmod [选项] 模式 文件名 符号方式： chmod u/g/o/a +/-/= rwx 文件 #+添加权限 -撤销权限 =设定权限 u/g/o对应的是拥有者，同属组，其他。chomd o+w a #向a的其他用户添加写权限chomd u=rw,g=r,o=r a#把a的拥有者权限为re,同属组权限为r,其他用户权限为r。 数字方式： #由于rwx通过二进制来区分 rwx就是111，十进制为7#rwx 7#rw- 6#r-- 4#r-x 5chomd 0777 a#把a的对应用户的权限变为rwx. chownchown 是 LinuxUnix 中用于更改文件或目录 所属用户（owner） 和 所属用户组（group） 的命令。 chown [选项] [新用户][:[新用户组]] 文件/目录 新用户：新的文件拥有者 新用户组：新的用户组（可选） 需要 sudo 权限（普通用户只能修改自己拥有的文件） #把文件所有者修改为root用户sudo chown root a#把文件所属者改为yustone,所属组改为rootsudo chown yustone:root a 软件安装和卸载使用包管理器安装和卸载Ubuntu Debian 系列 安装 sudo apt update # 更新软件源sudo apt install 软件名 # 安装软件 卸载 sudo apt remove 软件名 # 删除程序但保留配置文件sudo apt purge 软件名 # 连配置文件一并删除 离线软件包安装： sudo dpkg -i package.deb 离线软件包卸载： sudo dpkg -r 软件名 使用 Snap 安装（跨平台容器化安装方式） sudo snap install 软件名 使用 Snap 卸载（跨平台容器化安装方式） sudo snap remove 软件名 从源代码编译安装 ./configuremakesudo make install 重定向主要是把命令输出的内容（之前是屏幕）输入到文件里。 ls /etc/passwd output.txt #标准正确输出重定向到output.txt（这里是覆盖原文件）ls /etc/passwd output.txt #标准正确输出追加重定向到output.txt(这里是追加)llll 2 error.txt #标准错误输出重定向到error.txt(这里是覆盖原文件)llll 2 error.txt #标准错误输出追加重定向到error.txtlll 2 /dev/null #标准错误输出重定向到黑洞ls ddddd /etc/passwd /dev/null #标准正确输出和标准错误输出全部重定向到黑洞。ls ddddd /etc/passwd output.txt #标准正确输出和标准错误输出以追加的方式全部重定向到output.txt. 其他命令treetree以树状形式查看指定目录内容。 tree 目录 lnln命令主要用于创建链接文件。 链接文件分为软链接和硬链接： 硬链接只能链接普通文件，不能链接目录。软链接不占用磁盘空间，源文件删除则链接失效。 ln 源文件 链接文件 #硬链接ln -s 源文件 链接文件 #软链接 如果没有-s选项代表建立一个硬链接文件，两个文件占用同一块的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s比较常用。如果软链接文件和源文件不在同一目录，源文件最好使用绝对路径，不要使用相对路径。软链接文件存储的是目标文件的路径。 vimvim 是一款强大的 文本编辑器，常用于 Linux Unix 系统编程、脚本编辑、配置文件修改等场景。它是 vi 的增强版本，具有更强的功能，比如语法高亮、代码折叠、多窗口、多标签支持等。 vim的三种模式普通模式（Normal Mode） 默认启动模式，你一打开 Vim 就是在这个模式。 作用：浏览、复制、剪切、粘贴、删除、移动光标、跳转、执行命令等。 常用命令： 命令 说明 hl 左右移动光标 jk 下上移动光标 [n]dd 删除当前行开始的n行（准确说是剪切） [n]x 删除光标后n个字符 [n]X 删除光标前n个字符 [n]yy 复制从当前行开始的n行 p 粘贴 u 撤销前一个命令 Ctrl + r 还原（恢复） : 进入命令模式 i、a 进入插入模式 mGmgg 到指定行，m为目标行数 字符串 从当前光标位置向下查找（n,N查找内容切换） ?字符串 从当前光标位置向上查找（n,N查找内容切换） 插入模式（Insert Mode） 按 i、a、o 等从普通模式进入插入模式。 作用：输入文字、写代码、编辑内容。 常用进入方式： 命令 含义 i 在光标前插入 a 在光标后插入 o 在当前行下方新开一行并插入 I 跳到行首插入 A 跳到行尾插入 退出插入模式：按 Esc 返回普通模式。 命令模式（Command-Line Mode） 按 : 从普通模式进入命令模式。 用于输入各种操作命令，如保存、退出、查找、替换等。 常用命令： 命令 功能 :w 保存 :q 退出 :wq 或 ZZ 保存并退出 :q! 强制退出（不保存） :x 等同于 :wq :/关键字 向下查找关键字 :s/旧/新/g 当前行替换所有匹配项 :1,10sabc123g 把第一行到第十行之间的abc全部替换为123 :%s/旧/新/g 全文替换所有匹配项 :w filename 保存到指定文件（绝对路径） :sp 文件名 当前文件和另一个文件水平分屏 :vsp 文件名 当前文件和另一个文件垂直分屏 ctrl+w+w 在多个窗口切换光标 gcc编译器GCC（GNU Compiler Collection）是由 GNU 项目开发的一组编译器，最初是为了 C 语言开发的，现在支持多种编程语言 gcc编译器从拿到一个c源文件到生成一个可执行文件，中间一共经历了四个步骤： gcc -E hello.c -o hello.igcc -S hello.i -o hello.sgcc -c hello.s -o hello.ogcc hello.o -o hello./hello #执行gcc 源文件 -o 可执行文件 #一步到位gcc hello.c -o hello./hello 选项 含义 -o 指定输出文件名 -Wall 打开所有警告信息 -g 生成调试信息，用于 GDB 调试 -O0/-O1/-O2/-O3 优化等级（0 表示无优化） -c 只编译不链接，生成 .o 目标文件 -I 添加头文件搜索路径 -L 添加库文件搜索路径 -l 链接指定的库（例如 -lm 表示链接 math 库） -v–version 查看gcc版本号 -D 编译时定义宏 gcc -Wall test.c #显示所有的警告信息gcc -Wall -Werror test.c #把警告信息当作错误处理gcc tmp.c -DDEBUG #可以用来区分测试版和发布版,DEBUG是定义的宏 静态链接和动态链接静态链接：由链接器在链接时把库的内容加入到可执行程序中。 优点：对运行环境的依赖较小，具有较好的兼容性。 缺点：生成的程序比较大，在装入内存消耗更多的时间。库函数有了更新，必须重新编译。 动态链接：链接器在链接时仅仅建立和所需库函数的链接关系，在程序运行时才将所需资源调入可执行程序。 优点：在需要的时候才会调入对应的资源函数。简化程序的升级，有着较小的程序体积，实现进程间的资源共享（避免重复拷贝） 缺点：依赖动态库，不能独立运行，动态库依赖版本问题严重。 静态和动态编译对比我们编写的应用程序大量用到了库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入-static参数。 gcc test.c -o testgcc -static test.c -o test 静态编译是要比动态编译程序大的多。 静态库和动态库静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。按照习惯，一般以”.a”作为文件后缀名。静态库的命名一般分为三个部分：前缀：lib,库名称：自己定义。后缀：.a。最终静态库的名字为libxxx.a 静态库制作： gcc -c add.c -o add.o #-c是只编译不链接输出.o文件gcc -c sub.c -o sub.ogcc -c mul.c -o mul.ogcc -c div.c -o dic.oar -rcs libtest.a add.o sub.o mul.o div.o#使用打包工具ar将准备好的.o文件打包为.a文件libtest.a 在使用ar工具需要添加参数：rcs r更新，c创建，s建立索引 静态库使用：静态库制作完成之后，需要将.a文件和头文件一起发布给用户。假设测试文件是main.c,静态库文件为libtest.a，头文件为head.h 编译命令： gcc main.c -L./ -I./ -ltest -o main#注意这里链接库的名字 -L：表示要连接的库所在目录。 -ltest:指定链接时需要的库，去掉前缀和后缀 -I(这里是大写的i):表示要连接的头文件目录 动态库制作共享库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。 动态库在程序运行时才被载入，也解决了静态库对程序的更新，部署和发布的再次编译的问题，用户只需要更新动态库即可，增量更新。 一般以”.so”作为文件后缀名。共享库的命名一般分为三个部分：前缀lib,库名称:自己定义，后缀：.so。所以最终的动态库的名字应该为：libxxx.so。 #生成目标文件，此时要加编译选项：-fPIC(fpic)参数-fPIC创建与地址无关的编译程序（pic,position independent code）,是为了能在多个应用程序间共享。gcc -fPIC -c add.cgcc -fPIC -c sub.cgcc -fPIC -c mul.cgcc -fPIC -c div.c#生成共享库，此时要加链接器选项：-shared(指定生成动态链接库)gcc -shared add.o sub.o mul.o div.o -o libtest.so#通过nm命令查看对应的函数nm libtest.so | grep add#通过ldd命令查看可执行文件依赖的动态库ldd test 动态库使用引用动态库编译成可执行文件（和静态库一样） gcc main.c -L./ -I./ -ltest -o main#注意这里链接库的名字 这一步是可以过的，但是到了，执行main时发现找不到对应文件。第一种就是把libtest.so复制到lib里（需要sudo,这个方法不推荐，最好不要动Linux原本文件，覆盖了就不好玩了。） gcc main.c -I./ -ltest -o main#注意这里链接库的名字,执行可执行文件就可以执行了，这种方法不推荐 动态库加载失败问题解决当系统加载可执行代码，能够知道其所依赖的库的名字，但还需要知道其绝对路径。此时就需要系统动态载入器（dynamic linkerloader）。对于elf格式的可执行程序，是由ld-linux.so*来完成，他先后搜索elf文件的DT_RPATH段—环境变量LD_LIBRARY_PATH—etcld.so.cache文件列表—lib,usrlib目录找到库文件后将其载入内存。 拷贝自己制作的共享库到lib或者usrlib(不能是lib64目录) 临时设置LD_LIBRARY_PATH(只在当前终端生效): export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径#在原环境变量追加新的变量，库路径为绝对路径。 永久设置:把export LD_LIBRARY_PATH$LD_LIBRARY_PATH:库路径这段话，设置到~.bashrc source ~/.bashrc #让配置文件生效 除了以上三种还有两种将其添加到etcld.so.conf,这里只需要添加绝对路径，然后sudo ldconfig -v使路径生效。 还有使用符号链接，但一定要使用绝对路径。 sudo ln -s 库文件的绝对路径 /lib/库文件 GDB调试器GDB主要完成下面四个功能： 1.启动程序，可以按照你的自定义的要求随心所欲的运行程序。 2.可让被调试的程序在你指定的断点停住。 3.当程序被停住时，可以检查此时你的程序中所发生的事。 4.动态的改变你程序的执行环境。 生成调试信息一般来说GDB主要调试的是CC++的程序，要调试CC++的程序，首先在编译时，我们必须把调试信息加到可执行文件中。使用编译器（ccgccg++）的-g参数可以做到这一点。 gcc -g hello.c -o hellog++ -g hello.c -o hello 启动GDB启动gdb:gdb program program也就是你的执行文件，一般在当前目录下。 设置启动参数:启动后设置 set args #可指定运行参数set args 10 20 30 40 hello worldshow args #命令可以查看设置好的运行参数 启动程序： run:程序开始执行，如果有断点，停在第一个断点处。 start:程序向下执行一行。 n:执行下一步。 显示源代码用list（也可直接打l）命令来打印程序的源代码。默认打印10行。 list function#显示函数名为function的函数的源码set listsize count #设置一次显示源码的行数默认是10行show listsize #查看当前listsize的设置 断点操作简单断点: break设置断点，可以简写为b b 10 #设置断点，在源程序第十行b func #设置断点，在func函数入口处 多文件设置断点 break filename:linenum #在源文件filename的linenum行处停住break filename:function #在源文件filename的function函数的入口处停住break class::function或者function(type,type) #在类class的function函数入口处停住break namespace::class::function #在名称空间为namespace的类class的function函数的入口处停住。 查询所有断点 info binfo breaki breaki b 条件断点一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。 设置一个条件断点： b test.c:8 if Value == 5 #对test.c文件的当变量Value满足为5时，在test.c文件的第8行产生断点 维护断点delete 范围 删除指定的断点，其简写命令为d。如果不指定断点号，则表示删除所有的断点。 d 10-12 #删除编号为10-12的断点。编号可以使用i b命令查看 比删除更好的一种方法时disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可。 disable 断点编号 #使指定断点无效，简写命令是dis。如果什么都不指定，表示disable所有的停止点。enable 断点编号 #使无效断点生效，简写命令是ena。如果什么都不指定，表示enable所有的停止点 调试代码run #运行程序，可简写为r。程序开始执行，如果有断点，停在第一个断点处。next #单步跟踪，函数调用当作一条简单语句执行，可简写为n。step #单步跟踪，函数调用进入被调用函数体内，可简写为s。finish #退出进入的函数until #在一个循环体单步跟踪时，这个命令可以运行程序直到退出循环体，可简写为u。continue #继续运行程序，停在下一个断点的位置，可简写为c。quit #退出gdb,可简写为q。 数据查看#查看运行时的数据#print打印变量，字符串，表达式等的值，可简写为p。p count #打印count的值 自动显示可以设置一些自动显示的变量，当程序停住时，或在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display display 变量名 #在run启动程序后，使用该命令。info display #查看display设置的自动显示的信息（可以看到对应变量名的编号）undisplay num #info display是显示的编号 使对应编号的自动显示功能失效。delete display dnums #删除自动显示，dnums意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围的编号，可以用减号表示。disable display dnumsenable display dnumsdisable和enable#不删除自动显示的设置，而只是让其失效和恢复。 查看修改变量的值ptype width #查看变量width的类型p width #打印变量width的值 p是print命令的缩写。set var width=47 #将变量var值设置为47。在改变程序变量取值时，最好都使用set var格式的GDB命令。 自动化编译工具Makefilemake是个命令工具。 sudo apt install make #下载make命令 Makefile语法规则一条规则： 目标：依赖文件列表Tab命令列表 all:test1 test2\techo hello all\ttest1:\techo hello test1test2:\techo hello test2#总共三条规则#执行结果：make -f 1.mkecho hello test1hello test1echo hello test2hello test2echo hello allhello all Makefile基本规则三要素： 目标: ​\t通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作的名称。 依赖文件： ​\t用来输入从而产生目标的文件。 ​\t一个目标通常有几个依赖文件（可以没有） 命令： ​\tmake执行的动作，一个规则可以含几个命令（可以没有） ​\t有多个命令，每个命令占一行。 make命令格式make [-f file][options][targets][-f file]:make默认在工作目录中寻找为GNUmakefile,makefile,Makefile的文件作为makefile输入文件。-f可以指定以上名字以外的文件作为makefile输入文件。[options]:-v 显示make工具的版本-w 在处理makefile之前和之后显示工作路径-C dir 读取makefile之前改变工作路径至dir目录-n 只打印要执行的命令但不执行-s 执行但不显示执行的命令[targets]:若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个规则指定了make工具要实现的目标，目标可以是一个或多个（多个目标用空格隔开）make test1 -f 1.mk #就会执行目标为test1对应的语句。 Makefile示例测试程序：test.c add.c sub.c mul.c div.c add.h sub.h mul.h div.h #最简单的Makefile(首先vim Makefile)test:test.c add.c sub.c mul.c div.c\tgcc test.c add.c sub.c mul.c div.c -o test 缺点：效率低，修改一个文件，所有文件都要重新编译。 test:test.o add.o sub.o mul.o div.o gcc test.o add.o sub.o mul.o div.o -o testadd.o:add.c\tgcc -c add.c -o add.osub.o:sub.c\tgcc -c sub.c -o sub.omul.o:mul.c\tgcc -c mul.c -o mul.odiv.o:div.c\tgcc -c div.c -o div.otest.o:test.c\tgcc -c test.c -o test.o 这样，下次编译，他只会编译你修改的文件，最后再链接，这样是比较高效的。 Makefile中的变量在Makefile中使用变量有点类似c语言的宏定义，使用该变量相当于内容替换，使用变量可以使Makefile易于维护。如果.o文件很多，难道我们要一个一个打吗，这也未免太麻烦，还可能漏打。 自定义变量定义变量： 变量名=变量值 引用变量： $(变量名)或$变量名 makefile的变量名： makefile变量名可以以数字开头。 变量是大小写敏感的。 变量一般在makefile的头部定义 变量几乎可在makefile的任何地方使用 OBJS = test.o add.o sub.o mul.o div.otest:$(OBJS)\tgcc $(OBJS) -o testadd.o:add.c\tgcc -c add.c -o add.osub.o:sub.c\tgcc -c sub.c -o sub.omul.o:mul.c\tgcc -c mul.c -o mul.odiv.o:div.c\tgcc -c div.c -o div.otest.o:test.c\tgcc -c test.c -o test.o 除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户使用，我们可以直接对其进行赋值。 CC=gccCPPFLAGS:CFLAGS:LDFLAGS: 自动变量#这些变量不能单独使用 必须在命令中使用# $@ 表示目标# $^ 表示所有的依赖# $ 表示第一个依赖 OBJS = test.o add.o sub.o mul.o div.oTARGET=test$(TARGET):$(OBJS)\tgcc $^ -o $@add.o:add.c\tgcc -c $ -o $@sub.o:sub.c\tgcc -c $ -o $@mul.o:mul.c\tgcc -c $ -o $@div.o:div.c\tgcc -c $ -o $@test.o:test.c\tgcc -c $ -o $@ 模式规则#模式规则匹配示例%.o:%.c$(cc) -c $(CFLAGS) $(CPPFLAGS) $ -o $@ OBJS=test.o add.o sub.o mul.o div.oTARGET=test$(TARGET):$(OBJS)\tgcc $(OBJS) -o $(TARGET)#模式匹配 所有的.o都依赖对应的.c#将所有的.c生成对应的.o%.o:%.c\tgcc -c $ -o $@ Makefile的函数常用的函数 wildcard #查找指定目录下的指定类型的文件src=$(wildcard *.c) #找到当前目录下所有后缀为.c的文件，赋值给srcpatsubst #匹配替换obj=$(patsubst %.c,%.o,$(src)) #把src变量里所有后缀为.c的文件替换成.o 在makefile中所有的函数都是有返回值的。 #获取当前目录下所有的.c文件SRC=$(wildcard ./*.c)#将SRC中所有出现的.c的替换成.oOBJS=$(patsubst %.c,%.o,$(SRC))TARGET=test$(TARGET):$(OBJS)\tgcc $(OBJS) -o $(TARGET)#模式匹配 所有的.o都依赖对应的.c#将所有的.c生成对应的.o%.o:%.c\tgcc -c $ -o $@#clean目标清除编译生成的中间文件#执行命令 make cleanclean:\trm -rf $(OBJS) $(TARGET) Makefile中的伪目标clean用途：清除编译生成的中间.o文件和最终目标文件 make clean 如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案： 伪目标声明：.PHONY:clean 声明目标为伪目标之后，makefile将不会判断目标是否存在或者该目标是否需要更新。 #获取当前目录下所有的.c文件SRC=$(wildcard ./*.c)#将SRC中所有出现的.c的替换成.oOBJS=$(patsubst %.c,%.o,$(SRC))TARGET=test$(TARGET):$(OBJS)\tgcc $(OBJS) -o $(TARGET)#模式匹配 所有的.o都依赖对应的.c#将所有的.c生成对应的.o%.o:%.c\tgcc -c $ -o $@#clean目标清除编译生成的中间文件#执行命令 make clean#声明clean为伪目标.PHONY:cleanclean:\trm -rf $(OBJS) $(TARGET) 上面这个版本就是最终版。 @gcc -c $ -o $@ #在命令前加上@符号，表示不显示命令本身（默认显示），只显示结果-gcc -c $ -o $@ #加上-符号，此条命令出错，make也会继续执行后续的命令。 系统调用系统调用说的是操作系统提供给用户程序调用的一组”特殊”接口 系统调用和库函数的区别Linux下对文件操作有两种方式：系统调用和库函数调用 库函数调用有两类函数组成： 不需要系统调用：不需要切换到内核空间即可完成函数全部功能，并且结果反馈给应用程序，如strcpy,bzero等字符串操作函数。 需要调用系统调用：需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如printf,fread等。 错误处理函数errno是记录系统的最后一次错误代码，代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。 当Linux C api函数出现异常时，一般会将errno全局变量赋一个整数值。 #include stdio.h //fopen#include errno.h //errno#include string.h //strerror(errno)int main() FILE *fp=fopen(xxxx,r); if(fp==NULL) printf(%d ,errno);//打印错误码 printf(%d ,strerror(errno));//把errno的数字转换为相应的文字 perror(fopen err); //打印错误原因的字符串 //perror和printf(%d ,strerror(errno));实现效果相同。 return 0; 虚拟地址空间每个进程都会分配虚拟地址空间，在32位机器上，该地址空间为4G。Linux每个运行的程序（进程），操作系统就会为其分配一个04G的地址空间（虚拟地址空间）。03G是用户区，3G~4G是内核区。在进程里平时所说的指针变量，保存的就是虚拟地址，当应用程序使用虚拟地址访问内存时，处理器会将其转换为物理地址（MMU）MMU将虚拟地址转换为物理地址。这样做的好处在于：进程隔离，更好的保护系统安全运行，屏蔽物理差异带来的麻烦，方便操作系统和编译器安排进程地址。 文件描述符打开现存文件或新建文件时，系统内核会返回一个文件描述符，文件描述符用来指定已打开的的文件。这个文件描述符相当于已打开文件的标号，文件描述符是非负整数，是文件的标识，操作这个文件描述符相当于操作这个描述符所指定的文件。 程序运行起来后（每个进程）都有一张文件描述符的表，标准输入，标准输出，标准错误输出设备文件被打开，对应的文件描述符0，1，2记录在表中。程序运行起来后这三个文件描述符是默认打开的。 在程序运行起来后，打开其他文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中。 最大打开的文件个数：​\tLinux中一个进程最多只能打开NR_OPEN_DEFAULT(即1024)个文件（当然这个数量的设定是可以修改的），故当文件不再使用时应该及时调用close()函数关闭文件。 常用文件IO函数open函数#includesys/types.h#include sys/stat.h#include fcntl.hint open(const char *pathname,int flags);int open(const char *pathname,int flags,mode_t mode); 功能： ​\t打开文件，如果文件不存在则可以选择创建。 close函数#include unistd.hint close(int fd) 功能： ​\t关闭已打开的文件。 需要说明的是，当一个进程终止时，内核对该进程所有未关闭的文件描述符调用close关闭，所以即使用户程序不调用close,在终止时内核也会自动关闭它打开的文件。 但是对于一个常年累月的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量的文件描述符和系统资源。 #includestdio.h#includestring.h#includesys/type.h#includesys/stat.h#includefcntl.h//打开和关闭文件int main() int fd=-1; //以只读的方式打开一个文件，如果文件不存在就报错。 //fd=open(txt,O_RDONLY); //以只写的方式打开一个文件 如果文件存在就直接打开 如果文件不存在就新建一个文件。 //fd=open(txt,O_WRONLY|O_CREAT,644); //以只写的方式打开一个文件，如果文件存在就报错，如果文件不存在就新建一个。 //fd=open(txt,O_WRONLY|O_CREAT|O_EXCL,644); //以读写方式打开一个文件，如果文件存在就打开，如果文件不存在就新建一个文件。 //fd=open(txt,O_RDWR|O_CREAT,644); //O_TRUNC 清空文件内容,如果文件存在，打开并清空，不存在就新建一个文件。 //fd=open(txt,O_WRONLY|O_TRUNC|O_CREAT,644); //O_APPEND 追加的方式 //以只写的方式和追加的方式打开一个文件 如果文件不存在会报错。 fd=open(txt,O_WRONLY|O_APPEND) if(fd==-1) perror(open); return 1; //关闭文件 close(fd); return 0; write函数#includeunistd.hssize_t write(int fd,const void* buf,size_t count);功能： 把指定数目的数据写到文件（fd）参数： fd: 文件描述符 buf:数据首地址 count:写入数据的长度（字节）返回值： 成功：实际写入数据的字节个数 失败：-1 read函数#includeunistd.hssize_t read(int fd,void *buf,size_t count);功能： 把指定数目的数据读到内存（缓冲区）参数： fd:文件描述符 buf:内存首地址 count:读取的字节个数返回值： 成功：实际读取的字节个数 失败：-1 阻塞和非阻塞的概念读常规文件是不会阻塞，不管读多少字节，read一定会在有限的时间内返回。 从终端设备或网络则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会堵塞，如果网络上没有接受到数据包，调用read从网络读就会，至于会阻塞多久也是不确定的，如果没有一直收到数据到达就一直阻塞在那里。 同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。 阻塞和非阻塞是对于文件而言，而不是指read,write等的属性。 lseek函数#includesys/types.h#includeunistd.hoff_t lseek(int fd,off_t offset,int whence);功能： 改变文件的偏移量参数： fd:文件描述符 offset:根据whence来移动的位移数（偏移量），可以是正数，也可以是负数，如果正数，则相对于whence往右移动，如果是负数则相对于whence向左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。 whence:其取值如下： SEEK_SET:从文件开头移动offset个字节 SEEK_CUR:从当前位置移动offset个字节 SEEK_END:从文件末尾移动offset个字节返回值： 若lseek成功执行，则返回新的偏移量 如果失败，返回-1 所有打开的文件都有一个当前文件偏移量（current file offset）以下简称为cfo。cfo通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。 读写操作通常开始cfo,并且使cfo变大，增量为读写的字节数。文件被打开时，cfo会被初始化为0，除非使用了O_APPEND。 如果把文件偏移量移到最后，使用read函数，将不会读出数据。要将文件描述符提前移到开头或者其他可以读到的位置。所以要注意文件描述符的位置。 文件操作相关函数stat函数#includesys/types.h#includesys/stat.h#includeunistd.hint stat(const char* path,struct stat *buf);int lstat(const char* pathname,struct stat *buf);功能：\t获取文件状态信息 stat和lstat的区别： 当文件是一个符号链接时,lstat返回的是该符号链接本身的信息； 而stat返回的是该链接指向的文件的信息。参数： path:文件名 buf:保存文件信息的结构体返回值:\t成功：0 失败：-1 文件不存在 stat函数和命令stat 文件名的功能类似。 struct stat *buf结构体 struct stat dev_t st_dev; /* ID of device containing file */ ino_t st_ino; /* Inode number */ mode_t st_mode; /* File type and mode */ nlink_t st_nlink; /* Number of hard links */ uid_t st_uid; /* User ID of owner */ gid_t st_gid; /* Group ID of owner */ dev_t st_rdev; /* Device ID (if special file) */ off_t st_size; /* Total size, in bytes */ blksize_t st_blksize; /* Block size for filesystem I/O */ blkcnt_t st_blocks; /* Number of 512 B blocks allocated */ /* Since POSIX.1-2008, this structure supports nanosecond precision for the following timestamp fields. For the details before POSIX.1-2008, see VERSIONS. */ struct timespec st_atim; /* Time of last access */ struct timespec st_mtim; /* Time of last modification */ struct timespec st_ctim; /* Time of last status change */ #define st_atime st_atim.tv_sec /* Backward compatibility */ #define st_mtime st_mtim.tv_sec #define st_ctime st_ctim.tv_sec ; #includestdio.h#includestring.h#includestdlib.h#includesys/types.h#includesys/stat.h#includeunistd.hint main(void) int ret=-1; struct stat s; //获取指定文件信息 ret=stat(txt,s); if(ret==-1) perror(stat); return 1; //文件属性信息 printf(st_dev:%lu ,s.st_dev); printf(st_ino:%ld ,s.st_ino); return 0; st_mode;可以获取文件类型和文件三种用户的权限。 access函数#includeunistd.hint access(const char* pathname,int mode);功能：测试指定文件是否具有某种属性参数： pathname:文件名 mode:文件权限，4种权限（判断文件所属者） R_OK:是否有读权限 W_OK:是否有写权限 X_OK:是否有执行权限 F_OK:测试文件是否存在返回值： 0：有某种权限，或者文件存在 -1：没有，或者文件不存在 chmod函数#include sys/stat.hint chmod(const char*pathname,mode_t mode);功能：修改文件权限参数： pathname:文件名 mode:权限（8进制数）返回值： 成功：0 失败：-1 chown函数#includeunistd.hint chown(const char *pathname,uid_t owner,gid_t group);功能：修改文件所有者和所属组参数： pathname:文件或目录名 owner:文件所有者id，通过查看/etc/passwd得到所有者id group；文件所属组id,通过查看/etc/group得到用户组id返回值： 成功：0 失败：-1 truncate函数#includeunistd.h#includesys/types.hint truncate(const char *path,off_t length);功能：修改文件大小参数： path:文件名字 length:指定的文件大小 比原来小，删掉后边的部分 比原来大，向后拓展返回值： 成功：0 失败：-1 link函数#includeunistd.hint link(const char* oldpath,const char *newpath);功能：创建一个硬链接参数： oldpath:源文件名字 newpath:硬链接名字返回值： 成功：0 失败：-1 symlink函数#includeunistd.hint symlink(const char* target,const char* linkpath);功能：创建一个软链接参数： target：源文件名字 linKpath:软链接名字返回值： 成功：0 失败：-1 剩下的还有readlink函数，unlink函数，rename函数 文件描述符复制dup()和dup2()是两个非常有用的系统调用，都是用来复制一个文件的描述符，使新的文件描述符也标识旧的文件描述符所标识的文件 对比于dup(),dup2()也一样，通过原来的文件描述符复制出一个新的文件描述符，这样的话，原来的文件描述符和新的文件描述符都指向同一个文件，我们操作这两个文件描述符的任何一个，都能操作它所对应的文件。 dup函数#includeunistd.hint dup(int oldfd);功能： 通过oldfd复制出一个新的文件描述符，新的文件描述符使调用进程文件描述符表中最小可用的文件描述符，最终oldfd和新的文件描述符都指向同一个文件。参数： oldfd:需要复制的文件描述符oldfd返回值： 成功：新文件描述符 失败：-1 函数示例： #includestdio.h#includestring.h#includestdlib.h#includesys/types.h#includesys/stat.h#includefcntl.h#includeunistd.h//dup dup2int main() int fd=-1; int newfd=-1; //1.打开文件 fd=open(txt,O_RDWR|O_CREAT,0644); if(fd==-1) perror(open); return 1; newfd=dup(fd); if(-1==newfd) perror(dup); return 1; printf(newfd=%d ,newfd); //2.操作 write(fd,ABCDEFG,7); //因为这两个文件描述符共享一张文件表，所以当前文件的偏移量是共享的，所以下次不会覆盖而是追加 //使用另外一个文件描述符 write(newfd,1234567,7); //3.关闭文件描述符 close(fd); close(newfd); return 0; dup2函数#includeunistd.hint dup2(int oldfd,int newfd);功能： 通过oldfd复制出一个新的文件描述符newfd,如果成功，newfd和函数返回值是同一个返回值，最终oldfd和新的文件描述符newfd都指向同一个文件。参数： oldfd:需要复制的文件描述符 newfd:新的文件描述符，这个描述符可以人为指定一个合法数字（0-1023），如果指定的数字已经被占用，此函数会自动关闭close()断开这个数字和某个文件的关联，再来使用这个合法数字。返回值： 成功：返回newfd 失败；返回-1。 注意：这里有个场景，我有两个程序都是要打开同一个文件并且向里面写东西，当然这就有两个open函数，那我先后打开该文件，前者写的会被后者写的覆盖掉吗，这是会的。因为每次open函数都会把文件偏移量的位置放回0。但是dup函数和dup2函数不会，因为复制的文件描述符共享一个文件描述符表项的。 fcntl函数#includeunistd.h#includefcntl.hint fcntl(int fd,int cmd,.../*arg */);功能：改变已打开的文件性质，fcntl针对描述符提供控制。参数： fd:操作的文件描述符 cmd:操作方式 arg:针对cmd的值，fcntl能够接受第三个参数int arg。返回值： 成功：返回某个其他值 失败：-1 #includestdio.h#includestring.h#includestdlib.h#includesys/types.h#includesys/stat.h#includeunistd.h#includefcntl.h//fcntl复制文件描述符功能int main(void) int fd=-1; int newfd=-1; int ret=-1; //1.打开文件 fd=open(txt,O_WRONLY|O_CREAT,0644); if(fd==-1) perror(open); return 1; printf(fd=%d ,fd); //2.文件描述符复制 //功能等价于dup函数 //第三个参数0 表示返回一个最小的可用的文件描述符，并且大于或者等于0 newfd=fcntl(fd,F_DUPFD,0); if(-1==newfd) perror(fcntl); return 1; printf(newfd=%d ,newfd); //3.写操作 write(fd,123456789,9); write(newfd,ABCDEFGH,8); //4.关闭文件 close(fd); close(newfd) return 0; fcntl函数还可以改变文件状态标记。 目录相关操作getcwd函数#includeunistd.hchar *getcwd(char *buf,size_t size);功能：获取当前进程的工作目录参数： buf:缓冲区，存储当前的工作目录 size:缓冲区大小返回值： 成功：buf中保存当前进程工作目录位置 失败：NULL chdir函数#includeunistd.hint chdir(const char *path);功能：修改当前进程（应用程序）的路径参数： path:切换的路径返回值： 成功：0 失败：-1 opendir函数#includesys/types.h#includedirent.hDIR *opendir(const char*name);功能：打开一个目录参数： name:目录名返回值： 成功：返回指向该目录结构体指针 失败：NULL closedir函数#includesys/types.h#includedirent.hint closedir(DIR *dirp);功能：关闭目录参数： dirp:opendir返回指针返回值： 成功：0 失败：-1 readdir函数#includedirent.hstruct dirent* readdir(DIR *dirp);功能：读取目录参数： dirp:opendir的返回值返回值： 成功：目录结构体指针 失败：NULL readdir函数要读取目录所有内容是要循环读取。 进程控制进程和程序我们平时写的C语言代码，通过编译器编译，最终它会成为一个可执行程序，当这个可执行程序运行起来后（没有结束前），他就成为了一个进程。程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建，调度和消亡。程序是静态的，进程是动态的。 在Linux系统中，操作系统是通过进程去完成一个一个的任务，进程是管理事务的基本单元。 进程拥有自己独立的处理环境（当前需要用到那些环境变量，程序运行的目录在哪里，当前是哪个用户在运行此程序）和系统资源（处理器cpu占用率，存储器，IO设备，数据，程序）。 并行和并发并行：指在同一时刻，有多条指令在多个处理器上同时执行。 并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。 MMUMMU是Memory Management Unit的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器，物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权，多用户多进程操作系统。 进程控制块PCB进程运行时，内核为进程每个进程分配一个PCB(进程控制块)，维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。 这个结构体的内部成员有很多，我们要知道的： 进程id。系统中每个进程有唯一的id,在C语言中用pid_t类型表示，其实就是一个非负整数。 进程的状态，有就绪，运行，挂起，停止等状态。 进程切换时需要保存和恢复的一些CPU寄存器。 描述虚拟地址空间的信息。 描述控制终端的信息。 当前工作目录。 umask掩码 文件描述符表，包含很多指向file结构体的指针。 和信号相关的信息。 用户id和组id 会话（Session）和进程组。 进程可以使用的资源上限（Resource Limit）。 进程的状态进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。 在三态模型中，进程状态分为三个基本状态，即运行态，就绪态，阻塞态。 在五态模型中，进程分为新建态，终止态，运行态，就绪态，阻塞态。 ps进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。 ps命令可以查看进程的详细情况，常用选项（选项可以不加”-“）。 参数 含义 -a 显示终端上的所有进程，包括其他用户的进程 -u 显示进程的详细状态 -x 显示无控制终端的进程 -r 只显示正在运行的进程 ps aux ps ef和aux等价 ps -a top用来动态显示运行中的进程。 killkill命令指定进程号的进程，需要配合ps使用。 使用格式： kill [-signal] pid 信号值从0-15，其中9为绝对终止，可以处理一般信号无法终止的进程。 有些进程不能直接杀死，这时候我们需要加一个参数”-9”,”-9”代表强制结束。 killall通过进程名字杀死进程,进程名字是可以重复的。 killall -9 sleep 进程号和相关函数每个进程都由一个进程号来标识，其类型为pid_t（整型），进程号的范围：0~32767（2的15次方-1）。进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用。 三个不同的进程号进程号（PID）: 标识进程的一个非负整型数。 父进程号（PPID）:任何进程（除init进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号成为父进程号（PPID）。如A进程创建了B进程，A的进程号就是B进程的父进程号。 进程组号（PGID）: 进程组是一个或多个进程的集合，他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当作当前的进程组号。 getpid函数#includesys/types.h#includeunistd.hpid_t getpid();功能： 获取本进程号（PID）参数：无返回值：本进程号 getppid函数#includesys/types.h#includeunistd.hpid_t getppid();功能：获取调用此函数的进程的父进程号参数：无返回值：调用此函数的进程的父进程号（PPID） getpgid函数#includesys/types.h#includeunistd.hpid_t getpgid(pid_t pid);功能：获取进程组号（PGID）参数： pid:进程号返回值： 参数为0时返回当前进程组号，否则返回参数指定的进程的进程组号。 进程的创建系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。 #includesys/types.h#includeunistd.hpid_t fork();功能： 用于从一个已存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。参数：无返回值： 成功：子进程返回0，父进程中返回子进程ID，pid_t为整型。 失败：返回-1。 失败的两个主要原因: 1.当前的进程数已经达到系统规定的上限，这时errno的值被设置为EAGAIN。 2.系统内存不足，这时errno的值被设置为ENOMEM。 使用示例： #includestdio.h#includesys/types.h#includeunistd.h//创建一个子进程int main() //创建子进程 fork(); printf(hello world ); return 0; 这里的结果会输出两次hello world。这是为什么呢？ 首先，fork函数创建子进程，子进程会将父进程的代码复制下来来执行了，当然这就有人说了，那么子进程执行fork函数，那就不是一直创建子进程了吗。这里涉及到了一个问题。当父进程调用fork函数，父进程会有一个pc指针指向fork函数调用后的代码，当然，子进程也把这个pc指针的值也继承了下来，所以子进程也是一样执行。 父子进程关系使用fork函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的的静态描述），进程堆栈，打开的文件描述符，信号控制设定，进程优先级，进程组号等。 子进程所独有的只有它的进程号，计时器等（只有小量信息）。因此，使用fork()函数的代价是很大的。 简单来说，一个进程调用fork函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值和原来的进程的值不同。相当于克隆了一个自己。 实际上，Linux的fork函数使用是通过写时拷贝（copy-on-write）实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。 fork之后父子进程共享文件，fork产生的子进程和父进程相同的文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。 区分父子进程fork()函数被调用一次，但返回两次。两次返回的区别是：子进程的返回值是0，而父进程的返回值则是新子进程的进程ID。 #includestdio.h#includestdlib.h#includeunistd.h//区分父子进程int main() pid_t pid=-1; //创建一个子进程 //fork函数在在子进程中返回0 在父进程中返回子进程的pid pid=fork(); if(pid==0) //子进程 printf(hello pid:%d ppid:%d ,getpid(),getppid()); exit(0); else //父进程 //这里pid返回的就是新子进程的进程id printf(hello world pid:%d cpid:%d ,getpid(),pid); return 0; 父子进程堆空间当在创建子进程前在堆声明时，一定要对该指针指向区域释放两次。不然会出现内存泄露。 如何检测内存是否泄露gcc zfork.cvalgrind ./a.out GDB调试多进程使用GDB调试的时候，GDB只能跟踪一个进程。可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者跟踪子进程。默认跟踪父进程。 set follow-fork-mode child #设置gdb在fork之后跟踪子进程set follow-fork-mode parent #设置跟踪父进程（默认）#注意，一定要在fork函数调用之前设置才有效。 进程退出函数#includestdlib.hvoid exit(int status);#includeunistd.hvoid _exit(int status);功能： 结束调用此函数的进程参数： status:返回给父进程的参数（低8位有效），至于这个参数是多少根据需要来填写。返回值： 无 exit()和_exit()函数功能和用法是一样的，无非是包含的头文件不一样，还有的区别就是：exit()属于标准库函数，_exit()属于系统调用函数。 _exit()函数不会关闭文件描述符和I刷新IO缓冲区。exit()函数会做这些。 等待子进程退出函数在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号，退出状态，运行时间）。 父进程可以调用wait或waitpid得到他的退出状态同时彻底清除掉这个进程。 wait()和waitpid函数的功能一样，区别在于wait()函数会堵塞，waitpid()可以设置不堵塞，waitpid()还可以指定等待那个子进程结束。 一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。 wait函数#includesys/types.h#includesys/wait.hpid_t wait(int *status);功能： 等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。参数： status:进程退出时的状态信息。返回值： 成功：已经结束子进程的进程号 失败：-1 调用wait函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒（相当于继续往下执行）。 若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。 所以wait函数的主要功能为回收已经结束子进程的资源。如果参数status的值不是NULL,wait函数就会把子进程退出时的状态取出并且存入其中，这是一个整数值（int）,指出了子进程是正常退出还是被非正常结束的。这个退出信息在一个int中包含了多个字段，直接使用这个值是没有意义的，我们需要宏定义取出其中的每个字段。 使用对应的宏函数如WIFEXITED(status)为非0表明进程正常结束。WEXITSTATUS(status)若WIFEXITED(status)值为真，获取进程退出状态（exit的参数）。 //属于正常退出if(WIFEXITED(status)) printf(子进程退出状态码：%d ,WEXITSTATUS(status));else if(WIFSIGNALED(status)) //在bash输入kill 子进程号 printf(子进程被信号%d杀死了 ,WTERMSIG(status));else if(WIFSTOPPED(status)) //向指定进程发送暂停信号 //kill -19 子进程号 //唤醒指定暂停的进程 //kill -18 子进程号 printf(子进程被信号%d暂停 ,WSTOPSIG(status)); waitpid函数#includesys/types.h#includesys/wait.hpid_t waitpid(pid_t pid,int *status,int options);功能： 等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。参数： pid:参数pid的值有以下几种类型： pid0 等待进程ID等于pid的子进程。 pid=0 等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会等待他。 pid=-1 等待任一子进程，此时waitpid和wait作用一样。 pid-1 等待指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。 status:进程退出时的状态信息。和wait()用法一样。 options:options提供了一些额外的选项来控制waitpid(). 0:同wait(),阻塞父进程，等待子进程退出。 WNOHANG:没有任何已经结束的子进程，则立即返回 WUNTRACED:如果子进程暂停了则此函数马上返回，并且不予理会子进程的结束状态。返回值： 当正常返回时，返回收集到的已经回收子进程的进程号 如果设置了选项WNOHANG,而调用中waitpid()发现没有已经退出的子进程可等待，则返回0; 如果调用中出错，则返回-1，这是errno会被设置成相应的值以指示错误所在。 //等价于wait()waitpid(-1,status,0);//第三个参数表示不阻塞waitpid(-1,status,WNOHANG) 孤儿进程父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程。 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init,而init进程会循环wait()它的已经退出的子进程。所以init进程会处理孤儿进程的善后工作。 孤儿进程并没有什么危害。 僵尸进程进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程。这样就导致了一个问题，如果进程不调用wait()或者waitpid（）的话，那么保留的那段信息就不会释放，其进程号就会一直被占用。如果产生大量的僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 进程替换在Windows平台下，我们可以通过双击运行可执行程序，让这个可执行程序成为一个进程；而在Linux平台，我们可以通过.运行，让一个可执行程序成为一个进程。 但是，如果我们本来就运行着一个程序，我们如何在这个进程内部启动一个外部程序，由内核将这个外部程序读入内存，使其执行起来成为一个进程呢，我们通过exec函数族实现。 exec函数族是一组函数，在Linux并不存在exec函数。这组函数一共有6个。 #includeunistd.hextern char **environ;int execl(const char *path,const char *arg,.../*(char *) NULL*/);int execlp(const char *file,const char *arg,.../*(char *) NULL*/);int execle(const char *path,const char *arg,.../*,(char *) NULL,char * const envp[] */);int execv(const char *path,char *const argv[]);int execvp(const char *file,char *const argv[]);int execvpe(const char *file,char *const argv[],char *const envp[]);int execve(const char *filename,char *const argv[],char *const envp[]); 其中只有execve()是真正意义的系统调用，其他都是在此基础上经过包装的库函数。 exec函数族的作用是根据指定的文件名或目录名找到可执行文件，并用它来取代调用进程的内容。 进程在调用一种exec函数时，该进程完全由新程序替换，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后进程ID(当然还有父进程号，进程组号，当前工作目录)并未改变。exec只是用另一个新程序替换了当前进程的正文，数据，堆和栈段（进程替换）。 #includestdio.h#includestdlib.h#includeunistd.hint main() printf(hello ); //arg0 arg1 arg2 ... argn //arg0一般是可执行文件名 argn必须是NULL //execlp(ls,ls,-l,/home,NULL); //第一个参数是可执行文件的绝对路径或者相对路径 //第二个参数一般是可执行文件的名字 //中间的参数就是可执行文件的参数 //最后一个参数是NULL execl(/bin/ls,ls,-l,/home,NULL); printf(hello world ); return 0; #includestdio.h#includestdlib.h#includeunistd.h#define _GNU_SOURCEint main() char *argv[]=ls,-l,/home,NULL; char *envp[]=ADDR=BEIJING,NULL; printf(hello ); //第一个参数是可执行文件 //第二个参数是指针数组 最后一定以NULL结束 //execvp(ls,argv); //第一个参数是可执行文件 //第二个参数是指针数组 最后一定以NULL结束 //execv(/bin/ls,argv); //最后一个参数是环境变量指针数组 //execle(/bin/ls,ls,-l,/home,NULL,envp); //第一个参数是可执行文件 //第二个参数是参数列表 指针数组 //第三个参数是环境变量列表 指针数组 execvpe(ls,argv,envp); printf(hello world ); return 0; 进程间通信进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信。（IPC） 进程间通信的目的： 数据传输：一个进程需要将它的数据发送给另一个进程。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 Linux操作系统支持的主要进程间通信的通信机制： 无名管道管道也叫无名管道，它是UNIX系统IPC(进程间通信)的最古老方式，所有的UNIX系统都支持这种通信机制。 管道有如下特点： 半双工，数据在同一时刻只能在一个方向上流动。 数据只能从管道的一端写入，从另一端读出。 写入管道中的数据遵循先入先出的规则。 管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息。 管道不是普通文件，不属于某个文件系统，其只存在于内存中。 管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。 从管道读数据是一次性操作，数据一旦被读走，他就从管道中被抛弃，释放空间以便写更多的数据。 管道没有名字，只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。 管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。 pipe函数#includeunistd.hint pipe(int pipefd[2]);功能：创建无名管道参数： pipefd:为int型数组的首地址，其存放了管道的文件描述符pipefd[0],pipefd[1]。 当一个管道建立时，他会创建两个文件描述符fd[0]和fd[1]。其中fd[0]固定用于读管道，而fd[1]固定用于写管道。一般文件I/O的函数都可以用来操作管道（lseek()除外）。返回值： 成功：0 失败：-1 #includestdio.h#includestdlib.h#includestring.h#includeunistd.h//用于创建无名管道int main() int fd[2]; int ret=-1; //创建一个无名管道 ret=pipe(fd); if(ret==-1) perror(pipe); return 1; //fd[0]用于读 fd[1]用于写 printf(fd[0]:%d fd[1]:%d ,fd[0],fd[1]); //关闭文件描述符 close(fd[0]); close(fd[1]); return 0; 父子进程通过无名管道通信#includestdio.h#includestdlib.h#includestring.h#includeunistd.h#define SIZE 64//父子进程使用无名管道进行通信//父进程写管道 子进程读管道int main() int ret=-1; int fd[2]; char buffer[SIZE]; pid_t pid=-1; //1.创建无名管道 ret=pipe(fd); if(-1==ret) perror(pipe); return 1; //2.创建子进程 pid=fork(); if(-1==pid) perror(fork); return 1; //子进程 读管道 if(0==pid) //关闭写端 close(fd[1]); memset(buf,0,SIZE); ret=read(fd[0],buf,SIZE); if(ret0) perror(read); exit(-1); printf(child process buf :%s ,buf); //关闭读端 close(fd[0]); exit(0) //父进程 写管道 //关闭读端 close(fd[0]); ret=write(fd[1],ABCDE,5); if(ret0) perror(write); return 1; printf(parent process write: len:%d ,ret); //关闭写端 close(fd[1]); return 0; 管道读写特点四种情况： ​\t第一种： ​ 如果写端没有关闭，管道中没有数据，这个时候读管道进程去读管道会阻塞。 ​ 如果写端没有关闭，管道中有数据，这个时候读管道进程会将数据读出，下一次读没数据就会阻塞。 ​\t第二种： ​ 管道所有的写端关闭，读进程去读管道的内容，读取全部内容，最后返回0。 ​\t第三种： ​ 所有读端没有关闭，如果管道被写满了，写管道进程写管道会被阻塞。 ​\t第四种： ​ 所有的读端被关闭，写管道进程写管道会收到一个信号，然后退出。 设置为非阻塞的方法//获取原来的flagsint flags=fcntl(fd[0],F_GETFL);//设置新的flagsflag |= O_NONBLOCK;fcntl(fd[0],F_SETFL,flags); 如果写端没有关闭，读端设置为非阻塞，如果没有数据，直接返回-1。 查看管道缓冲区的大小ulimit -a#可以查看管道大小（大小为4k） 函数 #includeunistd.hlong fpathconf(int fd,int name);功能：该函数可以通过name参数查看不同的属性值参数： fd:文件描述符 name: _PC_PIPE_BUF，查看管道缓冲区大小 _PC_NAME_MAX,文件名字字节数的上限返回值： 成功：根据name返回的值的意义也不同。 失败：-1 有名管道管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这一缺点，提出了命名管道（FIFO）,也叫有名管道，FIFO文件。 命名管道不同于无名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径马，就能够彼此通过FIFO互相通信，因此，通过FIFO不相关的进程也能交换数据。 命名管道和无名管道有一些特点是相同的，不一样的地方在于： FIFO在文件系统中作为一个特殊的文件而存在，但FIFO的内容却放在内存中。 当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。 FIFO有名字，不相关的进程可以通过打开命名管道进行通信。 通过命令创建有名管道mkfifo fifo #创建有名管道 fifo是管道的名字 通过函数创建有名管道#includesys/types.h#includesys/stat.hint mkfifo(const char *pathname,mode_t mode);功能： 命名管道的创建。参数： pathname:普通的路径名，也就是创建后FIFO的名字。 mode:文件的权限，与打开普通文件的open()函数中的mode参数相同。（0644）返回值： 成功：0 状态码 失败：如果文件已经存在，则会出错且返回-1。 #includestdio.h#includestdlib.h#includestring.h#includesys/types.h#includesys/stat.h//通过mkfifo函数创建一个管道文件int main() int ret=-1; //创建一个有名管道 管道的名字fifo ret=mkfifo(fifo,0644); if(ret==-1) perror(mkfifo); return 1; printf(创建一个有名管道ok ); return 0; 有名管道读写操作一旦使用mkfifo创建了FIFO,就可以使用open打开它，常见的文件IO函数都可用于fifo。如：close，read,write,unlink等。 FIFO严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对他们的写则把数据添加到末尾。他们不支持诸如lseek()等文件定位操作。 //进程1，写操作int fd=open(my_fifo,O_WRONLY);char send[100]=hello Mike;write(fd,send,strlen(send));//进程2，读操作int fd=open(my_fifo,O_RDONLY);//等着只写char recv[100]=0;//读数据，命名管道没数据时会阻塞，有数据时就取出来read(fd,recv,sizeof(revc));printf(read from my_fifo buf=[%s] ,recv); 一个为只读而打开一个管道的进程会阻塞直到另外一个进程为只写打开该管道。 一个为只写而打开一个管道的进程会阻塞直到另外一个进程为只读打开该管道。 读管道： ​\t管道中有数据，read返回实际读到的字节数。 ​\t管道无数据： ​ 管道写端被全部关闭，read返回0（相当于读文件末尾）。 ​ 写端没有完全被关闭，read阻塞等待。 写管道： ​\t管道读端全部被关闭，进程异常终止（也可使用捕捉SIGPIPE信号，使进程终止）； ​\t管道读端没有全部关闭： ​ 管道已满，write阻塞。 ​ 管道未满，write将数据写入，并返回实际写入的字节数。 共享存储映射存储映射IO使一个磁盘文件与存储空间中的一个缓冲区相映射。 于是当从缓冲区中取数据，就相当于读文件中的相应字节。将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成IO操作。 共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式，因为进程可以直接读内存，而不需要任何数据的拷贝。 存储映射函数mmap函数#includesys/mman.hvoid *mmap(void *addr,size_t length,int prot,int flags,int fd,off_t offset);功能： 一个文件或者其他对象映射进内存参数： addr:指定映射的起始地址，通常设为NULL,由系统指定 length:映射到内存的文件长度 prot:映射区的保护方式，最常用的： 读：PROT_READ 写：PROT_WRITE 读写：PROT_READ|PROT_WRITE flags:映射区的特性，可以是 MAP_SHARED:写入映射区的数据会复制回文件，且允许其他映射该文件的进程共享。 MAP_PRIVATE:对映射区的写入操作会产生一个映射区的复制（copy-on-write）,对此区域所作的修改不会写回原文件。 fd:由open返回的文件描述符，代表要映射的文件。 offset:以文件开始处的偏移量，必须是4k的整数倍（4k为页的大小），通常为0,表示从文件头开始映射返回值： 成功：返回创建的映射区首地址 失败：MAP_FAILED宏 munmap函数#includesys/mman.hint munmap(void *addr,size_t length);功能： 释放内存映射区参数： addr:使用mmap函数创建的映射区的首地址 length:映射区的大小返回值： 成功：0 失败：-1 #includestdio.h#includestdlib.h#includestring.h#includesys/types.h#includesys/stat.h#includeunistd.h#includefcntl.h#includesys/mman.h//存储映射int main() int fd=-1; int ret=-1; void *addr=NULL; //1.以读写形式打开一个文件。 fd=open(txt,O_RDWR); if(-1==fd) perror(open); return 1; //2.将文件映射到内存 addr=mmap(NULL,1024,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); if(addr==MAP_FAILED) perror(mmap); return 1; //3.关闭文件 close(fd); //4.写文件 memcpy(addr,1234567890,10); //5.断开存储映射 munmap(addr,1024); return 0; 匿名映射实现父子进程通信通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。 通常为了建立映射区要open一个temp文件，创建好了再unlink,close掉，比较麻烦。同样需要借助标志位flags来指定。使用MAP_ANONYMOUS（或者MAP_ANON）。 int *p=mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0); #includestdio.h#includestring.h#includestdlib.h#includesys/types.h#includesys/stat.h#includeerror.h#includefcntl.h#includeunistd.h#includesys/mman.h#includesys/wait.h//父子进程使用匿名映射进行进程间通信int main() int ret=-1; pid_t pid=-1; void *addr=NULL; //1.创建匿名映射 addr=mmap(NULL,4096,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0); if(MAP_FAILED==addr) perror(mmap); return 1; //2.创建子进程 pid=fork(); if(-1==pid) perror(fork); munmap(addr,4096); return 1; //3.父子进程通信 if(pid==0) //子进程写 memcpy(addr,123456789,10); else //父进程读 wait(NULL); printf(parent process %s ,(char *)addr); //4.断开映射 munmap(addr,4096); return 0; 信号信号是Linux进程间通信的最古老的方式。信号是软件中断，它是在软件层次上对中断机制的一次模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个进程正在运行的异步进程中断，转而处理某一个突发事件。 信号的特点：简单，不能携带大量信息，满足某个特设条件才发送。 信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了那些系统事件。 一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数。 这里信号的产生，注册，注销是信号的内部机制，而不是信号的函数实现。 信号的编号Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley和ATT都对信号做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。 Linux可使用命令： kill -l(字母l)#查看相应的信号。 不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。 Linux 常用信号（signals）一览表 编号 信号名 默认行为 说明（用途） 1 SIGHUP 终止进程 终端挂起或控制进程终止（如终端关闭） 2 SIGINT 终止进程 键盘中断（Ctrl+C） 3 SIGQUIT 创建核心转储 键盘退出（Ctrl+\\），带 core dump 4 SIGILL 创建核心转储 非法指令 6 SIGABRT 创建核心转储 调用 abort() 函数终止程序 8 SIGFPE 创建核心转储 浮点异常（如除以0） 9 SIGKILL 强制终止 无法被捕获或忽略，立即终止 11 SIGSEGV 创建核心转储 无效内存引用（段错误） 13 SIGPIPE 终止进程 管道破裂（写到没有读者的管道） 14 SIGALRM 终止进程 计时器超时（alarm()） 15 SIGTERM 终止进程 终止信号（kill 默认发送） 17 SIGCHLD 忽略捕获 子进程结束时通知父进程 18 SIGCONT 继续执行 继续一个停止的进程 19 SIGSTOP 停止进程 无法被捕获或忽略，强制停止 20 SIGTSTP 停止进程 用户请求停止（Ctrl+Z） 21 SIGTTIN 停止进程 后台进程读终端输入 22 SIGTTOU 停止进程 后台进程写终端输出 23 SIGURG 忽略捕获 套接字有紧急数据 24 SIGXCPU 创建核心转储 超出 CPU 时间限制 25 SIGXFSZ 创建核心转储 超出文件大小限制 26 SIGVTALRM 终止进程 虚拟定时器到期 27 SIGPROF 终止进程 分析定时器到期 28 SIGWINCH 忽略捕获 终端窗口大小发生变化 29 SIGIO 忽略捕获 IO 事件通知 30 SIGPWR 忽略终止 电源故障 31 SIGSYS 创建核心转储 非法的系统调用 信号四要素每个信号必备四要素，分别是： 编号，名称，事件，默认处理动作 man 7 signal#查看帮助文档获取信号的信息 默认动作： ​\tTerm:终止进程 ​\tIgn:忽略信号（默认即时对该种信号忽略操作） ​\tCore:终止进程，生成Core文件。（查验死亡原因，用于gdb调试） ​\tStop:停止（暂停）进程 ​\tCont:继续运行进程 SIGKILL(9)和SIGSTOP(19)，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。 另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不应乱发信号。 阻塞信号集和未决信号集信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。 Linux内核的进程控制块PCB是一个结构体，task_struct,除了包含进程id，状态，工作目录，用户id,组id,文件描述符表，还包含了信号相关信息，主要指阻塞信号集和未决信号集。 阻塞信号集： 将某些信号加入集合，对他们设置屏蔽，当屏蔽X信号后，再收到该信号，该信号的处理将推后（处理发生在解除屏蔽后）。 未决信号集： 信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回0。这一时刻往往非常短暂。 信号产生后由于某些原因（主要是阻塞）不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。 信号产生函数kill函数#includesys/types.h#includesignal.hint kill(pid_t pid,int sig);功能：给指定进程发送指定信号（不一定杀死）参数： pid:取值有4种情况： pid0:将信号传送给进程ID为pid的进程。 pid=0：将信号传送给当前进程所在进程组中的所有进程。 pid=-1:将信号传送给系统内所有的进程 pid-1:将信号传送给指定进程组的所有进程。这个进程组号等于pid的绝对值。 sig:信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令kill -l进行查看，不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。返回值： 成功：0 失败：-1 超级用户（root）可以发送信号给任意用户，普通用户是不能向系统用户发送信号。也不能向其他普通用户发送信号，终止其进程。只能向自己创建的进程发送信号。 #includestdio.h#includestdlib.h#includestring.h#includesys/types.h#includesignal.h#includeunistd.h//父进程杀死子进程int main() pid_t pid=-1; //创建一个子进程 pid=fork(); if(-1==pid) perror(fork); return 1; //子进程 if(0==pid) while(1) printf(child process do work.... ); sleep(1); //进程退出 exit(0); else //父进程 sleep(3); printf(子进程退出 ); kill(pid,SIGTERM); printf(父进程该结束了，已经完成了他的使命 ); return 0; raise函数#includesignal.hint raise(int sig);功能：给当前进程发送指定信号（自己给自己发），等价于kill(getpid(),sig);参数： sig:信号编号返回值： 成功：0 失败：非0值 abort函数#includestdlib.hvoid abort(void);功能：给自己发送异常终止信号编号为6 SIGABRT,并产生core文件，等价于kill(getpid(),SIGABRT);参数：无返回值：无 alarm函数（闹钟）#includeunistd.hunsigned int alarm(unsigned int seconds);功能： 设置定时器（闹钟）。在指定seconds后，内核会给当前进程发送编号14 SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有一个唯一的定时器。 取消定时器alarm(0),返回旧闹钟余下秒数。参数： seconds:指定的时间，以秒为单位返回值： 返回0或剩余的秒数 定时，与进程状态无关（自然定时法）。就绪，运行，挂起（阻塞。暂停），终止，僵尸。。。。无论进程处于何种状态，alarm都计时。 #includestdio.h#includestdlib.h#includestring.h#includeunistd.h//测试alarm函数int main() unsigned int ret=0; //第一次设置闹钟 5秒钟之后就超时 发送对应的信号 ret=alarm(5); printf(上一次闹钟剩下的时间是%u ,ret);//这时ret为0 sleep(2); //之前没有超时的闹钟被新的设置给覆盖 ret=alarm(4); printf(上一次闹钟剩下的时间是%u ,ret);//这时ret为3 printf(按下任意键继续。。。。 ); getchar(); return 0; setitimer函数（定时器）#includesys/time.hint setitimer(int which,const struct itimerval *new_value,struct itimerval *old_value);功能： 设置定时器（闹钟）。可替代alarm函数。精度微妙us,可以实现周期定时。参数： which:指定定时方式 自然定时:ITIMER_REAL 编号14的信号SIGALRM计算自然时间 虚拟空间计时（用户空间）:ITIMER_VIRTUAL 编号26的信号SIGVTALRM 只计算进程占用cpu的时间 运行时计时（用户+内核）:ITIMER_PROF 编号27的信号SIGPROF计算占用cpu及执行系统调用的时间 new_value:struct itimerval,负责设定timeout时间 struct itimerval struct timerval it_interval;//闹钟触发周期 struct timerval it_value;//闹钟触发时间 ; struct timerval long tv_sec;//秒 long tv_usec;//微秒 itimerval.it_value:设定第一次执行function所延迟的秒数 itimerval.it_interval:设定以后每几秒执行function old_value:存放旧的timeout值，一般指定为NULL返回值： 成功：0 失败：-1 #includestdio.h#includestdlib.h#includestring.h#includesys/time.hint main() int ret=-1; struct itimerval tmo; //第一次触发时间 tmo.it_value.tv_sec=3; tmo.it_value.tv_usec=0; //触发周期 tmo.it_interval.tv_sec=2; tmo.it_interval.tv_usec=0; //设置定时器 ret=setitimer(ITIMER_REAL,tmo,NULL) if(-1==ret) perror(setitimer); return 1; //进程收到闹钟超时信号之后就会终止该进程，要想周期起来，要把信号捕捉 printf(按下任意键继续。。。 ); getchar(); return 0; 信号集在PCB中有两个非常重要的信号集。一个称之为”阻塞信号集”，另一个称之为”未决信号集”。 这两个信号集都是内核使用位图机制来实现的。但是操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。阻塞信号集可以读写，未决信号集不可以写，只可以读。 自定义信号集函数信号集是一个能表示多个信号的数据类型，sigset_t set,set即一个数据集。既然是一个集合，就需要对集合进行添加删除等操作。 相关函数： #includesignal.hint sigemptyset(sigset_t *set);//将set集合置空int sigfillset(sigset_t *set);//将所有的信号加入set集合int sigaddset(sigset_t *set,int signo);//将signo信号加入到set集合int sigdelset(sigset_t *set,int signo);//将set集合中移除signo信号int sigismember(const sigset_t *set,int signo);//判断信号是否存在 示例程序： #includestdio.h#includestdlib.h#includestring.h#includesignal.h//显示信号集void show_set(sigset_t *s) int i=0; for(i=1;i32;i++) //判断指定的信号是否在集合中 if(sigismember(s,i)) printf(1); else printf(0); putchar( );//信号集处理函数int main() int i=0; //信号集集合 sigset_t set; //清空集合 sigemptyset(set); show_set(set) //将所有的信号加入到set集合中 sigfillset(set); show_set(set); //将信号2和信号3从信号集中移除 sigdelset(set,SIGINT); sigdelset(set,SIGQUIT); show_set(set); //将信号2添加到集合中 sigaddset(set,SIGINT); show_set(set); return 0; sigprocmask函数信号阻塞集也称信号屏蔽集。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述那些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。 所谓阻塞并不是禁止传送信号，而是暂缓信号的传送。若将被阻塞的信号从信号阻塞中删除，且对应的信号在被阻塞时发生了，进程会收到相应的信号。 我们可以通过sigprocmask()修改当前的信号掩码来改变信号的阻塞情况。 #includesignal.hint sigprocmask(int how,const sigset_t *set,sigset_t *oldset);功能： 检查或修改信号阻塞集，根据how指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由set指定，而原先的信号阻塞集合由oldset保存。参数： how:信号阻塞集合的修改方法，有三种情况： SIG_BLOCK:向信号阻塞集合中添加set信号集，新的信号掩码是set和旧信号掩码的并集。相当于mask=mask|set. SIG_UNBLOCK:从信号阻塞集合中删除set信号集，从当前信号掩码中去除set中的信号，相当于mask=mask~set. SIG_SETMASK:将信号阻塞集合设为set信号集，相当于原来信号阻塞集内容清空，然后按照set中的信号重新设置信号阻塞集。相当于mask=set. set:要操作的信号集地址。 若set为NULL，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到oldset中。 oldset:保存原先信号阻塞集地址返回值： 成功：0 失败：-1，失败时错误代码只可能是EINVAL,表示参数how不合法 代码示例 #includestdio.h#includestdlib.h#includestring.h#includesignal.h#includeunistd.h//信号处理函数1void func1(int signum) printf(捕捉到信号：%d ,signum);//信号处理函数2void func2(int signum) printf(捕捉到信号：%d ,signum);//信号注册函数int main() int ret=-1; //信号集 sigset_t set; sigset_t oldset; //信号注册 //Ctrl+C signal(SIGINT,func1); //Ctrl+\\ signal(SIGQUIT,func2); printf(按下任意键 阻塞信号2 ); getchar(); sigemptyset(set); sigemptyset(oldset); sigaddset(set,SIGINT); //设置屏蔽编号为2的信号 ret=sigprocmask(SIG_BLOCK,set,oldset); if(ret==-1) perror(sigprocmask); return 1; printf(设置屏蔽编号为2的信号成功了。。。。 ); printf(按下任意键 解除阻塞信号2 ); getchar(); //将信号屏蔽集设置为原来的集合,解除屏蔽后，不管之前发了多少次相同的信号，最后只会捕捉一次 ret=sigprocmask(SIG_SETMASK,oldset,NULL); if(ret==-1) perror(sigprocmask); return 1; printf(按下任意键退出。。。。 ); getchar(); return 0; sigpending函数#includesignal.hint sigpending(sigset_t *set);功能：读取当前进程的未决信号集参数： set：未决信号集返回值： 成功：0 失败：-1 信号捕捉信号处理方式一个进程收到一个信号的时候，可以用如下方法进行处理： 执行系统默认动作 对大多数信号来说，系统默认动作是用来终止该进程。 忽略此信号（丢弃） 接受到此信号后没有任何动作。 执行自定义信号处理函数（捕获） 用用户自定义的信号处理函数处理该信号。 SIGKILL和SIGSTOP不能更改信号的处理方式，因为他们向用户提供了一种使进程终止的可靠方法。 signal函数#includesignal.htypedef void(*sighandler_t)(int);sighandler_t signal(int signum,sighandler_t handler);功能： 注册信号处理函数（不可用于SIGKILL,SIGSTOP信号），即可确定收到信号后处理函数的入口地址。此函数不会阻塞。参数： signum:信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令kill -l进行相应查看。 handler:取值有三种情况 SIG_IGN:忽略该信号。 SIG_DFL:执行系统默认动作 信号处理函数名：自定义信号处理函数。如：func 回调函数的定义如下： void func(int signo) //signo 为触发的信号，为signal()第一个参数 返回值： 成功：第一次返回NULL,下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面声明此函数指针的类型。 失败：返回SIG_ERR 该函数有ANSI定义，由于历史原因在不同版本的UNIX和不同版本的LINUX中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。 #includestdio.h#includestdlib.h#includestring.h#includesignal.h#includeunistd.h//信号处理函数1void func1(int signum) printf(捕捉到信号：%d ,signum);//信号处理函数2void func2(int signum) printf(捕捉到信号：%d ,signum);//信号注册函数int main() //信号注册 //Ctrl+C signal(SIGINT,func1); //Ctrl+\\ signal(SIGQUIT,func2); while(1) getchar(); return 0; 在学会捕捉后，对之前的setitimer函数实现的例子更新一下 #includestdio.h#includestdlib.h#includestring.h#includesys/time.h#includesignal.h//信号处理函数void func(int signo) printf(捕捉到信号：%d ,signo);int main() int ret=-1; struct itimerval tmo; //第一次触发时间 tmo.it_value.tv_sec=3; tmo.it_value.tv_usec=0; //触发周期 tmo.it_interval.tv_sec=2; tmo.it_interval.tv_usec=0; //捕捉信号 SIGALRM signal(SIGALRM,func); //设置定时器 ret=setitimer(ITIMER_REAL,tmo,NULL) if(-1==ret) perror(setitimer); return 1; //进程收到闹钟超时信号之后就会终止该进程，要想周期起来，要把信号捕捉 printf(按下任意键继续。。。 ); getchar(); return 0; sigaction函数#includesignal.hint sigaction(int signum,const struct sigaction *act,struct sigaction *oldact);功能： 检查或修改指定信号的设置（或同时执行这两种操作）。操作： signum:要操作的信号。 act: 要设置的对信号的新处理方式（传入参数）。 oldact:原来对信号的处理方式（传出参数）。 如果act指针非空，则要改变指定信号的处理方式（设置）,如果oldact指针非空，则系统将此前指定信号的处理方式存入oldact返回值： 成功：0 失败：-1 struct sigaction 结构体： struct sigaction void(*sa_handler)(int);//旧的信号处理函数指针 void(*sa_sigaction)(int,siginfo_t*,void *);//新的信号处理函数指针 sigset_t sa_mask; //信号阻塞集 在信号处理函数执行过程中，临时屏蔽指定的信号 int sa_flags; //信号处理方式 void(*sa_restorer)(void); //已弃用; 代码示例： #includestdio.h#includestdlib.h#includestring.h#includesignal.h//信号处理函数void fun(int signo) printf(捕捉到信号 %d ,signo);//演示sigaction函数使用int main() int ret=-1; struct sigaction act; //使用旧的信号处理函数指针 act.sa_handler=fun; //标志为默认 默认使用旧的信号处理函数指针 act.sa_flags=0; ret=sigaction(SIGINT,act,NULL); if(-1==ret) perror(sigaction); return 1; printf(按下任意键退出。。。。 ); while(1) getchar(); return 0; #includestdio.h#includestdlib.h#includestring.h#includesignal.h//新的信号处理函数void fun1(int signo,siginfo_t *info,void *context) printf(捕捉到信号 %d ,signo);//演示sigaction函数使用int main() int ret=-1; struct sigaction act; //使用新的信号处理函数指针 act.sa_sigaction=fun1; //标志指定使用新的信号处理函数指针 act.sa_flags=SA_SIGINFO; if(-1==ret) perror(sigaction); return 1; printf(按下任意键退出。。。。 ); while(1) getchar(); return 0; sigqueue函数（一般不用，用kill函数）#includesignal.hint sigqueue(pid_t pid,int sig,const union sigval value);功能： 给指定进程发送信号参数： pid:进程号 sig：信号的编号 value:通过信号传递的参数。 union sigval类型如下： union sigval int sival_int; void *sival_ptr; 返回值： 成功：0 失败：-1 不可重入，可重入函数如果有一个函数不幸被设计成为这样：那么不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。 满足下列条件的函数多数是不可重入（不安全）的： 函数体内使用了静态的数据结构； 函数体内调用了malloc()或者free()函数（谨慎使用堆）； 函数体内调用了标准IO函数（包含缓冲区）。 相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。 保证函数的可重入性的方法： 在写函数时候尽量使用局部变量（例如寄存器，栈中变量）； 对于要使用的全局变量要加以保护（如采取中断，信号量等互斥方法），这样构成的函数就一定是一个可重入的函数。 信号处理函数应为可重入函数。 SIGCHLD信号SIGCHLD信号产生的条件 子进程终止时 子进程接收到SIGSTOP信号停止时 子进程处在停止态，接受到SIGCONT后唤醒时 如何避免僵尸进程 最简单的方法，父进程通过wait()和waitpid()等函数等待子进程结束，但是，这会导致父进程挂起。 如果父进程要处理的事情很多，不能够挂起，通过signal()函数人为处理信号SIGCHLD，只要有子进程退出自动调用指定好的回调函数，因为子进程结束后，父进程会收到该信号SIGCHLD（17号）,可以在其回调函数里调用wait()或waitpid()回收。 示例程序 #includestdio.h#includestdlib.h#includestring.h#includesignal.h#includesys/wait.h//信号处理函数void fun(int signo) printf(捕捉到信号 %d ,signo); printf(有子进程退出。。。。 ); //以非阻塞方式 while((waitpid(-1,NULL,WNOHANG))0) continue; //演示sigaction函数使用int main() pid_t pid=-1; struct sigaction act; //使用旧的信号处理函数指针 act.sa_handler=fun; //标志为默认 默认使用旧的信号处理函数指针 act.sa_flags=0; sigaction(SIGCHLD,act,NULL); pid=fork(); if(pid0) perror(fork error); return 1; if(pid==0) printf(子进程累); sleep(2); printf(子进程退出); exit(0) else //父进程 while(1) printf(父进程do working); sleep(1); return 0; 守护进程和线程进程组进程组，也称之为作业。代表一个或多个进程的集合。 每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用过。操作系统设计的进程组的概念，是为了简化堆多个进程的管理。 当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID为第一个进程ID（组长进程）。 会话会话是一个或多个进程组的集合。 一个会话可以有一个控制终端。这通常是终端设备或伪终端设备； 建立与控制终端连接的会话首进程被称为控制进程； 一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组； 如果一个会话有一个控制终端，则他有一个前台进程组，其他进程组为后台进程组。 如果终端接口检测到断开连接，则将挂断信号发送至控制进程（会话首进程）。 守护进程守护进程也就是通常说的Daemon进程（精灵进程），是Linux的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。 守护进程是一个特殊的孤儿进程，这种进程脱离终端，为了避免进程被任何终端产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在Linux中，每个系统与用户进行交流的界面叫做终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程会自动关闭。 守护进程模型 创建子进程，父进程退出（必须） 所有工作在子进程中进行形式上脱离了控制终端 在子进程中创建新会话（必须） setsid()函数 使子进程完全独立出来，脱离控制 改变当前目录为根目录（不是必须） chdir()函数 防止占用可卸载的文件系统 也可以换成其他路径 重设文件权限掩码（不是必须） umask()函数(可以对文件权限进行修改，如果umask为0000,那创建普通文件文件权限为0666，目录文件文件权限为0777，但是umask默认为0002) 防止继承的文件创建屏蔽字拒绝某些权限 增加守护进程灵活性 关闭文件描述符（不是必须） 继承的打开文件不会用到，浪费系统资源，无法卸载。标准输入，标准输出，标准错误输出设备文件默认被打开 开始执行守护进程核心工作（必须） 守护进程退出处理程序模型 守护进程参考代码#includestdio.h#includestdlib.h#includestring.h#includeunistd.h#includesys/types.h#includesys/stat.h//创建守护进程int main() pid_t pid=-1; int ret=-1; //1.创建子进程 父进程退出 pid=fork(); if(-1==pid) perror(fork); return 1; if(pid0) //父进程退出 exit(0); //2.创建新的会话 完全脱离控制终端 pid=setsid(); if(-1==pid) perror(setsid); return 1; //3.改变当前工作目录 ret=chdir(/); if(ret==-1) perror(chdir); return 1; //4.设置权限掩码 umask(0); //5.关闭文件描述符 close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); //6.执行核心的任务 //每隔一秒钟输出当前的时间到/tmp/txt.log文件中 while(1) system(date /tmp/txt.log); sleep(1); return 0; 获取系统时间，日志文件需要创建当天的文件，文件名为当天的日期。 #includestdio.h#includestdlib.h#includestring.h#includeunistd.h#includesys/types.h#includesys/stat.h#includetime.h#define SIZE 64//创建守护进程int main()\ttime_t t=-1; pid_t pid=-1; int ret=-1; struct tm *pT=NULL; char file_name[SIZE]; //1.创建子进程 父进程退出 pid=fork(); if(-1==pid) perror(fork); return 1; if(pid0) //父进程退出 exit(0); //2.创建新的会话 完全脱离控制终端 pid=setsid(); if(-1==pid) perror(setsid); return 1; //3.改变当前工作目录 ret=chdir(/); if(ret==-1) perror(chdir); return 1; //4.设置权限掩码 umask(0); //5.关闭文件描述符 close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO); //6.执行核心的任务 //每隔一秒钟输出当前的时间到/tmp/txt.log文件中 while(1) //获取当前时间 以秒为单位 从1970-01-01 00:00:00 开始到现在秒数。 t=time(NULL); //转化为时间 pT=localtime(t); if(pT==NULL) return 1; //转化为文件名 memset(file_name,0,SIZE); sprintf(file_name,%s%d%d%d%d%d%d.log,touch /home/deng/log/,pT-tm_year+1990,pT-tm_mon+1,pT-tm_mday,pT-tm_hour,pT-tm_min,pT-tm_sec); system(file_name); sleep(1); return 0; 线程在许多经典的操作系统教科书中，总是把进程定义为程序的执行实例，她并不执行什么，只是维护应用程序所需的各种资源，而线程才是真正的执行实体。 所以线程是轻量级的线程，在Linux环境下线程的本质仍是进程。 为了让进程完成一定的工作，进程必须至少包含一个线程。 进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统以进程为单位，分配系统资源，所以我们也说，进程是CPU分配资源的最小单位。 线程存在进程当中，是操作系统调度执行的最小单位。 线程的特点 线程是轻量级进程（light-weight process），也有PCB,创建线程使用的底层函数和进程一样，都是clone。 从内核里看进程和线程是一样的，都有各自不同的PCB。 进程可以蜕变成线程。 在Linux下，线程是最小的执行单位；进程是最小的分配资源单位。 查看指定进程的LWP号： ps -Lf pid 实际上，无论是创建进程的fork,还是创建线程的pthread_create,底层实现都是调用同一个内核函数clone。 如果复制对方的地址空间（深拷贝），那么就产生一个进程 如果共享对方的地址空间（浅拷贝），就产生一个线程。 *Linux内核是不区分进程和线程的，只在用户层面上进行区分。所以，线程所有操作函数pthread_是库函数，而非系统调用。 线程共享资源 文件描述符表 每种信号的处理方式 当前工作目录 用户ID和组ID 内存地址空间(.text.data.bssheap共享库)(这里是多线程共享) 线程非共享资源 线程id 处理器现场和栈指针（内核栈） 独立的栈空间（用户空间栈） errno变量 信号屏蔽字 调度优先级 线程常用操作进程号在整个系统中是唯一的，但线程号不同，线程号只在它所属的进程环境中有效。 进程号用pid_t数据类型表示，是一个非负整数。线程号则用pthread_t数据类型来表示，Linux使用无符号长整数表示。 有的系统在实现pthread_t的时候，用一个结构体来表示，所以在可移植的操作系统实现不能把他作为整数处理。 pthread_self函数 #includepthread.hpthread_t pthread_self(void);功能： 获取线程号参数： 无返回值： 调用线程的线程id。 pthread_equal函数： int pthread_equal(pthread_t t1,pthread_t t2);功能： 判断线程号t1和t2是否相等。为了方便移植，尽量使用函数来比较线程ID.参数： t1,t2:待判断的线程号返回值： 相等：非0 不相等：0 参考程序 #includestdio.h#includestdlib.h#includestring.h#includepthread.h//指定链接线程库//gcc pthread_self.c -pthread //线程常用函数int main() pthread_t tid=0; //获取当前线程的线程号 tid=pthread_self(); printf(tid: %lu ,tid); //比较两个线程ID是否相同 if(pthread_equal(tid,pthread_self())) printf(两个线程ID相同 ); else printf(两个线程ID不相同 ); return 0; 线程的创建pthread_create函数： #includepthread.hint pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(*start_routine)(void *),void *arg);功能： 创建一个线程。参数： thread:线程标识符地址 attr:线程属性结构体地址，通常设置为NULL start_routine:线程函数的入口地址 arg:传入线程函数的参数返回值： 成功：0 失败：非0 在一个线程中调用pthread_create()函数创建新的进程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。 由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以用strerror()把错误码转换成错误信息再打印。 参考程序: #includestdio.h#includestdlib.h#includestring.h#includepthread.h//线程调度后执行的任务void *fun(void *arg) printf(新的线程执行任务 tid:%lu ,pthread_self()); return NULL;void *fun1(void *arg) int var=(int)(long)arg; printf(线程2 var=%d ,var); return NULL;int main() int ret=-1; pthread_t tid=-1; pthread_t tid2=-1; //创建一个线程 ret=pthread_create(tid,NULL,fun,NULL); if(ret!=0) printf(pthread_Create failed ); return 1; //创建一个线程 ret=pthread_create(tid2,NULL,fun1,(void *)0x3); if(ret!=0) printf(pthread_Create failed ); return 1; printf(main thread....tid:%lu ,pthread_self()); printf(按下任意键主线程退出); getchar(); return 0; 线程资源回收pthread_join函数： #includepthread.hint pthread_join(pthread_t thread,void **retval);功能： 等待线程结束（此函数会阻塞），并回收线程资源，类似进程的wait函数。如果线程已经结束，那么该函数会立即返回。参数： thread:被等待的线程号。 retval:用来存储线程退出状态的指针的地址返回值： 成功：0 失败：非0 参考程序： #includestdio.h#includestdlib.h#includestring.h#includepthread.h#includeunistd.h//线程处理函数void *fun(void *arg) int i=0; for(i=0;i5;i++) printf(fun thread do working %d ,i); sleep(1); return (void *)0x3;//回收线程的资源int main() int ret=-1; pthread_t tid=-1; void *retp=NULL; //创建一个线程 ret=pthread_create(tid,NULL,fun,NULL); if(ret!=0) printf(pthread_create failed... ); return 1; printf(main thread running... ); //等待线程结束 会阻塞 ret=pthread_join(tid,retp); if(ret!=0) printf(pthread_join failed... ); return 1; printf(retp: %p ,retp); printf(main thread exit... ); return 0; main thread running...fun thread do working 0fun thread do working 1fun thread do working 2fun thread do working 3fun thread do working 4retp: 0x3main thread exit... 线程分离一般情况下，线程终止后，其终止状态一直保留到其他线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它所占用的资源，而不保留终止状态。 不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。 pthread_detach函数： #includepthread.hint pthread_detach(pthread_t thread);功能： 使调用线程与当前进程分离，分离后不代表此线程不依赖当前进程（进程退出，线程也结束），线程分离的目的是将线程资源的回收工作交由系统自动完成，也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以。此函数不会阻塞。参数： thread:线程号返回值： 成功：0 失败：非0 代码示例： #include stdio.h#include stdlib.h#include string.h#include pthread.h#include unistd.h// 线程处理函数void *fun(void *arg) int i = 0; for (i = 0; i 5; i++) printf(fun thread do working %d , i); sleep(1); return NULL;// 回收线程的资源int main() int ret = -1; pthread_t tid = -1; // 创建一个线程 ret = pthread_create(tid, NULL, fun, NULL); if (ret != 0) printf(pthread_create failed... ); return 1; printf(main thread running... ); //设置线程分离 ret=pthread_detach(tid); if(ret!=0) printf(pthread_detach failed... ); return 1; printf(按下任意键主线程退出。。。 ); getchar(); return 0; main thread running...按下任意键主线程退出。。。fun thread do working 0fun thread do working 1fun thread do working 2fun thread do working 3fun thread do working 4 线程退出在进程中我们可以用exit函数或_exit函数来结束进程，在一个线程中我们可以通过一下三种在不终止整个进程的情况下停止它的控制流。 线程从执行函数返回。 线程调用pthread_exit退出线程 线程可以被同一进程中的其他线程取消。 pthread_exit函数： #includepthread.hvoid pthread_exit(void *retval);功能： 退出调用线程。一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源并不会释放。参数： retval:存储线程退出状态的指针。返回值：无 代码示例： #include stdio.h#include stdlib.h#include string.h#include pthread.h#include unistd.h// 线程处理函数void *fun(void *arg) int i = 0; for (i = 0; i 5; i++) printf(fun thread do working %d , i); sleep(1); //return NULL; //相当于return NULL pthread_exit(NULL); //终止整个进程 //exit(0);// 回收线程的资源int main() int ret = -1; pthread_t tid = -1; // 创建一个线程 ret = pthread_create(tid, NULL, fun, NULL); if (ret != 0) printf(pthread_create failed... ); return 1; printf(main thread running... ); //设置线程分离 ret=pthread_detach(tid); if(ret!=0) printf(pthread_detach failed... ); return 1; printf(按下任意键主线程退出。。。 ); getchar(); return 0; 线程取消#includepthread.hint pthread_cancel(pthread_t thread);功能： 杀死（取消）线程参数： thread:目标线程ID返回值： 成功：0 失败：出错编号 注:线程的取消并不是实时的，而又一定的延时。需要等待线程到达某个取消点（检查点）。 取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat,open，pause,close,read,write…可粗略认为一个系统调用（进入内核）为一个取消点。 代码示例： #include stdio.h#include stdlib.h#include string.h#include pthread.h#include unistd.h// 线程处理函数void *fun(void *arg) int i = 0; for (i = 0; i 5; i++) printf(fun thread do working %d , i); sleep(1); pthread_exit(NULL);// 回收线程的资源int main() int ret = -1; pthread_t tid = -1; // 创建一个线程 ret = pthread_create(tid, NULL, fun, NULL); if (ret != 0) printf(pthread_create failed... ); return 1; printf(main thread running... ); //设置线程分离 ret=pthread_detach(tid); if(ret!=0) printf(pthread_detach failed... ); return 1; sleep(3); pthread_cancel(tid); printf(主线程睡眠了3秒 取消子线程。。 ); return 0; main thread running...fun thread do working 0fun thread do working 1fun thread do working 2主线程睡眠了3秒 取消子线程。。 线程使用注意事项 主线程退出其他线程不退出，主线程应调用pthread_exit 避免僵尸线程，pthread_joinpthread_detachpthread_create指定分离属性 malloc和mmap申请的内存可以被其他线程释放。 避免在多线程模型中调用fork,除非马上exec,子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit 信号的复杂语义很难和多线程共存，避免在多线程引入信号机制。 线程同步互斥锁现代操作系统基本都是多任务操作系统，即同时有大量可调度实体在运行。在多任务操作系统中，同时运行的多个任务： 都需要访问使用同一种资源 多个任务之间有依赖关系，某个任务的运行依赖另一个任务 同步和互斥就是用于解决这两个问题。 互斥：是指散步在不同任务之间的若干程序片段，当某个任务运行其中一个程序片段时，其他任务就不能运行他们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。 同步：是指散步在不同任务之间的若干程序片段，他们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如A任务的运行依赖于B任务产生的数据。 互斥锁Mutex介绍在线程里，也有这么一把锁：互斥锁（mutex）,也叫互斥量，互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态，即加锁（lock）和解锁（unlock）。 互斥锁的操作流程如下： 在访问共享资源后临界区域前，对互斥锁进行加锁。 在访问完成后释放互斥锁 对互斥锁进行加锁后，任何试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。 互斥锁的数据类型是：pthread_mutex_t pthread_mutex_init函数初始化互斥锁： #include pthread.hint pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);功能： 初始化一个互斥锁参数： mutex:互斥锁地址。类型是pthread_mutex_t. attr:设置互斥量的属性，通常采用默认属性，即可将attr设为NULL. 返回值： 成功：0，成功申请的锁是默认打开的。 失败：非0错误码 pthread_mutex_destory函数#includepthread.hint pthread_mutex_destory(pthread_mutex_t *mutex);功能： 销毁指定的一个互斥锁。互斥锁在使用完毕，必须要对互斥锁进行销毁，以释放资源。参数： mutex:互斥锁地址。返回值： 成功：0 失败：非0错误码 pthread_mutex_lock函数#includepthread.hint pthread_mutex_lock(pthread_mutex_t *mutex);功能： 对互斥锁上锁，若互斥锁已经上锁，则调用者阻塞，直到互斥锁解锁后上锁。参数:\tmutex:互斥锁地址返回值： 成功：0 失败：非0错误码 int pthread_mutex_trylock(pthread_mutex_t *mutex);\t调用该函数时，若互斥锁未加锁，则上锁，返回0； 若互斥锁已加锁，则函数直接返回失败，即EBUSY. pthread_mutex_unlock函数#includepthread.hint pthread_mutex_unlock(pthread_mutex_t *mutex);功能： 对指定的互斥锁解锁参数： mutex:互斥锁地址返回值： 成功：0 失败：非0错误码 #includestdio.h#includestdlib.h#includestring.h#includepthread.h#includeunistd.h//互斥锁变量pthread_mutex_t mutex;//输出大写字母void *fun1(void *arg) int i=0; //加锁 pthread_mutex_lock(mutex); for(i=A;iZ;i++) putchar(i); fflush(stdout); usleep(10000); //解锁 pthread_mutex_unlock(mutex); return NULL;//输出小写字母void *fun2(void *arg) int i=0; //加锁 pthread_mutex_lock(mutex); for(i=a;iz;i++) putchar(i); fflush(stdout); usleep(10000); //解锁 pthread_mutex_unlock(mutex); return NULL;int main() int ret=-1; pthread_t tid1,tid2; //初始化一个互斥量 互斥锁 ret=pthread_mutex_init(mutex,NULL); if(0!=ret) printf(pthread_mutex_init failed... ); return 1; printf(初始化一个互斥量成功。。。。 ); //创建两个线程 pthread_create(tid1,NULL,fun1,NULL); pthread_create(tid2,NULL,fun2,NULL); //等待两个线程结束 pthread_join(tid1,NULL); pthread_join(tid2,NULL); printf( ); printf(main thread exit... ); //销毁互斥量 互斥锁 pthread_mutex_destroy(mutex); 初始化一个互斥量成功。。。。ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxymain thread exit... 死锁（DeadLock）死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。若无外力作用，他们将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 预防死锁的方法破坏请求和保持条件 协议1：所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会提出资源需求，破坏了请求条件，即使有一种资源不能满足需求，也不会给他分配正在空闲的进程，这样他就没有资源，这样他就没有资源，就破环了保持条件，从而预防。 协议2：允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来。然后再请求新的资源。 破坏不可抢占条件 当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能满足时，他必须释放已经保持的所有资源，以后需要时再重新申请。 破坏循环等待条件 对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。 读写锁当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其他几个线程也想读取这个共享资源，但是由于互斥锁的排他性，所有其他线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。 为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。 读写锁的特点如下： 如果有其他线程读数据，则允许其他线程执行读操作，但不允许写操作。 如果有其他线程写数据，则其他线程都不允许读，写操作。 POSIX定义的读写锁的数据类型是：pthread_rwlock_t。 pthread_rwlock_init函数#includepthread.hint pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);功能： 用来初始化rwlock所指向的读写锁参数： rwlock:指向要初始化的读写指针。 attr:读写锁的属性指针。如果attr为NULL则会使用默认的属性初始化读写锁，否则使用指定的attr初始化读写锁。返回值： 成功：0,读写锁的状态将成为已初始化和已解锁 失败:非0错误码 pthread_rwlock_destroy函数#includepthread.hint pthread_rwlock_destroy(pthread_rwlock_t *rwlock);功能： 用于销毁一个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init()自动申请的资源）参数： rwlock:读写锁指针返回值： 成功：0 失败：非0错误码 pthread_rwlock_rdlock函数#includepthread.hint pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);功能： 以阻塞方式在读写锁上获取读锁（读锁定） 如果没有写者持有该锁，并且没有写者阻塞在该锁上，则调用线程会获取读锁。 如果调用线程未获取读锁，则它将阻塞直到他获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。线程可以成功调用pthread_rwlock_rdlock函数多次，但是之后该线程必须调用pthread_rwlock_unlock函数n次才能解除锁定。参数： rwlock；读写锁指针返回值： 成功：0 失败：非0错误码int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\t用于尝试以非阻塞的方式来在读写锁上获取读锁 如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。 pthread_rwlock_wrlock函数#includepthread.hint pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);功能： 在读写锁上获取写锁（写锁定） 如果没有写者持有该锁，并且没有读者持有该锁，则调用线程获取写锁 如果调用线程未获取写锁，则它将阻塞直到它获取了该锁。参数： rwlock:读写锁指针返回值： 成功：0 失败：非0错误码int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\t用于尝试以非阻塞的方式来在读写锁上获取写锁 如果有任何的读者和写者持有该锁，则立即失败返回。 pthread_rwlock_unlock函数#includepthread.hint pthread_rwlock_unlock(pthread_rwlock_t *rwlock);功能： 无论是写锁还是读锁，都可以通过此函数解锁参数： rwlock:读写锁指针返回值： 成功：0 失败：非0错误码 示例代码#include stdio.h#includestdlib.h#includestring.h#includeunistd.h#includepthread.h//读写锁变量pthread_rwlock_t rwlock;//全局变量int num=0;//读线程void *fun_read(void *arg) //获取线程的编号 int index=(int)(long)arg; while(1) //加读写锁读锁 pthread_rwlock_rdlock(rwlock); printf(线程%d 读取num的值 %d ,index,num); //解锁 pthread_rwlock_unlock(rwlock); //随机睡眠1到3秒 sleep(random()%3+1); return NULL;//写线程void *fun_write(void *arg) //获取线程的编号 int index=(int)(long)arg; while(1) //加读写锁的写锁 pthread_rwlock_wrlock(rwlock); num++; printf(线程%d 修改num的值 %d ,index,num); //解锁 pthread_rwlock_unlock(rwlock); //随机睡眠1到3秒 sleep(random()%3+1); return NULL;int main() int i=0; int ret=-1; pthread_t tid[8]; //设置随机种子 srandom(getpid()); //初始化读写锁 ret=pthread_rwlock_init(rwlock,NULL); if(ret!=0) printf(pthread_rwlock_init failed.. ); return 1; //创建8个线程 for(i=0;i8;i++) //创建读线程 if(i5) pthread_create(tid[i],NULL,fun_read,(void *)(long)i); else //创建写线程 pthread_create(tid[i],NULL,fun_write,(void *)(long)i); //回收八个线程的资源 for(i=0;i8;i++) pthread_join(tid[i],NULL); //销毁读写锁 pthread_rwlock_destroy(rwlock); return 0; 线程0 读取num的值 0线程1 读取num的值 0线程2 读取num的值 0线程3 读取num的值 0线程4 读取num的值 0线程5 修改num的值 1线程7 修改num的值 2线程6 修改num的值 3线程3 读取num的值 3线程4 读取num的值 3线程6 修改num的值 4线程0 读取num的值 4线程2 读取num的值 4线程5 修改num的值 5线程6 修改num的值 6线程1 读取num的值 6线程0 读取num的值 6线程2 读取num的值 6线程4 读取num的值 6线程7 修改num的值 7线程5 修改num的值 8线程6 修改num的值 9线程3 读取num的值 9线程7 修改num的值 10 条件变量条件变量是用来等待而不是用来上锁的，条件变量本身不是锁。 条件变量用来自动阻塞一个线程，直到某种特殊情况发生为止。通常条件变量和互斥锁同时使用。 条件变量的两个动作： 条件不满足，阻塞线程 当条件满足时，通知阻塞的线程开始工作 条件变量的类型：pthread_cond_t pthread_cond_init函数#includepthread.hint pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);功能： 初始化一个条件变量参数： cond:指向要初始化的条件变量指针。 attr:条件变量属性，通常为默认值，传NULL即可返回值： 成功：0 失败：非0错误码 pthread_cond_destroy函数#includepthread.hint pthread_cond_destroy(pthread_cond_t *cond);功能： 销毁一个条件变量参数:\tcond：指向要初始化的条件变量指针返回值： 成功：0 失败：非0错误码 pthread_cond_wait函数#includepthread.hint pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);功能： 阻塞等待一个条件变量 1.阻塞等待条件变量cond(参数1)满足 2.释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(mutex); 以上的两步为一个原子操作（不可中断，取消） 3.当被唤醒时，pthread_cond_wait函数返回时，解除阻塞并重新申请互斥锁pthread_mutex_lock(mutex);参数： cond:指向要初始化的条件变量指针 mutex:互斥锁返回值： 成功：0 失败：非0错误码 pthread_cond_signal函数唤醒阻塞在条件变量上的线程 #includepthread.hint pthread_cond_signal(pthread_cond_t *cond);功能： 唤醒至少一个阻塞在条件变量上的线程参数： cond:指向要初始化的条件变量指针返回值： 成功：0 失败：非0错误码 int pthread_cond_broadcast(pthread_cond_t *cond);功能： 唤醒全部阻塞在条件变量上的线程参数:\tcond:指向要初始化的条件变量指针返回值： 成功：0 失败：非0错误码 示例代码： #includestdio.h#includestdlib.h#includestring.h#includeunistd.h#includepthread.hint flag=0;//互斥量pthread_mutex_t mutex;//条件变量pthread_cond_t cond;//改变条件的线程void *fun1(void *arg) while(1) //加锁 pthread_mutex_lock(mutex); flag=1; //解锁 pthread_mutex_unlock(mutex); //唤醒因为条件而阻塞线程 pthread_cond_signal(cond); sleep(2); return NULL;//等待条件的线程void *fun2(void *arg) while(1) //加锁 pthread_mutex_lock(mutex); //表示条件不满足 if(flag==0) //等待条件满足 会阻塞 pthread_cond_wait(cond,mutex); printf(线程2因为条件满足 开始运行。。。 ); flag=0; //解锁 pthread_mutex_unlock(mutex); return NULL;//条件变量的应用int main() int ret=-1; pthread_t tid1,tid2; //初始化条件变量 ret=pthread_cond_init(cond,NULL); if(ret!=0) printf(pthread_cond_init failed... ); return 1; //初始化互斥量 ret=pthread_mutex_init(mutex,NULL); if(ret!=0) printf(pthread_mutex_init failed... ); return 1; //创建两个线程 pthread_create(tid1,NULL,fun1,NULL); pthread_create(tid2,NULL,fun2,NULL); //回收线程 ret=pthread_join(tid1,NULL); if(ret!=0) printf(pthread_join failed.. ); return 1; ret=pthread_join(tid2,NULL); if(ret!=0) printf(pthread_join failed.. ); return 1; //销毁互斥量 pthread_mutex_destroy(mutex); //销毁条件变量 pthread_cond_destroy(cond); return 0; 线程2因为条件满足 开始运行。。。线程2因为条件满足 开始运行。。。线程2因为条件满足 开始运行。。。线程2因为条件满足 开始运行。。。线程2因为条件满足 开始运行。。。线程2因为条件满足 开始运行。。。线程2因为条件满足 开始运行。。。线程2因为条件满足 开始运行。。。线程2因为条件满足 开始运行。。。线程2因为条件满足 开始运行。。。 生产者和消费者模型（由条件变量实现）#include stdio.h#include string.h#include stdlib.h#include unistd.h#include pthread.htypedef struct _node_t int data; struct _node_t *next; node_t;//条件变量pthread_cond_t cond;//互斥量pthread_mutex_t mutex;node_t *head = NULL;// 生产者线程void *producer(void *arg) // 循环生产产品 while (1) //加锁 pthread_mutex_lock(mutex); node_t *new = malloc(sizeof(node_t)); if (new == NULL) printf(malloc failed.... ); break; memset(new, 0, sizeof(node_t)); // 1-100 new-data = random() % 100 + 1; new-next = NULL; // 头插法 new-next = head; head = new; printf(生产者生产产品%d ,new-data); //解锁 pthread_mutex_unlock(mutex); //唤醒因为条件变量阻塞的线程 pthread_cond_signal(cond); // 随机睡眠 sleep(random() % 3 + 1); pthread_exit(NULL);// 消费者线程void *customer(void *arg) node_t *tmp = NULL; // 循环消费 while (1) //加锁 pthread_mutex_lock(mutex); if (NULL == head) //如果链表为空 就阻塞 pthread_cond_wait(cond,mutex); else tmp = head; head = head-next; printf(消费者消费 %d ,tmp-data); free(tmp); //解锁 pthread_mutex_unlock(mutex); pthread_exit(NULL);// 生产者和消费者模型 条件变量的版本int main() int ret=-1; pthread_t tid1 = -1, tid2 = -1; //设置随机种子 srandom(getpid()); //初始化条件变量 ret=pthread_cond_init(cond,NULL); if(ret!=0) printf(pthread_cond_init failed... ); return 1; //初始化互斥量 ret=pthread_mutex_init(mutex,NULL); if(ret!=0) printf(pthread_mutex_init failed... ); return 1; // 创建两个线程 生产者线程 消费者线程 pthread_create(tid1, NULL, producer, NULL); pthread_create(tid2, NULL, customer, NULL); // 等待两个线程结束 pthread_join(tid1, NULL); pthread_join(tid2, NULL); //销毁 pthread_cond_destroy(cond); pthread_mutex_destroy(mutex); return 0; 产者生产产品71消费者消费 71生产者生产产品69消费者消费 69生产者生产产品69消费者消费 69生产者生产产品54消费者消费 54生产者生产产品20消费者消费 20生产者生产产品4消费者消费 4生产者生产产品33消费者消费 33生产者生产产品23消费者消费 23 条件变量的优缺点相对于mutex而言，条件变量可以减少竞争。 如直接使用mutex,除了生产者，消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果链表中没有数据，消费者之间竞争互斥锁是无意义的。 有了条件变量机制后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。 信号量信号量广泛用于进程或进程间的同步和互斥，信号量本质上是一个非负的整数计数器，它用来控制对公共资源的访问。 编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号值大于0时，则可以访问，否则将阻塞。 PV原语对信号量的操作，一次P操作使信号量减1，一次V操作使信号量加1. 信号量主要用于进程或线程间的同步和互斥这两种典型情况。 信号量数据类型：sem_t sem_init函数初始化信号量： #includesemaphore.hint sem_init(sem_t *sem,int pshared,unsigned int value);功能： 创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化。参数： sem:信号量地址 pshared:等于0，信号量在线程间共享（常用）；不等于0，信号量在进程间共享 value:信号量的初始值返回值： 成功：0 失败：-1 sem_destroy函数销毁信号量： #includesemaphore.hint sem_destroy(sem_t *sem);功能： 删除sem标识的信号量参数： sem:信号量地址返回值： 成功：0 失败：-1 信号量P操作（减1）#includesemaphore.hint sem_wait(sem_t *sem);功能： 将信号量的值减1，操作前，先检查信号量（sem）的值是否为0，若信号量为0，此函数会阻塞，直到信号量大于0时才进行减1操作。参数： sem:信号量的地址返回值： 成功：0 失败：-1int sem_trywait(sem_t *sem);\t以阻塞的方式来对信号量进行减1操作。 若操作前，信号量的值等于0，则对信号量的操作失败，函数立即返回。 信号量V操作（加1）#includesemaphore.hint sem_post(sem_t *sem);功能： 将信号量的值加1并发出信号唤醒等待线程（ sem_wait() ）;参数： sem:信号量的地址返回值： 成功：0\t失败：-1 获取信号量的值#includesemaphore.hint sem_getvalue(sem_t *sem,int *sval);功能： 获取sem标识的信号量的值，保存在sval中参数： sem:信号量地址 sval:保存信号量值的地址返回值： 成功：0 失败：-1 信号量用于互斥一次性打印完大写或者小写。 #includestdio.h#includestdlib.h#includestring.h#includepthread.h#includeunistd.h#includesemaphore.h//信号量变量sem_t sem;//输出大写字母void *fun1(void *arg) int i=0; //申请资源 将可用资源减1 sem_wait(sem); for(i=A;iZ;i++) putchar(i); fflush(stdout); usleep(10000); //释放资源 将可用资源加1 sem_post(sem); return NULL;//输出小写字母void *fun2(void *arg) int i=0; //申请资源 将可用资源减1 sem_wait(sem); for(i=a;iz;i++) putchar(i); fflush(stdout); usleep(10000); //释放资源 将可用资源加1 sem_post(sem); return NULL;int main() int ret=-1; pthread_t tid1,tid2; //初始化一个信号量 ret=sem_init(sem,0,1); if(0!=ret) printf(sem_init failed... ); return 1; printf(初始化一个信号量成功。。。。 ); //创建两个线程 pthread_create(tid1,NULL,fun1,NULL); pthread_create(tid2,NULL,fun2,NULL); //等待两个线程结束 pthread_join(tid1,NULL); pthread_join(tid2,NULL); printf( ); printf(main thread exit... ); //销毁信号量 sem_destroy(sem); return 0; 初始化一个信号量成功。。。。ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxymain thread exit... 信号量用于同步生产者和消费者模型（信号量） #include stdio.h#include string.h#include stdlib.h#include unistd.h#include pthread.h#include semaphore.htypedef struct _node_t int data; struct _node_t *next; node_t;node_t *head = NULL;// 信号量变量// 容器的个数sem_t sem_producer;// 可以卖产品的个数sem_t sem_customer;// 生产者线程void *producer(void *arg) // 循环生产产品 while (1) // 申请一个资源 容器 sem_wait(sem_producer); node_t *new = malloc(sizeof(node_t)); if (new == NULL) printf(malloc failed.... ); break; memset(new, 0, sizeof(node_t)); // 1-100 new-data = random() % 100 + 1; new-next = NULL; // 头插法 new-next = head; head = new; printf(生产者生产产品%d , new-data); // 通知消费者消费 将可以卖的商品个数加1 sem_post(sem_customer); // 随机睡眠 sleep(random() % 3 + 1); pthread_exit(NULL);// 消费者线程void *customer(void *arg) node_t *tmp = NULL; // 循环消费 while (1) // 申请资源 可以卖的商品个数减1 sem_wait(sem_customer); if (NULL == head) // 如果链表为空 就阻塞 printf(产品为空); tmp = head; head = head-next; printf(消费者消费 %d , tmp-data); free(tmp); // 释放资源 将容器个数加1 sem_post(sem_producer); // 睡眠1-3秒 sleep(random() % 3 + 1); pthread_exit(NULL);// 生产者和消费者模型 条件变量的版本int main() int ret = -1; pthread_t tid1 = -1, tid2 = -1; // 设置随机种子 srandom(getpid()); // 初始化 ret = sem_init(sem_producer, 0, 4); if (ret != 0) printf(sem_producer_init failed... ); return 1; ret = sem_init(sem_customer, 0, 0); if (ret != 0) printf(sem_customer_init failed... ); return 1; // 创建两个线程 生产者线程 消费者线程 pthread_create(tid1, NULL, producer, NULL); pthread_create(tid2, NULL, customer, NULL); // 等待两个线程结束 pthread_join(tid1, NULL); pthread_join(tid2, NULL); // 销毁 sem_destroy(sem_producer); sem_destroy(sem_customer); return 0; 生产者生产产品7消费者消费 7生产者生产产品10消费者消费 10生产者生产产品65消费者消费 65生产者生产产品84消费者消费 84生产者生产产品13消费者消费 13生产者生产产品10消费者消费 10生产者生产产品51 多生产者和多消费者 #include stdio.h#include string.h#include stdlib.h#include unistd.h#include pthread.h#include semaphore.htypedef struct _node_t int data; struct _node_t *next; node_t;node_t *head = NULL;//互斥锁pthread_mutex_t mutex;// 信号量变量// 容器的个数sem_t sem_producer;// 可以卖产品的个数sem_t sem_customer;// 生产者线程void *producer(void *arg) // 循环生产产品 while (1) // 申请一个资源 容器 sem_wait(sem_producer); pthread_mutex_lock(mutex); node_t *new = malloc(sizeof(node_t)); if (new == NULL) printf(malloc failed.... ); break; memset(new, 0, sizeof(node_t)); // 1-100 new-data = random() % 100 + 1; new-next = NULL; // 头插法 new-next = head; head = new; printf(生产者生产产品%d , new-data); pthread_mutex_unlock(mutex); // 通知消费者消费 将可以卖的商品个数加1 sem_post(sem_customer); // 随机睡眠 sleep(random() % 3 + 1); pthread_exit(NULL);// 消费者线程void *customer(void *arg) node_t *tmp = NULL; // 循环消费 while (1) // 申请资源 可以卖的商品个数减1 sem_wait(sem_customer); pthread_mutex_lock(mutex); if (NULL == head) // 如果链表为空 就阻塞 printf(产品为空); tmp = head; head = head-next; printf(消费者消费 %d , tmp-data); free(tmp); pthread_mutex_unlock(mutex); // 释放资源 将容器个数加1 sem_post(sem_producer); // 睡眠1-3秒 sleep(random() % 3 + 1); pthread_exit(NULL);// 生产者和消费者模型 条件变量的版本int main() int ret = -1; pthread_t tid[6]; // 设置随机种子 srandom(getpid()); //互斥锁初始化 pthread_mutex_init(mutex,NULL); // 初始化 ret = sem_init(sem_producer, 0, 8); if (ret != 0) printf(sem_producer_init failed... ); return 1; ret = sem_init(sem_customer, 0, 0); if (ret != 0) printf(sem_customer_init failed... ); return 1; for(int i=0;i6;i++) //生产者 if(i2) pthread_create(tid[i], NULL, producer, NULL); else pthread_create(tid[i], NULL, customer, NULL); // 等待线程结束 for(int i=0;i6;i++) pthread_join(tid[i], NULL); // 销毁 sem_destroy(sem_producer); sem_destroy(sem_customer); //互斥锁销毁 pthread_mutex_destroy(mutex); return 0; 生产者生产产品59消费者消费 59生产者生产产品68消费者消费 68生产者生产产品12消费者消费 12生产者生产产品28消费者消费 28生产者生产产品97消费者消费 97生产者生产产品12消费者消费 12生产者生产产品51消费者消费 51生产者生产产品99消费者消费 99生产者生产产品96 完结撒花","tags":["Linux System Programming"],"categories":["Linux System Programming"]},{"title":"数据结构100题","path":"/2025/06/03/数据结构100题/","content":"两数之和题目描述​ 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6输出：[0,1] 思路：具体思路：首先使用unordered_map，在遍历原数组时，边查边找。 如果没找到，就把当前值的值和下标存入unordered_map，以便下次寻找可以搜素以前的键值对，看是否有满足情况（target-nums[i]）的key,若有，取出对应的value(iter-second)和当前的数组下标一起返回。当然最坏的情况，遍历完了，也没有符合情况的出现。可以直接返回空。 std::unordered_map的核心特性：1. 基于哈希表实现（Hash Table） unordered_map 通过哈希函数（std::hash）将键（key）映射到一个桶（bucket）中，实现常数时间复杂度（O(1)）的查找、插入和删除操作（平均情况）。 哈希冲突通过链表（或更优化的结构）解决。 键唯一（Key is Unique） 每个键（key）在 unordered_map 中必须是唯一的，如果插入相同键，会覆盖原有值或插入失败（取决于操作方式）。 3. 无序（Unordered） 元素的存储顺序不保证稳定性或有序性，与插入顺序无关。 如果需要有序容器，应使用 std::map。 4. 自动扩容 unordered_map 会根据负载因子（load factor）自动扩展桶的数量，以保持操作效率。 用户可以手动调整负载因子和桶数量（如 rehash() 或 reserve() 函数）。 5. 允许自定义哈希函数与相等比较器 支持用户为自定义类型指定哈希函数（通过模板参数 Hash 和 KeyEqual）。 cpp复制编辑std::unordered_mapMyType, int, MyHash, MyEqual 6. 快速访问接口 operator[]：快速访问键对应的值，如果键不存在，则自动插入默认值。 find()：返回一个迭代器，指向查找到的键值对，否则为 end()。 7. 不支持排序算法 由于无序存储，标准排序算法（如 sort）不能直接应用于 unordered_map，但可以通过将其内容复制到 vectorpair 后排序实现。 8. 多线程下非线程安全 多线程环境下访问 unordered_map 必须加锁或使用线程安全容器。 代码块class Solution public: vectorint twoSum(vectorint nums, int target) std::unordered_mapint,int map; for(int i=0;inums.size();i++) auto iter =map.find(target-nums[i]); if(iter!=map.end()) return i,iter-second; map.insert(pairint,int(nums[i],i)); return ; ; 时间复杂度： 一次遍历 nums 数组，时间是 O(n)。 对于每个元素： map.find(...) 查找操作的平均时间复杂度是 **O(1)**。 map.insert(...) 插入操作的平均时间复杂度也是 **O(1)**。 因此，总体时间复杂度是： **O(n)**（n 是数组中元素的数量） 空间复杂度： 最多会向 unordered_map 中插入 n 个元素（每个 nums[i] 和其索引 i）。 所以空间复杂度与 nums 的大小成正比。 **O(n)**（额外使用了哈希表来存储 n 个键值对） 字母异位词分组题目描述：给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 示例 1: 输入: strs = [eat, tea, tan, ate, nat, bat]输出: [[bat],[nat,tan],[ate,eat,tea]] 示例 2: 输入: strs = []输出: [[]] 示例 3: 输入: strs = [a]输出: [[a]] 提示： 1 = strs.length = 104 0 = strs[i].length = 100 strs[i] 仅包含小写字母 思路具体思路：​ 首先使用std::unordered_map结构，当然不用再介绍了。这个题的意思是把那些排序之后相同的单词放在一个组合。 所以我们可以先使用unordered_mapstring,vector存储键值对，键就是排序之后的单词，毕竟排序之后都一样。 键对应的值就是对应的单词（排序相同的单词），最后再遍历这个unordered_map，输出结果。 代码块：class Solution public: vectorvectorstring groupAnagrams(vectorstring strs) //做这道题首先对于字母异位词 排序之后是相同的，所以可以用一个哈希表，键存储排序后的结果，值为结果集 std::unordered_mapstring,vectorstring record; for(int i=0;istrs.size();i++) string temp=strs[i]; sort(temp.begin(),temp.end()); record[temp].emplace_back(strs[i]); vectorvectorstring ans; for(auto it=record.begin();it!=record.end();it++) ans.emplace_back(it-second); return ans; ; 时间复杂度：假设： n 是字符串数组 strs 的长度。 k 是每个字符串的平均长度。 遍历 strs 中的每个字符串，共 n 次。 对每个字符串排序：O(k log k) 哈希表插入查找键值对：O(1) 平均时间。 所以总时间复杂度为： O(n * k log k) 空间复杂度： 哈希表 record 最多存 n 个键，每个键存一个 vectorstring，整体字符串内容不变，只是重新组织。 排序后的中间变量 temp 的开销为 O(k)，共用一次。 最终结果 ans 存储所有原字符串内容。 所以额外空间主要包括： 哈希表键（排序后的字符串）：最多 n 个，每个长度为 k：O(n * k) 哈希表值（字符串集合）：整体还是输入的字符串，只是重新组织，不算重复存储 排序的临时变量（重复使用）：忽略不计 因此总空间复杂度为： O(n * k) 最长连续序列题目描述：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1： 输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 示例 2： 输入：nums = [0,3,7,2,5,8,4,6,0,1]输出：9 示例 3： 输入：nums = [1,0,1,2]输出：3 思路：具体思路：​ 首先将数组存入unordered_set中避免重复，为什么用unordered_set，因为找元素它是O(1)。 接下来遍历unordered_set，先判断当前元素有没有前一个连续的元素（例子：当前元素为5，查是否有4），有则跳过，没有则进行下一步，并且这个节点是作为开始节点。 然后先保存当前节点的值和连续序列的长度（这个时候为1），然后循环查找连续序列，最后获得连续序列的长度，再和历史最长连续序 列比较，更新历史最长连续序列。遍历完unordered_set，返回历史最长连续序列即可。 std::unordered_set的特性：std::unordered_set 是 C++ 标准库中提供的 无序集合容器，它内部基于哈希表实现，主要用于快速判断一个元素是否存在，并确保元素唯一。下面是它的详细特性： 1. 元素唯一（Unique Elements） 它是一个 集合（set），不允许重复元素。 插入相同元素将失败，已有的不会被替换。 2. 基于哈希表（Hash Table） 内部使用哈希表存储元素。 插入、查找、删除的**平均时间复杂度是 O(1)**，非常高效。 如果发生大量哈希冲突，最坏情况会退化为 O(n)，但 STL 默认哈希函数表现良好，一般不会发生。 3. 元素无序（Unordered） 和 std::set（基于红黑树，有序）不同，unordered_set 中的元素存储顺序不固定。 遍历时元素的顺序是哈希桶顺序，不可预测。 4. 可自定义哈希函数（支持自定义类型） 可以为自定义类型提供哈希函数和等价比较函数。 std::unordered_setMyType, MyHash, MyEqual 5. 常用操作和函数 函数 功能 insert(val) 插入元素，若已存在则不插入 erase(val) 删除元素 find(val) 查找元素，返回迭代器 count(val) 判断元素是否存在（返回 0 或 1） size() 元素个数 empty() 是否为空 clear() 清空所有元素 begin(), end() 返回迭代器（可用于范围遍历） 5.与 std::set 的区别 特性 std::set（有序） std::unordered_set（无序） 底层结构 红黑树（平衡 BST） 哈希表 元素是否有序 是 否 查找插入效率 O(log n) 平均 O(1) 内存使用 较少 较多（需额外存哈希结构） 自定义排序 支持 不支持 代码块：class Solution public: int longestConsecutive(vectorint nums) unordered_setint num_set; //使用unordered_set存储nums的所有值 for(const int num:nums) num_set.insert(num); int longSum=0; for(const int num:num_set) //上述遍历用nums和num_set有什么区别，在leetcode一个能过一个不能过 //以遍历的每个元素为起点，满足才进行下一步操作 if(!num_set.count(num-1)) //满足条件后，存储当前节点的信息 int currentNum=num; int currentSum=1; //寻找该节点的最长连续序列 while(num_set.count(currentNum+1)) currentNum=currentNum+1; currentSum+=1; //最后与longSum比较，更新历史最长连续序列 longSum=max(currentSum,longSum); return longSum; ; 编写代码产生的问题：上述遍历用nums和num_set有什么区别，在leetcode一个能过一个不能过 遍历 num_set： 每个元素最多只被作为“起点”处理一次。 例如：对于序列 [100, 101, 102, 103]，只有 100 会进入 while 循环处理。 其他如 101、102 在 if (!num_set.count(num - 1)) 时会被跳过（因为 100 已经处理了它们）。 所以是 O(n) 时间复杂度。 遍历 nums： nums 可能包含重复值，也可能无序。 比如你在 nums 中遇到 102，它不是起点，但你仍会试图查找连续数字，造成重复计算。 重复调用 count()，浪费性能，导致 超时 或 错误结果（重复统计）。 时间复杂度：设输入数组 nums 的长度为 n。 unordered_set 插入 n 个元素：**O(n)**（平均时间，插入是 O(1)）。 第二个循环遍历 num_set 中的每个元素，每个连续序列只处理一次。 if (!num_set.count(num - 1)) 这个判断确保每个序列的起点只会被处理一次。 例如序列 [100, 101, 102, 103] 只会从 100 开始处理一次，不会在遍历到 101 时重复处理。 因此： **总时间复杂度：O(n)**（哈希表操作均为 O(1) 平均时间） 空间复杂度： 使用了一个 unordered_set 存储 n 个整数，占用 O(n) 的空间。 其他变量如 currentNum, currentSum 等为常数空间。 因此： 总空间复杂度：O(n) 移动零题目描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0] 示例 2: 输入: nums = [0]输出: [0] 思路：具体思路：​ 我们可以采用双指针的方法，先left,right同时指向起始点，right到最后位置结束。当right找到非零节点，与left进行值交换，left只有交换结束才left++;这样最后非零节点都在前面，0都在末尾。 代码块：class Solution public: void moveZeroes(vectorint nums) int n=nums.size(),left=0,right=0; while(rightn) if(nums[right]) swap(nums[left],nums[right]); left++; right++; ; 时间复杂度： right 从 0 遍历到 n-1，每个元素访问一次。 最多发生 n 次 swap 操作（每个非零元素最多被交换一次）。 所以： 总时间复杂度：O(n) 空间复杂度： 只使用了常量级别的辅助变量 left 和 right。 所有操作都在原数组上进行，原地修改，没有开辟额外数组。 总空间复杂度：O(1) 盛最多水的容器题目描述：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 示例 1： 输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2： 输入：height = [1,1]输出：1 思路：具体思路：​ 我们采用双指针的方式求解。这个题目的是求解柱子之间的最大面积。我们可以采用将两个指针放在两端，如果左边的柱子高度大于或等于右边的柱子高度，我们先算出容器对应的面积（高度以低柱子为准）。算出后更新历史最大面积。执行完，将右边的柱子向左移动。同时，还有一种情况，左边的柱子高度小于右边的柱子高度，先算出容器对应的面积（高度以低柱子为准）。算出后更新历史最大面积。执行完，将左边的柱子向右移动。直到当前的左柱子和右柱子重合。 代码块：class Solution public: int maxArea(vectorint height) int ans=0; //采用双指针的方式求解 int left=0; int right=height.size()-1; while(leftright) if(height[left]=height[right]) ans=max(ans,(right-left)*height[right]); right--; else ans=max(ans,(right-left)*height[left]); left++; return ans; ; 时间复杂度：时间复杂度：O(n) 解释：使用的是双指针方法，从两端向中间遍历整个数组，每一次迭代都会移动左指针或右指针之一，因此总共最多移动 n-1 次。 所以时间复杂度是 **线性的 O(n)**，其中 n 是 height 数组的长度。 空间复杂度：空间复杂度：O(1) 解释：只使用了常数个额外变量（如 ans, left, right, h, w），不依赖于输入数据的大小。 因此空间复杂度是 **常数级 O(1)**。 三数之和题目描述：给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 示例 2： 输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 示例 3： 输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 思路：具体思路：​ 这题的目标是在在整数数组中，找到所有三个数满足和为零，最后结果不可以重复。这个题我们可以先定下一个值，剩下两个值用双指针法遍历，找到符合结果的。还有一些细节，还要考虑不能重复的问题，对于这个问题，我们可以先排序（升序）这个数组，从小到大定第一个值，首先如果这第一个值大于0，这个可以结束了，这个数组就不会存在符合条件的三元组。当然如果当前元素与上一个元素相同，也跳过，这样执行，首先我想的是定第一个元素，当当前元素和下一个元素相同直接跳过，后来发现，[-1,-1,2]这种情况没有考虑。当然那你为甚么还是要写当前元素与上一个元素相同，也跳过，我完全可以不管嘛，那不行，我的思路是当第一个元素是-1时，这一次直接找出所有符合第一个元素是-1的情况，要不然会十分混乱，所以我会说如果当前元素与上一个元素相同，也跳过。因为上一个元素已经找完了第一个元素为-1的三元组了，当避免找完-1还会再出现，我们用了排序。这样第一个元素的逻辑就结束了，接下来找剩下两个，用双指针，左指针指向当前元素的下一个元素，右指针指向末尾元素。我们是要找到所有符合情况，当三元组的值大于0，将右指针左移。当三元组的值小于0，将左指针右移。当三元组的值等于0，将三元组的值加入结果集。接下来再判断找到的左元素是否与后面的元素重复（因为是排序的，相同的元素就在身边）。跳过这些元素，找到的右元素是否与后面的元素重复（因为是排序的，相同的元素就在身边）。跳过这些元素。只要左指针和右指针没有重合，就一直找，找完符合情况的三元组。 代码块：class Solution public: vectorvectorint threeSum(vectorint nums) vectorvectorint ans; //先升序排序 sort(nums.begin(),nums.end()); //遍历排序后的数组 for(int i=0;inums.size();i++) //先定第一个元素 //第一个元素大于0,因为是升序排序，后面都大于零，那没有满足条件的结果了 if(nums[i]0) break; //如果上一个元素相同，跳过当前，用下一个 if(i0 nums[i]==nums[i-1]) continue; //采用双指针定剩下两个 int left=i+1; int right=nums.size()-1; while(leftright) if(nums[i]+nums[left]+nums[right]0) right--; else if(nums[i]+nums[left]+nums[right]0) left++; else if(nums[i]+nums[left]+nums[right]==0) ans.push_back(nums[i],nums[left],nums[right]); //下面判断是否有相同的，避免重复 while(leftright nums[left]==nums[left+1])left++; while(leftright nums[right]==nums[right-1]) right--; left++; right--; return ans; ; 时间复杂度： 时间复杂度：O(n^2) 详细分析： 外层循环遍历数组中的每个数作为固定值 nums[i]，这部分是 O(n)。 内层使用双指针 left 和 right 来查找另外两个数，最坏情况下每次都需要遍历一次剩余数组，即 O(n)。 所以总的时间复杂度是： O(n^2) 去重操作的影响： 去重操作使用的是 while(left right nums[left] == nums[left + 1]) 这类逻辑，在最坏情况下最多也只是跳过相同元素，不改变主导复杂度。 空间复杂度：空间复杂度：O(1)（不计输出） 解释： 如果不考虑返回结果 ans 所占用的空间（即题目允许将返回值空间复杂度忽略），则使用的额外空间为： 排序使用的可能是原地排序（如 std::sort），**空间复杂度为常数级 O(1)**。 其他仅使用了一些指针和变量，都是常数级空间。 如果 将返回结果的空间也算入，最坏情况是 O(k)，其中 k 是满足条件的三元组个数。 接雨水题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2： 输入：height = [4,2,0,3,2,5]输出：9 思路：具体思路：这里采用的是动态规划解法，还有其他方法。动态规划解法，需要构造两个数组分别储存各个节点的左边最大高度和右边最大高度，便于计算当前节点所积水高度。问题在于左边和右边最大高度该如何获取。最左边的左边最大高度就是它自身，最右边的右边最大高度就是它自身，以这两个边界条件，左边最大高度就是当前节点的左边节点的左边最大高度和当前节点的高度的最大值，右边最大高度也是一样。求解出放入之前的两个数组中。已知这两个数组，可以遍历这两个数组，把当前节点的积水量算出，再累加一起，就是所求的雨水量。 代码块class Solution public: int trap(vectorint height) //这题采用动态规划 int n=height.size(); if(n==0) return 0; vectorint leftMax(n); vectorint rightMax(n); leftMax[0]=height[0]; rightMax[n-1]=height[n-1]; for(int i=1;in;i++) leftMax[i]=max(leftMax[i-1],height[i]); for(int i=n-2;i=0;i--) rightMax[i]=max(rightMax[i+1],height[i]); int ans=0; for(int i=0;in;i++) ans+=min(leftMax[i],rightMax[i])-height[i]; return ans; ; 时间复杂度：时间复杂度：O(n) 遍历了三次数组： 构造 leftMax：O(n) 构造 rightMax：O(n) 遍历一次计算总雨水量：O(n) 所以总时间复杂度是： O(n) 空间复杂度：空间复杂度：O(n) 使用了两个辅助数组： leftMax：大小为 n rightMax：大小为 n 所以额外空间是 2n，即 O(n) 空间复杂度。 无重复字符的最长子串题目描述：给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 示例 1: 输入: s = abcabcbb输出: 3 解释: 因为无重复字符的最长子串是 abc，所以其长度为 3。 示例 2: 输入: s = bbbbb输出: 1解释: 因为无重复字符的最长子串是 b，所以其长度为 1。 示例 3: 输入: s = pwwkew输出: 3解释: 因为无重复字符的最长子串是 wke，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，pwke 是一个子序列，不是子串。 思路：具体思路：我们使用滑动窗口和哈希表实现这个题目。哈希表存储枚举值的下标，初始值为-1，j值在没有重合的情况下，会在每次循环+1，但是如果遇到重合，j值会跑到对应的下标位置之后的位置（下标位置存储在哈希表中）。只要有重合就调整窗口。 代码块：class Solution public: int lengthOfLongestSubstring(string s) //滑动窗口和哈希表 vectorint pos(128,-1); int ans=0; //j为滑动窗口的起始节点 for(int i=0,j=0;is.size();i++) j=max(j,pos[s[i]]+1); ans=max(ans,i-j+1); pos[s[i]]=i; return ans; ; 时间复杂度：时间复杂度：O(n) 其中 n 是字符串 s 的长度。 每个字符最多访问两次（一次作为右指针扩展窗口，一次作为左指针缩小窗口）。 所以整体是线性时间复杂度 O(n)。 空间复杂度：空间复杂度：O(1) 使用了一个 pos 数组来记录 ASCII 字符上次出现的位置，长度是固定的 128（ASCII 字符集）。 即使改成 256（扩展 ASCII）或 100,000（Unicode 范围），只要是定长的字符集，空间复杂度都是 O(1) 常数级。 如果字符集不固定，比如用 unordered_mapchar, int，那空间复杂度是 O(k)，其中 k 是字符集大小。 找到字符串中所有字母异位词题目描述：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 示例 1: 输入: s = cbaebabacd, p = abc输出: [0,6]解释:起始索引等于 0 的子串是 cba, 它是 abc 的异位词。起始索引等于 6 的子串是 bac, 它是 abc 的异位词。 示例 2: 输入: s = abab, p = ab输出: [0,1,2]解释:起始索引等于 0 的子串是 ab, 它是 ab 的异位词。起始索引等于 1 的子串是 ba, 它是 ab 的异位词。起始索引等于 2 的子串是 ab, 它是 ab 的异位词。 思路：具体思路：这道题的整体思路是让我找到对应字符串的所有异位词在一个陌生的字符串里。这里要解决两个问题，首先是异位词问题，找异位词可以通过枚举法，总共26个字母，我们通过数组存储使用字母的个数，最后对比，如果数组相等，就说明是异位词。还有一个问题：在陌生字符串找到所有的异位词，并且返回索引，找异位词是一个范围问题，所以我要使用流动窗口，大小就是对应字符串的大小。在陌生字符串扫描。最后返回结果。 代码块：class Solution public: vectorint findAnagrams(string s, string p) //首先记录两字符串的长度 int sLen=s.size(),pLen=p.size(); //如果字符串s的长度还不比p字符串长 if(sLenpLen) return vectorint(); //记录结果 vectorint ans; //记录s字符串和p字符串的字母对应的个数，枚举法 vectorint sletter(26); vectorint pletter(26); //先试试索引为0的 for(int i=0;ipLen;i++) ++sletter[s[i]-a]; ++pletter[p[i]-a]; //如果符合，说明索引为0符合情况 if(sletter==pletter) ans.emplace_back(0); //之后按照索引为1往后遍历，采取流动窗口,把前一次的流动窗口的第一个去掉，再往后补一个，形成新的流动窗口. //注意这里是按流动窗口为整体，上面的循环是为了形成流动窗口。 for(int i=0;isLen-pLen;i++) --sletter[s[i]-a]; ++sletter[s[i+pLen]-a]; if(sletter==pletter) ans.emplace_back(i+1); return ans; ; 时间复杂度： 初始化部分：O(p) 滑动窗口：O(n) 由于通常 p 比 n 小，所以总时间复杂度是：O(n) 空间复杂度： 使用了两个长度为 26 的数组：sletter, pletter； 还使用了一个结果数组 ans，最坏情况下长度也是 O(n)； 因此： 空间复杂度是 O(1) + O(k)，其中 k 是结果中异位词的数量，通常最多为 O(n)。 和为 K 的子数组题目描述：给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。 子数组是数组中元素的连续非空序列。 示例 1： 输入：nums = [1,1,1], k = 2输出：2 示例 2： 输入：nums = [1,2,3], k = 3输出：2 思路：具体思路：这里采取两个方法，第一种方法就是枚举法，暴力轮询。（为什莫要两种，因为我第一种leetcode超时了）。 方法二：首先通过前缀和这个点，定义 pre[i] 为 [0..i] 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：pre[i]pre[i−1]+nums[i]那么[j..i] 这个子数组和为 k 这个条件我们可以转化为pre[i]−pre[j−1]k简单移项可得符合条件的下标 j 需要满足pre[j−1]pre[i]−k所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。建立以上条件，我们的问题就简化为寻找有多少个符合条件的pre[j]即可，我们建立哈希表，键是前缀和，值是前缀和重复的个数。在遍历的过程中，pre存储当前的前缀和，先不放进哈希表中，先在哈希表中查找是否有键pre-k,有的话，就取出对应的值加到count里，不管找没找到，都要将当前的前缀和存到哈希表中。这代码的逻辑是基于前缀和得出的只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。 代码块：方法一：枚举法 class Solution public: int subarraySum(vectorint nums, int k) //这题我们采用枚举法 int count=0;//返回的结果值 int n=nums.size(); for(int start=0;startn;++start) int sum=0; for(int end=start;endn;++end) sum+=nums[end]; if(sum==k) count++; return count; ; 方法二：前缀和+哈希表优化 class Solution public: int subarraySum(vectorint nums, int k) //前缀和+哈希表优化 unordered_mapint,int mp; mp[0]=1;//初始前缀和的个数为1 int count=0,pre=0;//count是返回结果的，pre是前缀和 for(auto temp:nums) pre+=temp; if(mp.find(pre-k)!=mp.end()) count+=mp[pre-k]; mp[pre]++; return count; ; 时间复杂度：方法一： 时间复杂度：O(n²) 方法二： O(n) 时间 空间复杂度：方法一： 空间复杂度：O(1) 方法二： **O(n)**（最坏情况下所有前缀和都不相同，哈希表大小为 n）","tags":["data structure"],"categories":["数据结构100题"]},{"title":"c++实现集群聊天服务器","path":"/2025/06/02/c-实现集群聊天服务器/","content":"json学习#include json.hppusing json=nlohmann::json; 使用json,要包含json的头文件 ，方便使用可以重命名nlohmann::json为json。 //json序列化示例1std::string func1() json js; js[msg_type]=2; js[from]=zhang san; js[to] = li si; js[msg]=hello,what are you doing now; std::string sendBuf=js.dump(); std::coutsendBuf.c_str()std::endl; return sendBuf; js使用很像键值对。js.dump()是 nlohmann::json库中用于将 JSON 对象序列化（转为字符串）的方法，它会把一个 json类型的变量转换成 JSON 格式的字符串。 std::string recvBuf= func1(); //数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问） json jsbuf=json::parse(recvBuf); std::coutjsbuf[msg_type]std::endl; std::coutjsbuf[from]std::endl; std::coutjsbuf[to]std::endl; std::coutjsbuf[msg]std::endl; 这是main函数中执行。json::parse() 是 nlohmann::json 库中用来将 JSON 字符串 → JSON 对象 的函数，也就是实现反序列化。 转化为json对象后使用对应的键可以把对应的值取出来。结果： from:zhang san,msg:hello,what are you doing now,msg_type:2,to:li sizhang sanli sihello,what are you doing now //json序列化示例2std::string func2() json js; //添加数组 js[id]=1,2,3,4,5; //添加key-value js[name]=zhang san; //添加对象 js[msg][zhang san]= hello world; js[msg][liu shuo] =hello china; //上面等同下面这句一次性添加数组对象 js[msg]=zhang san,hello world,liu shuo,hello china; std::coutjsstd::endl; return js.dump(); json还可以放数组，还可以嵌套json语句。 std::string recvBuf= func2(); //数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问） json jsbuf=json::parse(recvBuf); std::coutjsbuf[id]std::endl; auto arr=jsbuf[id]; std::coutarr[2]std::endl; auto msgjs=jsbuf[msg]; std::coutmsgjs[zhang san]std::endl; std::coutmsgjs[liu shuo]std::endl; “id”存储的是一个数组，取出来还可以作为数组使用。“msg”存储的值还可以是json语句，并且可以进入再取里面的值。 结果： id:[1,2,3,4,5],msg:liu shuo:hello china,zhang san:hello world,name:zhang san[1,2,3,4,5]hello worldhello china //json序列化示例3std::string func3() json js; //直接序列化一个vector容器 std::vectorint vec; vec.push_back(1); vec.push_back(2); vec.push_back(5); js[list]=vec; //直接序列化一个map容器 std::mapint,std::string m; m.insert(1,黄山); m.insert(2,华山); m.insert(3,泰山); js[path] =m; std::string sendBuf =js.dump();//json数据对象-序列化json字符串 std::coutsendBufstd::endl; return sendBuf; 还可以序列化容器。 std::string recvBuf= func3(); //数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问） json jsbuf=json::parse(recvBuf); std::vectorint vec =jsbuf[list];//js对象里面的数组类型，直接放入vector容器当中 for(int v:vec) std::coutv ; std::coutstd::endl; std::mapint,std::string mymap=jsbuf[path]; for(auto p:mymap) std::coutp.first p.secondstd::endl; std::coutstd::endl; return 0; 结果： list:[1,2,5],path:[[1,黄山],[2,华山],[3,泰山]]1 2 5 1 黄山2 华山3 泰山 muduo网络库学习muduo 是一个现代 C++ 的非阻塞 IO 网络库，采用 Reactor 模式 + 多线程 + epoll + 定时器 + 高效缓冲区 + 智能指针设计，在性能和工程性方面都表现非常优秀。 /*muduo网络库给用户提供了两个主要的类TcpServer :用于编写服务器程序的TcpClient :用于编写客户端程序的epoll+线程池好处：能够把网络I/O的代码和业务代码区分开了业务代码 :用户的连接和断开 用户的可读写事件*/#includemuduo/net/TcpServer.h#includemuduo/net/EventLoop.h#include functional#include iostream#include stringusing namespace std;using namespace muduo;using namespace muduo::net;using namespace placeholders;/*基于muduo网络库开发服务器程序1.组合TcpServer对象2.创建EventLoop事件循环对象的指针3.明确TcpServer构造函数需要什么参数，输出ChatServer的构造函数4.在当前服务器类的构造函数当中，注册处理连接的回调函数和处理读写事件的回调函数5.设置合适的服务端线程数量，muduo库会自己分配I/O线程和worker线程*/class ChatServerpublic: ChatServer(EventLoop* loop,//事件循环 const InetAddress listenAddr,//ip+port const string nameArg)//服务器的名字 :_server(loop,listenAddr,nameArg),_loop(loop) //给服务器注册用户连接的创建和断开回调 _server.setConnectionCallback(std::bind(ChatServer::onConnection,this,_1)); //给服务器注册用户读写事件回调 _server.setMessageCallback(std::bind(ChatServer::onMessage,this,_1,_2,_3)); //设置服务器端的线程数量 1个I/o线程 3个worker线程 _server.setThreadNum(4); //开启事件循环 void start() _server.start(); private: //专门处理用户的连接创建和断开 void onConnection(const TcpConnectionPtrconn) if(conn-connected()) coutconn-peerAddress().toIpPort()- conn-localAddress().toIpPort()state:onlineendl; else//对方关闭连接或断开 coutconn-peerAddress().toIpPort()- conn-localAddress().toIpPort()state:offlineendl; conn-shutdown(); //close(fd)//关闭连接 // _loop-quit();通常用于程序结束或手动控制关闭 Muduo //loop-quit() 使loop.loop()不再阻塞。 //专门处理用户的读写事件 void onMessage(const TcpConnectionPtrconn,//连接 Buffer* buffer,//缓冲区 Timestamp time)//接受数据的时间信息 //是一个指向 muduo::net::Buffer 对象的指针，用于暂存客户端发送的数据。 //Muduo 采用 非阻塞、事件驱动的方式，当客户端发送数据时，数据先被读入 Buffer 中，之后由用户注册的回调函数（例如 onMessage）来处理。 //retrieveAllAsString()把缓冲区中的所有可读数据提取为一个 std::string，然后清空缓冲区。 string buf=buffer-retrieveAllAsString(); coutrecv data: buftime:time.toString()endl; conn-send(buf);//原封不动发回去 muduo::net::TcpServer _server; muduo::net::EventLoop *_loop;;int main() EventLoop loop;//epoll InetAddress addr(127.0.0.1,6000); ChatServer server(loop,addr,ChatServer); server.start();//listenfd epoll_ctl-epoll loop.loop(); //epoll wait以阻塞方式等待新用户连接，已连接用户的读写事件等 return 0; 先将bind函数讲清楚， 基本格式 std::bind(类名::成员函数, 对象指针, 占位符参数...) 所以： std::bind(ChatServer::onConnection, this, _1) 意思是： 把当前对象（this）的 onConnection 成员函数绑定起来，形成一个可调用对象，并接受一个参数 _1。 分解解释 组件 说明 ChatServer::onConnection 指向 ChatServer 类的成员函数 onConnection 的指针 this 当前对象的指针，告诉 bind 这个函数是哪个对象的方法（即调用 this-onConnection） _1 占位符，代表回调传入的第一个参数，实际调用时会被替换 最终生成一个 std::functionvoid(const TcpConnectionPtr) 类型的函数对象。 CMakeList.txt学习主CMakeList.txt cmake_minimum_required(VERSION 3.10)project(chat)#配置编译选项set(CMAKE_CXX_FLAGS $CMAKE_CXX_FLAGS -g)#配置最终的可执行文件输出的路径set(EXECUTABLE_OUTPUT_PATH $PROJECT_SOURCE_DIR/bin)#配置头文件搜索路径include_directories($PROJECT_SOURCE_DIR/include)include_directories($PROJECT_SOURCE_DIR/include/server)#加载子目录add_subdirectory(src) src文件夹下的CMakeList.txt add_subdirectory(server) src文件夹下的server文件夹下的CMakeList.txt #定义了SRC_LIST变量，包含了当前目录下的所有源文件aux_source_directory(. SRC_LIST) #获取当前目录下所有源文件#指定生成可执行文件add_executable(ChatServer $SRC_LIST)#指定可执行文件需要链接的库target_link_libraries(ChatServer muduo_net muduo_base pthread) #链接muduo库和pthread库 项目常见的cmake指令使用步骤mkdir buildcd buildcmake ..make # 如果你使用的是 Unix/Linux/macOS，或者是 MinGW 解释： mkdir build：创建构建目录（推荐 out-of-source build） cd build：进入构建目录 cmake ..：执行 CMake，读取上一级目录的 CMakeLists.txt，生成构建系统（默认是 Makefile） make：使用生成的 Makefile 编译项目 集群聊天服务器项目目录 bin文件夹编译完成后的 .exe（Windows）或无扩展的可执行文件。 build文件夹通常用于存放 构建过程中产生的所有中间文件，它是整个编译流程的“临时工作区”。 include文件夹存放头文件（Header Files），src文件夹是 C++ 项目中最常见也最核心的目录之一，用于存放 源代码实现文件（source files），主要是 .cpp 文件（也包括 .c, .cc, .cxx 等）。 test文件夹在 C++ 项目中用于存放测试代码，主要用于验证项目功能是否正确，确保每个模块在修改后仍然可以正常工作。 thirdparty文件夹在 C++ 项目中用于存放第三方依赖库的源码或接口文件。在这里存储了json.hpp文件。 CMakeLists.txt文件存放和使用CMakeLists.txt文件放在了主目录，src文件夹里，srcserver文件夹里，接下来分别说明对应文件夹中CMakeLists.txt的作用。 主目录文件夹 cmake_minimum_required(VERSION 3.10)project(chat)#配置编译选项set(CMAKE_CXX_FLAGS $CMAKE_CXX_FLAGS -g)#配置最终的可执行文件输出的路径set(EXECUTABLE_OUTPUT_PATH $PROJECT_SOURCE_DIR/bin)#配置头文件搜索路径include_directories($PROJECT_SOURCE_DIR/include)include_directories($PROJECT_SOURCE_DIR/include/server)include_directories($PROJECT_SOURCE_DIR/include/server/db)include_directories($PROJECT_SOURCE_DIR/thirdparty)#加载子目录add_subdirectory(src) 主目录 CMakeLists.txt 的作用概括： 设置项目基本信息：指定 CMake 最低版本和项目名称。 配置全局编译选项：例如添加调试信息（-g）以便调试。 设置可执行文件输出路径：统一将程序输出到 bin/ 目录。 配置头文件搜索路径：包括项目头文件目录和第三方库目录，便于代码引用。 组织子目录构建：通过 add_subdirectory(src) 加载 src 子目录，交由其继续组织源码编译。 src文件夹 add_subdirectory(server) add_subdirectory(server) 把 server 子目录纳入构建流程，交由其内部的 CMakeLists.txt 具体定义编译规则，是模块化项目管理的关键步骤。 srcserver文件夹 #定义了SRC_LIST变量，包含了当前目录下的所有源文件aux_source_directory(. SRC_LIST) #获取当前目录下所有源文件aux_source_directory(./db DB_LIST)#获取db文件下的所有源文件#指定生成可执行文件add_executable(ChatServer $SRC_LIST $DB_LIST)#指定可执行文件需要链接的库target_link_libraries(ChatServer muduo_net muduo_base mysqlclient pthread) #链接muduo库和pthread库 src/server/CMakeLists.txt 的作用概括： 收集源文件：自动获取当前目录和 db 子目录下的所有 .cpp 文件。 生成可执行程序：将源文件编译为 ChatServer 可执行文件。 链接依赖库：链接 Muduo 网络库、MySQL 客户端库和 pthread 线程库。 thirdparty文件夹（第三方库）json.hpp聊天服务器项目中，json.hpp 负责处理客户端与服务端之间的 JSON 数据格式，承担消息的 解析、构建与传输格式化，是通信协议的关键组件。 includeserverchatserver.hpp 聊天服务器的主类#ifndef CHATSERVER_H#define CHATSERVER_H#include muduo/net/TcpServer.h#include muduo/net/EventLoop.h#include functionalusing namespace std::placeholders;using namespace std;using namespace muduo;using namespace muduo::net;//聊天服务器的主类class ChatServerpublic: //初始化聊天服务器队对象 ChatServer(EventLoop* loop, const InetAddress listenAddr, const string nameArg); //启动服务 void start();private: //上报连接相关信息的回调函数 void onConnection(const TcpConnectionPtr conn); //上报读写事件的回调函数 void onMessage(const TcpConnectionPtr conn, Buffer* buffer, Timestamp time); TcpServer _server;//组合的muduo库，实现服务器功能的类对象 EventLoop *_loop;//指向事件循环的指针;#endif ChatServer.h 作用及结构概括 类功能 定义了聊天服务器的主类 ChatServer，负责网络服务的初始化、启动和事件处理。 成员变量 _server：muduo::net::TcpServer 对象，负责网络连接管理和服务端监听。 _loop：muduo::net::EventLoop 指针，负责事件循环和调度。 核心接口 构造函数 ChatServer(EventLoop*, const InetAddress, const string)：初始化服务器监听地址、名称和事件循环。 start()：启动服务器监听，进入事件循环。 回调函数（私有） onConnection()：处理客户端连接和断开事件。 onMessage()：处理客户端消息接收事件，进行消息读写。 ChatServer 类是整个聊天项目的网络核心，利用 Muduo 库提供的 TCP 服务器功能，封装了网络事件的注册与处理，负责服务器端的网络通信逻辑。 srcserverchatserver.cpp#include chatserver.hpp#include string#include chatservice.hpp#include functional#include json.hppusing json =nlohmann::json;//初始化聊天服务器队对象ChatServer::ChatServer(EventLoop* loop, const InetAddress listenAddr, const string nameArg) : _server(loop, listenAddr, nameArg), _loop(loop) //注册连接回调 _server.setConnectionCallback( std::bind(ChatServer::onConnection, this, std::placeholders::_1)); //注册消息回调 _server.setMessageCallback( std::bind(ChatServer::onMessage, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)); //设置线程数量 _server.setThreadNum(4);//启动服务void ChatServer::start() _server.start();//上报连接相关信息的回调函数void ChatServer::onConnection(const TcpConnectionPtr conn) //客户端断开连接 if(!conn-connected()) conn-shutdown(); //上报读写事件的回调函数void ChatServer::onMessage(const TcpConnectionPtr conn, Buffer* buffer, Timestamp time) string buf=buffer-retrieveAllAsString(); //数据的反序列化 json js=json::parse(buf); //达到的目的:完全解耦网络模块的代码和业务模块的代码 //通过js[msgid] 获取=》业务handler=conn js time auto msgHandler=ChatService::instance()-getHandler(js[msgid].getint()); //回调消息绑定好的事件处理器，来执行相应的业务处理 msgHandler(conn,js,time); ChatServer.cpp 作用与关键点概括 构造函数初始化 初始化 Muduo 的 TCP 服务器对象 _server 和事件循环 _loop。 注册回调函数： onConnection 处理连接建立与断开； onMessage 处理客户端消息。 设置线程数为4，支持多线程处理网络事件。 启动服务 start() 调用 Muduo 的 _server.start() 启动监听和事件循环。 连接回调 onConnection 判断客户端是否断开连接，断开时调用 conn-shutdown() 关闭连接。 消息回调 onMessage 将网络缓冲区中的数据读取为字符串。 使用 json.hpp 将字符串反序列化成 JSON 对象。 通过消息中的 msgid 字段，调用业务层 ChatService 获取对应的消息处理函数（回调）。 执行该消息处理函数，完成具体的业务逻辑处理。 作用总结 这段代码实现了聊天服务器的核心网络处理逻辑，做到： 网络层与业务层解耦：网络部分只负责收发和解析数据，业务处理由 ChatService 中注册的处理器完成。 灵活消息分发：根据 JSON 中的 msgid 动态调用对应业务处理函数，实现消息驱动机制。 高效异步处理：基于 Muduo 多线程事件循环模型，支持高并发网络请求。 includeserverchatservice.hpp 聊天服务器业务类#ifndef CHATSERVICE_H#define CHATSERVICE_H#include muduo/net/TcpConnection.h#include unordered_map#include functional#include json.hppusing namespace std;using namespace muduo;using namespace muduo::net;using json =nlohmann::json;//表示处理消息的事件回调方法类型using MsgHandler = std::functionvoid(const TcpConnectionPtr conn,json js,Timestamp);//聊天服务器业务类class ChatServicepublic: //获取单例对象的接口函数 static ChatService * instance(); //处理登录业务 void login(const TcpConnectionPtr conn,json js,Timestamp); //处理注册业务 void reg(const TcpConnectionPtr conn,json js,Timestamp); //获取消息对应的处理器 MsgHandler getHandler(int msgid);private: ChatService(); //存储消息id和其对应的业务处理方法 unordered_mapint,MsgHandler _msgHandlerMap;;#endif ChatService.h 作用与结构概括 类功能 负责处理聊天服务器的核心业务逻辑，如登录、注册等。 管理消息 ID 与对应的处理函数的映射，实现消息的动态分发。 核心类型 MsgHandler：消息处理函数类型，参数包括 TCP 连接指针、JSON 消息对象和时间戳。 接口函数 static ChatService* instance()：单例模式，获取业务服务唯一实例。 void login(...)：处理登录业务逻辑。 void reg(...)：处理注册业务逻辑。 MsgHandler getHandler(int msgid)：根据消息 ID 获取对应的消息处理函数。 成员变量 _msgHandlerMap：存储消息 ID 与处理函数的映射，支持根据消息类型快速调用相应业务处理器。 srcserverchatservice.cpp#include chatservice.hpp#include public.hpp#include string#include muduo/base/Logging.husing namespace muduo;using namespace std;//获取单例对象的接口函数//在cpp文件就不需要写static了ChatService * ChatService::instance() static ChatService service; return service;//注册消息以及对应的Handler回调操作 ChatService::ChatService() //注册业务 _msgHandlerMap.insert(LOGIN_MSG,std::bind(ChatService::login,this,_1,_2,_3)); _msgHandlerMap.insert(REG_MSG,std::bind(ChatService::reg,this,_1,_2,_3)); //获取消息对应的处理器 MsgHandler ChatService::getHandler(int msgid) //记录错误日志，msgid没有对应的事件处理回调 auto it =_msgHandlerMap.find(msgid); if(it ==_msgHandlerMap.end()) //返回一个默认的处理器，空操作 return [=](const TcpConnectionPtr conn,json js,Timestamp) LOG_ERRORmsgid: msgid can not find handler!; ; else return _msgHandlerMap[msgid]; //处理登录业务void ChatService::login(const TcpConnectionPtr conn,json js,Timestamp) LOG_INFO do login service!!!!;//处理注册业务void ChatService::reg(const TcpConnectionPtr conn,json js,Timestamp) LOG_INFOdo reg service!!!; ChatService.cpp 作用和关键点 单例模式实现 instance() 函数内部静态变量实现线程安全的单例模式，保证 ChatService 只有一个实例。 构造函数注册消息处理函数 在构造函数中通过 _msgHandlerMap.insert 将消息 ID（LOGIN_MSG、REG_MSG）绑定到成员函数 login 和 reg 的回调。 使用 std::bind 绑定成员函数和 this 指针，方便后续调用。 动态消息处理函数获取 getHandler(int msgid) 根据传入的消息 ID 返回对应的处理函数。 如果消息 ID 未注册，返回一个默认空操作的 lambda，同时写错误日志，保证系统健壮性。 业务处理函数示例 login() 和 reg() 目前仅打印日志，代表登录和注册的业务处理接口，后续可以扩展具体业务逻辑。 includepublic.hpp#ifndef PUBLIC_H#define PUBLIC_H/*server和client的公共文件*/enum EnMsgType LOGIN_MSG = 1,//登录消息 REG_MSG//注册消息;#endif public.h 作用简述 共享消息类型定义 定义了枚举类型 EnMsgType，用于区分不同的消息类型。 目前包含两种消息： LOGIN_MSG = 1：登录消息 REG_MSG：注册消息 作用 服务端和客户端都包含这个头文件，保证双方对消息类型有统一的理解和对应关系，方便通信协议的设计与实现。 srcservermain.cpp#include chatserver.hpp#include iostreamusing namespace std;int main() EventLoop loop; InetAddress addr(127.0.0.1,6000); ChatServer server(loop, addr, ChatServer); server.start(); //开启事件循环 loop.loop(); return 0; 启动聊天服务器： 创建事件循环和服务器监听地址，初始化 ChatServer 对象，启动服务器后进入事件循环，开始接受和处理客户端连接与消息。 includeserverdbdb.h 数据库操作类#ifndef DB_H#define DB_H#includemysql/mysql.h#includestringusing namespace std;// 数据库操作类class MySQL public: // 初始化数据库连接MySQL();// 释放数据库连接资源~MySQL();// 连接数据库bool connect();// 更新操作bool update(string sql);// 查询操作MYSQL_RES* query(string sql);//获取连接MYSQL * getConnection();private: MYSQL *_conn;;#endif MySQL 数据库操作类说明 类功能 封装对 MySQL 数据库的连接、查询和更新操作，方便上层业务调用。 主要成员函数 **构造函数 MySQL()**：初始化数据库连接相关资源。 **析构函数 ~MySQL()**：释放数据库连接资源。 **bool connect()**：连接数据库，返回连接是否成功。 **bool update(string sql)**：执行更新类 SQL 语句（如 INSERT、UPDATE、DELETE）。 **MYSQL_RES* query(string sql)**：执行查询类 SQL 语句，返回结果集指针。 **MYSQL* getConnection()**：获取底层 MySQL 连接对象，便于其他操作。 成员变量 **MYSQL *_conn**：指向 MySQL 连接句柄的指针。 srcserverdbdb.cpp#include db.h#include muduo/base/Logging.h// 数据库配置信息static string server = 127.0.0.1;static string user = root;static string password = 123456;static string dbname = chat;// 初始化数据库连接MySQL::MySQL() _conn = mysql_init(nullptr);// 释放数据库连接资源MySQL::~MySQL() if (_conn != nullptr) mysql_close(_conn);// 连接数据库bool MySQL::connect() MYSQL *p = mysql_real_connect(_conn, server.c_str(), user.c_str(),password.c_str(), dbname.c_str(), 3306, nullptr, 0); if (p != nullptr) //C和C++代码默认的编码字符是ASCII,如果不设置，从MySQL上拉下来的中文显示？ mysql_query(_conn, set names gbk); LOG_INFO connect mysql success!; else LOG_INFO connect mysql failed!; return p;// 更新操作bool MySQL::update(string sql) if (mysql_query(_conn, sql.c_str())) LOG_INFO __FILE__ : __LINE__ : sql 更新失败!; return false; return true;// 查询操作MYSQL_RES* MySQL::query(string sql) if (mysql_query(_conn, sql.c_str())) LOG_INFO __FILE__ : __LINE__ : sql 查询失败!; return nullptr; return mysql_use_result(_conn);//获取连接MYSQL * MySQL::getConnection() return _conn; MySQL 类实现功能简述 初始化连接 构造函数 MySQL() 调用 mysql_init 初始化 MySQL 连接对象。 释放连接资源 析构函数 ~MySQL() 关闭数据库连接，释放资源。 连接数据库 connect() 使用 mysql_real_connect 连接到数据库。 成功连接后设置字符集为 gbk，防止中文乱码。 通过日志打印连接成功或失败信息。 执行更新操作 update(string sql) 执行 SQL 更新语句（如 INSERT、UPDATE、DELETE）。 失败时打印错误日志，返回 false。 执行查询操作 query(string sql) 执行 SQL 查询语句。 返回查询结果指针，失败时返回 nullptr。 获取底层连接 getConnection() 返回当前的 MySQL 连接指针，方便其他数据库操作调用。 includeserveruser.hpp 数据库中user表对应的类#ifndef USER_H#define USER_H#includestringusing namespace std;//User表的ORM类class User public: User(int id=1,string name=,string pwd=,string state=offline) this-id=id; this-name=name; this-password=pwd; this-state=state; void setId(int id)this-id=id; void setName(string name)this-name=name; void setPwd(string pwd)this-password=pwd; void setState(string state)this-state=state; int getId()return this-id; string getName()return this-name; string getPwd()return this-password; string getState()return this-state; private: int id; string name; string password; string state;;#endif User 类作用概括： ORM 映射作用 该类是对数据库 User 表的一个对象化表示（Object-Relational Mapping）。 将数据库中的一条用户记录封装成一个 C++ 对象，便于在程序中操作。 属性封装 类中包含如下用户信息字段： id: 用户编号 name: 用户名 password: 用户密码 state: 用户状态（如 online offline） 基本接口功能 提供了以下功能函数： 构造函数（支持默认值） setXXX() 设置各字段值 getXXX() 获取各字段值 项目中的实际用途 基于 Muduo 的聊天服务器项目中： 用户数据从数据库中查询出来后，可以封装成 User 类对象； 在业务逻辑中传递用户信息时，使用 User 类便于管理； 与数据库交互模块（如 DAO 类）进行数据传递、封装与解封装； 便于将用户信息序列化为 JSON 数据发送到客户端。 includeserverusermodel.hpp user表的数据操作类#ifndef USERMODEL_H#define USERMODEL_H#include user.hpp//user表的数据操作类class UserModelpublic: //User表的增加方法 bool insert(User user);;#endif #ifndef/#define/#endif：防止头文件重复包含（include guard）； #include user.hpp：引入用户实体类定义； class UserModel：封装了对 User 表的数据库操作； bool insert(User user)：定义了插入用户的方法，返回是否成功。 srcserverusermodel.cpp#include usermodel.hpp#include db.h#include iostreamusing namespace std;//User表的增加方法bool UserModel::insert(User user) //1 组装sql语句 char sql[1024] =0; sprintf(sql,insert into User(name,password,state) values(%s,%s,%s), user.getName().c_str(),user.getPwd().c_str(),user.getState().c_str()); MySQL mysql; if(mysql.connect()) if(mysql.update(sql)) //获取插入成功的用户数据生成的主键id user.setId(mysql_insert_id(mysql.getConnection())); return true; return false; sprintf 组装 SQL； MySQL 是你自定义的数据库操作类，封装了 connect() 和 update()； 插入成功后，用 mysql_insert_id() 获取刚插入的记录主键 ID。 注册业务实现实现步骤public.hpp enum EnMsgType LOGIN_MSG = 1,//登录消息 REG_MSG,//注册消息 REG_MSG_ACK //注册响应消息; 再加上REG_MSG_ACK 注册响应消息，告诉客户端已经收到消息。 chatservice.hpp private: ChatService(); //存储消息id和其对应的业务处理方法 unordered_mapint,MsgHandler _msgHandlerMap; //数据操作类对象 UserModel _userModel; 在private中加入数据操作类对象UserModel _userModel，这个是自定义的对象在usermodel.hpp chatservice.cpp void ChatService::reg(const TcpConnectionPtr conn,json js,Timestamp) string name=js[name]; string pwd=js[password]; User user; user.setName(name); user.setPwd(pwd); bool state=_userModel.insert(user); if(state) //注册成功 json response; response[msgid]= REG_MSG_ACK; response[errno]=0; response[id]=user.getId(); conn-send(response.dump()); else //注册失败 json response; response[msgid]= REG_MSG_ACK; response[errno]=1; conn-send(response.dump()); 在ChatService类的reg函数，负责处理注册业务的。js中存储的是我们的消息以json存储的。这里面的字段例如msgid,name,password都是服务端和客户端约定好的。首先将消息中的name,和password拿出来赋值给User类对象user,注册业务，把对应的值存入数据库chat中的User表中。当数据操作类对象_userModel插入成功时，返回消息给客户端，msgid是客户端和服务端规定的消息类型，消息REG_MSG_ACK注册后的回应消息。返回的消息有消息类型和是否注册成功的标志errno(0表示成功，1表示失败)，注册失败id也不会产生，所以不用发了。最后使用json的dump()函数转换为字符串通过conn的send函数再发出去。 conn是TcpConnectionPtr类型TcpConnectionPtr 是 Muduo 网络库 中定义的一个智能指针类型，指向 TcpConnection 对象，通常用于表示一条活跃的 TCP 连接。 typedef std::shared_ptrTcpConnection TcpConnectionPtr; 它的生命周期由 Muduo 网络库自动管理。 常见成员函数（通过 TcpConnectionPtr 调用） conn-send(data)：发送数据到客户端 conn-shutdown()：关闭连接（半关闭） conn-connected()：是否仍保持连接 conn-peerAddress()：对端地址 conn-localAddress()：本地地址 conn-setContext() conn-getContext()：绑定上下文（可保存登录信息、用户ID等） 实现注册业务时出现的问题实现注册业务时，使用vscod远程连接Linux出现了连接数据库不上的问题。 20250604 13:22:35.282815Z 18893 INFO connect mysql failed!Access denied for user root@localhost - db.cpp:29 数据库拒绝了 root 用户从 localhost 的访问请求。 解决方案 1.使用Linux root用户登录mysql 2.修改root用户认证方式为密码登录 ALTER USER root@localhost IDENTIFIED WITH mysql_native_password BY 123456;FLUSH PRIVILEGES;EXIT; 第一句ALTER USER修改存在的用户 ‘root‘@’localhost’用户名为root,本地连接。IDENTIFIED WITH mysql_native_password 设置认证插件为 mysql_native_password（密码方式） 第二句MySQL 会将用户和权限信息缓存在内存中，这条命令强制它 重新加载所有权限表。ALTER USER 做的更改立即生效，而不必重启 MySQL 服务 第三句对用户权限和密码的修改完成了，退出命令行界面即可。 auth_socket 是 MySQL 默认的一种用户认证方式，主要用于本地登录，不使用密码，而是通过操作系统身份验证。MySQL 会验证： 你是否是当前 Linux 系统的 root 用户； 如果是，允许登录； 否则，拒绝访问，即使你输入了正确的密码也没用。 登录业务实现实现步骤：public.hpp enum EnMsgType LOGIN_MSG = 1,//登录消息 LOGIN_MSG_ACK,//登录响应消息 REG_MSG,//注册消息 REG_MSG_ACK //注册响应消息; 加入LOGIN_MSG_ACK,登录响应消息 usermodel.hpp //根据用户号码查询用户信息User query(int id);//更新用户的状态信息bool updateState(User user); 加入这两个函数，后面会在登录业务用到 usermodel.cpp 对应函数的具体实现 //根据用户号码查询用户信息User UserModel::query(int id) //1 组装sql语句 char sql[1024] =0; sprintf(sql,select * from User where id=%d,id); MySQL mysql; if(mysql.connect()) MYSQL_RES* res=mysql.query(sql); if(res!=nullptr)//查询成功 MYSQL_ROW row=mysql_fetch_row(res);//查一行 if(row!=nullptr) User user; user.setId(atoi(row[0]));//转换id为int，从数据库取出的都是字符串 user.setName(row[1]);//用户名 user.setPwd(row[2]);//密码 user.setState(row[3]);//状态，以上是根据查询出的结果集取得 mysql_free_result(res);//释放结果集资源 return user; return User();//更新用户的状态信息bool UserModel::updateState(User user) //1 组装sql语句 char sql[1024] =0; sprintf(sql,update User set state = %s where id = %d,user.getState().c_str(),user.getId()); MySQL mysql; if(mysql.connect()) if(mysql.update(sql)) return true; return false; chatservice.cpp 实现login函数 //处理登录业务 id pwdvoid ChatService::login(const TcpConnectionPtr conn,json js,Timestamp) int id=js[id]; string pwd=js[password]; User user=_userModel.query(id); if(user.getId()==iduser.getPwd()==pwd) if(user.getState()==online) //该用户已经登录，不允许重复登录 json response; response[msgid]= LOGIN_MSG_ACK; response[errno]=2; response[errmsg]=该账号已经登录，请输入新账号; conn-send(response.dump()); else //登录成功，更新用户状态信息 state offline=online user.setState(online); _userModel.updateState(user); json response; response[msgid]= LOGIN_MSG_ACK; response[errno]=0; response[id]=user.getId(); response[name]=user.getName(); conn-send(response.dump()); else //该用户不存在，登陆失败 json response; response[msgid]= LOGIN_MSG_ACK; response[errno]=1; response[errmsg]=用户名或者密码错误; conn-send(response.dump()); 记录用户的连接信息及线程安全性因为要实现用户与用户之间的消息往来，所以要实现记录上线用户的连接信息和下线的删除。 chatservice.hpp private: //存储在线用户的通信连接 注意线程安全 unordered_mapint,TcpConnectionPtr _userConnMap; 那么这个值在什么时候更新，首先在登录成功时，添加连接 chatservice.cpp login函数 _userConnMap.insert(id,conn);//unordered_map容器没有线程安全需要添加线程互斥操作 当然插入了还不够，多个用户连接服务器，_userConnMap这个是在多线程环境下，要保证线程互斥性。 大多数 C++ STL 容器本身（如 vector、map、unordered_map 等）不是线程安全的。 所以我们要在对这个插入数据加锁。 chatservice.hpp private: //记得包含头文件#include mutex//定义互斥锁，保证_userConnMap的线程安全 mutex _connMutex; chatservice.cpp login函数 还是在登录成功那里 //登录成功，记录用户连接信息 lock_guardmutex lock(_connMutex);//如果不析构，得得遇到为止，都是互斥，所以加个域 _userConnMap.insert(id,conn);//unordered_map容器没有线程安全需要添加线程互斥操作 有人会问为什么再加一个花括号，这是为了让lock_guard的生命周期结束，这个变量的特性是构造时加锁，析构时自动解锁。 客户端异常退出业务当客户端异常退出时，我们的数据库还没有修改当前状态时在线还是下线，所以要实现这个业务 chatservice.cpp 定义公共函数clientCloseException //处理客户端异常退出void clientCloseException(const TcpConnectionPtr conn); chatservice.cpp 对应函数实现 //处理客户端异常退出void ChatService::clientCloseException(const TcpConnectionPtr conn) User user; lock_guardmutex lock(_connMutex);//如果不析构，得得遇到为止，都是互斥，所以加个域 for(auto it=_userConnMap.begin();it!=_userConnMap.end();++it) if(it-second == conn) user.setId(it-first); //从map表删除用户的连接信息 _userConnMap.erase(it); break; //更新用户的状态信息 if(user.getId()!=-1) user.setState(offline); _userModel.updateState(user); chatserver.cpp onConnection函数 if(!conn-connected()) //处理异常退出业务，state更新为offline ChatService::instance()-clientCloseException(conn); conn-shutdown(); 在确认断开后，使用clientCloseException将state更新为offline。 一对一聊天业务：在线聊天实现public.hpp 加入聊天消息ONE_CHAT_MSG /*server和client的公共文件*/enum EnMsgType LOGIN_MSG = 1,//登录消息 LOGIN_MSG_ACK,//登录响应消息 REG_MSG,//注册消息 REG_MSG_ACK, //注册响应消息 ONE_CHAT_MSG, //聊天消息; 既然注册了业务，所以还要在chatservice.cpp的构造函数，注册业务 _msgHandlerMap.insert(ONE_CHAT_MSG,std::bind(ChatService::oneChat,this,_1,_2,_3)); chatservice.hpp 声明一对一聊天业务函数声明 //一对一聊天业务 void oneChat(const TcpConnectionPtr conn,json js,Timestamp); chatservice.cpp 声明一对一聊天业务函数声明 void ChatService::oneChat(const TcpConnectionPtr conn,json js,Timestamp) int toid=js[to]; lock_guardmutex lock(_connMutex); auto it=_userConnMap.find(toid); if(it!=_userConnMap.end()) //toid在线，转发消息 //凡涉及_userConnMap注意线程安全性 //服务器主动推送原消息给toid用户 it-second-send(js.dump()); return; //toid不在线，存储离线信息 这里js里面的构成是 msgid 消息类型id\t发消息的idfrom 发消息的nameto\t接受方的idmsg 要发送的消息 在线发送消息整体实现就是服务端接收到消息，之后查看接受用户是否在线，在线则调出服务端与接收端的连接，转发原消息。 一对一聊天业务：离线消息首先离线消息是存储在数据库的一张表里 这张表只有两个字段userid和message 这里就不用ORM映射构造一个类来保留，所以我们直接构造一个关于这张表的操作类OfflineMsgModel offlinemessagemodel.hpp #includestring#includevectorusing namespace std;//提供离线消息表的操作接口方法class OfflineMsgModelpublic: //存储用户的离线消息 void insert(int userid,string msg); //删除用户的离线消息 void remove(int userid); //查询用户的离线消息 vectorstring query(int userid);; offlinemessagemodel.cpp #include offlinemessagemodel.hpp#include db.h// 存储用户的离线消息void OfflineMsgModel::insert(int userid, string msg) //1 组装sql语句 char sql[1024] =0; sprintf(sql,insert into offlineMessage values(%d,%s),userid,msg.c_str()); MySQL mysql; if(mysql.connect()) mysql.update(sql); // 删除用户的离线消息void OfflineMsgModel::remove(int userid) //1 组装sql语句 char sql[1024] =0; sprintf(sql,delete from offlineMessage where userid=%d,userid); MySQL mysql; if(mysql.connect()) mysql.update(sql); // 查询用户的离线消息并返回对应id的消息数组vectorstring OfflineMsgModel::query(int userid) //1 组装sql语句 char sql[1024] =0; sprintf(sql,select message from offlineMessage where userid=%d,userid); MySQL mysql; vectorstring vec; if(mysql.connect()) MYSQL_RES* res=mysql.query(sql); if(res!=nullptr)//查询成功 //把userid用户的所有离线消息放入vec中返回 //查多行 MYSQL_ROW row; while((row=mysql_fetch_row(res))!=nullptr) vec.push_back(row[0]); mysql_free_result(res); return vec; return vec; 构造好对应的数据操作类，要在chatservice类实现功能 chatservice.hpp 添加对应类的声明 OfflineMsgModel _offlineMsgModel; chatservice.cpp 首先在用户登录成功后，要查看离线表中是否有属于它的离线消息，所以在login函数中登录成功板块还要添加 //查询该用户是否有离线消息 vectorstring vec=_offlineMsgModel.query(id); if(!vec.empty()) response[offlinemsg]=vec; //读取该用户的离线消息后，把该用户的所有离线消息删除掉 _offlineMsgModel.remove(id); 首先查询对应id是否有离线消息存在，存到vector数组中，如果不为空的话，response添加offlinemsg字段存储离线消息，并且在服务端删除属于接收端的离线消息，做完这些转发给接收端。 还有存储离线消息在onechat函数中对应的接收端不在线，存储离线消息在服务端。 //toid不在线，存储离线信息 _offlineMsgModel.insert(toid,js.dump()); 这样一对一的聊天业务就算实现了。 服务器异常退出问题解决（ctrl+c退出）这里遇到的问题是服务器异常退出，User表中用户们的在线状态并没有改变，所以我们要将其改变。 因为这里数据库的操作，所以在usermodel.cpp UserModel类实现resetState函数，记得在hpp文件声明 //重置用户的状态信息void UserModel::resetState() //1 组装sql语句 char sql[1024] =update User set state = offline where state = online; MySQL mysql; if(mysql.connect()) mysql.update(sql); 这个函数就在chatservice.cpp中ChatService类的reset新函数调用 //服务器异常，业务重置方法void ChatService::reset() //把online状态的用户，设置成offline _userModel.resetState(); 最后在main.cpp实现这一功能 //处理服务器ctrl+c结束后，重置user的状态信息void resetHandler(int) ChatService::instance()-reset(); exit(0); 在main函数添加对应的信号 int main() signal(SIGINT,resetHandler); EventLoop loop; InetAddress addr(127.0.0.1,6000); ChatServer server(loop, addr, ChatServer); server.start(); //开启事件循环 loop.loop(); return 0; 重点：signal(SIGINT,resetHandler); 注册信号处理函数 SIGINT 是一个信号，表示 中断信号，通常在终端按下 Ctrl+C 时触发。 resetHandler 是你定义的函数，用来在收到这个信号时执行一些清理逻辑。它的参数类型必须是 int，因为它接受信号编号 当然signal(SIGINT,resetHandler);这句话也不能随便放，得放在服务端启动前。 SIGINT 信号是： Interrupt Signal（中断信号），编号是 2，表示用户希望中断（终止）正在运行的程序。 常见触发方式： 当你在 终端命令行里运行一个程序时，按下 Ctrl + C，操作系统就会向该程序发送一个 SIGINT 信号。 举个例子： bash复制编辑$ ./chat_server# 运行中...# 你按下 Ctrl+C 这时，系统向 chat_server 进程发送 SIGINT 信号： 如果你没处理这个信号，程序会直接终止； 如果你写了 signal(SIGINT, resetHandler);，就会先执行 resetHandler()，再退出。 背后原理： LinuxUnix 中，信号（signal）是一种异步通知机制，用于通知进程发生了某种事件。 SIGINT 是一种 软件信号，由终端驱动程序发送给前台进程组。 常见信号对比： 信号名 编号 含义 默认行为 SIGINT 2 终端中断（Ctrl+C） 终止进程 SIGTERM 15 程序终止（系统或用户发送） 终止进程 SIGKILL 9 强制终止（不能捕获） 立即终止进程 SIGQUIT 3 退出（Ctrl+\\）并生成 core dump 终止+生成转储文件 SIGSEGV 11 段错误（访问非法内存） 终止进程 总结一句话：SIGINT 是终端用户通过 Ctrl+C 发出的“中断信号”，默认会终止程序，但你可以捕获它，在程序退出前做一些清理处理。 添加好友业务代码public.hpp enum EnMsgType LOGIN_MSG = 1,//登录消息 LOGIN_MSG_ACK,//登录响应消息 REG_MSG,//注册消息 REG_MSG_ACK, //注册响应消息 ONE_CHAT_MSG, //聊天消息 ADD_FRIEND_MSG,//添加好友消息; 添加ADD_FRIEND_MSG,添加好友消息 添加好友在数据库中对应的一张Friend表，其中字段是userid和friendid,所以我们实现一个操控Friend表的model类 friendmodel.hpp #ifndef FRIENDMODEL_H#define FRIENDMODEL_H#include user.hpp#includevectorusing namespace std;//维护好友信息的操作接口方法class FriendModelpublic: //添加好友关系 void insert(int userid,int friendid); //返回用户好友列表 friendid vectorUser query(int userid);;#endif friendmodel.cpp #include friendmodel.hpp#include db.h//添加好友关系void FriendModel::insert(int userid,int friendid) //1 组装sql语句 char sql[1024] =0; sprintf(sql,insert into Friend values(%d,%d),userid,friendid); MySQL mysql; if(mysql.connect()) mysql.update(sql); //返回用户好友列表 friendidvectorUser FriendModel::query(int userid) //1 组装sql语句 char sql[1024] =0; sprintf(sql,select a.id,a.name,a.state from User a inner join Friend b on b.friendid=a.id where b.userid=%d,userid); MySQL mysql; vectorUser vec; if(mysql.connect()) MYSQL_RES* res=mysql.query(sql); if(res!=nullptr)//查询成功 //把userid用户的所有离线消息放入vec中返回 //查多行 MYSQL_ROW row; while((row=mysql_fetch_row(res))!=nullptr) User user; user.setId(atoi(row[0])); user.setName(row[1]); user.setState(row[2]); vec.push_back(user); mysql_free_result(res); return vec; return vec; insert函数实现的是将好友关系加到数据库中。query返回的是从数据库中返回的好友数据。 当然还有一个业务绑定 首先在chatservice.hpp声明一个FriendModel对象 FriendModel _friendModel; 在ChatService的构造函数实现绑定 _msgHandlerMap.insert(ADD_FRIEND_MSG,std::bind(ChatService::addFriend,this,_1,_2,_3)); 在chatservice.hpp声明一个addFriend的函数 addFriend函数实现: //添加好友业务 msgid id friendidvoid ChatService::addFriend(const TcpConnectionPtr conn,json js,Timestamp) int userid=js[id]; int friendid=js[friendid]; //存储好友信息 _friendModel.insert(userid,friendid); 这里收到的json消息格式为 msgid:6,id:1,friendid:2 还有一个问题，在用户登录时，也要好友信息的显示，所以在用户登陆成功时，服务端也要把好友信息发给用户端。 所以在服务端登录的回复信息这里需要加上好友信息 //查询该用户的好友信息并返回 vectorUser userVec=_friendModel.query(id); if(!userVec.empty()) vectorstring vec2; for(User user:userVec) json js; js[id]=user.getId(); js[name]=user.getName(); js[state]=user.getState(); vec2.push_back(js.dump()); response[friends]=vec2; 这里添加好友的业务就实现了。 群组业务首先要实现群组业务，我在数据库有两张表实现群组业务AllGroup和GroupUser AllGroup的数据结构： +-----------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-----------+--------------+------+-----+---------+----------------+| id | int | NO | PRI | NULL | auto_increment || groupname | varchar(50) | NO | | NULL | || groupdesc | varchar(200) | YES | | | |+-----------+--------------+------+-----+---------+----------------+ GroupUSer的数据结构 +------------+--------------------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+------------+--------------------------+------+-----+---------+-------+| groupid | int | NO | PRI | NULL | || userid | int | NO | | NULL | || groupprole | enum(creator,normal) | YES | | normal | |+------------+--------------------------+------+-----+---------+-------+ groupuser.hpp #ifndef GROUPUSER_H#define GROUPUSER_H#include user.hpp//群组用户，多了个role角色信息，从User类直接继承，复用User的其他信息//对应的GroupUser表，但是光是这张表的不够，还要联表查询，所以继承User类。class GroupUser:public Userpublic: void setRole(string role)this-role=role; string getRole()return this-role;private: string role;;#endif GroupUser类对象是记录关于组成员的详细信息的类，所以继承User。 group.hpp #ifndef GROUP_H#define GROUP_H#includevector#includestring#include groupuser.hppusing namespace std;//AllGroup表的ORM类但也不完全是还加了储存组用户的数组class Grouppublic: Group(int id=-1,string name =,string desc=) this-id=id; this-name=name; this-desc=desc; void setId(int id) this-id=id; void setName(string name) this-name=name; void setDesc(string desc)this-desc=desc; int getId() return this-id; string getName() return this-name; string getDesc() return this-desc; vectorGroupUser getUsers() return this-users;private: int id;//组id string name;//组名 string desc;//组功能描述 vectorGroupUser users;//组员的详细信息;#endif Group类对象是AllGroup表的ORM类，但也不完全，这个类还添加了存储组成员详细信息的结构vector users; 因为这两张表的关联系很大，所以我们第一这个群组业务的数据操作接口。 groupmodel.hpp #ifndef GROUPMODEL_H#define GROUPMODEL_H#include group.hpp#includestring#includevectorusing namespace std;//维护群组信息的操作接口方法class GroupModelpublic: //创建群组 bool createGroup(Group group); //加入群组 void addGroup(int userid,int groupid,string role); //查询用户所在群组消息 vectorGroup queryGroups(int userid); //根据指定的groupid查询群组用户id列表，除userid自己，主要用户群聊业务给群组其他成员群发消息。 vectorint queryGroupUsers(int userid,int groupid);;#endif 对应函数实现 创建群组createGroup函数： // 创建群组bool GroupModel::createGroup(Group group) //1.组装sql语句 char sql[1024]=0; sprintf(sql,insert into AllGroup(groupname,groupdesc) values(%s,%s),group.getName().c_str(),group.getDesc().c_str()); MySQL mysql; if(mysql.connect()) if(mysql.update(sql)) group.setId(mysql_insert_id(mysql.getConnection())); return true; return false; 将组名和组介绍存到AllGroup表中。 加入群组addGroup函数： // 加入群组void GroupModel::addGroup(int userid, int groupid, string role) //1.组装sql语句 char sql[1024]=0; sprintf(sql,insert into GroupUser values(%d,%d,%s),groupid,userid,role.c_str()); MySQL mysql; if(mysql.connect()) mysql.update(sql); 查询用户所在群组信息queryGroups // 查询用户所在群组消息vectorGroup GroupModel::queryGroups(int userid) // 1.先根据userid在GroupUser表中查询该用户所属的群组消息 // 2.再根据群组消息，查询属于该群组的所有用户的userid,并且和User表进行多表联合查询，查出用户的详细信息 char sql[1024]=0; sprintf(sql,select a.id,a.groupname,a.groupdesc from AllGroup a inner join GroupUser b on a.id=b.groupid where b.userid=%d,userid); vectorGroup groupVec; MySQL mysql; if(mysql.connect()) MYSQL_RES *res=mysql.query(sql); if(res!=nullptr) MYSQL_ROW row; //查出userid所有的群组消息 while((row=mysql_fetch_row(res))!=nullptr) Group group; group.setId(atoi(row[0])); group.setName(row[1]); group.setDesc(row[2]); groupVec.push_back(group); mysql_free_result(res); //查询群组的用户信息 for(Group group:groupVec) sprintf(sql,select a.id,a.name,a.state,b.grouprole from User a inner join GroupUser b on b.userid=a.id where b.groupid=%d,group.getId()); MYSQL_RES *res=mysql.query(sql); if(res!=nullptr) MYSQL_ROW row; while((row=mysql_fetch_row(res))!=nullptr) GroupUser user; user.setId(atoi(row[0])); user.setName(row[1]); user.setState(row[2]); user.setRole(row[3]); group.getUsers().push_back(user); mysql_free_result(res); return groupVec; 根据指定的groupid查询群组用户id列表，除userid自己。queryGroupUsers函数： // 根据指定的groupid查询群组用户id列表，除userid自己，主要用户群聊业务给群组其他成员群发消息。vectorint GroupModel::queryGroupUsers(int userid, int groupid) char sql[1024]=0; sprintf(sql,select userid from GroupUser where groupid=%d and userid!=%d,groupid,userid); vectorint idVec; MySQL mysql; if(mysql.connect()) MYSQL_RES *res=mysql.query(sql); if(res!=nullptr) MYSQL_ROW row; while((row=mysql_fetch_row(res))!=nullptr) idVec.push_back(atoi(row[0])); mysql_free_result(res); return idVec; 完成这些在业务类使用这些功能 首先在public.hpp更新消息类型： CREATE_GROUP_MSG,//创建群组 ADD_GROUP_MSG,//加入群组 GROUP_CHAT_MSG,//群聊天 在业务类ChatService中添加对应的数据操作类对象： GroupModel _groupModel; 加入功能实现函数： //创建群组业务 void createGroup(const TcpConnectionPtr conn,json js,Timestamp); //加入群组业务 void addGroup(const TcpConnectionPtr conn,json js,Timestamp); //群组聊天业务 void groupChat(const TcpConnectionPtr conn,json js,Timestamp); 创建群组业务: //创建群组业务void ChatService::createGroup(const TcpConnectionPtr conn,json js,Timestamp) int userid=js[id]; string name=js[groupname]; string desc=js[groupdesc]; //存储新创建的群组消息 Group group(-1,name,desc); if(_groupModel.createGroup(group)) //存储群组创建人消息 _groupModel.addGroup(userid,group.getId(),creator); 加入群组业务: //加入群组业务void ChatService::addGroup(const TcpConnectionPtr conn,json js,Timestamp) int userid=js[id]; int groupid=js[groupid]; _groupModel.addGroup(userid,groupid,normal); 群组聊天业务: //群组聊天业务void ChatService::groupChat(const TcpConnectionPtr conn,json js,Timestamp) int userid=js[id]; int groupid=js[groupid]; vectorint useridVec=_groupModel.queryGroupUsers(userid,groupid); lock_guardmutex lock(_connMutex); for(int id:useridVec) auto it=_userConnMap.find(id); if(it!=_userConnMap.end()) //转发群消息 it-second-send(js.dump()); else //存储离线群消息 _offlineMsgModel.insert(id,js.dump()); 还要在构造函数绑定消息对应函数： //群组业务注册 _msgHandlerMap.insert(CREATE_GROUP_MSG,std::bind(ChatService::createGroup,this,_1,_2,_3)); _msgHandlerMap.insert(ADD_GROUP_MSG,std::bind(ChatService::addGroup,this,_1,_2,_3)); _msgHandlerMap.insert(GROUP_CHAT_MSG,std::bind(ChatService::groupChat,this,_1,_2,_3)); 当然在用户登录成功时，还要把群组的信息发给客户端。 //查询用户的群组信息 vectorGroup groupuserVec=_groupModel.queryGroups(id); if(!groupuserVec.empty()) //group:[groupid:[xxx,xxx,xxx,xxx]] vectorstring groupV; for(Group group:groupuserVec) json grpjson; grpjson[id]=group.getId(); grpjson[groupname]=group.getName(); grpjson[groupdesc]=group.getDesc(); vectorstring userV; for(GroupUser user:group.getUsers()) json js; js[id]=user.getId(); js[name]=user.getName(); js[state]=user.getState(); js[role]=user.getRole(); userV.push_back(js.dump()); grpjson[users]=userV; groupV.push_back(grpjson.dump()); response[groups]=groupV; 群组业务就完成了。 客户端开发-首页面开发首先在srcclient编写CMakeLists.txt和main.cpp CMakeLists.txt #定义了一个SRC_LIST变量，包含了该目录下所有的源文件aux_source_directory(. SRC_LIST)#指定生成可执行文件add_executable(ChatClient $SRC_LIST)#指定可执行文件链接时所需要依赖的库文件target_link_libraries(ChatClient pthread) main.cpp编写我们的客户端程序 首先保存的变量 //记录当前系统登录的用户信息User g_currentUser;//记录当前登录用户的好友列表信息vectorUser g_currentUserFriendList;//记录当前登录用户的群组列表信息vectorGroup g_currentUserGroupList; 目前的函数 //显示当前登录成功用户的基本信息void showCurrentUserData();//接受线程void readTaskHandler(int clientfd);//获取系统时间(聊天信息需要添加时间信息)string getCurrentTime();//主聊天页面程序void mainMenu(); 主线程main函数 int main(int argc,char **argv) 参数说明： int argc：Argument Count，命令行参数的数量（包括程序本身的名称）。 char **argv：Argument Vector，命令行参数的数组。argv[0] 是程序的名字，argv[1] 到 argv[argc-1] 是你在命令行中输入的其他参数。 在命令行运行.ChatClient 127.0.0.1 6000即可运行 客户端和服务端的连接首先客户端和服务端的连接代码： if(argc3) cerrcommand invalid!example:./ChatClient 127.0.0.1 6000endl; exit(-1);//异常退出 exit(0)是正常退出//解析通过命令行参数传递的ip和portchar *ip=argv[1];uint16_t port=atoi(argv[2]);//创建client端的socketint clientfd=socket(AF_INET,SOCK_STREAM,0);if(-1==clientfd) cerrsocket create errorendl; exit(-1);//填写client需要连接的server信息ip+portsockaddr_in server;memset(server,0,sizeof(sockaddr_in));server.sin_family=AF_INET;server.sin_port=htons(port);server.sin_addr.s_addr=inet_addr(ip);//client和server进行连接if(-1==connect(clientfd,(sockaddr *)server,sizeof(sockaddr_in))) cerr connect server errorendl; close(clientfd); exit(-1); 对其中的函数解释： int clientfd=socket(AF_INET,SOCK_STREAM,0); socket函数功能：创建一个 TCP 套接字（socket） 其中的socket函数 #include sys/socket.h 各个参数含义： socket(int domain, int type, int protocol) AF_INET（地址族） 指定使用 IPv4 地址（Internet Protocol version 4）。 如果是 AF_INET6，那就是 IPv6。 SOCK_STREAM（套接字类型） 表示使用的是 面向连接的、可靠的、基于字节流 的通信方式。 通常对应 TCP 协议。 0（协议编号） 填 0 表示让系统根据前两个参数自动选择合适的协议。 对于 AF_INET + SOCK_STREAM，系统会自动选择 TCP 协议。 返回值： 成功时返回一个非负整数（文件描述符，也就是 clientfd），用于后续的读写操作。 失败时返回 -1，常见原因包括：系统资源耗尽、参数错误等。 sockaddr_in server; sockaddr_in 是 CC++ 中专门用来表示 IPv4 网络地址 的结构体。 对应的头文件： #include netinet/in.h memset(server,0,sizeof(sockaddr_in)); 把 server 结构体从首地址开始，连续 sizeof(server) 个字节都设置为 0。 memset函数用法 void *memset(void *ptr, int value, size_t num); 参数说明： 参数 说明 ptr 指向要被设置的内存的指针 value 要设置的值（会被转换为 unsigned char 类型） num 要设置的字节数 server.sin_family=AF_INET;server.sin_port=htons(port);server.sin_addr.s_addr=inet_addr(ip); server.sin_family = AF_INET; 表示使用的地址类型是 IPv4。 AF_INET 是 Address Family Internet 的缩写。 这是 sockaddr_in 中的 sin_family 字段，必须设置为 AF_INET，否则系统无法识别地址格式。 server.sin_port = htons(port); 设置端口号，例如：6000。 htons() 是 Host to Network Short 的缩写：h 它把本地主机的字节序（可能是小端）转换为网络字节序（大端）。 因为 TCPIP 协议使用大端字节序进行数据传输。 port 是你从命令行传进来的端口号字符串转成的整数。 htons函数头文件： #include netinet/in.h 端口必须转换成网络字节序，否则客户端连接服务器时会出错！ server.sin_addr.s_addr = inet_addr(ip); 设置 IP 地址。 inet_addr() 函数把点分十进制的 IP 字符串（如 127.0.0.1）转换成 32 位的二进制整数。 转换后的结果赋值给 sin_addr.s_addr，用于 socket 连接。 inet_addr函数头文件： #include arpa/inet.h //client和server进行连接 if(-1==connect(clientfd,(sockaddr *)server,sizeof(sockaddr_in))) cerr connect server errorendl; close(clientfd);//释放socket资源 exit(-1); connect() 函数详解： int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 参数 说明 sockfd 用 socket() 创建的套接字文件描述符（即 clientfd） addr 服务器地址结构指针（需要强转成 sockaddr* 类型） addrlen addr 结构体的大小，通常是 sizeof(sockaddr_in) 客户端业务实现首先在一个死循环中实现循环选择： //显示首页面菜单 登录,注册，退出 cout==================================endl; cout1. loginendl; cout2. registerendl; cout3. quitendl; cout==================================endl; cout choice:; int choice=0; cinchoice; cin.get();//读掉缓冲区残留的回车 使用switch语句实现不断选择。 首先登录业务：case 1://login业务 int id=0; char pwd[50]=0; cout userid:; cin id; cin.get();//读掉缓冲区残留的回车 coutuser password:; cin.getline(pwd,50); json js; js[msgid]=LOGIN_MSG; js[id]=id; js[password]=pwd; string request =js.dump(); int len=send(clientfd,request.c_str(),strlen(request.c_str())+1,0); if(len==-1) cerrsend login msg error:requestendl; else char buffer[1024]=0; len=recv(clientfd,buffer,1024,0); if(len==-1) cerr recv login response errorendl; else json responsejs=json::parse(buffer); if(responsejs[errno]!=0) cerrresponsejs[errmsg]endl; else//登录成功 //记录当前用户的id和name g_currentUser.setId(responsejs[id]); g_currentUser.setName(responsejs[name]); //记录当前用户的好友列表信息 if(responsejs.contains(friends))//看是否包含friends这个键 vectorstring vec=responsejs[friends]; for(string str:vec) json js=json::parse(str); User user; user.setId(js[id]); user.setName(js[name]); user.setState(js[state]); g_currentUserFriendList.push_back(user); //记录当前用户的群组列表信息 if(responsejs.contains(groups)) vectorstring vec1=responsejs[groups]; for(string groupstr:vec1) json grpjs=json::parse(groupstr); Group group; group.setId(grpjs[id]); group.setName(grpjs[groupname]); group.setDesc(grpjs[groupdesc]); vectorstring vec2=grpjs[users]; for(string userstr:vec2) GroupUser user; json js=json::parse(userstr); user.setId(js[id]); user.setName(js[name]); user.setState(js[state]); user.setRole(js[role]); group.getUsers().push_back(user); g_currentUserGroupList.push_back(group); //显示登录用户的基本信息 showCurrentUserData(); //显示当前用户的离线消息 个人聊天消息或者群组消息 if(responsejs.contains(offlinemsg)) vectorstring vec=responsejs[offlinemsg]; for(string str:vec) json js=json::parse(str); //time +[id]+name+said: +xxx coutjs[time][js[id]]js[name] said js[msg]endl; //登录成功，启动接受线程负责接受数据 std::thread readTask(readTaskHandler,clientfd); readTask.detach(); //进入聊天主菜单页面 mainMenu(); break; 这里解释一些函数 int len=send(clientfd,request.c_str(),strlen(request.c_str())+1,0); 通过 send() 函数将字符串 request 的内容发送到套接字 clientfd 所代表的对端。 各参数详解： send(socket, buffer, length, flags) clientfd：套接字描述符，表示要发送数据的目标。 request.c_str()：将 std::string 类型的 request 转为 C 风格的字符串（返回 const char* 指针）。c++ strlen(request.c_str()) + 1：表示发送的数据长度，+1 是为了包括字符串末尾的 \\0（空字符终止符），这是为了让接收方知道字符串结束。 0：表示不使用额外的标志（默认行为）。 关于返回值： 返回值 len 意义说明 0 成功发送了 len 字节的数据 0 TCP 连接被优雅关闭（几乎不会出现在 send()，常出现在 recv()） -1 发送失败，需检查 errno 查看错误原因 len=recv(clientfd,buffer,1024,0); 从 clientfd 套接字接收最多 1024 字节的数据，存入 buffer 缓冲区中。 各参数详解： recv(socket, buffer, length, flags) clientfd：连接的套接字描述符（已连接的对端）。 buffer：用于存放接收数据的内存区域（char buffer[1024]; 或 char* buffer = new char[1024];）。 1024：最多接收 1024 字节（防止缓冲区溢出）。 0：标志位，通常设置为 0（表示默认阻塞接收）。 返回值说明（关键点）： 返回值 len 意义说明 0 实际接收到的数据字节数（并不一定等于 1024） 0 连接已关闭（对方调用了 close()） -1 接收失败，可通过 errno 查看错误原因 注意recv() 并不会自动在 buffer 的末尾添加 ‘\\0‘ 所以我们定义buffer:保证末尾有’\\0‘ char buffer[1024]=0; //登录成功，启动接受线程负责接受数据 std::thread readTask(readTaskHandler,clientfd); readTask.detach(); 创建了一个新线程，并立刻将它分离（detach），用来异步执行函数 readTaskHandler(clientfd)。 分析每一行作用： std::thread readTask(readTaskHandler, clientfd); 创建一个线程对象 readTask，该线程会立即开始运行 readTaskHandler(clientfd)。 通常用于处理客户端请求，比如接收数据、解析消息等。 readTask.detach(); 将线程分离，让它独立运行。 主线程不再管理这个子线程，也无法调用 join() 等待它。 线程资源会在线程函数执行完毕后由系统自动回收。 detach 的 优点与风险： 优点： 简单，不阻塞主线程，不需要显式 join()。 适合执行时间短、无需主线程等待的任务（比如客户端的消息监听）。 风险： 无法再追踪或管理线程：你不能再 join 或获取其返回状态。 容易引发悬空引用或资源泄漏问题： 如果 readTaskHandler() 里访问了已经销毁的变量，会崩。 比如使用了传进来的 clientfd 后，主线程先关闭了它。 调试困难：detach 后的线程出错更难排查。 注册业务：case 2://register业务 char name[50]=0; char pwd[50]=0; cout username:; cin.getline(name,50); coutuser password:; cin.getline(pwd,50); json js; js[msgid]=REG_MSG; js[name]=name; js[password]=pwd; string request=js.dump(); int len=send(clientfd,request.c_str(),strlen(request.c_str())+1,0); if(len==-1) cerr send reg msg error:requestendl; else char buffer[1024]=0; len=recv(clientfd,buffer,1024,0); if(len==-1) cerrrecv reg response errorendl; else json responsejs=json::parse(buffer); if(0!=responsejs[errno])//注册失败 cerrnameis already exist,register error!endl; else//注册成功 coutnameregister success,userid is responsejs[id], do not forget it!endl; break; 退出业务：case 3://quit 业务 close(clientfd);//释放连接，不要重复关闭 exit(0); 聊天主界面业务：首先在登录业务实现，登录成功又该何去何从，所以聊天主界面业务，首先在登录业务有几个函数，还没有实现，实现一下： //显示登录用户的基本信息showCurrentUserData(); 具体实现： //显示当前登录成功用户的基本信息void showCurrentUserData() cout==========================login user==============================endl; coutcurrent login user =id:g_currentUser.getId()name:g_currentUser.getName()endl; cout-------------------------friend list------------------------------endl; if(!g_currentUserFriendList.empty()) for(User user:g_currentUserFriendList) coutuser.getId() user.getName() user.getState() endl; cout--------------------------group list-------------------------------endl; if(!g_currentUserGroupList.empty()) for(Group group:g_currentUserGroupList) coutgroup.getId() group.getName() group.getDesc()endl; for(GroupUser user:group.getUsers()) coutuser.getId() user.getName() user.getState()user.getRole()endl; cout====================================================================endl; //登录成功，启动接受线程负责接受数据std::thread readTask(readTaskHandler,clientfd);readTask.detach(); 其中readTaskHandler的实现： //接受线程void readTaskHandler(int clientfd) for(;;) char buffer[1024]=0; int len =recv(clientfd,buffer,1024,0); if(-1==len||0==len) close(clientfd); exit(-1); //接收ChatServer转发的数据，反序列化生成json数据对象 json js=json::parse(buffer); if(ONE_CHAT_MSG==js[msgid]) coutjs[time].getstring()[js[id]]js[name].getstring() said: js[msg].getstring()endl; continue; 这个函数是用来接受服务端发来的消息的。主线程是发消息的。但是当前就实现了关于一对一聊天的接受消息。 //进入聊天主菜单页面 mainMenu(clientfd); 进入聊天主菜单页面实现具体的业务： //主聊天页面程序void mainMenu(int clientfd) help(); char buffer[1024]=0; for(;;) cin.getline(buffer,1024); string commandbuf(buffer); string command; int idx=commandbuf.find(:); if(idx==-1) command=commandbuf; else command=commandbuf.substr(0,idx); auto it=commandHandlerMap.find(command); if(it==commandHandlerMap.end()) cerr invalid input command!endl; continue; //调用相应命令的事件处理回调，mainMenu对修改封闭，添加新功能不需要修改该函数 it-second(clientfd,commandbuf.substr(idx+1,commandbuf.size()-idx));//调用命令处理方法 这个函数实现进入主页面使用对应的指令使用对应的功能。接下来说说其中的变量commandHandlerMap。 //注册系统支持的客户端命令处理unordered_mapstring,functionvoid(int,string)commandHandlerMap= help,help, chat,chat, addfriend,addfriend, creategroup,creategroup, addgroup,addgroup, groupchat,groupchat, loginout,loginout; 通过哈希表绑定对应的字符串和对应函数的实现。 当然在实现这些功能时得要有一个文字说明，这就是help功能。 //help command handlervoid help(int fd,string str) cout show command lists:endl; for(autop:commandMap) coutp.first : p.secondendl; coutendl; 这有个细节，因为后续用户如果还想要再次使用help功能，所以把他放在commandHandlerMap中，但是help()函数不满足functionvoid(int,string),所以我们在声明的时候赋初始值，这样就可以直接help()实现了。在其中commandMap也是自己定义提示用户如何使用这些功能。 //系统支持的客户端命令列表unordered_mapstring,string commandMap= help,显示所有支持的命令，格式help, chat,一对一聊天，格式chat:friendid:message, addfriend,添加好友，格式addfriend:friendid, creategroup,创建群组，格式creategroup:groupname:groupdesc, addgroup,加入群组，格式addgroup:groupid, groupchat,群聊，格式groupchat:groupid:message, loginout,注销，格式loginout; 由commandHandlerMap知道要实现的功能。 //调用相应命令的事件处理回调，mainMenu对修改封闭，添加新功能不需要修改该函数it-second(clientfd,commandbuf.substr(idx+1,commandbuf.size()-idx));//调用命令处理方法 这样就可以把具体实现的内容封装到每一个函数中，所以接下来聚集每个实现的函数。 chat功能实现：//chat command handlervoid chat(int clientfd,string str) int idx=str.find(:);//friendid:message if(idx==-1) cerrchat command invalid!endl; return; int friendid=atoi(str.substr(0,idx).c_str()); string message=str.substr(idx+1,str.size()-idx); json js; js[msgid]=ONE_CHAT_MSG; js[id]=g_currentUser.getId(); js[name]=g_currentUser.getName(); js[msg] = message; js[toid]=friendid; js[time]=getCurrentTime(); string buffer=js.dump(); int len=send(clientfd,buffer.c_str(),strlen(buffer.c_str())+1,0); if(len==-1) cerrsend chat msg error:bufferendl; 还要实现getCurrentTime函数： //获取系统时间(聊天信息需要添加时间信息)string getCurrentTime() auto tt = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()); struct tm *ptm = localtime(tt); char date[60] = 0; sprintf(date, %d-%02d-%02d %02d:%02d:%02d, (int)ptm-tm_year + 1900, (int)ptm-tm_mon + 1, (int)ptm-tm_mday, (int)ptm-tm_hour, (int)ptm-tm_min, (int)ptm-tm_sec); return std::string(date); addfriend功能实现：//addfriend command handlervoid addfriend(int clienfd,string str) int friendid=atoi(str.c_str()); json js; js[msgid]=ADD_FRIEND_MSG; js[id]=g_currentUser.getId(); js[friendid]=friendid; string buffer=js.dump(); int len=send(clienfd,buffer.c_str(),strlen(buffer.c_str())+1,0); if(len==-1) cerrsend addfriend msg error-bufferendl; creategroup功能实现：//creategroup command handlervoid creategroup(int clientfd, string str) int idx = str.find(:); if (idx == -1) cerr creategroup command invalid! endl; return; string groupname = str.substr(0, idx); string groupdesc = str.substr(idx + 1, str.size() - idx); json js; js[msgid] = CREATE_GROUP_MSG; js[id] = g_currentUser.getId(); js[groupname] = groupname; js[groupdesc] = groupdesc; string buffer = js.dump(); int len = send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0); if (len == -1) cerr send creategroup msg error: buffer endl; addgroup功能实现：//addgroup command handlervoid addgroup(int clientfd, string str) int groupid = atoi(str.c_str()); json js; js[msgid] = ADD_GROUP_MSG; js[id] = g_currentUser.getId(); js[groupid] = groupid; string buffer = js.dump(); int len = send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0); if (len == -1) cerr send addgroup msg error: buffer endl; groupchat功能实现：//groupchat command handlervoid groupchat(int clientfd, string str) int idx = str.find(:); if (idx == -1) cerr groupchat command invalid! endl; return; int groupid = atoi(str.substr(0, idx).c_str()); string message = str.substr(idx + 1, str.size() - idx); json js; js[msgid] = GROUP_CHAT_MSG; js[id] = g_currentUser.getId(); js[name] = g_currentUser.getName(); js[groupid] = groupid; js[msg] = message; js[time] = getCurrentTime(); string buffer = js.dump(); int len = send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0); if (len == -1) cerr send groupchat msg error: buffer endl; 实现群聊功能后，需要在接受线程实现解析返回的信息，并且输出。服务端在这里是直接将消息转发。所以如下实现： if (GROUP_CHAT_MSG == msgtype)\tcout 群消息[ js[groupid] ]: js[time].getstring() [ js[id] ] js[name].getstring() said: js[msg].getstring() endl; continue; 当然离线消息同时也要输出群组消息. if (ONE_CHAT_MSG == js[msgid].getint()) cout js[time].getstring() [ js[id] ] js[name].getstring() said: js[msg].getstring() endl; else cout 群消息[ js[groupid] ]: js[time].getstring() [ js[id] ] js[name].getstring() said: js[msg].getstring() endl; else部分即为离线群组消息。 loginout功能实现：//login out command handlervoid loginout(int clientfd, string str) json js; js[msgid]=LOGINOUT_MSG; js[id]=g_currentUser.getId(); string buffer=js.dump(); int len=send(clientfd,buffer.c_str(),strlen(buffer.c_str())+1,0); if(len==-1) cerrsend loginout msg error:bufferendl; else isMainMenuRunning=false; 首先这个函数实现需要在public.hpp LOGINOUT_MSG,//注销消息 在服务器端做出对应的函数：（记得在构造函数注册注销业务） //处理注销业务void ChatService::loginout(const TcpConnectionPtr conn,json js,Timestamp) int userid=js[id]; lock_guardmutex lock(_connMutex); auto it=_userConnMap.find(userid); if(it!=_userConnMap.end()) _userConnMap.erase(it); //更新用户的状态信息 User user(userid,,,offline); _userModel.updateState(user); 将_userConnMap对应的id的连接删去，并且更新用户的状态。 isMainMenuRunning是一个全局变量，用来确保loginout后会回到首页。所以默认值为false。当进入主菜单界面时，变为true。这样mainMenu函数就会退出循环，运行结束，进入首页的循环。 当然这里就出现了一个问题就是loginoutr退出但是程序没有退出，很多全局变量还保留着上一次的值，这就会在输出这些变量时会把上一次登录的用户信息都输出。所以在登录成功时，记得将对应变量初始化清空，再进行赋值。 // 记录当前登录用户的好友列表信息vectorUser g_currentUserFriendList;// 记录当前登录用户的群组列表信息vectorGroup g_currentUserGroupList; 这两个变量在登录成功后，会进行赋值，记得在赋值前，初始化，清空。 这里还有一个问题，每次登录成功都会创造一个线程，当我在loginout后再次登录，又创造了一个新线程。所以要保证只有一个线程实现接受。所以在登录成功部分修改： // 登录成功，启动接受线程负责接受数据 ,该线程只启动一次static int readthreadnumber=0;if(readthreadnumber==0)\tstd::thread readTask(readTaskHandler, clientfd); // 在Linux pthread_create\treadTask.detach();\treadthreadnumber++; // Linux pthread_detach 引入负载均衡器：以上我们基本完成了客户端和服务端的开发，由于是一个聊天服务器，要考虑一台服务器同时可以多少用户在线。我借用muduo模型创建 1个主线程（accept连接）+ 4个子线程（处理连接和事件）总共 5个线程，用于服务端 IO。主线程用于 accept 新连接4 个 EventLoop 子线程处理客户端连接的 IO 事件（读写、消息分发等） //设置线程数量_server.setThreadNum(4); 操作系统的限制操作系统对单个进程的文件描述符数量有限制，每个客户端连接通常占用一个文件描述符（socket）。 Linux默认值（可以用 ulimit -n 查看）：通常是 1024，也就是说一个进程默认最多只能同时处理约1000个客户端连接。 实际可支持的并发连接数（估算）： 类型 数量 Idle连接（不活跃） 40,000 ~ 100,000（受内核和 FD 限制） 活跃连接（频繁收发消息） 10,000 ~ 20,000（实际取决于业务逻辑复杂度） 这是单进程、多线程、epoll 架构下的典型并发能力，非常高效。 什么是 Idle连接（不活跃连接）？Idle（空闲）连接 是指： 客户端虽然 已经建立了连接，但 长时间没有发送或接收任何数据，也就是说： 连接处于打开状态（TCP连接存在） 但没有发生 读写事件 占用资源极少（仅占用文件描述符、少量内存） 为什么要区分 Idle 与 活跃连接？ 资源占用不同 Idle 连接不产生消息，不触发回调，服务器处理负担极低 活跃连接需要处理消息、业务逻辑，负担高 并发能力的评估 很多高并发服务器说能支持“10万连接”，指的是 Idle连接数量 真正活跃（消息频繁）的连接，一般几千~上万就会达到服务器上限 是否需要清理 Idle连接 有些服务器会设置 心跳超时机制，长时间不活跃的连接会被断开，防止资源泄漏或恶意占用 我们还要提高并发量，就要引入负载均衡器的概念。 负载均衡器负载均衡器（Load Balancer） 是一个把大量客户端请求 均匀分发 给多个后端服务器的组件，以提高系统的 吞吐能力、稳定性和可用性。 为什么需要它？在高并发系统中，如果所有请求都打到一个服务器上，容易导致： 响应慢 连接超时 服务宕机 使用负载均衡器可以： 水平扩展服务器（多个 Muduo 实例） 分担压力 实现高可用（某个服务器挂了不影响整体） 按协议层划分（TCPHTTP） 类型 层级 说明 常用代表 四层负载均衡（L4） TCPUDP 基于 IP、端口、协议 LVS、HAProxy、Nginx Stream、Keepalived 七层负载均衡（L7） HTTP、HTTPS 基于 URL、Header、Cookie Nginx、HAProxy、Traefik、Envoy、Kong 常见软件负载均衡器对比 名称 协议支持 类型 特点 场景 LVS L4 (TCPUDP) 内核模块 性能极高、稳定、复杂配置 超高并发、基础设施层 HAProxy L4 + L7 用户态 灵活、高性能、支持健康检查、监控完备 Web、API 网关、数据库代理 Nginx L7 (也支持 L4) 用户态 配置简单，静态资源支持好 Web服务器、轻量级反代 Traefik L7 云原生 自动发现服务（K8s、Docker）、面向微服务 DevOps、容器化 Envoy L4 + L7 云原生 微服务架构核心组件、支持 gRPC、动态配置 Istio、Service Mesh Kong L7 API网关 插件丰富 基于 Nginx，提供限流、安全等扩展能力 企业 API 管理 Keepalived L4 高可用 常与 LVS 配合，提供主备切换 双主结构、高可用架构 OpenResty L7 基于 Nginx 支持 Lua，适合做复杂业务逻辑 高定制需求 Caddy L7 自动 TLS HTTPS 自动配置简单 个人、低门槛网站部署 我们这里要使用的是Nginx 的 TCP 负载均衡模块（即 stream 模块） 这是负载均衡器在本项目发挥的作用图。 Nginx 默认是 HTTP 层负载均衡（七层），但它的 stream 模块 支持四层（TCPUDP）负载均衡，非常适合。 说白了，通过多台后台服务器提高并发量。但也面临着如何处理跨服务器通信的问题。 引入服务器中间件（redis）Redis（Remote Dictionary Server） 是一个开源的、基于内存的键值对存储（Key-Value Store）数据库，支持丰富的数据结构，读写极快，非常适合用作缓存、中间件、消息队列等。 引入redis是要解决如果一个用户要和另一个用户通信，但是另一个用户在另一台服务器上，我们能从数据库中看到他在线，但是我们不能获取他的连接，所以引入中间件。这样就可以解决跨服务器通信的问题。 这里是redis在本项目的作用图： nginx项目配置nginx配置编译好后，去修改usrlocalnginxconf中修改nginx.conf文件。 #nginx tcp loadbalance configstream upstream MyServer server 127.0.0.1:6000 weight=1 max_fails=3 fail_timeout=30s; server 127.0.0.1:6002 weight=1 max_fails=3 fail_timeout=30s; server proxy_connect_timeout 1s; #proxy_timeout 3s; # 可以根据需要开启，控制代理的读写超时 listen 8000; proxy_pass MyServer; tcp_nodelay on; 在events和http领域之间加入上述代码。这一段代码就是加入**stream 模块** 。 说明 **stream{}**：用于 TCPUDP 负载均衡。 upstream MyServer：定义了两个后端服务器，权重相等。 max_fails3 fail_timeout30s：3次失败后，30秒内认为该节点不可用。 listen 8000：监听本机 8000 端口。 proxy_connect_timeout 1s：连接超时时间为1秒。 proxy_pass MyServer：请求转发到 MyServer 负载均衡组。 tcp_nodelay on：开启 TCP_NODELAY，减少延迟。 这样就实现了多个客户端只需要向一个ip+port就可以。通过nginx对多台服务器管理，这样就增加了聊天服务器的并发量。当然跨服务器通信这一问题还没有解决。 Redis项目配置首先在include和src建立redis文件夹，在对应的文件夹添加redis.hpp和redis.cpp。记得更新CMakeLists.txt文件。这里调用了hiredis库。hiredis是c++使用redis封装的库。 redis.hpp #ifndef REDIS_H#define REDIS_H#include hiredis/hiredis.h#include thread#include functionalusing namespace std;class Redis public: Redis(); ~Redis(); //连接redis服务器 bool connect(); //向redis指定的通道channel发布消息 bool publish(int channel,string message); //向redis指定的通道subscribe订阅消息 bool subscribe(int channel); //向redis指定的通道unsubscribe取消订阅消息 bool unsubscribe(int channel); //在独立线程中接受订阅通道中的消息 void observer_channel_message(); //初始化向业务层上报通道消息的回调对象 void init_notify_handler(functionvoid(int,string) fn); private: //hiredis同步上下文对象，负责publish消息 redisContext *_publish_context; //hiredis同步上下文对象，负责subscribe消息 redisContext * _subscribe_context; //回调操作，收到订阅的消息，给service层上报 functionvoid (int,string) _notify_message_handler;;#endif redis.cpp #includeredis.hpp#includeiostreamusing namespace std;Redis::Redis():_publish_context(nullptr),_subscribe_context(nullptr)Redis::~Redis() if(_publish_context!=nullptr) redisFree(_publish_context); if(_subscribe_context!=nullptr) redisFree(_subscribe_context); bool Redis::connect() //负责publish发布消息的上下文连接 _publish_context=redisConnect(127.0.0.1,6379); if(_publish_context==nullptr) cerr connect redis failed!endl; return false; //负责subscribe订阅消息的上下文连接 _subscribe_context=redisConnect(127.0.0.1,6379); if(_subscribe_context==nullptr) cerr connect redis failed!endl; return false; //在单独的线程中，监听通道上的事件，有消息给业务层进行上报 thread t([]() observer_channel_message(); ); t.detach(); coutconnect redis_server success!endl; return true;//向redis指定的通道channel发布消息bool Redis::publish(int channel,string message) redisReply *reply=(redisReply*)redisCommand(_publish_context,PUBLISH %d %s,channel,message.c_str()); if(reply==nullptr) cerrpublish command failedendl; return false; freeReplyObject(reply); return true;//向redis指定的通道subscribe订阅消息bool Redis::subscribe(int channel) //subscribe命令本身会造成线程阻塞等待通道里面发生消息，这里只做订阅通道，不接受消息 //通道消息的接受专门在observer_channel_message函数中的独立线程中进行 //只负责发送命令，不阻塞接受redis server响应消息，否则和notifyMsg线程抢占响应资源。 if(REDIS_ERR==redisAppendCommand(this-_subscribe_context,SUBSCRIBE %d,channel)) cerrsubscribe command failed!endl; return false; //redisBufferWrite 可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1） int done=0; while(!done) if(REDIS_ERR==redisBufferWrite(this-_subscribe_context,done)) cerrsubscribe command failed!endl; return false; //redisGetReply不执行 return true;//向redis指定的通道unsubscribe取消订阅消息bool Redis::unsubscribe(int channel) if(REDIS_ERR==redisAppendCommand(this-_subscribe_context,UNSUBSCRIBE %d,channel)) cerrunsubscribe command failed!endl; return false; //redisBufferWrite 可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1） int done=0; while(!done) if(REDIS_ERR==redisBufferWrite(this-_subscribe_context,done)) cerrunsubscribe command failed!endl; return false; return true;//在独立线程中接受订阅通道中的消息void Redis::observer_channel_message() redisReply *reply=nullptr; while(REDIS_OK==redisGetReply(this-_subscribe_context,(void**)reply)) //订阅收到的消息是一个带三元组的数组 if(reply!=nullptrreply-element[2]!=nullptrreply-element[2]-str!=nullptr) //给业务层上报通道上发生的消息 _notify_message_handler(atoi(reply-element[1]-str),reply-element[2]-str); freeReplyObject(reply); cerrobserver_channel_message quit endl;//初始化向业务层上报通道消息的回调对象void Redis::init_notify_handler(functionvoid(int,string) fn) this-_notify_message_handler=fn; 这里需要注意的点就是关于订阅和发布，发布publish直接用redisCommand函数即可，因为这个命令直接执行本身不会堵塞（服务器会很快给出回复）。但是subscribe不一样，他直接执行会卡在那里，一直等待消息进入通道里（服务器不会很快回复）。所以我们这里使用redisAppendCommand+redisBufferWrite这两个函数一起，不用再等待响应。所以我们单开一个线程来接受通道里的消息。 总结对比 功能 redisCommand redisAppendCommand + redisBufferWrite 用法 直接发送+等待响应 仅发送命令到 Redis，不等待响应 是否阻塞 会阻塞直到响应 不会阻塞 适用场景 普通命令（GETSET） 发布订阅等需要后台线程响应的命令 所以我们把监听逻辑放到线程里。 注意： Redis 的订阅-发布机制设计： 订阅连接会被阻塞监听消息，不允许执行其他命令。 如果同一个连接既用来订阅又用来发布，订阅时会阻塞导致发布失败或延迟。 所以一般建议发布和订阅使用独立的连接，保证各自的流畅性和响应效率。 解决跨服务器通信问题我们已经配置好redis,并且封装了对应的redis类。接下来在业务类实现加入redis。 在对应的ChatService类声明私有变量。 //redis操作对象 Redis _redis; 在ChatService类的构造函数，实现redis连接并且加入回调函数。 //连接redis服务器if(_redis.connect())\t//设置上报消息的回调\t_redis.init_notify_handler(std::bind(ChatService::handleRedisSubscribeMessage,this,_1,_2)); handleRedisSubscribeMessage函数是从redis消息队列中获取订阅的消息（在另一个线程执行） //从redis消息队列中获取订阅的消息void ChatService::handleRedisSubscribeMessage(int userid,string msg) lock_guardmutex lock(_connMutex); auto it=_userConnMap.find(userid); if(it!=_userConnMap.end()) it-second-send(msg); return; //存储该用户的离线消息 _offlineMsgModel.insert(userid,msg); 从redis返回的userid和message是当前服务器订阅的通道返回的消息，所以当前userid一定在当前服务器的_userConnMap中，当然也存在一种情况，发消息给redis时，还在线，redis传给对应的服务器时，该用户下线了，所以也要存储该用户的离线消息。 接着还要在登录功能和注销功能做修改 在登录成功后： //id用户登录成功后，向redis订阅channel(id)_redis.subscribe(id); 要向redis订阅消息，有向当前用户发送的消息会向在redis通道存储，之后会向当前用户输送。 在注销（退出）后： //用户注销，相当于下线，在redis中取消订阅通道_redis.unsubscribe(userid); 关闭掉订阅通道。当然还有客户端异常退出时，也要关闭订阅 //客户端关闭，相当于下线，在redis中取消订阅通道_redis.unsubscribe(user.getId()); 最后对一对一聊天和群聊功能做修改。 一对一聊天，当查到目标用户没有在_userConnMap中，说明目标用户不在当前服务器上或者不在线，所以接下来去数据库查看目标用户是否在线，若在线，则向redis对应的通道发布消息。不在线则存储连线消息。 //查询toid是否在线（可能在其他服务器上）User user=_userModel.query(toid);if(user.getState()==online)\t_redis.publish(toid,js.dump());\treturn; 群聊，当查到目标用户没有在_userConnMap中，说明目标用户不在当前服务器上或者不在线，所以接下来去数据库查看目标用户是否在线，若在线，则向redis对应的通道发布消息。不在线则存储连线消息。 auto it=_userConnMap.find(id);if(it!=_userConnMap.end()) //转发群消息 it-second-send(js.dump()); else //查询id是否在线 User user=_userModel.query(id); if(user.getState()==online) _redis.publish(id,js.dump()); else //存储离线群消息 _offlineMsgModel.insert(id,js.dump()); 至此解决跨服务器通信问题。 解决登录注销后再次登录会阻塞的问题在登录后注销退出后，在进行登录会一直卡住，没有关于用户的信息展示和指令展示，核查发现是主线程在执行recv,接受线程也在recv同一个socket,所以这里我们引入 // 用于读写线程的通信sem_t rwem;// 记录登录状态atomic_bool g_isLoginSuccessfalse; sem_t 是 POSIX 信号量类型（semaphore），用于线程之间同步或通信。 tomic_bool 是 C++ 的原子变量类型之一，用于线程安全地读写布尔值，防止并发条件竞争。 一、信号量 sem_t 的初始化 在使用前，必须初始化。常用的是 sem_init： sem_t rwem;sem_init(rwem, 0, 0); 参数解释： int sem_init(sem_t *sem, int pshared, unsigned int value); 参数 说明 sem 指向信号量的指针 pshared=0 表示是线程之间使用（同一进程） value=0 初始值为 0（表示“没有资源”） 通常设为 0，表示线程必须等待 sem_post() 才能继续。 二、sem_post 和 sem_wait 的配合逻辑 函数 含义 sem_post(rwem) 给信号量加1，表示“有资源了”或“可以继续了” sem_wait(rwem) 阻塞等待信号量值0，然后减1，表示“我来用这个资源” 总体步骤： 步骤 函数 示例 初始化 sem_init(rwem, 0, 0); 启动阶段 发送信号（通知） sem_post(rwem); 接收线程收到数据时 等待信号 sem_wait(rwem); 处理线程等待数据 销毁 sem_destroy(rwem); 程序结束或退出登录时 由于登录成功和注册成功的消息的收取是在主线程进行的，其他信息的收取是在另一个进程中，所以我要修改代码，把登录和注册的回复消息由接受进程收取。 首先在客户端main函数中连接服务器端成功后，插入 // 初始化读写线程通信用的信号量sem_init(rwem, 0, 0);// 连接服务器成功，启动接受线程std::thread readTask(readTaskHandler, clientfd); // 在Linux pthread_createreadTask.detach(); 在登录时向服务端发送登录消息后，插入 sem_wait(rwem); // 等待信号量，由子线程处理完登录的响应消息后，通知这里g_isLoginSuccess = false; sem_wait(rwem); 是为了接受线程消息处理好后会sem_post(rewm)，主线程接受到信号进行往下走。 g_isLoginSuccess时为了确认登录是否成功，如不成功，就进入首页面，成功进主菜单页面。 if (g_isLoginSuccess) // 进入聊天主菜单页面 isMainMenuRunning = true; mainMenu(clientfd); 注册就只需要等待信号就可以了 sem_wait(rwem); // 等待信号量，由子线程处理完注册的响应消息后，通知这里 在退出业务记得把信号回收 sem_destroy(rwem); 在接受线程里 if (LOGIN_MSG_ACK == msgtype) doLoginResponse(js); // 处理登录响应的业务逻辑 sem_post(rwem); // 通知主线程，登录结果处理完成 continue; if (REG_MSG_ACK == msgtype) doRegResponse(js); sem_post(rwem); // 通知主线程，注册结果处理完成 continue; 当收到对应业务的消息，就执行对应逻辑。 // 处理登录响应的业务void doLoginResponse(json responsejs) if (responsejs[errno] != 0) cerr responsejs[errmsg] endl; g_isLoginSuccess = false; else // 登录成功 // 记录当前用户的id和name g_currentUser.setId(responsejs[id]); g_currentUser.setName(responsejs[name]); // 记录当前用户的好友列表信息 if (responsejs.contains(friends)) // 初始化 g_currentUserFriendList.clear(); // 看是否包含friends这个键 vectorstring vec = responsejs[friends]; for (string str : vec) json js = json::parse(str); User user; user.setId(js[id]); user.setName(js[name]); user.setState(js[state]); g_currentUserFriendList.push_back(user); // 记录当前用户的群组列表信息 if (responsejs.contains(groups)) // 初始化 g_currentUserGroupList.clear(); vectorstring vec1 = responsejs[groups]; for (string groupstr : vec1) json grpjs = json::parse(groupstr); Group group; group.setId(grpjs[id]); group.setName(grpjs[groupname]); group.setDesc(grpjs[groupdesc]); vectorstring vec2 = grpjs[users]; for (string userstr : vec2) GroupUser user; json js = json::parse(userstr); user.setId(js[id]); user.setName(js[name]); user.setState(js[state]); user.setRole(js[role]); group.getUsers().push_back(user); g_currentUserGroupList.push_back(group); // 显示登录用户的基本信息 showCurrentUserData(); // 显示当前用户的离线消息 个人聊天消息或者群组消息 if (responsejs.contains(offlinemsg)) vectorstring vec = responsejs[offlinemsg]; for (string str : vec) json js = json::parse(str); // time +[id]+name+said: +xxx if (ONE_CHAT_MSG == js[msgid].getint()) cout js[time].getstring() [ js[id] ] js[name].getstring() said: js[msg].getstring() endl; else cout 群消息[ js[groupid] ]: js[time].getstring() [ js[id] ] js[name].getstring() said: js[msg].getstring() endl; g_isLoginSuccess = true; 当然，在登陆成功后记得把g_isLoginSuccess置为true。 // 处理注册响应的业务void doRegResponse(json responsejs) if (0 != responsejs[errno]) // 注册失败 cerr name is already exist,register error! endl; else // 注册成功 cout name register success,userid is responsejs[id] , do not forget it! endl; 这样就把这个问题解决了。","tags":["C++ chatserver"],"categories":["c++实现集群聊天服务器"]},{"title":"关于","path":"/about/index.html","content":"你好，我是 Jun Cen，目前专注于 C++ 开发、前端技术和 AI 应用研究。我喜欢分享，也乐于从开源项目中汲取灵感。 solar:github-bold-duotoneGitHub solar:home-bold-duotone博客主页"},{"title":"友情链接","path":"/friends/index.html","content":"🤝 我的友链 Hexo 官方 Stellar 主题作者 xaoxuu GitHub 想互换友链？欢迎通过邮件或评论联系我！"},{"title":"更多","path":"/more/index.html","content":"更多内容关于 solar:link-bold-duotone友链 欢迎浏览更多页面。"}]