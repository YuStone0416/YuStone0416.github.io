[{"title":"数据结构100题","url":"/2025/06/03/data-structure-100.html","content":"两数之和题目描述​\t\t 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums &#x3D; [2,7,11,15], target &#x3D; 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。\n\n示例 2：\n输入：nums &#x3D; [3,2,4], target &#x3D; 6\n输出：[1,2]\n\n示例 3：\n输入：nums &#x3D; [3,3], target &#x3D; 6\n输出：[0,1]\n\n思路：具体思路：首先使用unordered_map，在遍历原数组时，边查边找。\n如果没找到，就把当前值的值和下标存入unordered_map，以便下次寻找可以搜素以前的键值对，看是否有满足情况（target-nums[i]）的key,若有，取出对应的value(iter-&gt;second)和当前的数组下标一起返回。当然最坏的情况，遍历完了，也没有符合情况的出现。可以直接返回空。\nstd::unordered_map的核心特性：1. 基于哈希表实现（Hash Table）\n\nunordered_map 通过哈希函数（std::hash）将键（key）映射到一个桶（bucket）中，实现常数时间复杂度（O(1)）的查找、插入和删除操作（平均情况）。\n哈希冲突通过链表（或更优化的结构）解决。\n\n\n\n键唯一（Key is Unique）\n\n\n每个键（key）在 unordered_map 中必须是唯一的，如果插入相同键，会覆盖原有值或插入失败（取决于操作方式）。\n\n\n3. 无序（Unordered）\n\n元素的存储顺序不保证稳定性或有序性，与插入顺序无关。\n如果需要有序容器，应使用 std::map。\n\n\n4. 自动扩容\n\nunordered_map 会根据负载因子（load factor）自动扩展桶的数量，以保持操作效率。\n用户可以手动调整负载因子和桶数量（如 rehash() 或 reserve() 函数）。\n\n\n5. 允许自定义哈希函数与相等比较器\n\n支持用户为自定义类型指定哈希函数（通过模板参数 Hash 和 KeyEqual）。\n\ncpp\n\n\n复制编辑\nstd::unordered_map&lt;MyType, int, MyHash, MyEqual&gt;\n\n 6. 快速访问接口\n\noperator[]：快速访问键对应的值，如果键不存在，则自动插入默认值。\nfind()：返回一个迭代器，指向查找到的键值对，否则为 end()。\n\n\n7. 不支持排序算法\n\n由于无序存储，标准排序算法（如 sort）不能直接应用于 unordered_map，但可以通过将其内容复制到 vector&lt;pair&lt;&gt;&gt; 后排序实现。\n\n\n8. 多线程下非线程安全\n\n多线程环境下访问 unordered_map 必须加锁或使用线程安全容器。\n\n代码块class Solution &#123;\npublic:\n    vector&lt;int> twoSum(vector&lt;int>&amp; nums, int target) &#123;\n        std::unordered_map&lt;int,int> map;\n        for(int i=0;i&lt;nums.size();i++)&#123;\n            auto iter =map.find(target-nums[i]);\n            if(iter!=map.end())&#123;\n                return &#123;i,iter->second&#125;;\n            &#125;\n            map.insert(pair&lt;int,int>(nums[i],i));\n        &#125;\n        return &#123;&#125;;\n    &#125;\n&#125;;\n\n\n\n时间复杂度：\n一次遍历 nums 数组，时间是 O(n)。\n对于每个元素：\nmap.find(...) 查找操作的平均时间复杂度是 **O(1)**。\nmap.insert(...) 插入操作的平均时间复杂度也是 **O(1)**。\n\n\n\n因此，总体时间复杂度是：\n**O(n)**（n 是数组中元素的数量）\n空间复杂度：\n最多会向 unordered_map 中插入 n 个元素（每个 nums[i] 和其索引 i）。\n所以空间复杂度与 nums 的大小成正比。\n\n**O(n)**（额外使用了哈希表来存储 n 个键值对）\n字母异位词分组题目描述：给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1:\n输入: strs &#x3D; [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]\n输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]\n\n示例 2:\n输入: strs &#x3D; [&quot;&quot;]\n输出: [[&quot;&quot;]]\n\n示例 3:\n输入: strs &#x3D; [&quot;a&quot;]\n输出: [[&quot;a&quot;]]\n\n提示：\n\n1 &lt;= strs.length &lt;= 104\n0 &lt;= strs[i].length &lt;= 100\nstrs[i] 仅包含小写字母\n\n思路具体思路：​\t\t首先使用std::unordered_map结构，当然不用再介绍了。这个题的意思是把那些排序之后相同的单词放在一个组合。\n所以我们可以先使用unordered_map&lt;string,vector&gt;存储键值对，键就是排序之后的单词，毕竟排序之后都一样。\n键对应的值就是对应的单词（排序相同的单词），最后再遍历这个unordered_map，输出结果。\n代码块：class Solution &#123;\npublic:\n    vector&lt;vector&lt;string>> groupAnagrams(vector&lt;string>&amp; strs) &#123;\n        //做这道题首先对于字母异位词 排序之后是相同的，所以可以用一个哈希表，键存储排序后的结果，值为结果集\n        std::unordered_map&lt;string,vector&lt;string>> record;\n        for(int i=0;i&lt;strs.size();i++)&#123;\n            string temp=strs[i];\n            sort(temp.begin(),temp.end());\n            record[temp].emplace_back(strs[i]);\n\n        &#125;\n        vector&lt;vector&lt;string>> ans;\n        for(auto it=record.begin();it!=record.end();it++)&#123;\n            ans.emplace_back(it->second);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n\n时间复杂度：假设：\n\nn 是字符串数组 strs 的长度。\nk 是每个字符串的平均长度。\n\n\n遍历 strs 中的每个字符串，共 n 次。\n对每个字符串排序：O(k log k)\n哈希表插入&#x2F;查找键值对：O(1) 平均时间。\n\n所以总时间复杂度为：\nO(n * k log k)\n空间复杂度：\n哈希表 record 最多存 n 个键，每个键存一个 vector&lt;string&gt;，整体字符串内容不变，只是重新组织。\n排序后的中间变量 temp 的开销为 O(k)，共用一次。\n最终结果 ans 存储所有原字符串内容。\n\n所以额外空间主要包括：\n\n哈希表键（排序后的字符串）：最多 n 个，每个长度为 k：O(n * k)\n哈希表值（字符串集合）：整体还是输入的字符串，只是重新组织，不算重复存储\n排序的临时变量（重复使用）：忽略不计\n\n因此总空间复杂度为：\nO(n * k)\n最长连续序列题目描述：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n请你设计并实现时间复杂度为 O(n) 的算法解决此问题。\n示例 1：\n输入：nums &#x3D; [100,4,200,1,3,2]\n输出：4\n解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n\n示例 2：\n输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]\n输出：9\n\n示例 3：\n输入：nums &#x3D; [1,0,1,2]\n输出：3\n\n思路：具体思路：​\t\t首先将数组存入unordered_set中避免重复，为什么用unordered_set，因为找元素它是O(1)。\n接下来遍历unordered_set，先判断当前元素有没有前一个连续的元素（例子：当前元素为5，查是否有4），有则跳过，没有则进行下一步，并且这个节点是作为开始节点。\n然后先保存当前节点的值和连续序列的长度（这个时候为1），然后循环查找连续序列，最后获得连续序列的长度，再和历史最长连续序\n列比较，更新历史最长连续序列。遍历完unordered_set，返回历史最长连续序列即可。\nstd::unordered_set的特性：std::unordered_set 是 C++ 标准库中提供的 无序集合容器，它内部基于哈希表实现，主要用于快速判断一个元素是否存在，并确保元素唯一。下面是它的详细特性：\n\n1. 元素唯一（Unique Elements）\n\n它是一个 集合（set），不允许重复元素。\n插入相同元素将失败，已有的不会被替换。\n\n\n2. 基于哈希表（Hash Table）\n\n内部使用哈希表存储元素。\n插入、查找、删除的**平均时间复杂度是 O(1)**，非常高效。\n如果发生大量哈希冲突，最坏情况会退化为 O(n)，但 STL 默认哈希函数表现良好，一般不会发生。\n\n\n3. 元素无序（Unordered）\n\n和 std::set（基于红黑树，有序）不同，unordered_set 中的元素存储顺序不固定。\n遍历时元素的顺序是哈希桶顺序，不可预测。\n\n\n4. 可自定义哈希函数（支持自定义类型）\n\n可以为自定义类型提供哈希函数和等价比较函数。\n\nstd::unordered_set&lt;MyType, MyHash, MyEqual>\n\n\n5. 常用操作和函数\n\n\n\n函数\n功能\n\n\n\ninsert(val)\n插入元素，若已存在则不插入\n\n\nerase(val)\n删除元素\n\n\nfind(val)\n查找元素，返回迭代器\n\n\ncount(val)\n判断元素是否存在（返回 0 或 1）\n\n\nsize()\n元素个数\n\n\nempty()\n是否为空\n\n\nclear()\n清空所有元素\n\n\nbegin(), end()\n返回迭代器（可用于范围遍历）\n\n\n\n5.与 std::set 的区别\n\n\n\n特性\nstd::set（有序）\nstd::unordered_set（无序）\n\n\n\n底层结构\n红黑树（平衡 BST）\n哈希表\n\n\n元素是否有序\n是\n否\n\n\n查找&#x2F;插入效率\nO(log n)\n平均 O(1)\n\n\n内存使用\n较少\n较多（需额外存哈希结构）\n\n\n自定义排序\n支持\n不支持\n\n\n代码块：class Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int>&amp; nums) &#123;\n        unordered_set&lt;int> num_set;\n        //使用unordered_set存储nums的所有值\n        for(const int &amp;num:nums)&#123;\n            num_set.insert(num);\n        &#125;\n        int longSum=0;\n        for(const int &amp;num:num_set)&#123;\n            //上述遍历用nums和num_set有什么区别，在leetcode一个能过一个不能过\n            //以遍历的每个元素为起点，满足才进行下一步操作\n            if(!num_set.count(num-1))&#123;\n                //满足条件后，存储当前节点的信息\n                int currentNum=num;\n                int currentSum=1;\n                //寻找该节点的最长连续序列\n                while(num_set.count(currentNum+1))&#123;\n                    currentNum=currentNum+1;\n                    currentSum+=1;\n                &#125;\n                //最后与longSum比较，更新历史最长连续序列\n                longSum=max(currentSum,longSum);\n            &#125;\n        &#125;\n        return longSum;\n    &#125;\n&#125;;\n\n编写代码产生的问题：上述遍历用nums和num_set有什么区别，在leetcode一个能过一个不能过\n遍历 num_set：\n\n每个元素最多只被作为“起点”处理一次。\n例如：对于序列 [100, 101, 102, 103]，只有 100 会进入 while 循环处理。\n其他如 101、102 在 if (!num_set.count(num - 1)) 时会被跳过（因为 100 已经处理了它们）。\n所以是 O(n) 时间复杂度。\n\n遍历 nums：\n\nnums 可能包含重复值，也可能无序。\n比如你在 nums 中遇到 102，它不是起点，但你仍会试图查找连续数字，造成重复计算。\n重复调用 count()，浪费性能，导致 超时 或 错误结果（重复统计）。\n\n时间复杂度：设输入数组 nums 的长度为 n。\n\nunordered_set 插入 n 个元素：**O(n)**（平均时间，插入是 O(1)）。\n第二个循环遍历 num_set 中的每个元素，每个连续序列只处理一次。\n\nif (!num_set.count(num - 1))\n\n\n这个判断确保每个序列的起点只会被处理一次。\n例如序列 [100, 101, 102, 103] 只会从 100 开始处理一次，不会在遍历到 101 时重复处理。\n\n因此：\n**总时间复杂度：O(n)**（哈希表操作均为 O(1) 平均时间）\n空间复杂度：\n使用了一个 unordered_set 存储 n 个整数，占用 O(n) 的空间。\n其他变量如 currentNum, currentSum 等为常数空间。\n\n因此：\n总空间复杂度：O(n)\n移动零题目描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n输入: nums &#x3D; [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n示例 2:\n输入: nums &#x3D; [0]\n输出: [0]\n\n思路：具体思路：​\t\t我们可以采用双指针的方法，先left,right同时指向起始点，right到最后位置结束。当right找到非零节点，与left进行值交换，left只有交换结束才left++;这样最后非零节点都在前面，0都在末尾。\n代码块：class Solution &#123;\npublic:\n    void moveZeroes(vector&lt;int>&amp; nums) &#123;\n        int n=nums.size(),left=0,right=0;\n        while(right&lt;n)&#123;\n            if(nums[right])&#123;\n                swap(nums[left],nums[right]);\n                left++;\n            &#125;\n            right++;\n        &#125;\n    &#125;\n&#125;;\n\n\n\n时间复杂度：\nright 从 0 遍历到 n-1，每个元素访问一次。\n最多发生 n 次 swap 操作（每个非零元素最多被交换一次）。\n所以：\n\n总时间复杂度：O(n)\n空间复杂度：\n只使用了常量级别的辅助变量 left 和 right。\n所有操作都在原数组上进行，原地修改，没有开辟额外数组。\n\n总空间复杂度：O(1)\n盛最多水的容器题目描述：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n说明：你不能倾斜容器。\n示例 1：\n\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49 \n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n示例 2：\n输入：height &#x3D; [1,1]\n输出：1\n\n思路：具体思路：​\t\t我们采用双指针的方式求解。这个题目的是求解柱子之间的最大面积。我们可以采用将两个指针放在两端，如果左边的柱子高度大于或等于右边的柱子高度，我们先算出容器对应的面积（高度以低柱子为准）。算出后更新历史最大面积。执行完，将右边的柱子向左移动。同时，还有一种情况，左边的柱子高度小于右边的柱子高度，先算出容器对应的面积（高度以低柱子为准）。算出后更新历史最大面积。执行完，将左边的柱子向右移动。直到当前的左柱子和右柱子重合。\n代码块：class Solution &#123;\npublic:\n    int maxArea(vector&lt;int>&amp; height) &#123;\n        int ans=0;\n        //采用双指针的方式求解\n        int left=0;\n        int right=height.size()-1;\n        while(left&lt;right)&#123;\n            if(height[left]>=height[right])&#123;\n                ans=max(ans,(right-left)*height[right]);\n                right--;\n            &#125;else&#123;\n                ans=max(ans,(right-left)*height[left]);\n                left++;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n\n\n\n时间复杂度：时间复杂度：O(n)\n\n解释：使用的是双指针方法，从两端向中间遍历整个数组，每一次迭代都会移动左指针或右指针之一，因此总共最多移动 n-1 次。\n所以时间复杂度是 **线性的 O(n)**，其中 n 是 height 数组的长度。\n\n空间复杂度：空间复杂度：O(1)\n\n解释：只使用了常数个额外变量（如 ans, left, right, h, w），不依赖于输入数据的大小。\n因此空间复杂度是 **常数级 O(1)**。\n\n三数之和题目描述：给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n示例 1：\n输入：nums &#x3D; [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。\nnums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。\nnums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n\n示例 2：\n输入：nums &#x3D; [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。\n\n示例 3：\n输入：nums &#x3D; [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。 \n\n思路：具体思路：​\t\t这题的目标是在在整数数组中，找到所有三个数满足和为零，最后结果不可以重复。这个题我们可以先定下一个值，剩下两个值用双指针法遍历，找到符合结果的。还有一些细节，还要考虑不能重复的问题，对于这个问题，我们可以先排序（升序）这个数组，从小到大定第一个值，首先如果这第一个值大于0，这个可以结束了，这个数组就不会存在符合条件的三元组。当然如果当前元素与上一个元素相同，也跳过，这样执行，首先我想的是定第一个元素，当当前元素和下一个元素相同直接跳过，后来发现，[-1,-1,2]这种情况没有考虑。当然那你为甚么还是要写当前元素与上一个元素相同，也跳过，我完全可以不管嘛，那不行，我的思路是当第一个元素是-1时，这一次直接找出所有符合第一个元素是-1的情况，要不然会十分混乱，所以我会说如果当前元素与上一个元素相同，也跳过。因为上一个元素已经找完了第一个元素为-1的三元组了，当避免找完-1还会再出现，我们用了排序。这样第一个元素的逻辑就结束了，接下来找剩下两个，用双指针，左指针指向当前元素的下一个元素，右指针指向末尾元素。我们是要找到所有符合情况，当三元组的值大于0，将右指针左移。当三元组的值小于0，将左指针右移。当三元组的值等于0，将三元组的值加入结果集。接下来再判断找到的左元素是否与后面的元素重复（因为是排序的，相同的元素就在身边）。跳过这些元素，找到的右元素是否与后面的元素重复（因为是排序的，相同的元素就在身边）。跳过这些元素。只要左指针和右指针没有重合，就一直找，找完符合情况的三元组。\n代码块：class Solution &#123;\npublic:\n    vector&lt;vector&lt;int>> threeSum(vector&lt;int>&amp; nums) &#123;\n        vector&lt;vector&lt;int>> ans;\n        //先升序排序\n        sort(nums.begin(),nums.end());\n        //遍历排序后的数组\n        for(int i=0;i&lt;nums.size();i++)&#123;\n            //先定第一个元素\n            //第一个元素大于0,因为是升序排序，后面都大于零，那没有满足条件的结果了\n            if(nums[i]>0) break;\n            //如果上一个元素相同，跳过当前，用下一个\n            if(i>0 &amp;&amp; nums[i]==nums[i-1]) continue;\n            //采用双指针定剩下两个\n            int left=i+1;\n            int right=nums.size()-1;\n            while(left&lt;right)&#123;\n                if(nums[i]+nums[left]+nums[right]>0) right--;\n                else if(nums[i]+nums[left]+nums[right]&lt;0) left++;\n                else if(nums[i]+nums[left]+nums[right]==0)&#123;\n                    ans.push_back(&#123;nums[i],nums[left],nums[right]&#125;);\n                    //下面判断是否有相同的，避免重复\n                    while(left&lt;right &amp;&amp; nums[left]==nums[left+1])left++;\n                    while(left&lt;right &amp;&amp; nums[right]==nums[right-1]) right--;\n                    left++;\n                    right--;\n                &#125;\n            &#125;\n\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n\n\n\n时间复杂度： 时间复杂度：O(n^2)\n详细分析：\n\n外层循环遍历数组中的每个数作为固定值 nums[i]，这部分是 O(n)。\n\n内层使用双指针 left 和 right 来查找另外两个数，最坏情况下每次都需要遍历一次剩余数组，即 O(n)。\n\n所以总的时间复杂度是：\nO(n^2)\n\n\n去重操作的影响：\n\n去重操作使用的是 while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) 这类逻辑，在最坏情况下最多也只是跳过相同元素，不改变主导复杂度。\n\n空间复杂度：空间复杂度：O(1)（不计输出）\n解释：\n\n如果不考虑返回结果 ans 所占用的空间（即题目允许将返回值空间复杂度忽略），则使用的额外空间为：\n排序使用的可能是原地排序（如 std::sort），**空间复杂度为常数级 O(1)**。\n其他仅使用了一些指针和变量，都是常数级空间。\n\n\n如果 将返回结果的空间也算入，最坏情况是 O(k)，其中 k 是满足条件的三元组个数。\n\n接雨水题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1：\n\n输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n示例 2：\n输入：height &#x3D; [4,2,0,3,2,5]\n输出：9\n\n思路：具体思路：这里采用的是动态规划解法，还有其他方法。动态规划解法，需要构造两个数组分别储存各个节点的左边最大高度和右边最大高度，便于计算当前节点所积水高度。问题在于左边和右边最大高度该如何获取。最左边的左边最大高度就是它自身，最右边的右边最大高度就是它自身，以这两个边界条件，左边最大高度就是当前节点的左边节点的左边最大高度和当前节点的高度的最大值，右边最大高度也是一样。求解出放入之前的两个数组中。已知这两个数组，可以遍历这两个数组，把当前节点的积水量算出，再累加一起，就是所求的雨水量。\n代码块class Solution &#123;\npublic:\n    int trap(vector&lt;int>&amp; height) &#123;\n        //这题采用动态规划\n        int n=height.size();\n        if(n==0)&#123;\n            return 0;\n        &#125;\n        vector&lt;int> leftMax(n);\n        vector&lt;int> rightMax(n);\n        leftMax[0]=height[0];\n        rightMax[n-1]=height[n-1];\n\n        for(int i=1;i&lt;n;i++)&#123;\n            leftMax[i]=max(leftMax[i-1],height[i]);\n        &#125;\n        for(int i=n-2;i>=0;i--)&#123;\n            rightMax[i]=max(rightMax[i+1],height[i]);\n        &#125;\n        int ans=0;\n        for(int i=0;i&lt;n;i++)&#123;\n            ans+=min(leftMax[i],rightMax[i])-height[i];\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n\n\n\n时间复杂度：时间复杂度：O(n)\n\n遍历了三次数组：\n\n构造 leftMax：O(n)\n构造 rightMax：O(n)\n遍历一次计算总雨水量：O(n)\n\n\n所以总时间复杂度是：\nO(n)\n\n\n空间复杂度：空间复杂度：O(n)\n\n使用了两个辅助数组：\nleftMax：大小为 n\nrightMax：大小为 n\n\n\n所以额外空间是 2n，即 O(n) 空间复杂度。\n\n无重复字符的最长子串题目描述：给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。\n示例 1:\n输入: s &#x3D; &quot;abcabcbb&quot;\n输出: 3 \n解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n\n示例 2:\n输入: s &#x3D; &quot;bbbbb&quot;\n输出: 1\n解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n\n示例 3:\n输入: s &#x3D; &quot;pwwkew&quot;\n输出: 3\n解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。\n\n\n\n思路：具体思路：我们使用滑动窗口和哈希表实现这个题目。哈希表存储枚举值的下标，初始值为-1，j值在没有重合的情况下，会在每次循环+1，但是如果遇到重合，j值会跑到对应的下标位置之后的位置（下标位置存储在哈希表中）。只要有重合就调整窗口。\n代码块：class Solution &#123;\npublic:\n    int lengthOfLongestSubstring(string s) &#123;\n        //滑动窗口和哈希表\n        vector&lt;int> pos(128,-1);\n        int ans=0;\n        //j为滑动窗口的起始节点\n        for(int i=0,j=0;i&lt;s.size();i++)&#123;\n            j=max(j,pos[s[i]]+1);\n            ans=max(ans,i-j+1);\n            pos[s[i]]=i;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n\n\n\n时间复杂度：时间复杂度：O(n)\n\n其中 n 是字符串 s 的长度。\n每个字符最多访问两次（一次作为右指针扩展窗口，一次作为左指针缩小窗口）。\n所以整体是线性时间复杂度 O(n)。\n\n空间复杂度：空间复杂度：O(1)\n\n使用了一个 pos 数组来记录 ASCII 字符上次出现的位置，长度是固定的 128（ASCII 字符集）。\n即使改成 256（扩展 ASCII）或 100,000（Unicode 范围），只要是定长的字符集，空间复杂度都是 O(1) 常数级。\n如果字符集不固定，比如用 unordered_map&lt;char, int&gt;，那空间复杂度是 O(k)，其中 k 是字符集大小。\n\n找到字符串中所有字母异位词题目描述：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n示例 1:\n输入: s &#x3D; &quot;cbaebabacd&quot;, p &#x3D; &quot;abc&quot;\n输出: [0,6]\n解释:\n起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。\n起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。\n\n 示例 2:\n输入: s &#x3D; &quot;abab&quot;, p &#x3D; &quot;ab&quot;\n输出: [0,1,2]\n解释:\n起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。\n起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。\n起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。\n\n思路：具体思路：这道题的整体思路是让我找到对应字符串的所有异位词在一个陌生的字符串里。这里要解决两个问题，首先是异位词问题，找异位词可以通过枚举法，总共26个字母，我们通过数组存储使用字母的个数，最后对比，如果数组相等，就说明是异位词。还有一个问题：在陌生字符串找到所有的异位词，并且返回索引，找异位词是一个范围问题，所以我要使用流动窗口，大小就是对应字符串的大小。在陌生字符串扫描。最后返回结果。\n代码块：class Solution &#123;\npublic:\n    vector&lt;int&gt; findAnagrams(string s, string p) &#123;\n        &#x2F;&#x2F;首先记录两字符串的长度\n        int sLen&#x3D;s.size(),pLen&#x3D;p.size();\n        &#x2F;&#x2F;如果字符串s的长度还不比p字符串长\n        if(sLen&lt;pLen)&#123;\n            return vector&lt;int&gt;();\n        &#125;\n        &#x2F;&#x2F;记录结果\n        vector&lt;int&gt; ans;\n        &#x2F;&#x2F;记录s字符串和p字符串的字母对应的个数，枚举法\n        vector&lt;int&gt; sletter(26);\n        vector&lt;int&gt; pletter(26);\n        &#x2F;&#x2F;先试试索引为0的\n        for(int i&#x3D;0;i&lt;pLen;i++)&#123;\n            ++sletter[s[i]-&#39;a&#39;];\n            ++pletter[p[i]-&#39;a&#39;];\n        &#125;\n        &#x2F;&#x2F;如果符合，说明索引为0符合情况\n        if(sletter&#x3D;&#x3D;pletter)&#123;\n            ans.emplace_back(0);\n        &#125;\n        &#x2F;&#x2F;之后按照索引为1往后遍历，采取流动窗口,把前一次的流动窗口的第一个去掉，再往后补一个，形成新的流动窗口.\n        &#x2F;&#x2F;注意这里是按流动窗口为整体，上面的循环是为了形成流动窗口。\n        for(int i&#x3D;0;i&lt;sLen-pLen;i++)&#123;\n            --sletter[s[i]-&#39;a&#39;];\n            ++sletter[s[i+pLen]-&#39;a&#39;];\n\n            if(sletter&#x3D;&#x3D;pletter)&#123;\n            ans.emplace_back(i+1);\n        &#125;\n        &#125;\n        \n        return ans;\n    &#125;\n&#125;;\n\n\n\n时间复杂度：\n初始化部分：O(p)\n滑动窗口：O(n)\n\n由于通常 p 比 n 小，所以总时间复杂度是：O(n)\n空间复杂度：\n使用了两个长度为 26 的数组：sletter, pletter；\n还使用了一个结果数组 ans，最坏情况下长度也是 O(n)；\n\n因此：\n空间复杂度是 O(1) + O(k)，其中 k 是结果中异位词的数量，通常最多为 O(n)。\n和为 K 的子数组题目描述：给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。\n子数组是数组中元素的连续非空序列。\n示例 1：\n输入：nums &#x3D; [1,1,1], k &#x3D; 2\n输出：2\n\n示例 2：\n输入：nums &#x3D; [1,2,3], k &#x3D; 3\n输出：2\n\n思路：具体思路：这里采取两个方法，第一种方法就是枚举法，暴力轮询。（为什莫要两种，因为我第一种leetcode超时了）。\n方法二：首先通过前缀和这个点，定义 pre[i] 为 [0..i] 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：pre[i]&#x3D;pre[i−1]+nums[i]那么[j..i] 这个子数组和为 k 这个条件我们可以转化为pre[i]−pre[j−1]&#x3D;&#x3D;k简单移项可得符合条件的下标 j 需要满足pre[j−1]&#x3D;&#x3D;pre[i]−k所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。建立以上条件，我们的问题就简化为寻找有多少个符合条件的pre[j]即可，我们建立哈希表，键是前缀和，值是前缀和重复的个数。在遍历的过程中，pre存储当前的前缀和，先不放进哈希表中，先在哈希表中查找是否有键pre-k,有的话，就取出对应的值加到count里，不管找没找到，都要将当前的前缀和存到哈希表中。这代码的逻辑是基于前缀和得出的只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。\n代码块：方法一：枚举法\nclass Solution &#123;\npublic:\n    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;\n        &#x2F;&#x2F;这题我们采用枚举法\n        int count&#x3D;0;&#x2F;&#x2F;返回的结果值\n        int n&#x3D;nums.size();\n        for(int start&#x3D;0;start&lt;n;++start)&#123;\n            int sum&#x3D;0;\n            for(int end&#x3D;start;end&lt;n;++end)&#123;\n                sum+&#x3D;nums[end];\n                if(sum&#x3D;&#x3D;k)&#123;\n                    count++;\n                &#125;\n            &#125;\n        &#125;\n        return count;\n    &#125;\n&#125;;\n\n方法二：前缀和+哈希表优化\nclass Solution &#123;\npublic:\n    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;\n        &#x2F;&#x2F;前缀和+哈希表优化\n        unordered_map&lt;int,int&gt; mp;\n        mp[0]&#x3D;1;&#x2F;&#x2F;初始前缀和的个数为1\n        int count&#x3D;0,pre&#x3D;0;&#x2F;&#x2F;count是返回结果的，pre是前缀和\n        for(auto &amp;temp:nums)&#123;\n            pre+&#x3D;temp;\n            if(mp.find(pre-k)!&#x3D;mp.end())&#123;\n                count+&#x3D;mp[pre-k];\n            &#125;\n            mp[pre]++;\n        &#125;\n        return count;\n    &#125;\n&#125;;\n\n时间复杂度：方法一：\n时间复杂度：O(n²)\n方法二：\nO(n) 时间\n空间复杂度：方法一：\n空间复杂度：O(1)\n方法二：\n**O(n)**（最坏情况下所有前缀和都不相同，哈希表大小为 n）\n","categories":["计算机学习"],"tags":["data structure"]},{"title":"c++实现集群聊天服务器","url":"/2025/06/02/C++-chatserver.html","content":"json学习#include \"json.hpp\"\nusing json=nlohmann::json;\n\n使用json,要包含json的头文件 ，方便使用可以重命名nlohmann::json为json。\n//json序列化示例1\nstd::string func1()&#123;\n    json js;\n    js[\"msg_type\"]=2;\n    js[\"from\"]=\"zhang san\";\n    js[\"to\"] = \"li si\";\n    js[\"msg\"]=\"hello,what are you doing now\";\n    std::string sendBuf=js.dump();\n    std::cout&lt;&lt;sendBuf.c_str()&lt;&lt;std::endl;\n    return sendBuf;\n&#125;\n\njs使用很像键值对。js.dump()是 nlohmann::json库中用于将 JSON 对象序列化（转为字符串）的方法，它会把一个 json类型的变量转换成 JSON 格式的字符串。\nstd::string recvBuf= func1();\n   //数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）\n   json jsbuf=json::parse(recvBuf);\n   std::cout&lt;&lt;jsbuf[\"msg_type\"]&lt;&lt;std::endl;\n   std::cout&lt;&lt;jsbuf[\"from\"]&lt;&lt;std::endl;\n   std::cout&lt;&lt;jsbuf[\"to\"]&lt;&lt;std::endl;\n   std::cout&lt;&lt;jsbuf[\"msg\"]&lt;&lt;std::endl;\n\n这是main函数中执行。json::parse() 是 nlohmann::json 库中用来将 JSON 字符串 → JSON 对象 的函数，也就是实现反序列化。\n转化为json对象后使用对应的键可以把对应的值取出来。结果：\n&#123;&quot;from&quot;:&quot;zhang san&quot;,&quot;msg&quot;:&quot;hello,what are you doing now&quot;,&quot;msg_type&quot;:2,&quot;to&quot;:&quot;li si&quot;&#125;\n2\n&quot;zhang san&quot;\n&quot;li si&quot;\n&quot;hello,what are you doing now&quot;\n\n//json序列化示例2\nstd::string func2()&#123;\n    json js;\n    //添加数组\n    js[\"id\"]=&#123;1,2,3,4,5&#125;;\n    //添加key-value\n    js[\"name\"]=\"zhang san\";\n    //添加对象\n    js[\"msg\"][\"zhang san\"]= \"hello world\";\n    js[\"msg\"][\"liu shuo\"] =\"hello china\";\n    //上面等同下面这句一次性添加数组对象\n    js[\"msg\"]=&#123;&#123;\"zhang san\",\"hello world\"&#125;,&#123;\"liu shuo\",\"hello china\"&#125;&#125;;\n    std::cout&lt;&lt;js&lt;&lt;std::endl;\n    return js.dump();\n&#125;\n\njson还可以放数组，还可以嵌套json语句。\nstd::string recvBuf= func2();\n    //数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）\n    json jsbuf=json::parse(recvBuf);\n    std::cout&lt;&lt;jsbuf[\"id\"]&lt;&lt;std::endl;\n    auto arr=jsbuf[\"id\"];\n    std::cout&lt;&lt;arr[2]&lt;&lt;std::endl;\n    auto msgjs=jsbuf[\"msg\"];\n    std::cout&lt;&lt;msgjs[\"zhang san\"]&lt;&lt;std::endl;\n    std::cout&lt;&lt;msgjs[\"liu shuo\"]&lt;&lt;std::endl;\n\n“id”存储的是一个数组，取出来还可以作为数组使用。“msg”存储的值还可以是json语句，并且可以进入再取里面的值。\n结果：\n&#123;&quot;id&quot;:[1,2,3,4,5],&quot;msg&quot;:&#123;&quot;liu shuo&quot;:&quot;hello china&quot;,&quot;zhang san&quot;:&quot;hello world&quot;&#125;,&quot;name&quot;:&quot;zhang san&quot;&#125;\n[1,2,3,4,5]\n3\n&quot;hello world&quot;\n&quot;hello china&quot;\n\n//json序列化示例3\nstd::string func3()&#123;\n    json js;\n    //直接序列化一个vector容器\n    std::vector&lt;int> vec;\n    vec.push_back(1);\n    vec.push_back(2);\n    vec.push_back(5);\n    js[\"list\"]=vec;\n    //直接序列化一个map容器\n    std::map&lt;int,std::string> m;\n    m.insert(&#123;1,\"黄山\"&#125;);\n    m.insert(&#123;2,\"华山\"&#125;);\n    m.insert(&#123;3,\"泰山\"&#125;);\n    js[\"path\"] =m;\n    std::string sendBuf =js.dump();//json数据对象->序列化json字符串\n    std::cout&lt;&lt;sendBuf&lt;&lt;std::endl;\n    return sendBuf;\n\n&#125;\n\n还可以序列化容器。\nstd::string recvBuf= func3();\n    //数据的反序列化 json字符串-》反序列化数据对象（看作容器，方便访问）\n    json jsbuf=json::parse(recvBuf);\n    std::vector&lt;int> vec =jsbuf[\"list\"];//js对象里面的数组类型，直接放入vector容器当中\n    for(int &amp;v:vec)&#123;\n        std::cout&lt;&lt;v&lt;&lt;\" \";\n    &#125;\n    std::cout&lt;&lt;std::endl;\n    std::map&lt;int,std::string> mymap=jsbuf[\"path\"];\n    for(auto &amp;p:mymap)&#123;\n        std::cout&lt;&lt;p.first&lt;&lt;\" \"&lt;&lt;p.second&lt;&lt;std::endl;\n    &#125;\n    std::cout&lt;&lt;std::endl;\n    return 0;\n\n结果：\n&#123;&quot;list&quot;:[1,2,5],&quot;path&quot;:[[1,&quot;黄山&quot;],[2,&quot;华山&quot;],[3,&quot;泰山&quot;]]&#125;\n1 2 5 \n1 黄山\n2 华山\n3 泰山\n\nmuduo网络库学习muduo 是一个现代 C++ 的非阻塞 I&#x2F;O 网络库，采用 Reactor 模式 + 多线程 + epoll + 定时器 + 高效缓冲区 + 智能指针设计，在性能和工程性方面都表现非常优秀。\n/*\nmuduo网络库给用户提供了两个主要的类\nTcpServer :用于编写服务器程序的\nTcpClient :用于编写客户端程序的\n\nepoll+线程池\n好处：能够把网络I/O的代码和业务代码区分开了\n业务代码 :用户的连接和断开 用户的可读写事件\n*/\n#include&lt;muduo/net/TcpServer.h>\n#include&lt;muduo/net/EventLoop.h>\n#include &lt;functional>\n#include &lt;iostream>\n#include &lt;string>\nusing namespace std;\nusing namespace muduo;\nusing namespace muduo::net;\nusing namespace placeholders;\n/*基于muduo网络库开发服务器程序\n1.组合TcpServer对象\n2.创建EventLoop事件循环对象的指针\n3.明确TcpServer构造函数需要什么参数，输出ChatServer的构造函数\n4.在当前服务器类的构造函数当中，注册处理连接的回调函数和处理读写事件的回调函数\n5.设置合适的服务端线程数量，muduo库会自己分配I/O线程和worker线程\n*/\nclass ChatServer&#123;\npublic:\n    ChatServer(EventLoop* loop,//事件循环\n            const InetAddress&amp; listenAddr,//ip+port\n            const string&amp; nameArg)//服务器的名字\n        :_server(loop,listenAddr,nameArg),_loop(loop)\n        &#123;\n            //给服务器注册用户连接的创建和断开回调\n            _server.setConnectionCallback(std::bind(&amp;ChatServer::onConnection,this,_1));            \n            //给服务器注册用户读写事件回调\n            _server.setMessageCallback(std::bind(&amp;ChatServer::onMessage,this,_1,_2,_3));\n            //设置服务器端的线程数量 1个I/o线程 3个worker线程\n            _server.setThreadNum(4);\n        &#125;\n        //开启事件循环\n        void start()&#123;\n            _server.start();\n        &#125;\nprivate:\n    //专门处理用户的连接创建和断开\n    void onConnection(const TcpConnectionPtr&amp;conn)&#123;\n        \n        if(conn->connected())&#123;\n            cout&lt;&lt;conn->peerAddress().toIpPort()&lt;&lt;\"->\"&lt;&lt;\n            conn->localAddress().toIpPort()&lt;&lt;\"state:online\"&lt;&lt;endl;\n        &#125;else&#123;//对方关闭连接或断开\n            cout&lt;&lt;conn->peerAddress().toIpPort()&lt;&lt;\"->\"&lt;&lt;\n            conn->localAddress().toIpPort()&lt;&lt;\"state:offline\"&lt;&lt;endl;\n            conn->shutdown(); //close(fd)//关闭连接\n            // _loop->quit();通常用于程序结束或手动控制关闭 Muduo\n            //loop->quit() 使loop.loop()不再阻塞。\n        &#125;\n    &#125;\n    //专门处理用户的读写事件\n    void onMessage(const TcpConnectionPtr&amp;conn,//连接\n                            Buffer* buffer,//缓冲区\n                            Timestamp time)//接受数据的时间信息\n    &#123;\n        //是一个指向 muduo::net::Buffer 对象的指针，用于暂存客户端发送的数据。\n\t\t//Muduo 采用 非阻塞、事件驱动的方式，当客户端发送数据时，数据先被读入 Buffer 中，之后由用户注册的回调函数（例如 \t\t\tonMessage）来处理。\n        //retrieveAllAsString()把缓冲区中的所有可读数据提取为一个 std::string，然后清空缓冲区。\n        string buf=buffer->retrieveAllAsString();\n        cout&lt;&lt;\"recv data:\" &lt;&lt;buf&lt;&lt;\"time:\"&lt;&lt;time.toString()&lt;&lt;endl;\n        conn->send(buf);//原封不动发回去                        \n    &#125;\n    muduo::net::TcpServer _server;\n    muduo::net::EventLoop *_loop;\n&#125;;\nint main()&#123;\n    EventLoop loop;//epoll\n    InetAddress addr(\"127.0.0.1\",6000);\n    ChatServer server(&amp;loop,addr,\"ChatServer\");\n    server.start();//listenfd epoll_ctl->epoll\n    loop.loop(); //epoll wait以阻塞方式等待新用户连接，已连接用户的读写事件等\n    return 0;\n&#125;\n\n先将bind函数讲清楚，\n基本格式\nstd::bind(&amp;类名::成员函数, 对象指针, 占位符参数...)\n\n所以：\nstd::bind(&amp;ChatServer::onConnection, this, _1)\n\n意思是：\n把当前对象（this）的 onConnection 成员函数绑定起来，形成一个可调用对象，并接受一个参数 _1。\n分解解释\n\n\n\n组件\n说明\n\n\n\n&amp;ChatServer::onConnection\n指向 ChatServer 类的成员函数 onConnection 的指针\n\n\nthis\n当前对象的指针，告诉 bind 这个函数是哪个对象的方法（即调用 this-&gt;onConnection）\n\n\n_1\n占位符，代表回调传入的第一个参数，实际调用时会被替换\n\n\n\n\n\n\n最终生成一个 std::function&lt;void(const TcpConnectionPtr&amp;)&gt; 类型的函数对象。\nCMakeList.txt学习主CMakeList.txt\ncmake_minimum_required(VERSION 3.10)\n\nproject(chat)\n\n#配置编译选项\nset(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)\n#配置最终的可执行文件输出的路径\nset(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;bin)\n#配置头文件搜索路径\ninclude_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)\ninclude_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include&#x2F;server)\n\n#加载子目录\nadd_subdirectory(src)\n\nsrc文件夹下的CMakeList.txt\nadd_subdirectory(server)\n\nsrc文件夹下的server文件夹下的CMakeList.txt\n#定义了SRC_LIST变量，包含了当前目录下的所有源文件\naux_source_directory(. SRC_LIST) #获取当前目录下所有源文件\n#指定生成可执行文件\nadd_executable(ChatServer $&#123;SRC_LIST&#125;)\n#指定可执行文件需要链接的库\ntarget_link_libraries(ChatServer muduo_net muduo_base pthread) #链接muduo库和pthread库\n\n项目常见的cmake指令使用步骤mkdir build\ncd build\ncmake ..\nmake         # 如果你使用的是 Unix&#x2F;Linux&#x2F;macOS，或者是 MinGW\n\n解释：\n\nmkdir build：创建构建目录（推荐 out-of-source build）\ncd build：进入构建目录\ncmake ..：执行 CMake，读取上一级目录的 CMakeLists.txt，生成构建系统（默认是 Makefile）\nmake：使用生成的 Makefile 编译项目\n\n集群聊天服务器项目目录\nbin文件夹编译完成后的 .exe（Windows）或无扩展的可执行文件。\nbuild文件夹通常用于存放 构建过程中产生的所有中间文件，它是整个编译流程的“临时工作区”。\ninclude文件夹存放头文件（Header Files），src文件夹是 C++ 项目中最常见也最核心的目录之一，用于存放 源代码实现文件（source files），主要是 .cpp 文件（也包括 .c, .cc, .cxx 等）。\ntest文件夹在 C++ 项目中用于存放测试代码，主要用于验证项目功能是否正确，确保每个模块在修改后仍然可以正常工作。\nthirdparty文件夹在 C++ 项目中用于存放第三方依赖库的源码或接口文件。在这里存储了json.hpp文件。\nCMakeLists.txt文件存放和使用CMakeLists.txt文件放在了主目录，src文件夹里，src&#x2F;server文件夹里，接下来分别说明对应文件夹中CMakeLists.txt的作用。\n主目录文件夹\ncmake_minimum_required(VERSION 3.10)\n\nproject(chat)\n\n#配置编译选项\nset(CMAKE_CXX_FLAGS $&#123;CMAKE_CXX_FLAGS&#125; -g)\n#配置最终的可执行文件输出的路径\nset(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;bin)\n#配置头文件搜索路径\ninclude_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)\ninclude_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include&#x2F;server)\ninclude_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include&#x2F;server&#x2F;db)\ninclude_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;thirdparty)\n\n#加载子目录\nadd_subdirectory(src)\n\n主目录 CMakeLists.txt 的作用概括：\n\n设置项目基本信息：指定 CMake 最低版本和项目名称。\n配置全局编译选项：例如添加调试信息（-g）以便调试。\n设置可执行文件输出路径：统一将程序输出到 bin/ 目录。\n配置头文件搜索路径：包括项目头文件目录和第三方库目录，便于代码引用。\n组织子目录构建：通过 add_subdirectory(src) 加载 src 子目录，交由其继续组织源码编译。\n\nsrc文件夹\nadd_subdirectory(server)\n\nadd_subdirectory(server) 把 server 子目录纳入构建流程，交由其内部的 CMakeLists.txt 具体定义编译规则，是模块化项目管理的关键步骤。\nsrc&#x2F;server文件夹\n#定义了SRC_LIST变量，包含了当前目录下的所有源文件\naux_source_directory(. SRC_LIST) #获取当前目录下所有源文件\naux_source_directory(.&#x2F;db DB_LIST)#获取db文件下的所有源文件\n#指定生成可执行文件\nadd_executable(ChatServer $&#123;SRC_LIST&#125; $&#123;DB_LIST&#125;)\n#指定可执行文件需要链接的库\ntarget_link_libraries(ChatServer muduo_net muduo_base mysqlclient pthread) #链接muduo库和pthread库\n\nsrc/server/CMakeLists.txt 的作用概括：\n\n收集源文件：自动获取当前目录和 db 子目录下的所有 .cpp 文件。\n生成可执行程序：将源文件编译为 ChatServer 可执行文件。\n链接依赖库：链接 Muduo 网络库、MySQL 客户端库和 pthread 线程库。\n\nthirdparty文件夹（第三方库）json.hpp聊天服务器项目中，json.hpp 负责处理客户端与服务端之间的 JSON 数据格式，承担消息的 解析、构建与传输格式化，是通信协议的关键组件。\ninclude&#x2F;server&#x2F;chatserver.hpp 聊天服务器的主类#ifndef CHATSERVER_H\n#define CHATSERVER_H\n\n#include &lt;muduo/net/TcpServer.h>\n#include &lt;muduo/net/EventLoop.h>\n#include &lt;functional>\nusing namespace std::placeholders;\nusing namespace std;\nusing namespace muduo;\nusing namespace muduo::net;\n//聊天服务器的主类\nclass ChatServer\n&#123;\npublic:\n    //初始化聊天服务器队对象\n    ChatServer(EventLoop* loop,\n            const InetAddress&amp; listenAddr,\n            const string&amp; nameArg);\n    //启动服务\n    void start();\nprivate:\n    //上报连接相关信息的回调函数\n    void onConnection(const TcpConnectionPtr&amp; conn);\n    //上报读写事件的回调函数\n    void onMessage(const TcpConnectionPtr&amp; conn,\n            Buffer* buffer,\n            Timestamp time);\n    TcpServer _server;//组合的muduo库，实现服务器功能的类对象\n    EventLoop *_loop;//指向事件循环的指针\n&#125;;\n\n#endif\n\nChatServer.h 作用及结构概括\n\n类功能\n\n定义了聊天服务器的主类 ChatServer，负责网络服务的初始化、启动和事件处理。\n\n成员变量\n\n\n_server：muduo::net::TcpServer 对象，负责网络连接管理和服务端监听。\n_loop：muduo::net::EventLoop 指针，负责事件循环和调度。\n\n\n核心接口\n\n\n构造函数 ChatServer(EventLoop*, const InetAddress&amp;, const string&amp;)：初始化服务器监听地址、名称和事件循环。\nstart()：启动服务器监听，进入事件循环。\n\n\n回调函数（私有）\n\n\nonConnection()：处理客户端连接和断开事件。\nonMessage()：处理客户端消息接收事件，进行消息读写。\n\nChatServer 类是整个聊天项目的网络核心，利用 Muduo 库提供的 TCP 服务器功能，封装了网络事件的注册与处理，负责服务器端的网络通信逻辑。\nsrc&#x2F;server&#x2F;chatserver.cpp#include &quot;chatserver.hpp&quot;\n#include &lt;string&gt;\n#include &quot;chatservice.hpp&quot;\n#include &lt;functional&gt;\n#include &quot;json.hpp&quot;\nusing json &#x3D;nlohmann::json;\n&#x2F;&#x2F;初始化聊天服务器队对象\nChatServer::ChatServer(EventLoop* loop,\n            const InetAddress&amp; listenAddr,\n            const string&amp; nameArg)\n    : _server(loop, listenAddr, nameArg),\n      _loop(loop)\n&#123;\n    &#x2F;&#x2F;注册连接回调\n    _server.setConnectionCallback(\n        std::bind(&amp;ChatServer::onConnection, this, std::placeholders::_1));\n    &#x2F;&#x2F;注册消息回调\n    _server.setMessageCallback(\n        std::bind(&amp;ChatServer::onMessage, this, std::placeholders::_1,\n                  std::placeholders::_2, std::placeholders::_3));\n    &#x2F;&#x2F;设置线程数量\n    _server.setThreadNum(4);\n&#125;\n&#x2F;&#x2F;启动服务\nvoid ChatServer::start()&#123;\n    _server.start();\n&#125;\n\n&#x2F;&#x2F;上报连接相关信息的回调函数\nvoid ChatServer::onConnection(const TcpConnectionPtr&amp; conn)&#123;\n    &#x2F;&#x2F;客户端断开连接\n    if(!conn-&gt;connected())&#123;\n        conn-&gt;shutdown();\n    &#125;\n&#125;\n    &#x2F;&#x2F;上报读写事件的回调函数\nvoid ChatServer::onMessage(const TcpConnectionPtr&amp; conn,\n            Buffer* buffer,\n            Timestamp time)\n&#123;\n    string buf&#x3D;buffer-&gt;retrieveAllAsString();\n    &#x2F;&#x2F;数据的反序列化\n    json js&#x3D;json::parse(buf);\n    &#x2F;&#x2F;达到的目的:完全解耦网络模块的代码和业务模块的代码\n    &#x2F;&#x2F;通过js[&quot;msgid&quot;] 获取&#x3D;》业务handler&#x3D;&gt;conn js time\n    auto msgHandler&#x3D;ChatService::instance()-&gt;getHandler(js[&quot;msgid&quot;].get&lt;int&gt;());\n    &#x2F;&#x2F;回调消息绑定好的事件处理器，来执行相应的业务处理\n    msgHandler(conn,js,time);\n    \n&#125;\n\nChatServer.cpp 作用与关键点概括\n\n构造函数初始化\n\n\n初始化 Muduo 的 TCP 服务器对象 _server 和事件循环 _loop。\n注册回调函数：\nonConnection 处理连接建立与断开；\nonMessage 处理客户端消息。\n\n\n设置线程数为4，支持多线程处理网络事件。\n\n\n启动服务\n\n\nstart() 调用 Muduo 的 _server.start() 启动监听和事件循环。\n\n\n连接回调 onConnection\n\n\n判断客户端是否断开连接，断开时调用 conn-&gt;shutdown() 关闭连接。\n\n\n消息回调 onMessage\n\n\n将网络缓冲区中的数据读取为字符串。\n使用 json.hpp 将字符串反序列化成 JSON 对象。\n通过消息中的 &quot;msgid&quot; 字段，调用业务层 ChatService 获取对应的消息处理函数（回调）。\n执行该消息处理函数，完成具体的业务逻辑处理。\n\n\n作用总结\n这段代码实现了聊天服务器的核心网络处理逻辑，做到：\n\n网络层与业务层解耦：网络部分只负责收发和解析数据，业务处理由 ChatService 中注册的处理器完成。\n灵活消息分发：根据 JSON 中的 msgid 动态调用对应业务处理函数，实现消息驱动机制。\n高效异步处理：基于 Muduo 多线程事件循环模型，支持高并发网络请求。\n\ninclude&#x2F;server&#x2F;chatservice.hpp 聊天服务器业务类#ifndef CHATSERVICE_H\n#define CHATSERVICE_H\n#include &lt;muduo&#x2F;net&#x2F;TcpConnection.h&gt;\n#include &lt;unordered_map&gt;\n#include &lt;functional&gt;\n#include &quot;json.hpp&quot;\nusing namespace std;\nusing namespace muduo;\nusing namespace muduo::net;\nusing json &#x3D;nlohmann::json;\n&#x2F;&#x2F;表示处理消息的事件回调方法类型\nusing MsgHandler &#x3D; std::function&lt;void(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&gt;;\n&#x2F;&#x2F;聊天服务器业务类\nclass ChatService&#123;\npublic:\n    &#x2F;&#x2F;获取单例对象的接口函数\n    static ChatService * instance();\n    &#x2F;&#x2F;处理登录业务\n    void login(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);\n    &#x2F;&#x2F;处理注册业务\n    void reg(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);\n    &#x2F;&#x2F;获取消息对应的处理器\n    MsgHandler getHandler(int msgid);\nprivate:\n    ChatService();\n    &#x2F;&#x2F;存储消息id和其对应的业务处理方法\n    unordered_map&lt;int,MsgHandler&gt; _msgHandlerMap;\n&#125;;\n\n\n#endif\n\nChatService.h 作用与结构概括\n\n类功能\n\n\n负责处理聊天服务器的核心业务逻辑，如登录、注册等。\n管理消息 ID 与对应的处理函数的映射，实现消息的动态分发。\n\n\n核心类型\n\n\nMsgHandler：消息处理函数类型，参数包括 TCP 连接指针、JSON 消息对象和时间戳。\n\n\n接口函数\n\n\nstatic ChatService* instance()：单例模式，获取业务服务唯一实例。\nvoid login(...)：处理登录业务逻辑。\nvoid reg(...)：处理注册业务逻辑。\nMsgHandler getHandler(int msgid)：根据消息 ID 获取对应的消息处理函数。\n\n\n成员变量\n\n\n_msgHandlerMap：存储消息 ID 与处理函数的映射，支持根据消息类型快速调用相应业务处理器。\n\nsrc&#x2F;server&#x2F;chatservice.cpp#include &quot;chatservice.hpp&quot;\n#include &quot;public.hpp&quot;\n#include &lt;string&gt;\n#include &lt;muduo&#x2F;base&#x2F;Logging.h&gt;\nusing namespace muduo;\nusing namespace std;\n&#x2F;&#x2F;获取单例对象的接口函数\n&#x2F;&#x2F;在cpp文件就不需要写static了\nChatService * ChatService::instance()&#123;\n    static ChatService service;\n    return &service;\n&#125;\n&#x2F;&#x2F;注册消息以及对应的Handler回调操作\n ChatService::ChatService()&#123;\n    &#x2F;&#x2F;注册业务\n    _msgHandlerMap.insert(&#123;LOGIN_MSG,std::bind(&amp;ChatService::login,this,_1,_2,_3)&#125;);\n    _msgHandlerMap.insert(&#123;REG_MSG,std::bind(&amp;ChatService::reg,this,_1,_2,_3)&#125;);\n &#125;\n&#x2F;&#x2F;获取消息对应的处理器\n MsgHandler ChatService::getHandler(int msgid)&#123;\n    &#x2F;&#x2F;记录错误日志，msgid没有对应的事件处理回调\n    auto it &#x3D;_msgHandlerMap.find(msgid);\n    if(it &#x3D;&#x3D;_msgHandlerMap.end())&#123;\n        &#x2F;&#x2F;返回一个默认的处理器，空操作\n        return [&#x3D;](const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n            LOG_ERROR&lt;&lt;&quot;msgid:&quot;&lt;&lt; msgid &lt;&lt;&quot;can not find handler!&quot;;\n        &#125;;\n    &#125;\n    else&#123;\n        return _msgHandlerMap[msgid];\n    &#125;\n&#125;\n&#x2F;&#x2F;处理登录业务\nvoid ChatService::login(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n    LOG_INFO &lt;&lt;&quot;do login service!!!!&quot;;\n&#125;\n&#x2F;&#x2F;处理注册业务\nvoid ChatService::reg(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n    LOG_INFO&lt;&lt;&quot;do reg service!!!&quot;;\n&#125;\n\nChatService.cpp 作用和关键点\n\n单例模式实现\n\n\ninstance() 函数内部静态变量实现线程安全的单例模式，保证 ChatService 只有一个实例。\n\n\n构造函数注册消息处理函数\n\n\n在构造函数中通过 _msgHandlerMap.insert 将消息 ID（LOGIN_MSG、REG_MSG）绑定到成员函数 login 和 reg 的回调。\n使用 std::bind 绑定成员函数和 this 指针，方便后续调用。\n\n\n动态消息处理函数获取\n\n\ngetHandler(int msgid) 根据传入的消息 ID 返回对应的处理函数。\n如果消息 ID 未注册，返回一个默认空操作的 lambda，同时写错误日志，保证系统健壮性。\n\n\n业务处理函数示例\n\n\nlogin() 和 reg() 目前仅打印日志，代表登录和注册的业务处理接口，后续可以扩展具体业务逻辑。\n\ninclude&#x2F;public.hpp#ifndef PUBLIC_H\n#define PUBLIC_H\n\n&#x2F;*\nserver和client的公共文件\n*&#x2F;\nenum EnMsgType&#123;\n    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息\n    REG_MSG&#x2F;&#x2F;注册消息\n&#125;;\n#endif\n\npublic.h 作用简述\n\n共享消息类型定义\n定义了枚举类型 EnMsgType，用于区分不同的消息类型。\n目前包含两种消息：\nLOGIN_MSG = 1：登录消息\nREG_MSG：注册消息\n\n\n\n\n作用\n服务端和客户端都包含这个头文件，保证双方对消息类型有统一的理解和对应关系，方便通信协议的设计与实现。\n\n\n\nsrc&#x2F;server&#x2F;main.cpp#include &quot;chatserver.hpp&quot;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()&#123;\n    EventLoop loop;\n    InetAddress addr(&quot;127.0.0.1&quot;,6000);\n    ChatServer server(&amp;loop, addr, &quot;ChatServer&quot;);\n    server.start();\n    &#x2F;&#x2F;开启事件循环\n    loop.loop();\n    return 0;\n&#125;\n\n启动聊天服务器： 创建事件循环和服务器监听地址，初始化 ChatServer 对象，启动服务器后进入事件循环，开始接受和处理客户端连接与消息。\ninclude&#x2F;server&#x2F;db&#x2F;db.h 数据库操作类#ifndef DB_H\n#define DB_H\n#include&lt;mysql&#x2F;mysql.h&gt;\n#include&lt;string&gt;\nusing namespace std;\n&#x2F;&#x2F; 数据库操作类\nclass MySQL\n &#123;\n public:\n &#x2F;&#x2F; 初始化数据库连接\nMySQL();\n&#x2F;&#x2F; 释放数据库连接资源\n~MySQL();\n&#x2F;&#x2F; 连接数据库\nbool connect();\n&#x2F;&#x2F; 更新操作\nbool update(string sql);\n&#x2F;&#x2F; 查询操作\nMYSQL_RES* query(string sql);\n&#x2F;&#x2F;获取连接\nMYSQL * getConnection();\nprivate:\n    MYSQL *_conn;\n&#125;;\n#endif\n\nMySQL 数据库操作类说明\n类功能\n封装对 MySQL 数据库的连接、查询和更新操作，方便上层业务调用。\n主要成员函数\n\n**构造函数 MySQL()**：初始化数据库连接相关资源。\n**析构函数 ~MySQL()**：释放数据库连接资源。\n**bool connect()**：连接数据库，返回连接是否成功。\n**bool update(string sql)**：执行更新类 SQL 语句（如 INSERT、UPDATE、DELETE）。\n**MYSQL_RES* query(string sql)**：执行查询类 SQL 语句，返回结果集指针。\n**MYSQL* getConnection()**：获取底层 MySQL 连接对象，便于其他操作。\n\n成员变量\n\n**MYSQL *_conn**：指向 MySQL 连接句柄的指针。\n\nsrc&#x2F;server&#x2F;db&#x2F;db.cpp#include &quot;db.h&quot;\n#include &lt;muduo&#x2F;base&#x2F;Logging.h&gt;\n&#x2F;&#x2F; 数据库配置信息\nstatic string server &#x3D; &quot;127.0.0.1&quot;;\nstatic string user &#x3D; &quot;root&quot;;\nstatic string password &#x3D; &quot;123456&quot;;\nstatic string dbname &#x3D; &quot;chat&quot;;\n&#x2F;&#x2F; 初始化数据库连接\nMySQL::MySQL()\n&#123;\n    _conn &#x3D; mysql_init(nullptr);\n&#125;\n&#x2F;&#x2F; 释放数据库连接资源\nMySQL::~MySQL()\n&#123;\n    if (_conn !&#x3D; nullptr)\n    mysql_close(_conn);\n&#125;\n&#x2F;&#x2F; 连接数据库\nbool MySQL::connect()\n&#123;\n    MYSQL *p &#x3D; mysql_real_connect(_conn, server.c_str(), user.c_str(),password.c_str(), dbname.c_str(), 3306, nullptr, 0);\n    if (p !&#x3D; nullptr)\n    &#123;\n        &#x2F;&#x2F;C和C++代码默认的编码字符是ASCII,如果不设置，从MySQL上拉下来的中文显示？\n        mysql_query(_conn, &quot;set names gbk&quot;);\n        LOG_INFO &lt;&lt; &quot;connect mysql success!&quot;;\n    &#125;else&#123;\n        LOG_INFO &lt;&lt; &quot;connect mysql failed!&quot;;\n    &#125;\n    return p;\n&#125;\n&#x2F;&#x2F; 更新操作\nbool MySQL::update(string sql)\n&#123;\n    if (mysql_query(_conn, sql.c_str()))\n    &#123;\n        LOG_INFO &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;:&quot;\n                &lt;&lt; sql &lt;&lt; &quot;更新失败!&quot;;\n            return false;\n    &#125;\n    return true;\n&#125;\n&#x2F;&#x2F; 查询操作\nMYSQL_RES* MySQL::query(string sql)\n&#123;\n    if (mysql_query(_conn, sql.c_str()))\n        &#123;\n            LOG_INFO &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;:&quot;\n                &lt;&lt; sql &lt;&lt; &quot;查询失败!&quot;;\n            return nullptr;\n        &#125;\n    return mysql_use_result(_conn);\n&#125;\n&#x2F;&#x2F;获取连接\nMYSQL * MySQL::getConnection()&#123;\n    return _conn;\n&#125;\n\nMySQL 类实现功能简述\n\n初始化连接\n构造函数 MySQL() 调用 mysql_init 初始化 MySQL 连接对象。\n\n\n释放连接资源\n析构函数 ~MySQL() 关闭数据库连接，释放资源。\n\n\n连接数据库\nconnect() 使用 mysql_real_connect 连接到数据库。\n成功连接后设置字符集为 gbk，防止中文乱码。\n通过日志打印连接成功或失败信息。\n\n\n执行更新操作\nupdate(string sql) 执行 SQL 更新语句（如 INSERT、UPDATE、DELETE）。\n失败时打印错误日志，返回 false。\n\n\n执行查询操作\nquery(string sql) 执行 SQL 查询语句。\n返回查询结果指针，失败时返回 nullptr。\n\n\n获取底层连接\ngetConnection() 返回当前的 MySQL 连接指针，方便其他数据库操作调用。\n\n\n\ninclude&#x2F;server&#x2F;user.hpp 数据库中user表对应的类#ifndef USER_H\n#define USER_H\n#include&lt;string&gt;\nusing namespace std;\n&#x2F;&#x2F;User表的ORM类\nclass User&#123;\n    public:\n        User(int id&#x3D;1,string name&#x3D;&quot;&quot;,string pwd&#x3D;&quot;&quot;,string state&#x3D;&quot;offline&quot;)&#123;\n            this-&gt;id&#x3D;id;\n            this-&gt;name&#x3D;name;\n            this-&gt;password&#x3D;pwd;\n            this-&gt;state&#x3D;state;\n        &#125;\n        void setId(int id)&#123;this-&gt;id&#x3D;id;&#125;\n        void setName(string name)&#123;this-&gt;name&#x3D;name;&#125;\n        void setPwd(string pwd)&#123;this-&gt;password&#x3D;pwd;&#125;\n        void setState(string state)&#123;this-&gt;state&#x3D;state;&#125;\n\n        int getId()&#123;return this-&gt;id;&#125;\n        string getName()&#123;return this-&gt;name;&#125;\n        string getPwd()&#123;return this-&gt;password;&#125;\n        string getState()&#123;return this-&gt;state;&#125;\n    private:\n        int id;\n        string name;\n        string password;\n        string state;\n&#125;;\n#endif\n\nUser 类作用概括：\n\nORM 映射作用\n\n\n该类是对数据库 User 表的一个对象化表示（Object-Relational Mapping）。\n将数据库中的一条用户记录封装成一个 C++ 对象，便于在程序中操作。\n\n\n属性封装\n\n类中包含如下用户信息字段：\n\nid: 用户编号\nname: 用户名\npassword: 用户密码\nstate: 用户状态（如 &quot;online&quot; &#x2F; &quot;offline&quot;）\n\n\n基本接口功能\n\n提供了以下功能函数：\n\n构造函数（支持默认值）\nsetXXX() 设置各字段值\ngetXXX() 获取各字段值\n\n项目中的实际用途\n基于 Muduo 的聊天服务器项目中：\n\n用户数据从数据库中查询出来后，可以封装成 User 类对象；\n在业务逻辑中传递用户信息时，使用 User 类便于管理；\n与数据库交互模块（如 DAO 类）进行数据传递、封装与解封装；\n便于将用户信息序列化为 JSON 数据发送到客户端。\n\ninclude&#x2F;server&#x2F;usermodel.hpp  user表的数据操作类#ifndef USERMODEL_H\n#define USERMODEL_H\n\n\n\n#include &quot;user.hpp&quot;\n&#x2F;&#x2F;user表的数据操作类\nclass UserModel&#123;\npublic:\n    &#x2F;&#x2F;User表的增加方法\n    bool insert(User &amp;user);\n&#125;;\n\n\n#endif\n\n#ifndef/#define/#endif：防止头文件重复包含（include guard）；\n#include &quot;user.hpp&quot;：引入用户实体类定义；\nclass UserModel：封装了对 User 表的数据库操作；\nbool insert(User &amp;user)：定义了插入用户的方法，返回是否成功。\nsrc&#x2F;server&#x2F;usermodel.cpp#include &quot;usermodel.hpp&quot;\n#include &quot;db.h&quot;\n#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;User表的增加方法\nbool UserModel::insert(User &amp;user)&#123;\n    &#x2F;&#x2F;1 组装sql语句\n    char sql[1024] &#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;insert into User(name,password,state) values(&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;)&quot;,\n        user.getName().c_str(),user.getPwd().c_str(),user.getState().c_str());\n    MySQL mysql;\n    if(mysql.connect())&#123;\n        if(mysql.update(sql))&#123;\n            &#x2F;&#x2F;获取插入成功的用户数据生成的主键id\n            user.setId(mysql_insert_id(mysql.getConnection()));\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nsprintf 组装 SQL；\nMySQL 是你自定义的数据库操作类，封装了 connect() 和 update()；\n插入成功后，用 mysql_insert_id() 获取刚插入的记录主键 ID。\n注册业务实现实现步骤public.hpp\nenum EnMsgType&#123;\n    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息\n    REG_MSG,&#x2F;&#x2F;注册消息\n    REG_MSG_ACK &#x2F;&#x2F;注册响应消息\n&#125;;\n\n再加上REG_MSG_ACK 注册响应消息，告诉客户端已经收到消息。\nchatservice.hpp\nprivate:\n    ChatService();\n    &#x2F;&#x2F;存储消息id和其对应的业务处理方法\n    unordered_map&lt;int,MsgHandler&gt; _msgHandlerMap;\n    &#x2F;&#x2F;数据操作类对象\n    UserModel _userModel;\n\n在private中加入数据操作类对象UserModel _userModel，这个是自定义的对象在usermodel.hpp\nchatservice.cpp\nvoid ChatService::reg(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n    string name&#x3D;js[&quot;name&quot;];\n    string pwd&#x3D;js[&quot;password&quot;];\n    User user;\n    user.setName(name);\n    user.setPwd(pwd);\n    bool state&#x3D;_userModel.insert(user);\n    if(state)&#123;\n        &#x2F;&#x2F;注册成功\n        json response;\n        response[&quot;msgid&quot;]&#x3D; REG_MSG_ACK;\n        response[&quot;errno&quot;]&#x3D;0;\n        response[&quot;id&quot;]&#x3D;user.getId();\n        conn-&gt;send(response.dump());\n    &#125;else&#123;\n        &#x2F;&#x2F;注册失败\n        json response;\n        response[&quot;msgid&quot;]&#x3D; REG_MSG_ACK;\n        response[&quot;errno&quot;]&#x3D;1;\n        conn-&gt;send(response.dump());\n    &#125;\n&#125;\n\n在ChatService类的reg函数，负责处理注册业务的。js中存储的是我们的消息以json存储的。这里面的字段例如msgid,name,password都是服务端和客户端约定好的。首先将消息中的name,和password拿出来赋值给User类对象user,注册业务，把对应的值存入数据库chat中的User表中。当数据操作类对象_userModel插入成功时，返回消息给客户端，msgid是客户端和服务端规定的消息类型，消息REG_MSG_ACK注册后的回应消息。返回的消息有消息类型和是否注册成功的标志errno(0表示成功，1表示失败)，注册失败id也不会产生，所以不用发了。最后使用json的dump()函数转换为字符串通过conn的send函数再发出去。\nconn是TcpConnectionPtr类型TcpConnectionPtr 是 Muduo 网络库 中定义的一个智能指针类型，指向 TcpConnection 对象，通常用于表示一条活跃的 TCP 连接。\ntypedef std::shared_ptr&lt;TcpConnection&gt; TcpConnectionPtr;\n\n它的生命周期由 Muduo 网络库自动管理。\n常见成员函数（通过 TcpConnectionPtr 调用）\n\nconn-&gt;send(data)：发送数据到客户端\nconn-&gt;shutdown()：关闭连接（半关闭）\nconn-&gt;connected()：是否仍保持连接\nconn-&gt;peerAddress()：对端地址\nconn-&gt;localAddress()：本地地址\nconn-&gt;setContext() &#x2F; conn-&gt;getContext()：绑定上下文（可保存登录信息、用户ID等）\n\n实现注册业务时出现的问题实现注册业务时，使用vscod远程连接Linux出现了连接数据库不上的问题。\n20250604 13:22:35.282815Z 18893 INFO  connect mysql failed!Access denied for user &#39;root&#39;@&#39;localhost&#39; - db.cpp:29\n\n数据库拒绝了 root 用户从 localhost 的访问请求。\n解决方案\n1.使用Linux root用户登录mysql\n2.修改root用户认证方式为密码登录\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';\nFLUSH PRIVILEGES;\nEXIT;\n\n第一句ALTER USER修改存在的用户 ‘root‘@’localhost’用户名为root,本地连接。IDENTIFIED WITH mysql_native_password 设置认证插件为 mysql_native_password（密码方式）\n第二句MySQL 会将用户和权限信息缓存在内存中，这条命令强制它 重新加载所有权限表。ALTER USER 做的更改立即生效，而不必重启 MySQL 服务\n第三句对用户权限和密码的修改完成了，退出命令行界面即可。\nauth_socket 是 MySQL 默认的一种用户认证方式，主要用于本地登录，不使用密码，而是通过操作系统身份验证。MySQL 会验证：\n\n你是否是当前 Linux 系统的 root 用户；\n如果是，允许登录；\n否则，拒绝访问，即使你输入了正确的密码也没用。\n\n登录业务实现实现步骤：public.hpp\nenum EnMsgType&#123;\n    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息\n    LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息\n    REG_MSG,&#x2F;&#x2F;注册消息\n    REG_MSG_ACK &#x2F;&#x2F;注册响应消息\n&#125;;\n\n加入LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息\nusermodel.hpp\n&#x2F;&#x2F;根据用户号码查询用户信息\nUser query(int id);\n&#x2F;&#x2F;更新用户的状态信息\nbool updateState(User user);\n\n加入这两个函数，后面会在登录业务用到\nusermodel.cpp 对应函数的具体实现\n&#x2F;&#x2F;根据用户号码查询用户信息\nUser UserModel::query(int id)&#123;\n    &#x2F;&#x2F;1 组装sql语句\n    char sql[1024] &#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;select * from User where id&#x3D;%d&quot;,id);\n    MySQL mysql;\n    if(mysql.connect())&#123;\n        MYSQL_RES* res&#x3D;mysql.query(sql);\n        if(res!&#x3D;nullptr)&#123;&#x2F;&#x2F;查询成功\n            MYSQL_ROW row&#x3D;mysql_fetch_row(res);&#x2F;&#x2F;查一行\n            if(row!&#x3D;nullptr)&#123;\n                User user;\n                user.setId(atoi(row[0]));&#x2F;&#x2F;转换id为int，从数据库取出的都是字符串\n                user.setName(row[1]);&#x2F;&#x2F;用户名\n                user.setPwd(row[2]);&#x2F;&#x2F;密码\n                user.setState(row[3]);&#x2F;&#x2F;状态，以上是根据查询出的结果集取得\n                mysql_free_result(res);&#x2F;&#x2F;释放结果集资源\n                return user;\n            &#125;\n        &#125;\n    &#125;\n    return User();\n&#125;\n&#x2F;&#x2F;更新用户的状态信息\nbool UserModel::updateState(User user)&#123;\n    &#x2F;&#x2F;1 组装sql语句\n    char sql[1024] &#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;update User set state &#x3D; &#39;%s&#39; where id &#x3D; %d&quot;,user.getState().c_str(),user.getId());\n    MySQL mysql;\n    if(mysql.connect())&#123;\n        if(mysql.update(sql))&#123;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nchatservice.cpp\n实现login函数\n&#x2F;&#x2F;处理登录业务 id pwd\nvoid ChatService::login(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n    int id&#x3D;js[&quot;id&quot;];\n    string pwd&#x3D;js[&quot;password&quot;];\n    User user&#x3D;_userModel.query(id);\n    if(user.getId()&#x3D;&#x3D;id&amp;&amp;user.getPwd()&#x3D;&#x3D;pwd)&#123;\n        if(user.getState()&#x3D;&#x3D;&quot;online&quot;)&#123;\n            &#x2F;&#x2F;该用户已经登录，不允许重复登录\n            json response;\n            response[&quot;msgid&quot;]&#x3D; LOGIN_MSG_ACK;\n            response[&quot;errno&quot;]&#x3D;2;\n            response[&quot;errmsg&quot;]&#x3D;&quot;该账号已经登录，请输入新账号&quot;;\n            conn-&gt;send(response.dump());\n        &#125;else\n        &#123;\n            &#x2F;&#x2F;登录成功，更新用户状态信息 state offline&#x3D;&gt;online\n            user.setState(&quot;online&quot;);\n            _userModel.updateState(user);\n            json response;\n            response[&quot;msgid&quot;]&#x3D; LOGIN_MSG_ACK;\n            response[&quot;errno&quot;]&#x3D;0;\n            response[&quot;id&quot;]&#x3D;user.getId();\n            response[&quot;name&quot;]&#x3D;user.getName();\n            conn-&gt;send(response.dump());\n        &#125;\n        \n        \n    &#125;else&#123;\n        &#x2F;&#x2F;该用户不存在，登陆失败\n        json response;\n        response[&quot;msgid&quot;]&#x3D; LOGIN_MSG_ACK;\n        response[&quot;errno&quot;]&#x3D;1;\n        response[&quot;errmsg&quot;]&#x3D;&quot;用户名或者密码错误&quot;;\n        conn-&gt;send(response.dump());\n    &#125;\n&#125;\n\n记录用户的连接信息及线程安全性因为要实现用户与用户之间的消息往来，所以要实现记录上线用户的连接信息和下线的删除。\nchatservice.hpp private:\n&#x2F;&#x2F;存储在线用户的通信连接 注意线程安全\n    unordered_map&lt;int,TcpConnectionPtr&gt; _userConnMap;\n\n那么这个值在什么时候更新，首先在登录成功时，添加连接\nchatservice.cpp login函数\n_userConnMap.insert(&#123;id,conn&#125;);&#x2F;&#x2F;unordered_map容器没有线程安全需要添加线程互斥操作\n\n当然插入了还不够，多个用户连接服务器，_userConnMap这个是在多线程环境下，要保证线程互斥性。\n大多数 C++ STL 容器本身（如 vector、map、unordered_map 等）不是线程安全的。\n所以我们要在对这个插入数据加锁。\nchatservice.hpp private:\n&#x2F;&#x2F;记得包含头文件#include &lt;mutex&gt;\n&#x2F;&#x2F;定义互斥锁，保证_userConnMap的线程安全\n    mutex _connMutex;\n\nchatservice.cpp login函数 \n还是在登录成功那里\n&#123;\n     &#x2F;&#x2F;登录成功，记录用户连接信息\n     lock_guard&lt;mutex&gt; lock(_connMutex);&#x2F;&#x2F;如果不析构，得得遇到&#125;为止，都是互斥，所以加个域\n     _userConnMap.insert(&#123;id,conn&#125;);&#x2F;&#x2F;unordered_map容器没有线程安全需要添加线程互斥操作\n&#125;\n\n有人会问为什么再加一个花括号，这是为了让lock_guard的生命周期结束，这个变量的特性是构造时加锁，析构时自动解锁。\n客户端异常退出业务当客户端异常退出时，我们的数据库还没有修改当前状态时在线还是下线，所以要实现这个业务\nchatservice.cpp 定义公共函数clientCloseException\n&#x2F;&#x2F;处理客户端异常退出\nvoid clientCloseException(const TcpConnectionPtr &amp;conn);\n\nchatservice.cpp 对应函数实现\n&#x2F;&#x2F;处理客户端异常退出\nvoid ChatService::clientCloseException(const TcpConnectionPtr &amp;conn)&#123;\n    User user;\n    &#123;\n        lock_guard&lt;mutex&gt; lock(_connMutex);&#x2F;&#x2F;如果不析构，得得遇到&#125;为止，都是互斥，所以加个域\n        for(auto it&#x3D;_userConnMap.begin();it!&#x3D;_userConnMap.end();++it)&#123;\n            if(it-&gt;second &#x3D;&#x3D; conn)&#123;\n                user.setId(it-&gt;first);\n                &#x2F;&#x2F;从map表删除用户的连接信息\n                _userConnMap.erase(it);\n                break;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;更新用户的状态信息\n    if(user.getId()!&#x3D;-1)&#123;\n        user.setState(&quot;offline&quot;);\n        _userModel.updateState(user);\n    &#125;\n&#125;\n\nchatserver.cpp  onConnection函数\nif(!conn-&gt;connected())&#123;\n       &#x2F;&#x2F;处理异常退出业务，state更新为offline\n       ChatService::instance()-&gt;clientCloseException(conn);\n       conn-&gt;shutdown();\n   &#125;\n\n在确认断开后，使用clientCloseException将state更新为offline。\n一对一聊天业务：在线聊天实现public.hpp 加入聊天消息ONE_CHAT_MSG\n&#x2F;*\nserver和client的公共文件\n*&#x2F;\nenum EnMsgType&#123;\n    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息\n    LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息\n    REG_MSG,&#x2F;&#x2F;注册消息\n    REG_MSG_ACK, &#x2F;&#x2F;注册响应消息\n    ONE_CHAT_MSG, &#x2F;&#x2F;聊天消息\n&#125;;\n\n既然注册了业务，所以还要在chatservice.cpp的构造函数，注册业务\n_msgHandlerMap.insert(&#123;ONE_CHAT_MSG,std::bind(&amp;ChatService::oneChat,this,_1,_2,_3)&#125;);\n\nchatservice.hpp 声明一对一聊天业务函数声明\n&#x2F;&#x2F;一对一聊天业务\n    void oneChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);\n\nchatservice.cpp 声明一对一聊天业务函数声明\nvoid ChatService::oneChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n    int toid&#x3D;js[&quot;to&quot;];\n    &#123;\n        lock_guard&lt;mutex&gt; lock(_connMutex);\n        auto it&#x3D;_userConnMap.find(toid);\n        if(it!&#x3D;_userConnMap.end())&#123;\n            &#x2F;&#x2F;toid在线，转发消息\n            &#x2F;&#x2F;凡涉及_userConnMap注意线程安全性\n            &#x2F;&#x2F;服务器主动推送原消息给toid用户\n            it-&gt;second-&gt;send(js.dump());\n            return;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;toid不在线，存储离线信息\n&#125;\n\n这里js里面的构成是\nmsgid &#x2F;&#x2F;消息类型id\t发消息的idfrom 发消息的nameto\t接受方的idmsg 要发送的消息\n在线发送消息整体实现就是服务端接收到消息，之后查看接受用户是否在线，在线则调出服务端与接收端的连接，转发原消息。\n一对一聊天业务：离线消息首先离线消息是存储在数据库的一张表里\n这张表只有两个字段userid和message 这里就不用ORM映射构造一个类来保留，所以我们直接构造一个关于这张表的操作类OfflineMsgModel\nofflinemessagemodel.hpp\n#include&lt;string&gt;\n#include&lt;vector&gt;\nusing namespace std;\n&#x2F;&#x2F;提供离线消息表的操作接口方法\nclass OfflineMsgModel&#123;\npublic:\n    &#x2F;&#x2F;存储用户的离线消息\n    void insert(int userid,string msg);\n\n    &#x2F;&#x2F;删除用户的离线消息\n    void remove(int userid);\n\n    &#x2F;&#x2F;查询用户的离线消息\n    vector&lt;string&gt; query(int userid);\n&#125;;\n\n\nofflinemessagemodel.cpp\n#include &quot;offlinemessagemodel.hpp&quot;\n#include &quot;db.h&quot;\n&#x2F;&#x2F; 存储用户的离线消息\nvoid OfflineMsgModel::insert(int userid, string msg)&#123;\n    &#x2F;&#x2F;1 组装sql语句\n    char sql[1024] &#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;insert into offlineMessage values(%d,&#39;%s&#39;)&quot;,userid,msg.c_str());\n    MySQL mysql;\n    if(mysql.connect())&#123;\n        mysql.update(sql);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 删除用户的离线消息\nvoid  OfflineMsgModel::remove(int userid)&#123;\n    &#x2F;&#x2F;1 组装sql语句\n    char sql[1024] &#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;delete from offlineMessage where userid&#x3D;%d&quot;,userid);\n    MySQL mysql;\n    if(mysql.connect())&#123;\n        mysql.update(sql);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 查询用户的离线消息并返回对应id的消息数组\nvector&lt;string&gt;  OfflineMsgModel::query(int userid)&#123;\n    &#x2F;&#x2F;1 组装sql语句\n    char sql[1024] &#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;select message from offlineMessage where userid&#x3D;%d&quot;,userid);\n    MySQL mysql;\n    vector&lt;string&gt; vec;   \n    if(mysql.connect())&#123;\n        MYSQL_RES* res&#x3D;mysql.query(sql);\n        if(res!&#x3D;nullptr)&#123;&#x2F;&#x2F;查询成功\n             &#x2F;&#x2F;把userid用户的所有离线消息放入vec中返回\n             &#x2F;&#x2F;查多行\n             MYSQL_ROW row;\n             while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;\n                vec.push_back(row[0]);\n             &#125;\n             mysql_free_result(res);\n             return vec;\n        &#125;\n    &#125;\n    return vec;\n&#125;\n\n构造好对应的数据操作类，要在chatservice类实现功能\nchatservice.hpp 添加对应类的声明\nOfflineMsgModel _offlineMsgModel;\n\nchatservice.cpp\n首先在用户登录成功后，要查看离线表中是否有属于它的离线消息，所以在login函数中登录成功板块还要添加\n&#x2F;&#x2F;查询该用户是否有离线消息\n            vector&lt;string&gt; vec&#x3D;_offlineMsgModel.query(id);\n            if(!vec.empty())&#123;\n                response[&quot;offlinemsg&quot;]&#x3D;vec;\n                &#x2F;&#x2F;读取该用户的离线消息后，把该用户的所有离线消息删除掉\n                _offlineMsgModel.remove(id);\n            &#125;\n\n首先查询对应id是否有离线消息存在，存到vector数组中，如果不为空的话，response添加offlinemsg字段存储离线消息，并且在服务端删除属于接收端的离线消息，做完这些转发给接收端。\n还有存储离线消息在onechat函数中对应的接收端不在线，存储离线消息在服务端。\n&#x2F;&#x2F;toid不在线，存储离线信息\n    _offlineMsgModel.insert(toid,js.dump());\n\n这样一对一的聊天业务就算实现了。\n服务器异常退出问题解决（ctrl+c退出）这里遇到的问题是服务器异常退出，User表中用户们的在线状态并没有改变，所以我们要将其改变。\n因为这里数据库的操作，所以在usermodel.cpp UserModel类实现resetState函数，记得在hpp文件声明\n&#x2F;&#x2F;重置用户的状态信息\nvoid UserModel::resetState()&#123;\n    &#x2F;&#x2F;1 组装sql语句\n    char sql[1024] &#x3D;&quot;update User set state &#x3D; &#39;offline&#39; where state &#x3D; &#39;online&#39;&quot;;\n    MySQL mysql;\n    if(mysql.connect())&#123;\n        mysql.update(sql);\n    &#125;\n&#125;\n\n这个函数就在chatservice.cpp中ChatService类的reset新函数调用\n&#x2F;&#x2F;服务器异常，业务重置方法\nvoid ChatService::reset()&#123;\n    &#x2F;&#x2F;把online状态的用户，设置成offline\n    _userModel.resetState();\n&#125;\n\n最后在main.cpp实现这一功能\n&#x2F;&#x2F;处理服务器ctrl+c结束后，重置user的状态信息\nvoid resetHandler(int)&#123;\n    ChatService::instance()-&gt;reset();\n    exit(0);\n&#125;\n\n在main函数添加对应的信号\nint main()&#123;\n    signal(SIGINT,resetHandler);\n    EventLoop loop;\n    InetAddress addr(&quot;127.0.0.1&quot;,6000);\n    ChatServer server(&amp;loop, addr, &quot;ChatServer&quot;);\n    server.start();\n    &#x2F;&#x2F;开启事件循环\n    loop.loop();\n    return 0;\n&#125;\n\n重点：signal(SIGINT,resetHandler);\n注册信号处理函数\n\nSIGINT 是一个信号，表示 中断信号，通常在终端按下 Ctrl+C 时触发。\nresetHandler 是你定义的函数，用来在收到这个信号时执行一些清理逻辑。它的参数类型必须是 int，因为它接受信号编号\n\n当然signal(SIGINT,resetHandler);这句话也不能随便放，得放在服务端启动前。\nSIGINT 信号是：\nInterrupt Signal（中断信号），编号是 2，表示用户希望中断（终止）正在运行的程序。\n常见触发方式：\n\n当你在 终端&#x2F;命令行里运行一个程序时，按下 Ctrl + C，操作系统就会向该程序发送一个 SIGINT 信号。\n\n举个例子：\nbash复制编辑$ .&#x2F;chat_server\n# 运行中...\n\n# 你按下 Ctrl+C\n\n这时，系统向 chat_server 进程发送 SIGINT 信号：\n\n如果你没处理这个信号，程序会直接终止；\n如果你写了 signal(SIGINT, resetHandler);，就会先执行 resetHandler()，再退出。\n\n背后原理：\n\nLinux&#x2F;Unix 中，信号（signal）是一种异步通知机制，用于通知进程发生了某种事件。\nSIGINT 是一种 软件信号，由终端驱动程序发送给前台进程组。\n\n常见信号对比：\n\n\n\n信号名\n编号\n含义\n默认行为\n\n\n\nSIGINT\n2\n终端中断（Ctrl+C）\n终止进程\n\n\nSIGTERM\n15\n程序终止（系统或用户发送）\n终止进程\n\n\nSIGKILL\n9\n强制终止（不能捕获）\n立即终止进程\n\n\nSIGQUIT\n3\n退出（Ctrl+\\）并生成 core dump\n终止+生成转储文件\n\n\nSIGSEGV\n11\n段错误（访问非法内存）\n终止进程\n\n\n总结一句话：SIGINT 是终端用户通过 Ctrl+C 发出的“中断信号”，默认会终止程序，但你可以捕获它，在程序退出前做一些清理处理。\n添加好友业务代码public.hpp\nenum EnMsgType&#123;\n    LOGIN_MSG &#x3D; 1,&#x2F;&#x2F;登录消息\n    LOGIN_MSG_ACK,&#x2F;&#x2F;登录响应消息\n    REG_MSG,&#x2F;&#x2F;注册消息\n    REG_MSG_ACK, &#x2F;&#x2F;注册响应消息\n    ONE_CHAT_MSG, &#x2F;&#x2F;聊天消息\n    ADD_FRIEND_MSG,&#x2F;&#x2F;添加好友消息\n&#125;;\n\n添加ADD_FRIEND_MSG,&#x2F;&#x2F;添加好友消息\n添加好友在数据库中对应的一张Friend表，其中字段是userid和friendid,所以我们实现一个操控Friend表的model类\nfriendmodel.hpp\n#ifndef FRIENDMODEL_H\n#define FRIENDMODEL_H\n#include &quot;user.hpp&quot;\n#include&lt;vector&gt;\nusing namespace std;\n\n&#x2F;&#x2F;维护好友信息的操作接口方法\nclass FriendModel&#123;\npublic:\n    &#x2F;&#x2F;添加好友关系\n    void insert(int userid,int friendid);\n\n    &#x2F;&#x2F;返回用户好友列表 friendid\n    vector&lt;User&gt; query(int userid);\n&#125;;\n\n\n\n#endif\n\nfriendmodel.cpp\n#include &quot;friendmodel.hpp&quot;\n#include &quot;db.h&quot;\n&#x2F;&#x2F;添加好友关系\nvoid FriendModel::insert(int userid,int friendid)&#123;\n    &#x2F;&#x2F;1 组装sql语句\n    char sql[1024] &#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;insert into Friend values(%d,%d)&quot;,userid,friendid);\n    MySQL mysql;\n    if(mysql.connect())&#123;\n        mysql.update(sql);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;返回用户好友列表 friendid\nvector&lt;User&gt; FriendModel::query(int userid)&#123;\n     &#x2F;&#x2F;1 组装sql语句\n    char sql[1024] &#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;select a.id,a.name,a.state from User a inner join Friend b on b.friendid&#x3D;a.id where b.userid&#x3D;%d&quot;,userid);\n    MySQL mysql;\n    vector&lt;User&gt; vec;   \n    if(mysql.connect())&#123;\n        MYSQL_RES* res&#x3D;mysql.query(sql);\n        if(res!&#x3D;nullptr)&#123;&#x2F;&#x2F;查询成功\n             &#x2F;&#x2F;把userid用户的所有离线消息放入vec中返回\n             &#x2F;&#x2F;查多行\n             MYSQL_ROW row;\n             while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;\n                User user;\n                user.setId(atoi(row[0]));\n                user.setName(row[1]);\n                user.setState(row[2]);\n                vec.push_back(user);\n             &#125;\n             mysql_free_result(res);\n             return vec;\n        &#125;\n    &#125;\n    return vec;\n&#125;\n\ninsert函数实现的是将好友关系加到数据库中。query返回的是从数据库中返回的好友数据。\n当然还有一个业务绑定\n首先在chatservice.hpp声明一个FriendModel对象\nFriendModel _friendModel;\n\n在ChatService的构造函数实现绑定\n_msgHandlerMap.insert(&#123;ADD_FRIEND_MSG,std::bind(&amp;ChatService::addFriend,this,_1,_2,_3)&#125;);\n\n在chatservice.hpp声明一个addFriend的函数\naddFriend函数实现:\n&#x2F;&#x2F;添加好友业务 msgid id friendid\nvoid ChatService::addFriend(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n    int userid&#x3D;js[&quot;id&quot;];\n    int friendid&#x3D;js[&quot;friendid&quot;];\n    &#x2F;&#x2F;存储好友信息\n    _friendModel.insert(userid,friendid);\n\n&#125;\n\n这里收到的json消息格式为\n&#123;\"msgid\":6,\"id\":1,\"friendid\":2&#125;\n\n还有一个问题，在用户登录时，也要好友信息的显示，所以在用户登陆成功时，服务端也要把好友信息发给用户端。\n所以在服务端登录的回复信息这里需要加上好友信息\n&#x2F;&#x2F;查询该用户的好友信息并返回\n            vector&lt;User&gt; userVec&#x3D;_friendModel.query(id);\n            if(!userVec.empty())&#123;\n               vector&lt;string&gt; vec2;\n               for(User &amp;user:userVec)&#123;\n                json js;\n                js[&quot;id&quot;]&#x3D;user.getId();\n                js[&quot;name&quot;]&#x3D;user.getName();\n                js[&quot;state&quot;]&#x3D;user.getState();\n                vec2.push_back(js.dump());\n               &#125;\n               response[&quot;friends&quot;]&#x3D;vec2;\n            &#125;\n\n这里添加好友的业务就实现了。\n群组业务首先要实现群组业务，我在数据库有两张表实现群组业务AllGroup和GroupUser\nAllGroup的数据结构：\n+-----------+--------------+------+-----+---------+----------------+\n| Field     | Type         | Null | Key | Default | Extra          |\n+-----------+--------------+------+-----+---------+----------------+\n| id        | int          | NO   | PRI | NULL    | auto_increment |\n| groupname | varchar(50)  | NO   |     | NULL    |                |\n| groupdesc | varchar(200) | YES  |     |         |                |\n+-----------+--------------+------+-----+---------+----------------+\n\nGroupUSer的数据结构\n+------------+--------------------------+------+-----+---------+-------+\n| Field      | Type                     | Null | Key | Default | Extra |\n+------------+--------------------------+------+-----+---------+-------+\n| groupid    | int                      | NO   | PRI | NULL    |       |\n| userid     | int                      | NO   |     | NULL    |       |\n| groupprole | enum('creator','normal') | YES  |     | normal  |       |\n+------------+--------------------------+------+-----+---------+-------+\n\ngroupuser.hpp\n#ifndef GROUPUSER_H\n#define GROUPUSER_H\n#include &quot;user.hpp&quot;\n&#x2F;&#x2F;群组用户，多了个role角色信息，从User类直接继承，复用User的其他信息\n&#x2F;&#x2F;对应的GroupUser表，但是光是这张表的不够，还要联表查询，所以继承User类。\nclass GroupUser:public User&#123;\npublic:\n    void setRole(string role)&#123;this-&gt;role&#x3D;role;&#125;\n    string getRole()&#123;return this-&gt;role;&#125;\nprivate:\n    string role;\n&#125;;\n\n#endif\n\nGroupUser类对象是记录关于组成员的详细信息的类，所以继承User。\ngroup.hpp\n#ifndef GROUP_H\n#define GROUP_H\n#include&lt;vector&gt;\n#include&lt;string&gt;\n#include &quot;groupuser.hpp&quot;\nusing namespace std;\n&#x2F;&#x2F;AllGroup表的ORM类但也不完全是还加了储存组用户的数组\nclass Group&#123;\npublic:\n    Group(int id&#x3D;-1,string name &#x3D;&quot;&quot;,string desc&#x3D;&quot;&quot;)&#123;\n        this-&gt;id&#x3D;id;\n        this-&gt;name&#x3D;name;\n        this-&gt;desc&#x3D;desc;\n    &#125;\n    void setId(int id)&#123;\n        this-&gt;id&#x3D;id;\n    &#125;\n    void setName(string name)&#123;\n        this-&gt;name&#x3D;name;\n    &#125;\n    void setDesc(string desc)&#123;this-&gt;desc&#x3D;desc;&#125;\n    int getId()&#123;\n        return this-&gt;id;\n    &#125;\n    string getName()&#123;\n        return this-&gt;name;\n    &#125;\n    string getDesc()&#123;\n        return this-&gt;desc;\n    &#125;\n    vector&lt;GroupUser&gt; &amp;getUsers() &#123;return this-&gt;users;&#125;\n\nprivate:\n    int id;&#x2F;&#x2F;组id\n    string name;&#x2F;&#x2F;组名\n    string desc;&#x2F;&#x2F;组功能描述\n    vector&lt;GroupUser&gt; users;&#x2F;&#x2F;组员的详细信息\n&#125;;\n#endif\n\nGroup类对象是AllGroup表的ORM类，但也不完全，这个类还添加了存储组成员详细信息的结构vector users;\n因为这两张表的关联系很大，所以我们第一这个群组业务的数据操作接口。\ngroupmodel.hpp\n#ifndef GROUPMODEL_H\n#define GROUPMODEL_H\n#include &quot;group.hpp&quot;\n#include&lt;string&gt;\n#include&lt;vector&gt;\nusing namespace std;\n&#x2F;&#x2F;维护群组信息的操作接口方法\nclass GroupModel&#123;\npublic:\n    &#x2F;&#x2F;创建群组\n    bool createGroup(Group &amp;group);\n    &#x2F;&#x2F;加入群组\n    void addGroup(int userid,int groupid,string role);\n    &#x2F;&#x2F;查询用户所在群组消息\n    vector&lt;Group&gt; queryGroups(int userid);\n    &#x2F;&#x2F;根据指定的groupid查询群组用户id列表，除userid自己，主要用户群聊业务给群组其他成员群发消息。\n    vector&lt;int&gt; queryGroupUsers(int userid,int groupid);\n&#125;;\n#endif\n\n对应函数实现\n创建群组createGroup函数：\n&#x2F;&#x2F; 创建群组\nbool GroupModel::createGroup(Group &amp;group)&#123;\n    &#x2F;&#x2F;1.组装sql语句\n    char sql[1024]&#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;insert into AllGroup(groupname,groupdesc) values(&#39;%s&#39;,&#39;%s&#39;)&quot;,group.getName().c_str(),group.getDesc().c_str());\n    MySQL mysql;\n    if(mysql.connect())&#123;\n        if(mysql.update(sql))&#123;\n            group.setId(mysql_insert_id(mysql.getConnection()));\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\n将组名和组介绍存到AllGroup表中。\n加入群组addGroup函数：\n&#x2F;&#x2F; 加入群组\nvoid GroupModel::addGroup(int userid, int groupid, string role)&#123;\n    &#x2F;&#x2F;1.组装sql语句\n    char sql[1024]&#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;insert into GroupUser values(%d,%d,&#39;%s&#39;)&quot;,groupid,userid,role.c_str());\n    MySQL mysql;\n    if(mysql.connect())&#123;\n       mysql.update(sql);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 查询用户所在群组信息queryGroups\n&#x2F;&#x2F; 查询用户所在群组消息\nvector&lt;Group&gt; GroupModel::queryGroups(int userid)&#123;\n    &#x2F;&#x2F; 1.先根据userid在GroupUser表中查询该用户所属的群组消息\n    &#x2F;&#x2F; 2.再根据群组消息，查询属于该群组的所有用户的userid,并且和User表进行多表联合查询，查出用户的详细信息\n    char sql[1024]&#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;select a.id,a.groupname,a.groupdesc from AllGroup a inner join GroupUser b on a.id&#x3D;b.groupid where b.userid&#x3D;%d&quot;,userid);\n    vector&lt;Group&gt; groupVec;\n    MySQL mysql;\n    if(mysql.connect())&#123;\n        MYSQL_RES *res&#x3D;mysql.query(sql);\n        if(res!&#x3D;nullptr)&#123;\n            MYSQL_ROW row;\n            &#x2F;&#x2F;查出userid所有的群组消息\n            while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;\n                Group group;\n                group.setId(atoi(row[0]));\n                group.setName(row[1]);\n                group.setDesc(row[2]);\n                groupVec.push_back(group);\n            &#125;\n            mysql_free_result(res);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;查询群组的用户信息\n    for(Group &amp;group:groupVec)&#123;\n        sprintf(sql,&quot;select a.id,a.name,a.state,b.grouprole from User a inner join GroupUser b on b.userid&#x3D;a.id where b.groupid&#x3D;%d&quot;,group.getId());\n        MYSQL_RES *res&#x3D;mysql.query(sql);\n        if(res!&#x3D;nullptr)&#123;\n            MYSQL_ROW row;\n            while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;\n                GroupUser user;\n                user.setId(atoi(row[0]));\n                user.setName(row[1]);\n                user.setState(row[2]);\n                user.setRole(row[3]);\n                group.getUsers().push_back(user);\n            &#125;\n            mysql_free_result(res);\n        &#125;\n    &#125;\n    return groupVec;\n&#125;\n\n根据指定的groupid查询群组用户id列表，除userid自己。queryGroupUsers函数：\n&#x2F;&#x2F; 根据指定的groupid查询群组用户id列表，除userid自己，主要用户群聊业务给群组其他成员群发消息。\nvector&lt;int&gt; GroupModel::queryGroupUsers(int userid, int groupid)&#123;\n    char sql[1024]&#x3D;&#123;0&#125;;\n    sprintf(sql,&quot;select userid from GroupUser where groupid&#x3D;%d and userid!&#x3D;%d&quot;,groupid,userid);\n    vector&lt;int&gt; idVec;\n    MySQL mysql;\n    if(mysql.connect())&#123;\n        MYSQL_RES *res&#x3D;mysql.query(sql);\n        if(res!&#x3D;nullptr)&#123;\n            MYSQL_ROW row;\n            while((row&#x3D;mysql_fetch_row(res))!&#x3D;nullptr)&#123;\n                idVec.push_back(atoi(row[0]));\n            &#125;\n            mysql_free_result(res);\n        &#125;\n    &#125;\n    return idVec;\n&#125;\n\n完成这些在业务类使用这些功能\n首先在public.hpp更新消息类型：\nCREATE_GROUP_MSG,&#x2F;&#x2F;创建群组\n    ADD_GROUP_MSG,&#x2F;&#x2F;加入群组\n    GROUP_CHAT_MSG,&#x2F;&#x2F;群聊天\n\n在业务类ChatService中添加对应的数据操作类对象：\nGroupModel _groupModel;\n\n加入功能实现函数：\n&#x2F;&#x2F;创建群组业务\n    void createGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);\n    &#x2F;&#x2F;加入群组业务\n    void addGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);\n    &#x2F;&#x2F;群组聊天业务\n    void groupChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp);\n\n创建群组业务:\n&#x2F;&#x2F;创建群组业务\nvoid ChatService::createGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n    int userid&#x3D;js[&quot;id&quot;];\n    string name&#x3D;js[&quot;groupname&quot;];\n    string desc&#x3D;js[&quot;groupdesc&quot;];\n    &#x2F;&#x2F;存储新创建的群组消息\n    Group group(-1,name,desc);\n    if(_groupModel.createGroup(group))&#123;\n        &#x2F;&#x2F;存储群组创建人消息\n        _groupModel.addGroup(userid,group.getId(),&quot;creator&quot;);\n    &#125;\n&#125;\n\n加入群组业务:\n&#x2F;&#x2F;加入群组业务\nvoid ChatService::addGroup(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n    int userid&#x3D;js[&quot;id&quot;];\n    int groupid&#x3D;js[&quot;groupid&quot;];\n    _groupModel.addGroup(userid,groupid,&quot;normal&quot;);\n&#125;\n\n群组聊天业务:\n&#x2F;&#x2F;群组聊天业务\nvoid ChatService::groupChat(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n    int userid&#x3D;js[&quot;id&quot;];\n    int groupid&#x3D;js[&quot;groupid&quot;];\n    vector&lt;int&gt; useridVec&#x3D;_groupModel.queryGroupUsers(userid,groupid);\n    lock_guard&lt;mutex&gt; lock(_connMutex);\n    for(int id:useridVec)&#123;\n        \n        auto it&#x3D;_userConnMap.find(id);\n        if(it!&#x3D;_userConnMap.end())&#123;\n            &#x2F;&#x2F;转发群消息\n            it-&gt;second-&gt;send(js.dump());\n        &#125;else&#123;\n            &#x2F;&#x2F;存储离线群消息\n            _offlineMsgModel.insert(id,js.dump());\n        &#125;\n    &#125;\n&#125;\n\n还要在构造函数绑定消息对应函数：\n&#x2F;&#x2F;群组业务注册\n    _msgHandlerMap.insert(&#123;CREATE_GROUP_MSG,std::bind(&amp;ChatService::createGroup,this,_1,_2,_3)&#125;);\n    _msgHandlerMap.insert(&#123;ADD_GROUP_MSG,std::bind(&amp;ChatService::addGroup,this,_1,_2,_3)&#125;);\n    _msgHandlerMap.insert(&#123;GROUP_CHAT_MSG,std::bind(&amp;ChatService::groupChat,this,_1,_2,_3)&#125;);\n\n当然在用户登录成功时，还要把群组的信息发给客户端。\n&#x2F;&#x2F;查询用户的群组信息\n            vector&lt;Group&gt; groupuserVec&#x3D;_groupModel.queryGroups(id);\n            if(!groupuserVec.empty())&#123;\n                &#x2F;&#x2F;group:[&#123;groupid:[xxx,xxx,xxx,xxx]&#125;]\n                vector&lt;string&gt; groupV;\n                for(Group &amp;group:groupuserVec)&#123;\n                    json grpjson;\n                    grpjson[&quot;id&quot;]&#x3D;group.getId();\n                    grpjson[&quot;groupname&quot;]&#x3D;group.getName();\n                    grpjson[&quot;groupdesc&quot;]&#x3D;group.getDesc();\n                    vector&lt;string&gt; userV;\n                    for(GroupUser &amp;user:group.getUsers())&#123;\n                        json js;\n                        js[&quot;id&quot;]&#x3D;user.getId();\n                        js[&quot;name&quot;]&#x3D;user.getName();\n                        js[&quot;state&quot;]&#x3D;user.getState();\n                        js[&quot;role&quot;]&#x3D;user.getRole();\n                        userV.push_back(js.dump());\n                    &#125;\n                    grpjson[&quot;users&quot;]&#x3D;userV;\n                    groupV.push_back(grpjson.dump());\n                &#125;\n                response[&quot;groups&quot;]&#x3D;groupV;\n            &#125;\n\n群组业务就完成了。\n客户端开发-首页面开发首先在src&#x2F;client编写CMakeLists.txt和main.cpp\nCMakeLists.txt\n#定义了一个SRC_LIST变量，包含了该目录下所有的源文件\naux_source_directory(. SRC_LIST)\n\n\n#指定生成可执行文件\nadd_executable(ChatClient $&#123;SRC_LIST&#125;)\n#指定可执行文件链接时所需要依赖的库文件\ntarget_link_libraries(ChatClient pthread)\n\nmain.cpp编写我们的客户端程序\n首先保存的变量\n&#x2F;&#x2F;记录当前系统登录的用户信息\nUser g_currentUser;\n&#x2F;&#x2F;记录当前登录用户的好友列表信息\nvector&lt;User&gt; g_currentUserFriendList;\n&#x2F;&#x2F;记录当前登录用户的群组列表信息\nvector&lt;Group&gt; g_currentUserGroupList;\n\n目前的函数\n&#x2F;&#x2F;显示当前登录成功用户的基本信息\nvoid showCurrentUserData();\n&#x2F;&#x2F;接受线程\nvoid readTaskHandler(int clientfd);\n&#x2F;&#x2F;获取系统时间(聊天信息需要添加时间信息)\nstring getCurrentTime();\n&#x2F;&#x2F;主聊天页面程序\nvoid mainMenu();\n\n主线程main函数\nint main(int argc,char **argv) \n参数说明：\n\nint argc：Argument Count，命令行参数的数量（包括程序本身的名称）。\nchar **argv：Argument Vector，命令行参数的数组。argv[0] 是程序的名字，argv[1] 到 argv[argc-1] 是你在命令行中输入的其他参数。\n\n在命令行运行.&#x2F;ChatClient 127.0.0.1 6000即可运行\n客户端和服务端的连接首先客户端和服务端的连接代码：\nif(argc&lt;3)&#123;\n    cerr&lt;&lt;&quot;command invalid!example:.&#x2F;ChatClient 127.0.0.1 6000&quot;&lt;&lt;endl;\n    exit(-1);&#x2F;&#x2F;异常退出 exit(0)是正常退出\n&#125;\n&#x2F;&#x2F;解析通过命令行参数传递的ip和port\nchar *ip&#x3D;argv[1];\nuint16_t port&#x3D;atoi(argv[2]);\n&#x2F;&#x2F;创建client端的socket\nint clientfd&#x3D;socket(AF_INET,SOCK_STREAM,0);\nif(-1&#x3D;&#x3D;clientfd)&#123;\n    cerr&lt;&lt;&quot;socket create error&quot;&lt;&lt;endl;\n    exit(-1);\n&#125;\n&#x2F;&#x2F;填写client需要连接的server信息ip+port\nsockaddr_in server;\nmemset(&amp;server,0,sizeof(sockaddr_in));\nserver.sin_family&#x3D;AF_INET;\nserver.sin_port&#x3D;htons(port);\nserver.sin_addr.s_addr&#x3D;inet_addr(ip);\n&#x2F;&#x2F;client和server进行连接\nif(-1&#x3D;&#x3D;connect(clientfd,(sockaddr *)&amp;server,sizeof(sockaddr_in)))&#123;\n    cerr &lt;&lt;&quot;connect server error&quot;&lt;&lt;endl;\n    close(clientfd);\n    exit(-1);\n&#125;\n\n对其中的函数解释：\nint clientfd&#x3D;socket(AF_INET,SOCK_STREAM,0);\n\nsocket函数功能：创建一个 TCP 套接字（socket）\n其中的socket函数\n#include &lt;sys&#x2F;socket.h&gt;\n\n 各个参数含义：\nsocket(int domain, int type, int protocol)\n\n\nAF_INET（地址族）\n\n\n指定使用 IPv4 地址（Internet Protocol version 4）。\n如果是 AF_INET6，那就是 IPv6。\n\n\nSOCK_STREAM（套接字类型）\n\n\n表示使用的是 面向连接的、可靠的、基于字节流 的通信方式。\n通常对应 TCP 协议。\n\n\n0（协议编号）\n\n\n填 0 表示让系统根据前两个参数自动选择合适的协议。\n对于 AF_INET + SOCK_STREAM，系统会自动选择 TCP 协议。\n\n返回值：\n\n成功时返回一个非负整数（文件描述符，也就是 clientfd），用于后续的读写操作。\n失败时返回 -1，常见原因包括：系统资源耗尽、参数错误等。\n\nsockaddr_in server;\n\nsockaddr_in 是 C&#x2F;C++ 中专门用来表示 IPv4 网络地址 的结构体。\n对应的头文件：\n#include &lt;netinet&#x2F;in.h&gt;\n\nmemset(&amp;server,0,sizeof(sockaddr_in));\n\n把 server 结构体从首地址开始，连续 sizeof(server) 个字节都设置为 0。\nmemset函数用法\nvoid *memset(void *ptr, int value, size_t num);\n\n 参数说明：\n\n\n\n参数\n说明\n\n\n\nptr\n指向要被设置的内存的指针\n\n\nvalue\n要设置的值（会被转换为 unsigned char 类型）\n\n\nnum\n要设置的字节数\n\n\nserver.sin_family&#x3D;AF_INET;\nserver.sin_port&#x3D;htons(port);\nserver.sin_addr.s_addr&#x3D;inet_addr(ip);\n\nserver.sin_family &#x3D; AF_INET;\n\n\n表示使用的地址类型是 IPv4。\nAF_INET 是 Address Family Internet 的缩写。\n这是 sockaddr_in 中的 sin_family 字段，必须设置为 AF_INET，否则系统无法识别地址格式。\n\nserver.sin_port &#x3D; htons(port);\n\n\n设置端口号，例如：6000。\nhtons() 是 Host to Network Short 的缩写：h\n它把本地主机的字节序（可能是小端）转换为网络字节序（大端）。\n因为 TCP&#x2F;IP 协议使用大端字节序进行数据传输。\n\n\nport 是你从命令行传进来的端口号字符串转成的整数。\n\nhtons函数头文件：\n#include &lt;netinet&#x2F;in.h&gt;\n\n 端口必须转换成网络字节序，否则客户端连接服务器时会出错！\nserver.sin_addr.s_addr &#x3D; inet_addr(ip);\n\n\n设置 IP 地址。\ninet_addr() 函数把点分十进制的 IP 字符串（如 &quot;127.0.0.1&quot;）转换成 32 位的二进制整数。\n转换后的结果赋值给 sin_addr.s_addr，用于 socket 连接。\n\ninet_addr函数头文件：\n#include &lt;arpa&#x2F;inet.h&gt;\n\n&#x2F;&#x2F;client和server进行连接\n    if(-1&#x3D;&#x3D;connect(clientfd,(sockaddr *)&amp;server,sizeof(sockaddr_in)))&#123;\n        cerr &lt;&lt;&quot;connect server error&quot;&lt;&lt;endl;\n        close(clientfd);&#x2F;&#x2F;释放socket资源\n        exit(-1);\n    &#125;\n\nconnect() 函数详解：\nint connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n\n\n\n\n参数\n说明\n\n\n\nsockfd\n用 socket() 创建的套接字文件描述符（即 clientfd）\n\n\naddr\n服务器地址结构指针（需要强转成 sockaddr* 类型）\n\n\naddrlen\naddr 结构体的大小，通常是 sizeof(sockaddr_in)\n\n\n客户端业务实现首先在一个死循环中实现循环选择：\n&#x2F;&#x2F;显示首页面菜单 登录,注册，退出\n       cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;\n       cout&lt;&lt;&quot;1. login&quot;&lt;&lt;endl;\n       cout&lt;&lt;&quot;2. register&quot;&lt;&lt;endl;\n       cout&lt;&lt;&quot;3. quit&quot;&lt;&lt;endl;\n       cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;\n       cout&lt;&lt; &quot;choice:&quot;;\n       int choice&#x3D;0;\n       cin&gt;&gt;choice;\n       cin.get();&#x2F;&#x2F;读掉缓冲区残留的回车\n\n使用switch语句实现不断选择。\n首先登录业务：case 1:&#x2F;&#x2F;login业务\n            &#123;\n                int id&#x3D;0;\n                char pwd[50]&#x3D;&#123;0&#125;;\n                cout&lt;&lt; &quot;userid:&quot;;\n                cin&gt;&gt; id;\n                cin.get();&#x2F;&#x2F;读掉缓冲区残留的回车\n                cout&lt;&lt;&quot;user password:&quot;;\n                cin.getline(pwd,50);\n                json js;\n                js[&quot;msgid&quot;]&#x3D;LOGIN_MSG;\n                js[&quot;id&quot;]&#x3D;id;\n                js[&quot;password&quot;]&#x3D;pwd;\n                string request &#x3D;js.dump();\n                int len&#x3D;send(clientfd,request.c_str(),strlen(request.c_str())+1,0);\n                if(len&#x3D;&#x3D;-1)&#123;\n                    cerr&lt;&lt;&quot;send login msg error:&quot;&lt;&lt;request&lt;&lt;endl;\n                &#125;else&#123;\n                    char buffer[1024]&#x3D;&#123;0&#125;;\n                    len&#x3D;recv(clientfd,buffer,1024,0);\n                    if(len&#x3D;&#x3D;-1)&#123;\n                        cerr &lt;&lt;&quot;recv login response error&quot;&lt;&lt;endl;\n                    &#125;else&#123;\n                        json responsejs&#x3D;json::parse(buffer);\n                        if(responsejs[&quot;errno&quot;]!&#x3D;0)&#123;\n                            cerr&lt;&lt;responsejs[&quot;errmsg&quot;]&lt;&lt;endl;\n                        &#125;\n                        else&#123;&#x2F;&#x2F;登录成功\n                            &#x2F;&#x2F;记录当前用户的id和name\n                            g_currentUser.setId(responsejs[&quot;id&quot;]);\n                            g_currentUser.setName(responsejs[&quot;name&quot;]);\n                            &#x2F;&#x2F;记录当前用户的好友列表信息\n                            if(responsejs.contains(&quot;friends&quot;))&#123;&#x2F;&#x2F;看是否包含friends这个键\n                                vector&lt;string&gt; vec&#x3D;responsejs[&quot;friends&quot;];\n                                for(string &amp;str:vec)&#123;\n                                    json js&#x3D;json::parse(str);\n                                    User user;\n                                    user.setId(js[&quot;id&quot;]);\n                                    user.setName(js[&quot;name&quot;]);\n                                    user.setState(js[&quot;state&quot;]);\n                                    g_currentUserFriendList.push_back(user);\n                                &#125;\n                            &#125;\n                            &#x2F;&#x2F;记录当前用户的群组列表信息\n                            if(responsejs.contains(&quot;groups&quot;))&#123;\n                                vector&lt;string&gt; vec1&#x3D;responsejs[&quot;groups&quot;];\n                                for(string &amp;groupstr:vec1)&#123;\n                                    json grpjs&#x3D;json::parse(groupstr);\n                                    Group group;\n                                    group.setId(grpjs[&quot;id&quot;]);\n                                    group.setName(grpjs[&quot;groupname&quot;]);\n                                    group.setDesc(grpjs[&quot;groupdesc&quot;]);\n                                    vector&lt;string&gt; vec2&#x3D;grpjs[&quot;users&quot;];\n                                    for(string &amp;userstr:vec2)&#123;\n                                        GroupUser user;\n                                        json js&#x3D;json::parse(userstr);\n                                        user.setId(js[&quot;id&quot;]);\n                                        user.setName(js[&quot;name&quot;]);\n                                        user.setState(js[&quot;state&quot;]);\n                                        user.setRole(js[&quot;role&quot;]);\n                                        group.getUsers().push_back(user);\n                                    &#125;\n                                    g_currentUserGroupList.push_back(group);\n                                &#125;\n                            &#125;\n                            &#x2F;&#x2F;显示登录用户的基本信息\n                            showCurrentUserData();\n                            &#x2F;&#x2F;显示当前用户的离线消息 个人聊天消息或者群组消息\n                            if(responsejs.contains(&quot;offlinemsg&quot;))&#123;\n                                vector&lt;string&gt; vec&#x3D;responsejs[&quot;offlinemsg&quot;];\n                                for(string &amp;str:vec)&#123;\n                                    json js&#x3D;json::parse(str);\n                                    &#x2F;&#x2F;time +[id]+name+&quot;said: &quot;+xxx\n                                    cout&lt;&lt;js[&quot;time&quot;]&lt;&lt;&quot;[&quot;&lt;&lt;js[&quot;id&quot;]&lt;&lt;&quot;]&quot;&lt;&lt;js[&quot;name&quot;]&lt;&lt;&quot; said &quot;&lt;&lt;js[&quot;msg&quot;]&lt;&lt;endl;\n                                &#125;\n                            &#125;\n                            &#x2F;&#x2F;登录成功，启动接受线程负责接受数据\n                            std::thread readTask(readTaskHandler,clientfd);\n                            readTask.detach();\n                            &#x2F;&#x2F;进入聊天主菜单页面\n                            mainMenu();\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            break;\n\n这里解释一些函数\nint len&#x3D;send(clientfd,request.c_str(),strlen(request.c_str())+1,0);\n\n通过 send() 函数将字符串 request 的内容发送到套接字 clientfd 所代表的对端。\n各参数详解：\nsend(socket, buffer, length, flags)\n\n\nclientfd：套接字描述符，表示要发送数据的目标。\nrequest.c_str()：将 std::string 类型的 request 转为 C 风格的字符串（返回 const char* 指针）。c++\nstrlen(request.c_str()) + 1：表示发送的数据长度，+1 是为了包括字符串末尾的 \\0（空字符终止符），这是为了让接收方知道字符串结束。\n0：表示不使用额外的标志（默认行为）。\n\n关于返回值：\n\n\n\n返回值 len\n意义说明\n\n\n\n&gt; 0\n成功发送了 len 字节的数据\n\n\n&#x3D;&#x3D; 0\nTCP 连接被优雅关闭（几乎不会出现在 send()，常出现在 recv()）\n\n\n&#x3D;&#x3D; -1\n发送失败，需检查 errno 查看错误原因\n\n\nlen&#x3D;recv(clientfd,buffer,1024,0);\n\n从 clientfd 套接字接收最多 1024 字节的数据，存入 buffer 缓冲区中。\n各参数详解：\nrecv(socket, buffer, length, flags)\n\n\nclientfd：连接的套接字描述符（已连接的对端）。\nbuffer：用于存放接收数据的内存区域（char buffer[1024]; 或 char* buffer = new char[1024];）。\n1024：最多接收 1024 字节（防止缓冲区溢出）。\n0：标志位，通常设置为 0（表示默认阻塞接收）。\n\n返回值说明（关键点）：\n\n\n\n返回值 len\n意义说明\n\n\n\n&gt; 0\n实际接收到的数据字节数（并不一定等于 1024）\n\n\n&#x3D;&#x3D; 0\n连接已关闭（对方调用了 close()）\n\n\n&#x3D;&#x3D; -1\n接收失败，可通过 errno 查看错误原因\n\n\n注意recv() 并不会自动在 buffer 的末尾添加 ‘\\0‘\n所以我们定义buffer:保证末尾有’\\0‘\nchar buffer[1024]&#x3D;&#123;0&#125;;\n\n&#x2F;&#x2F;登录成功，启动接受线程负责接受数据\n                            std::thread readTask(readTaskHandler,clientfd);\n                            readTask.detach();\n\n创建了一个新线程，并立刻将它分离（detach），用来异步执行函数 readTaskHandler(clientfd)。\n分析每一行作用：\n\nstd::thread readTask(readTaskHandler, clientfd);\n\n\n创建一个线程对象 readTask，该线程会立即开始运行 readTaskHandler(clientfd)。\n通常用于处理客户端请求，比如接收数据、解析消息等。\n\n\nreadTask.detach();\n\n\n将线程分离，让它独立运行。\n主线程不再管理这个子线程，也无法调用 join() 等待它。\n线程资源会在线程函数执行完毕后由系统自动回收。\n\n detach 的 优点与风险：\n优点：\n\n简单，不阻塞主线程，不需要显式 join()。\n适合执行时间短、无需主线程等待的任务（比如客户端的消息监听）。\n\n风险：\n\n无法再追踪或管理线程：你不能再 join 或获取其返回状态。\n容易引发悬空引用或资源泄漏问题：\n如果 readTaskHandler() 里访问了已经销毁的变量，会崩。\n比如使用了传进来的 clientfd 后，主线程先关闭了它。\n\n\n调试困难：detach 后的线程出错更难排查。\n\n注册业务：case 2:&#x2F;&#x2F;register业务\n            &#123;\n                char name[50]&#x3D;&#123;0&#125;;\n                char pwd[50]&#x3D;&#123;0&#125;;\n                cout&lt;&lt; &quot;username:&quot;;\n                cin.getline(name,50);\n                cout&lt;&lt;&quot;user password:&quot;;\n                cin.getline(pwd,50);\n\n                json js;\n                js[&quot;msgid&quot;]&#x3D;REG_MSG;\n                js[&quot;name&quot;]&#x3D;name;\n                js[&quot;password&quot;]&#x3D;pwd;\n                string request&#x3D;js.dump();\n                int len&#x3D;send(clientfd,request.c_str(),strlen(request.c_str())+1,0);\n                if(len&#x3D;&#x3D;-1)&#123;\n                    cerr &lt;&lt;&quot;send reg msg error:&quot;&lt;&lt;request&lt;&lt;endl;\n                &#125;else&#123;\n                    char buffer[1024]&#x3D;&#123;0&#125;;\n                    len&#x3D;recv(clientfd,buffer,1024,0);\n                    if(len&#x3D;&#x3D;-1)&#123;\n                        cerr&lt;&lt;&quot;recv reg response error&quot;&lt;&lt;endl;\n                    &#125;else&#123;\n                        json responsejs&#x3D;json::parse(buffer);\n                        if(0!&#x3D;responsejs[&quot;errno&quot;])&#123;&#x2F;&#x2F;注册失败\n                            cerr&lt;&lt;name&lt;&lt;&quot;is already exist,register error!&quot;&lt;&lt;endl;\n                        &#125;else&#123;&#x2F;&#x2F;注册成功\n                            cout&lt;&lt;name&lt;&lt;&quot;register success,userid is &quot;&lt;&lt;responsejs[&quot;id&quot;]&lt;&lt;&quot;, do not forget it!&quot;&lt;&lt;endl;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            break;\n\n退出业务：case 3:&#x2F;&#x2F;quit 业务\n           &#123;\n               close(clientfd);&#x2F;&#x2F;释放连接，不要重复关闭\n               exit(0);\n           &#125;\n\n聊天主界面业务：首先在登录业务实现，登录成功又该何去何从，所以聊天主界面业务，首先在登录业务有几个函数，还没有实现，实现一下：\n&#x2F;&#x2F;显示登录用户的基本信息\nshowCurrentUserData();\n\n具体实现：\n&#x2F;&#x2F;显示当前登录成功用户的基本信息\nvoid showCurrentUserData()&#123;\n    cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;login user&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;current login user &#x3D;&gt;id:&quot;&lt;&lt;g_currentUser.getId()&lt;&lt;&quot;name:&quot;&lt;&lt;g_currentUser.getName()&lt;&lt;endl;\n    cout&lt;&lt;&quot;-------------------------friend list------------------------------&quot;&lt;&lt;endl;\n    if(!g_currentUserFriendList.empty())&#123;\n        for(User &amp;user:g_currentUserFriendList)&#123;\n            cout&lt;&lt;user.getId()&lt;&lt;&quot; &quot;&lt;&lt;user.getName()&lt;&lt;&quot; &quot;&lt;&lt;user.getState() &lt;&lt;endl;\n        &#125;\n    &#125;\n    cout&lt;&lt;&quot;--------------------------group list-------------------------------&quot;&lt;&lt;endl;\n    if(!g_currentUserGroupList.empty())&#123;\n        for(Group &amp;group:g_currentUserGroupList)&#123;\n            cout&lt;&lt;group.getId()&lt;&lt;&quot; &quot;&lt;&lt;group.getName()&lt;&lt;&quot; &quot;&lt;&lt;group.getDesc()&lt;&lt;endl;\n            for(GroupUser &amp;user:group.getUsers())&#123;\n                cout&lt;&lt;user.getId()&lt;&lt;&quot; &quot;&lt;&lt;user.getName()&lt;&lt;&quot; &quot;&lt;&lt;user.getState()&lt;&lt;user.getRole()&lt;&lt;endl;\n            &#125;\n        &#125;\n    &#125;\n    cout&lt;&lt;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&lt;&lt;endl;\n&#125;\n\n&#x2F;&#x2F;登录成功，启动接受线程负责接受数据\nstd::thread readTask(readTaskHandler,clientfd);\nreadTask.detach();\n\n其中readTaskHandler的实现：\n&#x2F;&#x2F;接受线程\nvoid readTaskHandler(int clientfd)&#123;\n    for(;;)&#123;\n        char buffer[1024]&#x3D;&#123;0&#125;;\n        int len &#x3D;recv(clientfd,buffer,1024,0);\n        if(-1&#x3D;&#x3D;len||0&#x3D;&#x3D;len)&#123;\n            close(clientfd);\n            exit(-1);\n        &#125;\n        &#x2F;&#x2F;接收ChatServer转发的数据，反序列化生成json数据对象\n        json js&#x3D;json::parse(buffer);\n        if(ONE_CHAT_MSG&#x3D;&#x3D;js[&quot;msgid&quot;])&#123;\n            cout&lt;&lt;js[&quot;time&quot;].get&lt;string&gt;()&lt;&lt;&quot;[&quot;&lt;&lt;js[&quot;id&quot;]&lt;&lt;&quot;]&quot;&lt;&lt;js[&quot;name&quot;].get&lt;string&gt;()&lt;&lt; &quot; said: &quot;&lt;&lt;js[&quot;msg&quot;].get&lt;string&gt;()&lt;&lt;endl;\n            continue;\n        &#125;\n    &#125;\n&#125;\n\n这个函数是用来接受服务端发来的消息的。主线程是发消息的。但是当前就实现了关于一对一聊天的接受消息。\n&#x2F;&#x2F;进入聊天主菜单页面\n mainMenu(clientfd);\n\n进入聊天主菜单页面实现具体的业务：\n&#x2F;&#x2F;主聊天页面程序\nvoid mainMenu(int clientfd)&#123;\n    help();\n\n    char buffer[1024]&#x3D;&#123;0&#125;;\n    for(;;)&#123;\n        cin.getline(buffer,1024);\n        string commandbuf(buffer);\n        string command;\n        int idx&#x3D;commandbuf.find(&quot;:&quot;);\n        if(idx&#x3D;&#x3D;-1)&#123;\n            command&#x3D;commandbuf;\n        &#125;\n        else&#123;\n            command&#x3D;commandbuf.substr(0,idx);\n        &#125;\n        auto it&#x3D;commandHandlerMap.find(command);\n        if(it&#x3D;&#x3D;commandHandlerMap.end())&#123;\n            cerr&lt;&lt; &quot;invalid input command!&quot;&lt;&lt;endl;\n            continue;\n        &#125;\n        &#x2F;&#x2F;调用相应命令的事件处理回调，mainMenu对修改封闭，添加新功能不需要修改该函数\n        it-&gt;second(clientfd,commandbuf.substr(idx+1,commandbuf.size()-idx));&#x2F;&#x2F;调用命令处理方法\n    &#125;\n&#125;\n\n这个函数实现进入主页面使用对应的指令使用对应的功能。接下来说说其中的变量commandHandlerMap。\n&#x2F;&#x2F;注册系统支持的客户端命令处理\nunordered_map&lt;string,function&lt;void(int,string)&gt;&gt;commandHandlerMap&#x3D;&#123;\n    &#123;&quot;help&quot;,help&#125;,\n    &#123;&quot;chat&quot;,chat&#125;,\n    &#123;&quot;addfriend&quot;,addfriend&#125;,\n    &#123;&quot;creategroup&quot;,creategroup&#125;,\n    &#123;&quot;addgroup&quot;,addgroup&#125;,\n    &#123;&quot;groupchat&quot;,groupchat&#125;,\n    &#123;&quot;loginout&quot;,loginout&#125;\n&#125;;\n\n通过哈希表绑定对应的字符串和对应函数的实现。\n当然在实现这些功能时得要有一个文字说明，这就是help功能。\n&#x2F;&#x2F;&quot;help&quot; command handler\nvoid help(int fd,string str)&#123;\n    cout&lt;&lt; &quot;show command lists:&quot;&lt;&lt;endl;\n    for(auto&amp;p:commandMap)&#123;\n        cout&lt;&lt;p.first&lt;&lt;&quot; : &quot;&lt;&lt;p.second&lt;&lt;endl;\n    &#125;\n    cout&lt;&lt;endl;\n&#125;\n\n\n这有个细节，因为后续用户如果还想要再次使用help功能，所以把他放在commandHandlerMap中，但是help()函数不满足function&lt;void(int,string)&gt;,所以我们在声明的时候赋初始值，这样就可以直接help()实现了。在其中commandMap也是自己定义提示用户如何使用这些功能。\n&#x2F;&#x2F;系统支持的客户端命令列表\nunordered_map&lt;string,string&gt; commandMap&#x3D;&#123;\n    &#123;&quot;help&quot;,&quot;显示所有支持的命令，格式help&quot;&#125;,\n    &#123;&quot;chat&quot;,&quot;一对一聊天，格式chat:friendid:message&quot;&#125;,\n    &#123;&quot;addfriend&quot;,&quot;添加好友，格式addfriend:friendid&quot;&#125;,\n    &#123;&quot;creategroup&quot;,&quot;创建群组，格式creategroup:groupname:groupdesc&quot;&#125;,\n    &#123;&quot;addgroup&quot;,&quot;加入群组，格式addgroup:groupid&quot;&#125;,\n    &#123;&quot;groupchat&quot;,&quot;群聊，格式groupchat:groupid:message&quot;&#125;,\n    &#123;&quot;loginout&quot;,&quot;注销，格式loginout&quot;&#125;\n&#125;;\n\n由commandHandlerMap知道要实现的功能。\n&#x2F;&#x2F;调用相应命令的事件处理回调，mainMenu对修改封闭，添加新功能不需要修改该函数\nit-&gt;second(clientfd,commandbuf.substr(idx+1,commandbuf.size()-idx));&#x2F;&#x2F;调用命令处理方法\n\n这样就可以把具体实现的内容封装到每一个函数中，所以接下来聚集每个实现的函数。\nchat功能实现：&#x2F;&#x2F;&quot;chat&quot; command handler\nvoid chat(int clientfd,string str)&#123;\n    int idx&#x3D;str.find(&quot;:&quot;);&#x2F;&#x2F;friendid:message\n    if(idx&#x3D;&#x3D;-1)&#123;\n        cerr&lt;&lt;&quot;chat command invalid!&quot;&lt;&lt;endl;\n        return;\n    &#125;\n    int friendid&#x3D;atoi(str.substr(0,idx).c_str());\n    string message&#x3D;str.substr(idx+1,str.size()-idx);\n    json js;\n    js[&quot;msgid&quot;]&#x3D;ONE_CHAT_MSG;\n    js[&quot;id&quot;]&#x3D;g_currentUser.getId();\n    js[&quot;name&quot;]&#x3D;g_currentUser.getName();\n    js[&quot;msg&quot;] &#x3D; message;\n    js[&quot;toid&quot;]&#x3D;friendid;\n    js[&quot;time&quot;]&#x3D;getCurrentTime();\n    string buffer&#x3D;js.dump();\n    int len&#x3D;send(clientfd,buffer.c_str(),strlen(buffer.c_str())+1,0);\n    if(len&#x3D;&#x3D;-1)&#123;\n        cerr&lt;&lt;&quot;send chat msg error:&quot;&lt;&lt;buffer&lt;&lt;endl;\n    &#125;\n\n&#125;\n\n还要实现getCurrentTime函数：\n&#x2F;&#x2F;获取系统时间(聊天信息需要添加时间信息)\nstring getCurrentTime()&#123;\n    auto tt &#x3D; std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n    struct tm *ptm &#x3D; localtime(&amp;tt);\n    char date[60] &#x3D; &#123;0&#125;;\n    sprintf(date, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,\n            (int)ptm-&gt;tm_year + 1900, (int)ptm-&gt;tm_mon + 1, (int)ptm-&gt;tm_mday,\n            (int)ptm-&gt;tm_hour, (int)ptm-&gt;tm_min, (int)ptm-&gt;tm_sec);\n    return std::string(date);\n&#125;\n\naddfriend功能实现：&#x2F;&#x2F;&quot;addfriend&quot; command handler\nvoid addfriend(int clienfd,string str)&#123;\n    int friendid&#x3D;atoi(str.c_str());\n    json js;\n    js[&quot;msgid&quot;]&#x3D;ADD_FRIEND_MSG;\n    js[&quot;id&quot;]&#x3D;g_currentUser.getId();\n    js[&quot;friendid&quot;]&#x3D;friendid;\n    string buffer&#x3D;js.dump();\n    int len&#x3D;send(clienfd,buffer.c_str(),strlen(buffer.c_str())+1,0);\n    if(len&#x3D;&#x3D;-1)&#123;\n        cerr&lt;&lt;&quot;send addfriend msg error-&gt;&quot;&lt;&lt;buffer&lt;&lt;endl;\n    &#125;\n&#125;\n\ncreategroup功能实现：&#x2F;&#x2F;&quot;creategroup&quot; command handler\nvoid creategroup(int clientfd, string str)\n&#123;\n    int idx &#x3D; str.find(&quot;:&quot;);\n    if (idx &#x3D;&#x3D; -1)\n    &#123;\n        cerr &lt;&lt; &quot;creategroup command invalid!&quot; &lt;&lt; endl;\n        return;\n    &#125;\n    string groupname &#x3D; str.substr(0, idx);\n    string groupdesc &#x3D; str.substr(idx + 1, str.size() - idx);\n    json js;\n    js[&quot;msgid&quot;] &#x3D; CREATE_GROUP_MSG;\n    js[&quot;id&quot;] &#x3D; g_currentUser.getId();\n    js[&quot;groupname&quot;] &#x3D; groupname;\n    js[&quot;groupdesc&quot;] &#x3D; groupdesc;\n    string buffer &#x3D; js.dump();\n    int len &#x3D; send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0);\n    if (len &#x3D;&#x3D; -1)\n    &#123;\n        cerr &lt;&lt; &quot;send creategroup msg error:&quot; &lt;&lt; buffer &lt;&lt; endl;\n    &#125;\n&#125;\n\naddgroup功能实现：&#x2F;&#x2F;&quot;addgroup&quot; command handler\nvoid addgroup(int clientfd, string str)\n&#123;\n    int groupid &#x3D; atoi(str.c_str());\n    json js;\n    js[&quot;msgid&quot;] &#x3D; ADD_GROUP_MSG;\n    js[&quot;id&quot;] &#x3D; g_currentUser.getId();\n    js[&quot;groupid&quot;] &#x3D; groupid;\n    string buffer &#x3D; js.dump();\n    int len &#x3D; send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0);\n    if (len &#x3D;&#x3D; -1)\n    &#123;\n        cerr &lt;&lt; &quot;send addgroup msg error:&quot; &lt;&lt; buffer &lt;&lt; endl;\n    &#125;\n&#125;\n\ngroupchat功能实现：&#x2F;&#x2F;&quot;groupchat&quot; command handler\nvoid groupchat(int clientfd, string str)\n&#123;\n    int idx &#x3D; str.find(&quot;:&quot;);\n    if (idx &#x3D;&#x3D; -1)\n    &#123;\n        cerr &lt;&lt; &quot;groupchat command invalid!&quot; &lt;&lt; endl;\n        return;\n    &#125;\n    int groupid &#x3D; atoi(str.substr(0, idx).c_str());\n    string message &#x3D; str.substr(idx + 1, str.size() - idx);\n    json js;\n    js[&quot;msgid&quot;] &#x3D; GROUP_CHAT_MSG;\n    js[&quot;id&quot;] &#x3D; g_currentUser.getId();\n    js[&quot;name&quot;] &#x3D; g_currentUser.getName();\n    js[&quot;groupid&quot;] &#x3D; groupid;\n    js[&quot;msg&quot;] &#x3D; message;\n    js[&quot;time&quot;] &#x3D; getCurrentTime();\n    string buffer &#x3D; js.dump();\n    int len &#x3D; send(clientfd, buffer.c_str(), strlen(buffer.c_str()) + 1, 0);\n    if (len &#x3D;&#x3D; -1)\n    &#123;\n        cerr &lt;&lt; &quot;send groupchat msg error:&quot; &lt;&lt; buffer &lt;&lt; endl;\n    &#125;\n&#125;\n\n实现群聊功能后，需要在接受线程实现解析返回的信息，并且输出。服务端在这里是直接将消息转发。所以如下实现：\nif (GROUP_CHAT_MSG &#x3D;&#x3D; msgtype)\n&#123;\n\tcout &lt;&lt; &quot;群消息[&quot; &lt;&lt; js[&quot;groupid&quot;] &lt;&lt; &quot;]:&quot; &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; \t\tjs[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;\n            continue;\n &#125;\n\n当然离线消息同时也要输出群组消息.\nif (ONE_CHAT_MSG &#x3D;&#x3D; js[&quot;msgid&quot;].get&lt;int&gt;())\n                                &#123;\n                                    cout &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;\n                                &#125;else&#123;\n                                    cout &lt;&lt; &quot;群消息[&quot; &lt;&lt; js[&quot;groupid&quot;] &lt;&lt; &quot;]:&quot; &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;\n                                &#125;\n\nelse部分即为离线群组消息。\nloginout功能实现：&#x2F;&#x2F;&quot;login out&quot; command handler\nvoid loginout(int clientfd, string str)\n&#123;\n    json js;\n    js[&quot;msgid&quot;]&#x3D;LOGINOUT_MSG;\n    js[&quot;id&quot;]&#x3D;g_currentUser.getId();\n    string buffer&#x3D;js.dump();\n    int len&#x3D;send(clientfd,buffer.c_str(),strlen(buffer.c_str())+1,0);\n    if(len&#x3D;&#x3D;-1)&#123;\n        cerr&lt;&lt;&quot;send loginout msg error:&quot;&lt;&lt;buffer&lt;&lt;endl;\n    &#125;else&#123;\n        isMainMenuRunning&#x3D;false;\n    &#125;\n\n&#125;\n\n首先这个函数实现需要在public.hpp\nLOGINOUT_MSG,&#x2F;&#x2F;注销消息\n\n在服务器端做出对应的函数：（记得在构造函数注册注销业务）\n&#x2F;&#x2F;处理注销业务\nvoid ChatService::loginout(const TcpConnectionPtr &amp;conn,json &amp;js,Timestamp)&#123;\n    int userid&#x3D;js[&quot;id&quot;];\n    &#123;\n        lock_guard&lt;mutex&gt; lock(_connMutex);\n        auto it&#x3D;_userConnMap.find(userid);\n        if(it!&#x3D;_userConnMap.end())&#123;\n            _userConnMap.erase(it);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;更新用户的状态信息\n    User user(userid,&quot;&quot;,&quot;&quot;,&quot;offline&quot;);\n    _userModel.updateState(user);\n\n&#125;\n\n将_userConnMap对应的id的连接删去，并且更新用户的状态。\nisMainMenuRunning是一个全局变量，用来确保loginout后会回到首页。所以默认值为false。当进入主菜单界面时，变为true。这样mainMenu函数就会退出循环，运行结束，进入首页的循环。\n当然这里就出现了一个问题就是loginoutr退出但是程序没有退出，很多全局变量还保留着上一次的值，这就会在输出这些变量时会把上一次登录的用户信息都输出。所以在登录成功时，记得将对应变量初始化清空，再进行赋值。\n&#x2F;&#x2F; 记录当前登录用户的好友列表信息\nvector&lt;User&gt; g_currentUserFriendList;\n&#x2F;&#x2F; 记录当前登录用户的群组列表信息\nvector&lt;Group&gt; g_currentUserGroupList;\n\n这两个变量在登录成功后，会进行赋值，记得在赋值前，初始化，清空。\n这里还有一个问题，每次登录成功都会创造一个线程，当我在loginout后再次登录，又创造了一个新线程。所以要保证只有一个线程实现接受。所以在登录成功部分修改：\n &#x2F;&#x2F; 登录成功，启动接受线程负责接受数据 ,该线程只启动一次\nstatic int readthreadnumber&#x3D;0;\nif(readthreadnumber&#x3D;&#x3D;0)&#123;\n\tstd::thread readTask(readTaskHandler, clientfd); &#x2F;&#x2F; 在Linux pthread_create\n\treadTask.detach();\n\treadthreadnumber++;                               &#x2F;&#x2F; Linux pthread_detach\n&#125;\n\n引入负载均衡器：以上我们基本完成了客户端和服务端的开发，由于是一个聊天服务器，要考虑一台服务器同时可以多少用户在线。我借用muduo模型创建 1个主线程（accept连接）+ 4个子线程（处理连接和事件）总共 5个线程，用于服务端 I&#x2F;O。主线程用于 accept 新连接4 个 EventLoop 子线程处理客户端连接的 I&#x2F;O 事件（读写、消息分发等）\n&#x2F;&#x2F;设置线程数量\n_server.setThreadNum(4);\n\n操作系统的限制操作系统对单个进程的文件描述符数量有限制，每个客户端连接通常占用一个文件描述符（socket）。\n\nLinux默认值（可以用 ulimit -n 查看）：通常是 1024，也就是说一个进程默认最多只能同时处理约1000个客户端连接。\n\n实际可支持的并发连接数（估算）：\n\n\n类型\n数量\n\n\n\nIdle连接（不活跃）\n40,000 ~ 100,000（受内核和 FD 限制）\n\n\n活跃连接（频繁收发消息）\n10,000 ~ 20,000（实际取决于业务逻辑复杂度）\n\n\n这是单进程、多线程、epoll 架构下的典型并发能力，非常高效。\n什么是 Idle连接（不活跃连接）？Idle（空闲）连接 是指：\n客户端虽然 已经建立了连接，但 长时间没有发送或接收任何数据，也就是说：\n\n连接处于打开状态（TCP连接存在）\n但没有发生 读写事件\n占用资源极少（仅占用文件描述符、少量内存）\n\n为什么要区分 Idle 与 活跃连接？\n资源占用不同\n\n\nIdle 连接不产生消息，不触发回调，服务器处理负担极低\n活跃连接需要处理消息、业务逻辑，负担高\n\n\n并发能力的评估\n\n\n很多高并发服务器说能支持“10万连接”，指的是 Idle连接数量\n真正活跃（消息频繁）的连接，一般几千~上万就会达到服务器上限\n\n\n是否需要清理 Idle连接\n\n\n有些服务器会设置 心跳&#x2F;超时机制，长时间不活跃的连接会被断开，防止资源泄漏或恶意占用\n\n我们还要提高并发量，就要引入负载均衡器的概念。\n负载均衡器负载均衡器（Load Balancer） 是一个把大量客户端请求 均匀分发 给多个后端服务器的组件，以提高系统的 吞吐能力、稳定性和可用性。\n为什么需要它？在高并发系统中，如果所有请求都打到一个服务器上，容易导致：\n\n响应慢\n连接超时\n服务宕机\n\n使用负载均衡器可以：\n\n水平扩展服务器（多个 Muduo 实例）\n分担压力\n实现高可用（某个服务器挂了不影响整体）\n\n按协议层划分（TCP&#x2F;HTTP）\n\n\n类型\n层级\n说明\n常用代表\n\n\n\n四层负载均衡（L4）\nTCP&#x2F;UDP\n基于 IP、端口、协议\nLVS、HAProxy、Nginx Stream、Keepalived\n\n\n七层负载均衡（L7）\nHTTP、HTTPS\n基于 URL、Header、Cookie\nNginx、HAProxy、Traefik、Envoy、Kong\n\n\n常见软件负载均衡器对比\n\n\n名称\n协议支持\n类型\n特点\n场景\n\n\n\nLVS\nL4 (TCP&#x2F;UDP)\n内核模块\n性能极高、稳定、复杂配置\n超高并发、基础设施层\n\n\nHAProxy\nL4 + L7\n用户态\n灵活、高性能、支持健康检查、监控完备\nWeb、API 网关、数据库代理\n\n\nNginx\nL7 (也支持 L4)\n用户态\n配置简单，静态资源支持好\nWeb服务器、轻量级反代\n\n\nTraefik\nL7\n云原生\n自动发现服务（K8s、Docker）、面向微服务\nDevOps、容器化\n\n\nEnvoy\nL4 + L7\n云原生\n微服务架构核心组件、支持 gRPC、动态配置\nIstio、Service Mesh\n\n\nKong\nL7 API网关\n插件丰富\n基于 Nginx，提供限流、安全等扩展能力\n企业 API 管理\n\n\nKeepalived\nL4\n高可用\n常与 LVS 配合，提供主备切换\n双主结构、高可用架构\n\n\nOpenResty\nL7\n基于 Nginx\n支持 Lua，适合做复杂业务逻辑\n高定制需求\n\n\nCaddy\nL7\n自动 TLS\nHTTPS 自动配置简单\n个人、低门槛网站部署\n\n\n我们这里要使用的是Nginx 的 TCP 负载均衡模块（即 stream 模块）\n\n这是负载均衡器在本项目发挥的作用图。\nNginx 默认是 HTTP 层负载均衡（七层），但它的 stream 模块 支持四层（TCP&#x2F;UDP）负载均衡，非常适合。\n说白了，通过多台后台服务器提高并发量。但也面临着如何处理跨服务器通信的问题。\n引入服务器中间件（redis）Redis（Remote Dictionary Server） 是一个开源的、基于内存的键值对存储（Key-Value Store）数据库，支持丰富的数据结构，读写极快，非常适合用作缓存、中间件、消息队列等。\n引入redis是要解决如果一个用户要和另一个用户通信，但是另一个用户在另一台服务器上，我们能从数据库中看到他在线，但是我们不能获取他的连接，所以引入中间件。这样就可以解决跨服务器通信的问题。\n这里是redis在本项目的作用图：\n\nnginx项目配置nginx配置编译好后，去修改&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf中修改nginx.conf文件。\n#nginx tcp loadbalance config\nstream &#123;\n        upstream MyServer &#123;\n                server 127.0.0.1:6000 weight=1 max_fails=3 fail_timeout=30s;\n                server 127.0.0.1:6002 weight=1 max_fails=3 fail_timeout=30s;\n        &#125;\n\n        server &#123;\n                proxy_connect_timeout 1s;\n                #proxy_timeout 3s; # 可以根据需要开启，控制代理的读写超时\n                listen 8000;\n                proxy_pass MyServer;\n                tcp_nodelay on;\n        &#125;       \n&#125;\n\n\n在events和http领域之间加入上述代码。这一段代码就是加入**stream 模块** 。\n说明\n\n**stream{}**：用于 TCP&#x2F;UDP 负载均衡。\nupstream MyServer：定义了两个后端服务器，权重相等。\nmax_fails&#x3D;3 fail_timeout&#x3D;30s：3次失败后，30秒内认为该节点不可用。\nlisten 8000：监听本机 8000 端口。\nproxy_connect_timeout 1s：连接超时时间为1秒。\nproxy_pass MyServer：请求转发到 MyServer 负载均衡组。\ntcp_nodelay on：开启 TCP_NODELAY，减少延迟。\n\n这样就实现了多个客户端只需要向一个ip+port就可以。通过nginx对多台服务器管理，这样就增加了聊天服务器的并发量。当然跨服务器通信这一问题还没有解决。\nRedis项目配置首先在include和src建立redis文件夹，在对应的文件夹添加redis.hpp和redis.cpp。记得更新CMakeLists.txt文件。这里调用了hiredis库。hiredis是c++使用redis封装的库。\nredis.hpp\n#ifndef REDIS_H\n#define REDIS_H\n#include &lt;hiredis&#x2F;hiredis.h&gt;\n#include &lt;thread&gt;\n#include &lt;functional&gt;\nusing namespace std;\nclass Redis&#123;\n    public:\n        Redis();\n        ~Redis();\n\n        &#x2F;&#x2F;连接redis服务器\n        bool connect();\n        &#x2F;&#x2F;向redis指定的通道channel发布消息\n        bool publish(int channel,string message);\n        &#x2F;&#x2F;向redis指定的通道subscribe订阅消息\n        bool subscribe(int channel);\n        &#x2F;&#x2F;向redis指定的通道unsubscribe取消订阅消息\n        bool unsubscribe(int channel);\n        &#x2F;&#x2F;在独立线程中接受订阅通道中的消息\n        void observer_channel_message();\n        &#x2F;&#x2F;初始化向业务层上报通道消息的回调对象\n        void init_notify_handler(function&lt;void(int,string)&gt; fn);\n    private:\n        &#x2F;&#x2F;hiredis同步上下文对象，负责publish消息\n        redisContext *_publish_context;\n        &#x2F;&#x2F;hiredis同步上下文对象，负责subscribe消息\n        redisContext * _subscribe_context;\n        &#x2F;&#x2F;回调操作，收到订阅的消息，给service层上报\n        function&lt;void (int,string)&gt; _notify_message_handler;\n&#125;;\n#endif\n\nredis.cpp\n#include&quot;redis.hpp&quot;\n#include&lt;iostream&gt;\nusing namespace std;\nRedis::Redis():_publish_context(nullptr),_subscribe_context(nullptr)&#123;\n\n&#125;\nRedis::~Redis()&#123;\n    if(_publish_context!&#x3D;nullptr)&#123;\n        redisFree(_publish_context);\n    &#125;\n    if(_subscribe_context!&#x3D;nullptr)&#123;\n        redisFree(_subscribe_context);\n    &#125;\n&#125;\nbool Redis::connect()&#123;\n    &#x2F;&#x2F;负责publish发布消息的上下文连接\n    _publish_context&#x3D;redisConnect(&quot;127.0.0.1&quot;,6379);\n    if(_publish_context&#x3D;&#x3D;nullptr)&#123;\n        cerr&lt;&lt; &quot;connect redis failed!&quot;&lt;&lt;endl;\n        return false;\n    &#125;\n    &#x2F;&#x2F;负责subscribe订阅消息的上下文连接\n    _subscribe_context&#x3D;redisConnect(&quot;127.0.0.1&quot;,6379);\n    if(_subscribe_context&#x3D;&#x3D;nullptr)&#123;\n        cerr&lt;&lt; &quot;connect redis failed!&quot;&lt;&lt;endl;\n        return false;\n    &#125;\n    &#x2F;&#x2F;在单独的线程中，监听通道上的事件，有消息给业务层进行上报\n    thread t([&amp;]()&#123;\n        observer_channel_message();\n    &#125;);\n    t.detach();\n    cout&lt;&lt;&quot;connect redis_server success!&quot;&lt;&lt;endl;\n\n    return true;\n&#125;\n&#x2F;&#x2F;向redis指定的通道channel发布消息\nbool Redis::publish(int channel,string message)&#123;\n    redisReply *reply&#x3D;(redisReply*)redisCommand(_publish_context,&quot;PUBLISH %d %s&quot;,channel,message.c_str());\n    if(reply&#x3D;&#x3D;nullptr)&#123;\n        cerr&lt;&lt;&quot;publish command failed&quot;&lt;&lt;endl;\n        return false;\n    &#125;\n    freeReplyObject(reply);\n    return true;\n&#125;\n&#x2F;&#x2F;向redis指定的通道subscribe订阅消息\nbool Redis::subscribe(int channel)&#123;\n    &#x2F;&#x2F;subscribe命令本身会造成线程阻塞等待通道里面发生消息，这里只做订阅通道，不接受消息\n    &#x2F;&#x2F;通道消息的接受专门在observer_channel_message函数中的独立线程中进行\n    &#x2F;&#x2F;只负责发送命令，不阻塞接受redis server响应消息，否则和notifyMsg线程抢占响应资源。\n    if(REDIS_ERR&#x3D;&#x3D;redisAppendCommand(this-&gt;_subscribe_context,&quot;SUBSCRIBE %d&quot;,channel))&#123;\n        cerr&lt;&lt;&quot;subscribe command failed!&quot;&lt;&lt;endl;\n        return false;\n    &#125;\n    &#x2F;&#x2F;redisBufferWrite 可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1）\n    int done&#x3D;0;\n    while(!done)&#123;\n        if(REDIS_ERR&#x3D;&#x3D;redisBufferWrite(this-&gt;_subscribe_context,&amp;done))&#123;\n            cerr&lt;&lt;&quot;subscribe command failed!&quot;&lt;&lt;endl;\n            return false;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;redisGetReply不执行\n    return true;\n\n&#125;\n&#x2F;&#x2F;向redis指定的通道unsubscribe取消订阅消息\nbool Redis::unsubscribe(int channel)&#123;\n    if(REDIS_ERR&#x3D;&#x3D;redisAppendCommand(this-&gt;_subscribe_context,&quot;UNSUBSCRIBE %d&quot;,channel))&#123;\n        cerr&lt;&lt;&quot;unsubscribe command failed!&quot;&lt;&lt;endl;\n        return false;\n    &#125;\n    &#x2F;&#x2F;redisBufferWrite 可以循环发送缓冲区，直到缓冲区数据发送完毕（done被置为1）\n    int done&#x3D;0;\n    while(!done)&#123;\n        if(REDIS_ERR&#x3D;&#x3D;redisBufferWrite(this-&gt;_subscribe_context,&amp;done))&#123;\n            cerr&lt;&lt;&quot;unsubscribe command failed!&quot;&lt;&lt;endl;\n            return false;\n        &#125;\n    &#125;\n    return true;\n&#125;\n&#x2F;&#x2F;在独立线程中接受订阅通道中的消息\nvoid Redis::observer_channel_message()&#123;\n    redisReply *reply&#x3D;nullptr;\n    while(REDIS_OK&#x3D;&#x3D;redisGetReply(this-&gt;_subscribe_context,(void**)&amp;reply))&#123;\n        &#x2F;&#x2F;订阅收到的消息是一个带三元组的数组\n        if(reply!&#x3D;nullptr&amp;&amp;reply-&gt;element[2]!&#x3D;nullptr&amp;&amp;reply-&gt;element[2]-&gt;str!&#x3D;nullptr)&#123;\n            &#x2F;&#x2F;给业务层上报通道上发生的消息\n            _notify_message_handler(atoi(reply-&gt;element[1]-&gt;str),reply-&gt;element[2]-&gt;str);\n        &#125;\n        freeReplyObject(reply);\n    &#125;\n    cerr&lt;&lt;&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;observer_channel_message quit &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;初始化向业务层上报通道消息的回调对象\nvoid Redis::init_notify_handler(function&lt;void(int,string)&gt; fn)&#123;\n    this-&gt;_notify_message_handler&#x3D;fn;\n&#125;\n\n这里需要注意的点就是关于订阅和发布，发布publish直接用redisCommand函数即可，因为这个命令直接执行本身不会堵塞（服务器会很快给出回复）。但是subscribe不一样，他直接执行会卡在那里，一直等待消息进入通道里（服务器不会很快回复）。所以我们这里使用redisAppendCommand+redisBufferWrite这两个函数一起，不用再等待响应。所以我们单开一个线程来接受通道里的消息。\n总结对比\n\n\n\n功能\nredisCommand\nredisAppendCommand + redisBufferWrite\n\n\n\n用法\n直接发送+等待响应\n仅发送命令到 Redis，不等待响应\n\n\n是否阻塞\n会阻塞直到响应\n不会阻塞\n\n\n适用场景\n普通命令（GET&#x2F;SET）\n发布订阅等需要后台线程响应的命令\n\n\n所以我们把监听逻辑放到线程里。\n注意：\nRedis 的订阅-发布机制设计：\n\n订阅连接会被阻塞监听消息，不允许执行其他命令。\n如果同一个连接既用来订阅又用来发布，订阅时会阻塞导致发布失败或延迟。\n所以一般建议发布和订阅使用独立的连接，保证各自的流畅性和响应效率。\n\n解决跨服务器通信问题我们已经配置好redis,并且封装了对应的redis类。接下来在业务类实现加入redis。\n在对应的ChatService类声明私有变量。\n&#x2F;&#x2F;redis操作对象\n Redis _redis;\n\n在ChatService类的构造函数，实现redis连接并且加入回调函数。\n&#x2F;&#x2F;连接redis服务器\nif(_redis.connect())&#123;\n\t&#x2F;&#x2F;设置上报消息的回调\n\t_redis.init_notify_handler(std::bind(&amp;ChatService::handleRedisSubscribeMessage,this,_1,_2));\n&#125;\n\nhandleRedisSubscribeMessage函数是从redis消息队列中获取订阅的消息（在另一个线程执行）\n&#x2F;&#x2F;从redis消息队列中获取订阅的消息\nvoid ChatService::handleRedisSubscribeMessage(int userid,string msg)&#123;\n    lock_guard&lt;mutex&gt; lock(_connMutex);\n    auto it&#x3D;_userConnMap.find(userid);\n    if(it!&#x3D;_userConnMap.end())&#123;\n        it-&gt;second-&gt;send(msg);\n        return;\n    &#125;\n    &#x2F;&#x2F;存储该用户的离线消息\n    _offlineMsgModel.insert(userid,msg);\n&#125;\n\n从redis返回的userid和message是当前服务器订阅的通道返回的消息，所以当前userid一定在当前服务器的_userConnMap中，当然也存在一种情况，发消息给redis时，还在线，redis传给对应的服务器时，该用户下线了，所以也要存储该用户的离线消息。\n接着还要在登录功能和注销功能做修改\n在登录成功后：\n&#x2F;&#x2F;id用户登录成功后，向redis订阅channel(id)\n_redis.subscribe(id);\n\n要向redis订阅消息，有向当前用户发送的消息会向在redis通道存储，之后会向当前用户输送。\n在注销（退出）后：\n&#x2F;&#x2F;用户注销，相当于下线，在redis中取消订阅通道\n_redis.unsubscribe(userid);\n\n关闭掉订阅通道。当然还有客户端异常退出时，也要关闭订阅\n&#x2F;&#x2F;客户端关闭，相当于下线，在redis中取消订阅通道\n_redis.unsubscribe(user.getId());\n\n最后对一对一聊天和群聊功能做修改。\n一对一聊天，当查到目标用户没有在_userConnMap中，说明目标用户不在当前服务器上或者不在线，所以接下来去数据库查看目标用户是否在线，若在线，则向redis对应的通道发布消息。不在线则存储连线消息。\n&#x2F;&#x2F;查询toid是否在线（可能在其他服务器上）\nUser user&#x3D;_userModel.query(toid);\nif(user.getState()&#x3D;&#x3D;&quot;online&quot;)&#123;\n\t_redis.publish(toid,js.dump());\n\treturn;\n&#125;\n\n群聊，当查到目标用户没有在_userConnMap中，说明目标用户不在当前服务器上或者不在线，所以接下来去数据库查看目标用户是否在线，若在线，则向redis对应的通道发布消息。不在线则存储连线消息。\nauto it&#x3D;_userConnMap.find(id);\nif(it!&#x3D;_userConnMap.end())&#123;\n            &#x2F;&#x2F;转发群消息\n            it-&gt;second-&gt;send(js.dump());\n        &#125;else&#123;\n            &#x2F;&#x2F;查询id是否在线\n            User user&#x3D;_userModel.query(id);\n            if(user.getState()&#x3D;&#x3D;&quot;online&quot;)&#123;\n                _redis.publish(id,js.dump());\n            &#125;else&#123;\n                &#x2F;&#x2F;存储离线群消息\n                _offlineMsgModel.insert(id,js.dump());\n            &#125;\n            \n        &#125;\n\n至此解决跨服务器通信问题。\n解决登录注销后再次登录会阻塞的问题在登录后注销退出后，在进行登录会一直卡住，没有关于用户的信息展示和指令展示，核查发现是主线程在执行recv,接受线程也在recv同一个socket,所以这里我们引入\n&#x2F;&#x2F; 用于读写线程的通信\nsem_t rwem;\n&#x2F;&#x2F; 记录登录状态\natomic_bool g_isLoginSuccess&#123;false&#125;;\n\nsem_t 是 POSIX 信号量类型（semaphore），用于线程之间同步或通信。\ntomic_bool 是 C++ 的原子变量类型之一，用于线程安全地读写布尔值，防止并发条件竞争。\n一、信号量 sem_t 的初始化\n在使用前，必须初始化。常用的是 sem_init：\nsem_t rwem;\nsem_init(&amp;rwem, 0, 0);\n\n参数解释：\nint sem_init(sem_t *sem, int pshared, unsigned int value);\n\n\n\n\n参数\n说明\n\n\n\nsem\n指向信号量的指针\n\n\npshared=0\n表示是线程之间使用（同一进程）\n\n\nvalue=0\n初始值为 0（表示“没有资源”）\n\n\n 通常设为 0，表示线程必须等待 sem_post() 才能继续。\n二、sem_post 和 sem_wait 的配合逻辑\n\n\n\n函数\n含义\n\n\n\nsem_post(&amp;rwem)\n给信号量加1，表示“有资源了”或“可以继续了”\n\n\nsem_wait(&amp;rwem)\n阻塞等待信号量值&gt;0，然后减1，表示“我来用这个资源”\n\n\n总体步骤：\n\n\n\n步骤\n函数\n示例\n\n\n\n初始化\nsem_init(&amp;rwem, 0, 0);\n启动阶段\n\n\n发送信号（通知）\nsem_post(&amp;rwem);\n接收线程收到数据时\n\n\n等待信号\nsem_wait(&amp;rwem);\n处理线程等待数据\n\n\n销毁\nsem_destroy(&amp;rwem);\n程序结束或退出登录时\n\n\n由于登录成功和注册成功的消息的收取是在主线程进行的，其他信息的收取是在另一个进程中，所以我要修改代码，把登录和注册的回复消息由接受进程收取。\n首先在客户端main函数中连接服务器端成功后，插入\n&#x2F;&#x2F; 初始化读写线程通信用的信号量\nsem_init(&amp;rwem, 0, 0);\n\n&#x2F;&#x2F; 连接服务器成功，启动接受线程\nstd::thread readTask(readTaskHandler, clientfd); &#x2F;&#x2F; 在Linux pthread_create\nreadTask.detach();\n\n在登录时向服务端发送登录消息后，插入\nsem_wait(&amp;rwem); &#x2F;&#x2F; 等待信号量，由子线程处理完登录的响应消息后，通知这里\ng_isLoginSuccess &#x3D; false;\n\nsem_wait(&amp;rwem); 是为了接受线程消息处理好后会sem_post(&amp;rewm)，主线程接受到信号进行往下走。\ng_isLoginSuccess时为了确认登录是否成功，如不成功，就进入首页面，成功进主菜单页面。\nif (g_isLoginSuccess)\n            &#123;\n                &#x2F;&#x2F; 进入聊天主菜单页面\n                isMainMenuRunning &#x3D; true;\n                mainMenu(clientfd);\n            &#125;\n\n注册就只需要等待信号就可以了\nsem_wait(&amp;rwem); &#x2F;&#x2F; 等待信号量，由子线程处理完注册的响应消息后，通知这里\n\n在退出业务记得把信号回收\nsem_destroy(&amp;rwem);\n\n在接受线程里\nif (LOGIN_MSG_ACK &#x3D;&#x3D; msgtype)\n        &#123;\n            doLoginResponse(js); &#x2F;&#x2F; 处理登录响应的业务逻辑\n            sem_post(&amp;rwem);     &#x2F;&#x2F; 通知主线程，登录结果处理完成\n            continue;\n        &#125;\n        if (REG_MSG_ACK &#x3D;&#x3D; msgtype)\n        &#123;\n            doRegResponse(js);\n            sem_post(&amp;rwem); &#x2F;&#x2F; 通知主线程，注册结果处理完成\n            continue;\n        &#125;\n\n当收到对应业务的消息，就执行对应逻辑。\n&#x2F;&#x2F; 处理登录响应的业务\nvoid doLoginResponse(json &amp;responsejs)\n&#123;\n    if (responsejs[&quot;errno&quot;] !&#x3D; 0)\n    &#123;\n        cerr &lt;&lt; responsejs[&quot;errmsg&quot;] &lt;&lt; endl;\n        g_isLoginSuccess &#x3D; false;\n    &#125;\n    else\n    &#123; &#x2F;&#x2F; 登录成功\n        &#x2F;&#x2F; 记录当前用户的id和name\n        g_currentUser.setId(responsejs[&quot;id&quot;]);\n        g_currentUser.setName(responsejs[&quot;name&quot;]);\n        &#x2F;&#x2F; 记录当前用户的好友列表信息\n        if (responsejs.contains(&quot;friends&quot;))\n        &#123;\n            &#x2F;&#x2F; 初始化\n            g_currentUserFriendList.clear();\n\n            &#x2F;&#x2F; 看是否包含friends这个键\n            vector&lt;string&gt; vec &#x3D; responsejs[&quot;friends&quot;];\n            for (string &amp;str : vec)\n            &#123;\n                json js &#x3D; json::parse(str);\n                User user;\n                user.setId(js[&quot;id&quot;]);\n                user.setName(js[&quot;name&quot;]);\n                user.setState(js[&quot;state&quot;]);\n                g_currentUserFriendList.push_back(user);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 记录当前用户的群组列表信息\n        if (responsejs.contains(&quot;groups&quot;))\n        &#123;\n            &#x2F;&#x2F; 初始化\n            g_currentUserGroupList.clear();\n\n            vector&lt;string&gt; vec1 &#x3D; responsejs[&quot;groups&quot;];\n            for (string &amp;groupstr : vec1)\n            &#123;\n                json grpjs &#x3D; json::parse(groupstr);\n                Group group;\n                group.setId(grpjs[&quot;id&quot;]);\n                group.setName(grpjs[&quot;groupname&quot;]);\n                group.setDesc(grpjs[&quot;groupdesc&quot;]);\n                vector&lt;string&gt; vec2 &#x3D; grpjs[&quot;users&quot;];\n                for (string &amp;userstr : vec2)\n                &#123;\n                    GroupUser user;\n                    json js &#x3D; json::parse(userstr);\n                    user.setId(js[&quot;id&quot;]);\n                    user.setName(js[&quot;name&quot;]);\n                    user.setState(js[&quot;state&quot;]);\n                    user.setRole(js[&quot;role&quot;]);\n                    group.getUsers().push_back(user);\n                &#125;\n                g_currentUserGroupList.push_back(group);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 显示登录用户的基本信息\n        showCurrentUserData();\n        &#x2F;&#x2F; 显示当前用户的离线消息 个人聊天消息或者群组消息\n        if (responsejs.contains(&quot;offlinemsg&quot;))\n        &#123;\n            vector&lt;string&gt; vec &#x3D; responsejs[&quot;offlinemsg&quot;];\n            for (string &amp;str : vec)\n            &#123;\n                json js &#x3D; json::parse(str);\n                &#x2F;&#x2F; time +[id]+name+&quot;said: &quot;+xxx\n                if (ONE_CHAT_MSG &#x3D;&#x3D; js[&quot;msgid&quot;].get&lt;int&gt;())\n                &#123;\n                    cout &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;\n                &#125;\n                else\n                &#123;\n                    cout &lt;&lt; &quot;群消息[&quot; &lt;&lt; js[&quot;groupid&quot;] &lt;&lt; &quot;]:&quot; &lt;&lt; js[&quot;time&quot;].get&lt;string&gt;() &lt;&lt; &quot;[&quot; &lt;&lt; js[&quot;id&quot;] &lt;&lt; &quot;]&quot; &lt;&lt; js[&quot;name&quot;].get&lt;string&gt;() &lt;&lt; &quot; said: &quot; &lt;&lt; js[&quot;msg&quot;].get&lt;string&gt;() &lt;&lt; endl;\n                &#125;\n            &#125;\n        &#125;\n        g_isLoginSuccess &#x3D; true;\n    &#125;\n&#125;\n\n当然，在登陆成功后记得把g_isLoginSuccess置为true。\n&#x2F;&#x2F; 处理注册响应的业务\nvoid doRegResponse(json &amp;responsejs)\n&#123;\n    if (0 !&#x3D; responsejs[&quot;errno&quot;])\n    &#123; &#x2F;&#x2F; 注册失败\n        cerr &lt;&lt;&quot;name is already exist,register error!&quot; &lt;&lt; endl;\n    &#125;\n    else\n    &#123; &#x2F;&#x2F; 注册成功\n        cout &lt;&lt;&quot;name register success,userid is &quot; &lt;&lt; responsejs[&quot;id&quot;] &lt;&lt; &quot;, do not forget it!&quot; &lt;&lt; endl;\n    &#125;\n&#125;\n\n这样就把这个问题解决了。\n","categories":["项目"],"tags":["C++"]},{"title":"Linux系统编程","url":"/2025/06/20/Linux-System%20Programming.html","content":"Linux常见目录\n\n\n目录\n说明\n\n\n\n/\n根目录，所有目录的起点，Linux 文件系统的顶级目录\n\n\n/bin\n存放常用的二进制可执行文件（如 ls、cp、mv 等），普通用户和系统都可使用\n\n\n/sbin\n系统管理命令，只有 root 用户可用（如 reboot、ifconfig）\n\n\n/etc\n配置文件目录（如 /etc/passwd、/etc/fstab、/etc/ssh/sshd_config）\n\n\n/home\n普通用户的家目录（如 /home/user1）\n\n\n/root\n超级用户（root）的家目录\n\n\n/lib\n核心共享库和驱动模块，供 /bin 和 /sbin 下的程序使用\n\n\n/usr\n存放用户应用程序和文件，子目录中包括 /usr/bin、/usr/lib 等\n\n\n/usr/bin\n普通用户使用的应用程序（非基本命令）\n\n\n/usr/sbin\n非系统引导时使用的系统管理员命令\n\n\n/var\n可变数据，如日志文件 /var/log、邮件、缓存、锁等\n\n\n/tmp\n临时文件，系统重启后可能会被清空\n\n\n/opt\n第三方软件安装目录（如 Chrome、VMware 等）\n\n\n/dev\n设备文件（如硬盘 /dev/sda，终端 /dev/tty）\n\n\n/proc\n虚拟文件系统，内核和进程信息（如 /proc/cpuinfo、/proc/meminfo）\n\n\n/sys\n另一种虚拟文件系统，提供与内核、设备驱动的交互接口\n\n\n/boot\n存放启动相关文件，如内核、grub 等（如 /boot/vmlinuz-*）\n\n\n/media\n可移动媒体挂载点（如 U 盘、光盘）\n\n\n/mnt\n临时挂载点，一般管理员手动挂载文件系统用\n\n\n/run\n系统运行时临时文件（如 PID、Socket）\n\n\n/srv\n提供服务的数据目录（如 Web 服务、FTP 服务的数据）\n\n\nBash解析器常用快捷键1.tap键\n补齐命令，补齐路径，显示当前目录下的所有目录\n2.清屏 clear\n3.中断进程 ctrl+c\n4 遍历输入的历史命令箭头上（ctrl+p）箭头下(ctrl+n)\n5 光标相关操作\n光标左移： ctrl+b（箭头左）\n光标右移： ctrl+f(箭头右)\n移动到头部: ctrl+a(home键)\n移动到尾部：ctrl+e(end键)\n6字符删除\n删除光标前面的字符：ctrl+h(Backspace)\n删除光标后面的字符：ctrl+d\n光标后面的字符即光标覆盖的字符\n删除光标前的所有内容：ctrl+u\n删除光标后的所有内容：ctrl+k\n终端相关快捷键（终端一定要选中）\nctrl+shift+N 新建一个终端\nctrl+shift+T 在终端里新建一个标签\nctrl+D 关闭当前一个终端\n内建命令和外部命令对比内建命令 vs 外部命令 对比总结\n\n\n\n比较项\n内建命令（Builtin Command）\n外部命令（External Command）\n\n\n\n定义\n由 Shell 内部直接实现的命令\n是文件系统中的可执行程序（如 /bin/ls）\n\n\n执行速度\n快（不需新建进程）\n较慢（需 fork 子进程执行）\n\n\n资源消耗\n少，执行在当前 Shell 进程中\n多，执行时创建子进程\n\n\n路径查找\n不需要依赖 PATH 环境变量\n需要从 PATH 中查找可执行文件\n\n\n是否可以替换\n一般不推荐重定义\n可以覆盖、替换或删改（如 alias 覆盖）\n\n\n是否常驻内存\n是，Shell 启动时加载\n否，执行时加载，执行完释放\n\n\n例子\ncd, echo, exit, pwd, type\nls, cp, gcc, vim, python\n\n\n查看方法\ntype cd → builtin\ntype ls → file\n\n\n命令类型查看方法\n使用type命令\ntype [选项] 命令名\n\n使用 -a 显示所有同名命令（包括 alias、builtin、文件）\n使用 -t 显示类型（简洁）\nLinux命令格式命令 [选项] [参数]\n\n\n\n\n部分\n说明\n\n\n\n命令\n要执行的操作，如 ls、cp、mkdir 等\n\n\n选项\n用于控制命令行为的开关，通常以 - 或 -- 开头，例如 -l、--help\n\n\n参数\n命令作用的对象，通常是文件名、目录名、用户名等\n\n\n选项类型说明\n\n\n\n类型\n示例\n说明\n\n\n\n短选项\n-l\n通常是一个字母，多个可组合（如 -al）\n\n\n长选项\n--help\n更易读，通常不可组合\n\n\n组合选项\n-avz\n相当于 -a -v -z\n\n\n帮助文档查看方法如果是内建命令（可以通过之前的type命令查看）使用 help +内建命令\nhelp pwd\n\n如果是外部命令 对应命令名 –help\nls --help\n\nman 是 Linux 中最常用的命令之一，全称是 manual（手册），用于查看各种命令、函数、配置文件的使用说明。它是学习和查找 Linux 命令最权威的工具。\nman 命令基本语法：\nman [选项] [命令名或函数名]\n\n man 手册的 9 个部分（章节）\n\n\n\n章节号\n内容\n示例\n\n\n\n1\n用户命令（常见终端命令）\nman ls\n\n\n2\n系统调用（内核提供的函数）\nman 2 open\n\n\n3\nC 库函数\nman 3 printf\n\n\n4\n设备文件和特殊文件\nman 4 tty\n\n\n5\n配置文件格式\nman 5 crontab\n\n\n6\n游戏与趣味（极少）\n\n\n\n7\n杂项（宏定义、协议、约定等）\nman 7 signal\n\n\n8\n系统管理员命令（只能 root 执行）\nman 8 ifconfig\n\n\n9\n内核开发接口（不常见）\n\n\n\n常用选项\n\n\n\n选项\n作用\n\n\n\n-k 关键词\n搜索相关命令（相当于 apropos）\n\n\n-f 命令名\n显示命令属于哪个章节（相当于 whatis）\n\n\n-a\n显示所有章节中匹配的 man 页\n\n\n-M\n指定手册路径\n\n\n--help\n查看 man 自身帮助信息\n\n\n目录相关命令pwd用于显示当前终端所在的工作目录（即当前绝对路径）。\ncdcd [目录路径]\n\n常见用法示例\n\n\n\n命令\n说明\n\n\n\ncd /home/user\n切换到绝对路径 /home/user 目录\n\n\ncd ..\n切换到上一级目录\n\n\ncd 或 cd ~\n切换到当前用户的主目录\n\n\ncd -\n切换到上一次所在的目录（切换目录的“切换”）\n\n\ncd ./folder\n切换到当前目录下的子目录 folder\n\n\nmkdir用于创建新目录的命令，创建不了已存在目录。\nmkdir [选项] 目录名\n\nmkdir test 在当前目录下创建test文件夹\nmkdir &#x2F;tmp&#x2F;test\nmkdir file{1..100}在当前目录创建100个文件夹，file1,file2,file3…file100\nmkdir “file{1..100}”在当前目录创建file{1..100}文件夹，只会创建一个。\nmkdir “a b” 在当前目录创建a b一个文件夹。\nmkdir a b 在当前目录创建a b两个文件夹。\n\n\n\n选项\n说明\n\n\n\n-p\n递归创建目录（父目录不存在时自动创建）\n\n\n-m MODE\n设置新建目录的权限，如 -m 755\n\n\n-v\n显示详细创建过程（verbose）\n\n\nrmdir用法和mkdir相同\n用于删除空目录的命令\n\n\n\n命令\n说明\n\n\n\nrmdir testdir\n删除当前目录下的 testdir（需为空）\n\n\nrmdir -p a/b/c\n递归删除空目录链：先删 c，再删 b，再删 a\n\n\nrmdir ./mydir/\n删除当前目录中的 mydir（需为空）\n\n\n\n\n\n选项\n说明\n\n\n\n-p\n递归删除路径中的所有空目录（从子到父）\n\n\n--ignore-fail-on-non-empty\n删除目录时忽略非空目录导致的错误\n\n\nLinux文件类型常用的文件类型有七种：普通文件，目录文件，设备文件，管道文件，链接文件和套接字。\n\n普通文件 是 Linux 中最常见的一类文件，主要用于存储用户数据。包括：\n\n文本文件（如 .txt, .c, .py）\n二进制文件（如 可执行程序、图片、音频等）\n脚本文件（如 .sh, .py，可以被解释执行）\n\n在 Linux 中，目录文件（Directory File） 是一种特殊的文件类型，用来组织和存放文件和其他目录（子目录）。 它本质上是一个保存了文件名和 inode 编号之间映射关系的文件。\n设备文件（Device File）是 Linux 中用于访问硬件设备的接口，本质上就是一种特殊的文件，程序通过它来与硬件设备通信。\n设备文件通常位于 /dev 目录中。\n常见设备文件举例\n\n\n\n路径\n类型\n功能描述\n\n\n\n/dev/sda\n块设备\n第一块硬盘\n\n\n/dev/tty\n字符设备\n当前终端\n\n\n/dev/null\n字符设备\n写入数据会被丢弃\n\n\n/dev/zero\n字符设备\n会源源不断输出 0\n\n\n/dev/random\n字符设备\n伪随机数生成器\n\n\n管道文件（或称命名管道，FIFO &#x3D; First In First Out）是一种特殊文件，用于在不同进程之间传输数据。 写入管道的数据会按顺序被读取，类似“排队喝水”的水管，先进先出。\n管道文件与匿名管道不同之处在于它有名字，存在于文件系统中（通常创建在某个路径下），因此不同进程不必有父子关系也能通信。\n链接文件 是指向另一个文件的引用，常用于：\n\n创建多个路径指向同一个文件（节省空间）\n为长路径或常用文件创建别名（提高效率）\n实现共享与替代功能\n\n\n\n\n类型\n描述\nls -l 标识\n\n\n\n软链接（符号链接）\n类似 Windows 快捷方式，是一个指向目标路径的独立文件\nl\n\n\n硬链接\n直接指向目标文件的 inode，本质上是同一个文件的另一个名字\n-\n\n\n在 Linux 中，你可以使用 ls -l 命令来区分各种文件类型。ls -l 输出的每一行开头的第一个字符表示文件类型。下面是 七种常见文件类型及其 ls -l 显示符号：\n七种常见文件类型及其标识\n\n\n\n文件类型\nls -l 类型字符\n示例路径\n含义说明\n\n\n\n普通文件\n-\n-rw-r--r-- file.txt\n常见的文本、二进制、可执行文件等\n\n\n目录文件\nd\ndrwxr-xr-x dir/\n存储文件的容器\n\n\n字符设备文件\nc\ncrw------- /dev/tty\n逐字符访问设备，如终端、串口等\n\n\n块设备文件\nb\nbrw-rw---- /dev/sda\n按块访问设备，如硬盘、U 盘等\n\n\n管道文件\np\nprw-r--r-- mypipe\n用于进程间通信的 FIFO 管道\n\n\n链接文件\nl\nlrwxrwxrwx link -&gt; target\n指向其他文件的软链接\n\n\n套接字文件\ns\nsrwxrwxrwx socket\n进程间网络通信接口，如 /tmp/.X11-unix/X0\n\n\n文件相关命令ls命令\n\n\n命令\n含义\n\n\n\nls\n简单列出当前目录内容\n\n\nls -a\n显示所有文件，包括隐藏文件（以.开头）\n\n\nls -l\n以长格式列出，显示权限、类型、时间等\n\n\nls -lh\n长格式 + 人类可读大小（如 KB, MB）\n\n\nls -lt\n按修改时间排序，最新的在前\n\n\nls -r\n反向排序\n\n\nls -R\n递归列出子目录\n\n\nls -d */\n只列出目录 ls -d只显示一个.\n\n\nls -l命令会输出长格式\n权限       硬链接数 拥有者 所属组  大小    修改日期      文件名\ndrwxr-xr-x   2    user   user  4096   Jun 21 13:00  mydir\n\n对权限部分说明一下权限部分总共10个字符\n\n\n\n位置\n含义\n\n\n\n1\n文件类型标识\n\n\n2-4\n拥有者（user）权限\n\n\n5-7\n同组用户（group）权限\n\n\n8-10\n其他用户（others）权限\n\n\n文件类型标识（第1个字符）\n\n\n\n字符\n类型\n\n\n\n-\n普通文件\n\n\nd\n目录\n\n\nl\n软链接\n\n\nc\n字符设备文件\n\n\nb\n块设备文件\n\n\np\n管道（FIFO）\n\n\ns\n套接字\n\n\n权限字符说明（2-10位置）\n\n\n\n字符\n含义\n\n\n\nr\n读权限 (read)\n\n\nw\n写权限 (write)\n\n\nx\n执行权限 (execute)\n\n\n-\n无该权限\n\n\ns\nsetuid&#x2F;setgid 位（特殊执行权限）\n\n\nt\n粘滞位（sticky bit）\n\n\n三组权限详解\n\n\n\n组别\n位置\n含义\n\n\n\n拥有者\n2~4 字符\n拥有该文件&#x2F;目录的用户权限\n\n\n组用户\n5~7 字符\n属于该文件组的用户权限\n\n\n其他用户\n8~10 字符\n系统中除拥有者和组以外的所有用户权限\n\n\n什么是通配符？通配符是一种简化文件名匹配的符号，用于在命令中匹配多个文件或目录。它可以让你不用输入完整文件名，就能选中符合规则的文件。\n常用的通配符类型\n\n\n\n通配符\n作用\n例子\n匹配结果示例\n\n\n\n*\n匹配任意数量的任意字符（包括0个）\nls *.txt\n匹配所有以 .txt 结尾的文件\n\n\n?\n匹配任意一个单字符\nls file?.txt\n匹配 file1.txt、fileA.txt，但不匹配 file10.txt\n\n\n[abc]\n匹配括号内的任意一个字符\nls file[123].txt\n匹配 file1.txt、file2.txt、file3.txt\n\n\n[a-z]\n匹配指定范围内的任意一个字符\nls file[a-c].txt\n匹配 filea.txt、fileb.txt、filec.txt\n\n\n[!abc]\n匹配不在括号内的任意一个字符\nls file[!123].txt\n匹配除 file1.txt、file2.txt、file3.txt 以外的文件\n\n\ntouch命令touch 是用来 创建空文件 或 更新已有文件的时间戳 的命令。\ntouch file.txt\n\n如果 file.txt 不存在，会被创建为空文件；如果存在，文件时间被更新。\ntouch file1.txt file2.txt file3.txt\n\n一次创建或更新多个文件。\ntouch file&#123;2,3,4&#125;#同时创建file2,file3,file4三个空文件和mkdir file&#123;1..100&#125;用法是一样的。\ntouch \"file&#123;2,3,4&#125;\"#创建file&#123;2,3,4&#125;这一个文件。\n\ncp命令cp 是 Linux 中用于 复制文件或目录 的命令。\n\n\n\n任务\n命令示例\n说明\n\n\n\n复制文件\ncp file1.txt file2.txt\n把 file1.txt 内容复制为 file2.txt\n\n\n复制文件到目录\ncp file1.txt /home/user/docs/\n把 file1.txt 复制进目录\n\n\n复制目录（加 -r）\ncp -r dir1/ dir2/\n递归复制整个目录 dir1 到 dir2 中\n\n\n保留属性复制文件\ncp -p file1.txt file2.txt\n保留原文件的时间戳、权限等信息\n\n\n强制覆盖目标文件\ncp -f file1.txt file2.txt\n如果 file2.txt 存在，强制覆盖\n\n\n复制并提示\ncp -i file1.txt file2.txt\n有冲突时会提示确认\n\n\n显示复制过程\ncp -v file1.txt file2.txt\n复制时显示详细过程（verbose 模式）\n\n\n\n\n\n选项\n含义\n\n\n\n-r\n递归复制目录（必须用于复制目录）\n\n\n-i\n覆盖文件前提示确认\n\n\n-f\n强制覆盖目标文件而不提示\n\n\n-p\n保留原文件的属性（权限、时间等）\n\n\n-u\n只在源文件较新时才复制\n\n\n-v\n显示复制过程（verbose）\n\n\n-a\n归档模式，等价于 -dpR，用于备份\n\n\n--parents\n保留源路径结构复制文件（适用于目录结构迁移）\n\n\nrm命令是用于在 Linux 中 删除文件和目录 的命令。注意：rm 删除后不会进入回收站，无法轻易恢复，请务必小心使用。\n\n\n\n功能\n命令\n说明\n\n\n\n删除单个文件\nrm file.txt\n删除文件 file.txt\n\n\n删除多个文件\nrm file1.txt file2.txt\n一次删除多个文件\n\n\n递归删除目录及内容\nrm -r mydir/\n删除目录 mydir 及其所有子目录和文件\n\n\n强制删除文件&#x2F;目录\nrm -f file.txt &#x2F; rm -rf mydir/\n忽略不存在的文件，且不提示确认\n\n\n删除前确认\nrm -i file.txt\n删除前逐一询问确认\n\n\n显示正在删除的文件\nrm -v file.txt\n显示被删除的文件名\n\n\n\n\n\n选项\n含义\n\n\n\n-r 或 --recursive\n递归删除目录及其内容（删除整个目录树）\n\n\n-f 或 --force\n强制删除，不提示，即使目标不存在也不报错\n\n\n-i\n删除前询问确认，适合新手使用以防误删\n\n\n-I\n删除多个文件或目录时才询问一次，比 -i 安全且不烦人\n\n\n-v 或 --verbose\n显示正在删除的每一个文件或目录\n\n\n--preserve-root\n默认保护根目录 / 不被删除（系统安全机制，防止 rm -rf / 误操作）\n\n\nmv命令移动文件或目录 到新位置，重命名 文件或目录。\n\n\n\n功能\n命令示例\n说明\n\n\n\n移动文件\nmv a.txt /home/user/docs/\n把 a.txt 移动到 /home/user/docs/ 目录\n\n\n重命名文件\nmv old.txt new.txt\n将 old.txt 重命名为 new.txt\n\n\n移动并重命名\nmv a.txt /home/user/docs/b.txt\n移动 a.txt 到新目录并改名为 b.txt\n\n\n移动目录\nmv dir1/ /home/user/backup/\n移动整个目录到新的路径\n\n\n覆盖已有文件\nmv -f a.txt b.txt\n如果 b.txt 存在，则强制覆盖\n\n\n覆盖前确认\nmv -i a.txt b.txt\n如果 b.txt 存在，移动前会询问是否覆盖\n\n\n显示移动过程\nmv -v a.txt b.txt\n显示正在移动的内容\n\n\n\n\n\n选项\n含义\n\n\n\n-f\n强制覆盖已有目标文件，不提示\n\n\n-i\n如果目标文件存在，提示是否覆盖（interactive）\n\n\n-n\n不覆盖已有的目标文件（no-clobber）\n\n\n-v\n显示移动过程（verbose）\n\n\n-u\n仅在源文件较新或目标文件不存在时才移动\n\n\n文件内容查看相关命令cat命令用于 查看、创建、合并文件 内容，常用于快速查看文本文件内容。\n\n\n\n选项\n含义\n\n\n\n-n\n给所有行编号\n\n\n-b\n只对非空行编号\n\n\n-s\n压缩连续空白行为一行\n\n\n-T\n显示 Tab 为 ^I\n\n\n-E\n显示每行结尾的 $（换行符可见）\n\n\n-A\n相当于 -vET，显示所有不可见字符\n\n\nless命令用于分页显示文件内容的命令，支持 向前&#x2F;向后翻页浏览，适合查看大型文本文件。它比 cat 更强大，且不会一次性加载全部内容到内存中。\n使用时常用快捷键（进入 less 后）\n\n\n\n快捷键\n功能说明\n\n\n\n空格\n向下翻一页\n\n\nb\n向上翻一页\n\n\nEnter\n向下滚动一行\n\n\nk\n向上一行（vi 风格）\n\n\nj\n向下一行\n\n\nG\n跳到文件末尾\n\n\ng\n跳到文件开头\n\n\n/关键词\n向下搜索（如 /error）\n\n\n?关键词\n向上搜索\n\n\nn\n重复上一次搜索\n\n\nN\n反向重复搜索\n\n\nq\n退出 less\n\n\nhead命令head 用于查看文件的前几行内容，默认显示前 10 行。适合快速预览文件开头，尤其是大型文件或日志文件。\n\n\n\n选项\n说明\n\n\n\n-n N\n显示前 N 行（如 head -n 15 file.txt）\n\n\n-c N\n显示前 N 个字节（如 head -c 100 file.txt）\n\n\n-q\n多文件时不显示文件名头部（quiet）\n\n\n-v\n总是显示文件名头部（verbose）\n\n\ntail命令用于显示文件的最后几行内容，默认是最后 10 行。常用于：\n\n查看日志尾部；\n实时监控文件内容变化（配合 -f 选项）；\n截取文件结尾部分数据。\n\ntail /etc/passwd #默认显示后十行\ntail -n 30 文件名 #显示后30行内容\ntail -c 30 文件名 #显示后30个字符\n\ndu和df命令du命令查看目录或文件占用的磁盘空间，会考虑磁盘块对齐、文件系统元数据、软链接等因素。\n\n\n\n参数\n含义\n\n\n\n-h\n以人类可读的方式显示（如 KB、MB）\n\n\n-s\n显示指定文件&#x2F;目录占用的数据块\n\n\n-a\n显示所有文件和目录的大小（默认只显示目录）\n\n\n--max-depth=N\n显示目录深度（限制递归层数）\n\n\ndu -sh 文件名/目录\n\n\n\n\n项目\nls -l\ndu -sh\n\n\n\n显示内容\n文件本身大小（内容字节数）\n实际磁盘占用（包含对齐和元数据）\n\n\n对目录\n显示目录结构本身大小\n显示目录下所有内容实际占用\n\n\n单位\n字节（Bytes）\n自动转换为 KB&#x2F;MB&#x2F;GB\n\n\n应用场景\n看文件大小&#x2F;属性\n查哪些文件&#x2F;目录占空间最多\n\n\necho \"hello\" > file.txt\nls -l file.txt      # 显示 6 bytes\ndu -sh file.txt     # 显示 4.0K\n\ndf命令查看整个磁盘的使用情况\ndf -h # 显示所有文件系统的使用情况（人类可读格式）\ndf -h /home # 查看 /home 所在分区的磁盘使用情况\n\n查找相关命令findfind 是 Linux 中功能非常强大的文件搜索命令，它可以根据名称、类型、时间、大小、权限等多种条件在目录中递归查找文件，还可以执行删除、移动、打印等操作。\nfind [搜索路径] [搜索条件] [处理动作]\n\n按文件名查询：使用参数 -name\nfind ./ -name \"*.txt\" #查找当前路径下符合后缀是。txt的文件\n\n按文件大小查询：使用参数 -size\nfind ./ -size +100k\n\n+100k 表示大于100k的文件\n-100k表示小于100k的文件\n100k 表示等于100k的文件\n大小方面：k小写，M大写\n查询大小范围\nfind ./ -size +50k -size -100k\n\n按文件类型查询：使用参数 -type\nfind ./ -type f #查询当前的普通文件\n\n\n\n\n类型代号\n含义\n示例\n\n\n\nf\n普通文件\nfind . -type f 查找所有普通文件（这里不是-，要和ls -l的文件类型区分）\n\n\nd\n目录\nfind . -type d 查找所有目录\n\n\nl\n符号链接（软链接）\nfind . -type l 查找所有软链接\n\n\nc\n字符设备文件\n/dev/null 等\n\n\nb\n块设备文件\n硬盘等块设备\n\n\ns\n套接字文件\nSocket 类型文件\n\n\np\n命名管道（FIFO）\n通信用的特殊文件\n\n\ngrepgrep 是 Linux 中非常常用的文本搜索工具，用于在文件或标准输出中查找匹配的字符串，功能强大，灵活，适合日志分析、配置文件搜索、编程辅助等场景。\ngrep [选项] \"模式\" [文件]\n\n\n\n\n选项\n含义说明\n\n\n\n-n\n显示匹配行的行号\n\n\n-i\n忽略大小写\n\n\n-v\n反向匹配（即显示不包含该字符串的行）\n\n\n-r or -R\n递归搜索目录下的所有文件\n\n\n-l\n只列出匹配的文件名\n\n\n-c\n统计匹配的行数\n\n\n--color=auto\n高亮显示匹配的内容\n\n\ngrep -i \"root\" /etc/passwd #不分大小写，在passwd查找root\ngrep -w \"hello\" /etc/passwd #在passwd查找完全匹配hello单词的行\ngrep -r \"u_char\" ./  #递归搜索当前目录下的符合u_char的行\ngrep -i \"hello\" /etc/passwd --color=auto #在/etc/passwd文件中找hello并且忽略大小写，然后高亮显示匹配的关键字\n\n管道管道（|）一个命令的输出可以通过管道作为另一个命令的输入。\nifconfig | grep \"ens33\" #在ifconfig输出的文字查找存在ens33的行\n\n压缩包管理tar把一系列文件归档到一个文件，也可以把档案文件解开以恢复数据。\ntar [选项] -f [文件名.tar] [要打包或解压的文件/目录]#f必须放到选项的最后\n\ntar -cvf sysctl.tar sysctl #打包文件，但是不压缩\ntar -xvf sysctl.tar #解包文件\ntar -tvf sysctl.tar #查看压缩文件内容\n\ngzip对单个文件进行压缩或解压，压缩率高、速度快，默认生成 .gz 文件。\ntar和gzip命令结合使用实现文件打包，压缩。\ntar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般为xxx.tar.gz。\ngzip单独使用，只可以对文件压缩和解压，不可以对目录。\ngzip test1 test2 #不保留源文件压缩。 \n\ntar和gzip结合对目录压缩\ntar -czvf sysctl.tar.gz sysctl #打包和压缩文件\ntar -xzvf sysctl.tar.gz #解包和解压文件\ntar -xzvf sysctl.tar.gz -C /temp #解包和解压文件到temp目录\n\nbzip2和gzip一样和tar结合。\ntar -cjvf test.tar.bz2 test #生成一个bz2压缩包\ntar -xjvf share.tar.bz2 #解压\n\nzip和unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。\nzip [选项] 目标文件（没有扩展名）源文件/目录\nunzip -d 解压后目录文件 压缩文件 #-d解压到指定目录\n\n文件权限管理访问权限说明：\n读权限（r）\n对文件而言，具有读取文件内容的权限；对目录而言，具有浏览目录的权限。\n写权限（w）\n对文件而言，具有新增，修改文件内容的权限；对目录而言，具有删除，移动目录内文件的权限。\n可执行权限（x）\n对文件而言，具有执行文件的权限；对目录而言，该用户具有进入目录的权限。\n通常。Unix&#x2F;Linux系统只允许文件的属主（所有者）或root用户改变文件的读写权限。\nchmodchmod（change mode）是 Linux&#x2F;Unix 系统中用于修改文件或目录权限的命令。它支持两种权限设置方式：数字方式和符号方式。\nchmod [选项] 模式 文件名\n\n符号方式：\nchmod u/g/o/a +/-/= rwx 文件 #+添加权限 -撤销权限 =设定权限 u/g/o对应的是拥有者，同属组，其他。\nchomd o+w a #向a的其他用户添加写权限\nchomd u=rw,g=r,o=r a#把a的拥有者权限为re,同属组权限为r,其他用户权限为r。\n\n数字方式：\n#由于rwx通过二进制来区分 rwx就是111，十进制为7\n#rwx   7\n#rw-   6\n#r--   4\n#r-x   5\nchomd 777 a#把a的对应用户的权限变为rwx.\n\nchownchown 是 Linux&#x2F;Unix 中用于更改文件或目录 所属用户（owner） 和 所属用户组（group） 的命令。\nchown [选项] [新用户][:[新用户组]] 文件/目录\n\n新用户：新的文件拥有者\n新用户组：新的用户组（可选）\n需要 sudo 权限（普通用户只能修改自己拥有的文件）\n#把文件所有者修改为root用户\nsudo chown root a\n#把文件所属者改为yustone,所属组改为root\nsudo chown yustone:root a\n\n软件安装和卸载使用包管理器安装和卸载Ubuntu &#x2F; Debian 系列\n安装\nsudo apt update          # 更新软件源\nsudo apt install 软件名  # 安装软件\n\n卸载\nsudo apt remove 软件名           # 删除程序但保留配置文件\nsudo apt purge 软件名            # 连配置文件一并删除\n\n离线软件包安装：\nsudo dpkg -i package.deb\n\n离线软件包卸载：\nsudo dpkg -r 软件名\n\n使用 Snap 安装（跨平台容器化安装方式）\nsudo snap install 软件名\n\n使用 Snap 卸载（跨平台容器化安装方式）\nsudo snap remove 软件名\n\n从源代码编译安装\n./configure\nmake\nsudo make install\n\n重定向主要是把命令输出的内容（之前是屏幕）输入到文件里。\nls /etc/passwd > output.txt #标准正确输出重定向到output.txt（这里是覆盖原文件）\nls /etc/passwd >> output.txt #标准正确输出追加重定向到output.txt(这里是追加)\nllll 2> error.txt #标准错误输出重定向到error.txt(这里是覆盖原文件)\nllll 2>> error.txt #标准错误输出追加重定向到error.txt\nlll 2> /dev/null #标准错误输出重定向到黑洞\nls ddddd /etc/passwd &amp;> /dev/null #标准正确输出和标准错误输出全部重定向到黑洞。\nls ddddd /etc/passwd &amp;>> output.txt #标准正确输出和标准错误输出以追加的方式全部重定向到output.txt.\n\n其他命令treetree以树状形式查看指定目录内容。\ntree 目录\n\nlnln命令主要用于创建链接文件。\n链接文件分为软链接和硬链接：\n硬链接只能链接普通文件，不能链接目录。软链接不占用磁盘空间，源文件删除则链接失效。\nln 源文件 链接文件 #硬链接\nln -s 源文件 链接文件 #软链接\n\n如果没有-s选项代表建立一个硬链接文件，两个文件占用同一块的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s比较常用。如果软链接文件和源文件不在同一目录，源文件最好使用绝对路径，不要使用相对路径。软链接文件存储的是目标文件的路径。\nvimvim 是一款强大的 文本编辑器，常用于 Linux &#x2F; Unix 系统编程、脚本编辑、配置文件修改等场景。它是 vi 的增强版本，具有更强的功能，比如语法高亮、代码折叠、多窗口、多标签支持等。\nvim的三种模式普通模式（Normal Mode）\n默认启动模式，你一打开 Vim 就是在这个模式。\n作用：浏览、复制、剪切、粘贴、删除、移动光标、跳转、执行命令等。\n常用命令：\n\n\n\n命令\n说明\n\n\n\nh&#x2F;l\n左&#x2F;右移动光标\n\n\nj&#x2F;k\n下&#x2F;上移动光标\n\n\n[n]dd\n删除当前行开始的n行（准确说是剪切）\n\n\n[n]x\n删除光标后n个字符\n\n\n[n]X\n删除光标前n个字符\n\n\n[n]yy\n复制从当前行开始的n行\n\n\np\n粘贴\n\n\nu\n撤销前一个命令\n\n\nCtrl + r\n还原（恢复）\n\n\n:\n进入命令模式\n\n\ni、a\n进入插入模式\n\n\nmG&#x2F;mgg\n到指定行，m为目标行数\n\n\n&#x2F;字符串\n从当前光标位置向下查找（n,N查找内容切换）\n\n\n?字符串\n从当前光标位置向上查找（n,N查找内容切换）\n\n\n插入模式（Insert Mode）\n按 i、a、o 等从普通模式进入插入模式。\n作用：输入文字、写代码、编辑内容。\n常用进入方式：\n\n\n\n命令\n含义\n\n\n\ni\n在光标前插入\n\n\na\n在光标后插入\n\n\no\n在当前行下方新开一行并插入\n\n\nI\n跳到行首插入\n\n\nA\n跳到行尾插入\n\n\n退出插入模式：按 Esc 返回普通模式。\n命令模式（Command-Line Mode）\n按 : 从普通模式进入命令模式。\n用于输入各种操作命令，如保存、退出、查找、替换等。\n常用命令：\n\n\n\n命令\n功能\n\n\n\n:w\n保存\n\n\n:q\n退出\n\n\n:wq 或 ZZ\n保存并退出\n\n\n:q!\n强制退出（不保存）\n\n\n:x\n等同于 :wq\n\n\n:/关键字\n向下查找关键字\n\n\n:s/旧/新/g\n当前行替换所有匹配项\n\n\n:1,10s&#x2F;abc&#x2F;123&#x2F;g\n把第一行到第十行之间的abc全部替换为123\n\n\n:%s/旧/新/g\n全文替换所有匹配项\n\n\n:w filename\n保存到指定文件（绝对路径）\n\n\n:sp 文件名\n当前文件和另一个文件水平分屏\n\n\n:vsp 文件名\n当前文件和另一个文件垂直分屏\n\n\nctrl+w+w\n在多个窗口切换光标\n\n\ngcc编译器GCC（GNU Compiler Collection）是由 GNU 项目开发的一组编译器，最初是为了 C 语言开发的，现在支持多种编程语言\ngcc编译器从拿到一个c源文件到生成一个可执行文件，中间一共经历了四个步骤：\n\ngcc -E hello.c -o hello.i\ngcc -S hello.i -o hello.s\ngcc -c hello.s -o hello.o\ngcc hello.o -o hello\n./hello #执行\ngcc 源文件 -o 可执行文件 #一步到位\ngcc hello.c -o hello\n./hello\n\n\n\n\n选项\n含义\n\n\n\n-o\n指定输出文件名\n\n\n-Wall\n打开所有警告信息\n\n\n-g\n生成调试信息，用于 GDB 调试\n\n\n-O0/-O1/-O2/-O3\n优化等级（0 表示无优化）\n\n\n-c\n只编译不链接，生成 .o 目标文件\n\n\n-I\n添加头文件搜索路径\n\n\n-L\n添加库文件搜索路径\n\n\n-l\n链接指定的库（例如 -lm 表示链接 math 库）\n\n\n-v&#x2F;–version\n查看gcc版本号\n\n\n-D\n编译时定义宏\n\n\ngcc -Wall test.c #显示所有的警告信息\ngcc -Wall -Werror test.c #把警告信息当作错误处理\ngcc tmp.c -DDEBUG #可以用来区分测试版和发布版,DEBUG是定义的宏\n\n静态链接和动态链接静态链接：由链接器在链接时把库的内容加入到可执行程序中。\n优点：对运行环境的依赖较小，具有较好的兼容性。\n缺点：生成的程序比较大，在装入内存消耗更多的时间。库函数有了更新，必须重新编译。\n动态链接：链接器在链接时仅仅建立和所需库函数的链接关系，在程序运行时才将所需资源调入可执行程序。\n优点：在需要的时候才会调入对应的资源函数。简化程序的升级，有着较小的程序体积，实现进程间的资源共享（避免重复拷贝）\n缺点：依赖动态库，不能独立运行，动态库依赖版本问题严重。\n静态和动态编译对比我们编写的应用程序大量用到了库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入-static参数。\ngcc test.c -o test\ngcc -static test.c -o test\n\n静态编译是要比动态编译程序大的多。\n静态库和动态库静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。按照习惯，一般以”.a”作为文件后缀名。静态库的命名一般分为三个部分：前缀：lib,库名称：自己定义。后缀：.a。最终静态库的名字为libxxx.a\n静态库制作：\ngcc -c add.c -o add.o #-c是只编译不链接输出.o文件\ngcc -c sub.c -o sub.o\ngcc -c mul.c -o mul.o\ngcc -c div.c -o dic.o\nar -rcs libtest.a add.o sub.o mul.o div.o#使用打包工具ar将准备好的.o文件打包为.a文件libtest.a\n\n在使用ar工具需要添加参数：rcs \nr更新，c创建，s建立索引\n静态库使用：静态库制作完成之后，需要将.a文件和头文件一起发布给用户。假设测试文件是main.c,静态库文件为libtest.a，头文件为head.h\n编译命令：\ngcc main.c -L./ -I./ -ltest -o main#注意这里链接库的名字\n\n-L：表示要连接的库所在目录。\n-ltest:指定链接时需要的库，去掉前缀和后缀\n-I(这里是大写的i):表示要连接的头文件目录\n动态库制作共享库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。\n动态库在程序运行时才被载入，也解决了静态库对程序的更新，部署和发布的再次编译的问题，用户只需要更新动态库即可，增量更新。\n一般以”.so”作为文件后缀名。共享库的命名一般分为三个部分：前缀lib,库名称:自己定义，后缀：.so。所以最终的动态库的名字应该为：libxxx.so。\n#生成目标文件，此时要加编译选项：-fPIC(fpic)参数-fPIC创建与地址无关的编译程序（pic,position independent code）,是为了能在多个应用程序间共享。\ngcc -fPIC -c add.c\ngcc -fPIC -c sub.c\ngcc -fPIC -c mul.c\ngcc -fPIC -c div.c\n#生成共享库，此时要加链接器选项：-shared(指定生成动态链接库)\ngcc -shared add.o sub.o mul.o div.o -o libtest.so\n#通过nm命令查看对应的函数\nnm libtest.so | grep \"add\"\n#通过ldd命令查看可执行文件依赖的动态库\nldd test\n\n动态库使用引用动态库编译成可执行文件（和静态库一样）\ngcc main.c -L./ -I./ -ltest -o main#注意这里链接库的名字\n\n这一步是可以过的，但是到了，执行main时发现找不到对应文件。第一种就是把libtest.so复制到&#x2F;lib里（需要sudo,这个方法不推荐，最好不要动Linux原本文件，覆盖了就不好玩了。）\ngcc main.c -I./ -ltest -o main#注意这里链接库的名字,执行可执行文件就可以执行了，这种方法不推荐\n\n动态库加载失败问题解决当系统加载可执行代码，能够知道其所依赖的库的名字，但还需要知道其绝对路径。此时就需要系统动态载入器（dynamic linker&#x2F;loader）。对于elf格式的可执行程序，是由ld-linux.so*来完成，他先后搜索elf文件的DT_RPATH段—环境变量LD_LIBRARY_PATH—&#x2F;etc&#x2F;ld.so.cache文件列表—&#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib目录找到库文件后将其载入内存。\n拷贝自己制作的共享库到&#x2F;lib或者&#x2F;usr&#x2F;lib(不能是&#x2F;lib64目录)\n临时设置LD_LIBRARY_PATH(只在当前终端生效):\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径#在原环境变量追加新的变量，库路径为绝对路径。\n\n永久设置:把export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:库路径这段话，设置到~&#x2F;.bashrc \nsource ~/.bashrc #让配置文件生效\n\n除了以上三种还有两种将其添加到&#x2F;etc&#x2F;ld.so.conf,这里只需要添加绝对路径，然后sudo ldconfig -v使路径生效。\n还有使用符号链接，但一定要使用绝对路径。\nsudo ln -s 库文件的绝对路径 /lib/库文件\n\nGDB调试器GDB主要完成下面四个功能：\n1.启动程序，可以按照你的自定义的要求随心所欲的运行程序。\n2.可让被调试的程序在你指定的断点停住。\n3.当程序被停住时，可以检查此时你的程序中所发生的事。\n4.动态的改变你程序的执行环境。\n生成调试信息一般来说GDB主要调试的是C&#x2F;C++的程序，要调试C&#x2F;C++的程序，首先在编译时，我们必须把调试信息加到可执行文件中。使用编译器（cc&#x2F;gcc&#x2F;g++）的-g参数可以做到这一点。\ngcc -g hello.c -o hello\ng++ -g hello.c -o hello\n\n启动GDB启动gdb:gdb program\nprogram也就是你的执行文件，一般在当前目录下。\n设置启动参数:启动后设置\nset args #可指定运行参数\nset args 10 20 30 40 \"hello world\"\nshow args #命令可以查看设置好的运行参数\n\n启动程序：\nrun:程序开始执行，如果有断点，停在第一个断点处。\nstart:程序向下执行一行。\nn:执行下一步。\n显示源代码用list（也可直接打l）命令来打印程序的源代码。默认打印10行。\nlist function#显示函数名为function的函数的源码\nset listsize count #设置一次显示源码的行数默认是10行\nshow listsize #查看当前listsize的设置\n\n断点操作简单断点:\nbreak设置断点，可以简写为b\nb 10 #设置断点，在源程序第十行\nb func #设置断点，在func函数入口处\n\n多文件设置断点\nbreak filename:linenum #在源文件filename的linenum行处停住\nbreak filename:function #在源文件filename的function函数的入口处停住\nbreak class::function或者function(type,type) #在类class的function函数入口处停住\nbreak namespace::class::function #在名称空间为namespace的类class的function函数的入口处停住。\n\n查询所有断点\ninfo b\ninfo break\ni break\ni b\n\n条件断点一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。\n设置一个条件断点：\nb test.c:8 if Value == 5 #对test.c文件的当变量Value满足为5时，在test.c文件的第8行产生断点\n\n维护断点delete 范围 删除指定的断点，其简写命令为d。如果不指定断点号，则表示删除所有的断点。\nd 10-12 #删除编号为10-12的断点。编号可以使用i b命令查看\n\n比删除更好的一种方法时disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可。\ndisable 断点编号 #使指定断点无效，简写命令是dis。如果什么都不指定，表示disable所有的停止点。\nenable 断点编号 #使无效断点生效，简写命令是ena。如果什么都不指定，表示enable所有的停止点\n\n调试代码run #运行程序，可简写为r。程序开始执行，如果有断点，停在第一个断点处。\nnext #单步跟踪，函数调用当作一条简单语句执行，可简写为n。\nstep #单步跟踪，函数调用进入被调用函数体内，可简写为s。\nfinish #退出进入的函数\nuntil #在一个循环体单步跟踪时，这个命令可以运行程序直到退出循环体，可简写为u。\ncontinue #继续运行程序，停在下一个断点的位置，可简写为c。\nquit #退出gdb,可简写为q。\n\n数据查看#查看运行时的数据\n#print打印变量，字符串，表达式等的值，可简写为p。\np count #打印count的值\n\n自动显示可以设置一些自动显示的变量，当程序停住时，或在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display\ndisplay 变量名 #在run启动程序后，使用该命令。\ninfo display #查看display设置的自动显示的信息（可以看到对应变量名的编号）\nundisplay num #info display是显示的编号 使对应编号的自动显示功能失效。\ndelete display dnums #删除自动显示，dnums意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围的编号，可以用减号表示。\ndisable display dnums\nenable display dnums\ndisable和enable#不删除自动显示的设置，而只是让其失效和恢复。\n\n查看修改变量的值ptype width #查看变量width的类型\np width #打印变量width的值 p是print命令的缩写。\nset var width=47 #将变量var值设置为47。在改变程序变量取值时，最好都使用set var格式的GDB命令。\n\n自动化编译工具Makefilemake是个命令工具。\nsudo apt install make #下载make命令\n\nMakefile语法规则一条规则：\n目标：依赖文件列表\n&lt;Tab>命令列表\n\nall:test1 test2\n\techo \"hello all\"\n\t\ntest1:\n\techo \"hello test1\"\n\ntest2:\n\techo \"hello test2\"\n#总共三条规则\n#执行结果：make -f 1.mk\necho \"hello test1\"\nhello test1\necho \"hello test2\"\nhello test2\necho \"hello all\"\nhello all\n\nMakefile基本规则三要素：\n目标:\n​\t通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作的名称。\n依赖文件：\n​\t用来输入从而产生目标的文件。\n​\t一个目标通常有几个依赖文件（可以没有）\n命令：\n​\tmake执行的动作，一个规则可以含几个命令（可以没有）\n​\t有多个命令，每个命令占一行。\nmake命令格式make [-f file][options][targets]\n[-f file]:\nmake默认在工作目录中寻找为GNUmakefile,makefile,Makefile的文件作为makefile输入文件。\n-f可以指定以上名字以外的文件作为makefile输入文件。\n[options]:\n-v 显示make工具的版本\n-w 在处理makefile之前和之后显示工作路径\n-C dir 读取makefile之前改变工作路径至dir目录\n-n 只打印要执行的命令但不执行\n-s 执行但不显示执行的命令\n[targets]:\n若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个规则\n指定了make工具要实现的目标，目标可以是一个或多个（多个目标用空格隔开）\nmake test1 -f 1.mk #就会执行目标为test1对应的语句。\n\nMakefile示例测试程序：test.c add.c sub.c mul.c div.c add.h sub.h mul.h div.h\n#最简单的Makefile(首先vim Makefile)\ntest:test.c add.c sub.c mul.c div.c\n\tgcc test.c add.c sub.c mul.c div.c -o test\n\n缺点：效率低，修改一个文件，所有文件都要重新编译。\ntest:test.o add.o sub.o mul.o div.o \n\tgcc test.o add.o sub.o mul.o div.o -o test\nadd.o:add.c\n\tgcc -c add.c -o add.o\nsub.o:sub.c\n\tgcc -c sub.c -o sub.o\nmul.o:mul.c\n\tgcc -c mul.c -o mul.o\ndiv.o:div.c\n\tgcc -c div.c -o div.o\ntest.o:test.c\n\tgcc -c test.c -o test.o\n\n这样，下次编译，他只会编译你修改的文件，最后再链接，这样是比较高效的。\nMakefile中的变量在Makefile中使用变量有点类似c语言的宏定义，使用该变量相当于内容替换，使用变量可以使Makefile易于维护。如果.o文件很多，难道我们要一个一个打吗，这也未免太麻烦，还可能漏打。\n自定义变量定义变量：\n变量名=变量值\n\n引用变量：\n$(变量名)或$&#123;变量名&#125;\n\nmakefile的变量名：\nmakefile变量名可以以数字开头。\n变量是大小写敏感的。\n变量一般在makefile的头部定义\n变量几乎可在makefile的任何地方使用\nOBJS = test.o add.o sub.o mul.o div.o\ntest:$(OBJS)\n\tgcc $(OBJS) -o test\nadd.o:add.c\n\tgcc -c add.c -o add.o\nsub.o:sub.c\n\tgcc -c sub.c -o sub.o\nmul.o:mul.c\n\tgcc -c mul.c -o mul.o\ndiv.o:div.c\n\tgcc -c div.c -o div.o\ntest.o:test.c\n\tgcc -c test.c -o test.o\n\n除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户使用，我们可以直接对其进行赋值。\nCC=gcc\nCPPFLAGS:\nCFLAGS:\nLDFLAGS:\n\n自动变量#这些变量不能单独使用 必须在命令中使用\n# $@ 表示目标\n# $^ 表示所有的依赖\n# $&lt; 表示第一个依赖\n\nOBJS = test.o add.o sub.o mul.o div.o\nTARGET=test\n$(TARGET):$(OBJS)\n\tgcc $^ -o $@\nadd.o:add.c\n\tgcc -c $&lt; -o $@\nsub.o:sub.c\n\tgcc -c $&lt; -o $@\nmul.o:mul.c\n\tgcc -c $&lt; -o $@\ndiv.o:div.c\n\tgcc -c $&lt; -o $@\ntest.o:test.c\n\tgcc -c $&lt; -o $@\n\n模式规则#模式规则匹配示例\n%.o:%.c\n$(cc) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@\n\nOBJS=test.o add.o sub.o mul.o div.o\nTARGET=test\n$(TARGET):$(OBJS)\n\tgcc $(OBJS) -o $(TARGET)\n#模式匹配 所有的.o都依赖对应的.c\n#将所有的.c生成对应的.o\n%.o:%.c\n\tgcc -c $&lt; -o $@\n\nMakefile的函数常用的函数\nwildcard #查找指定目录下的指定类型的文件\nsrc=$(wildcard *.c) #找到当前目录下所有后缀为.c的文件，赋值给src\npatsubst #匹配替换\nobj=$(patsubst %.c,%.o,$(src)) #把src变量里所有后缀为.c的文件替换成.o\n\n在makefile中所有的函数都是有返回值的。\n#获取当前目录下所有的.c文件\nSRC=$(wildcard ./*.c)\n#将SRC中所有出现的.c的替换成.o\nOBJS=$(patsubst %.c,%.o,$(SRC))\nTARGET=test\n$(TARGET):$(OBJS)\n\tgcc $(OBJS) -o $(TARGET)\n#模式匹配 所有的.o都依赖对应的.c\n#将所有的.c生成对应的.o\n%.o:%.c\n\tgcc -c $&lt; -o $@\n#clean目标清除编译生成的中间文件\n#执行命令 make clean\nclean:\n\trm -rf $(OBJS) $(TARGET)\n\nMakefile中的伪目标clean用途：清除编译生成的中间.o文件和最终目标文件\nmake clean 如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：\n伪目标声明：.PHONY:clean 声明目标为伪目标之后，makefile将不会判断目标是否存在或者该目标是否需要更新。\n#获取当前目录下所有的.c文件\nSRC=$(wildcard ./*.c)\n#将SRC中所有出现的.c的替换成.o\nOBJS=$(patsubst %.c,%.o,$(SRC))\nTARGET=test\n$(TARGET):$(OBJS)\n\tgcc $(OBJS) -o $(TARGET)\n#模式匹配 所有的.o都依赖对应的.c\n#将所有的.c生成对应的.o\n%.o:%.c\n\tgcc -c $&lt; -o $@\n#clean目标清除编译生成的中间文件\n#执行命令 make clean\n#声明clean为伪目标\n.PHONY:clean\nclean:\n\trm -rf $(OBJS) $(TARGET)\n\n上面这个版本就是最终版。\n@gcc -c $&lt; -o $@ #在命令前加上@符号，表示不显示命令本身（默认显示），只显示结果\n-gcc -c $&lt; -o $@ #加上-符号，此条命令出错，make也会继续执行后续的命令。\n\n系统调用系统调用说的是操作系统提供给用户程序调用的一组”特殊”接口\n系统调用和库函数的区别Linux下对文件操作有两种方式：系统调用和库函数调用\n库函数调用有两类函数组成：\n不需要系统调用：不需要切换到内核空间即可完成函数全部功能，并且结果反馈给应用程序，如strcpy,bzero等字符串操作函数。\n需要调用系统调用：需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如printf,fread等。\n\n错误处理函数errno是记录系统的最后一次错误代码，代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。\n当Linux C api函数出现异常时，一般会将errno全局变量赋一个整数值。\n#include &lt;stdio.h> //fopen\n#include &lt;errno.h> //errno\n#include &lt;string.h> //strerror(errno)\nint main()&#123;\n    FILE *fp=fopen(\"xxxx\",\"r\");\n    if(fp==NULL)&#123;\n        printf(\"%d\\n\",errno);//打印错误码\n        printf(\"%d\\n\",strerror(errno));//把errno的数字转换为相应的文字\n        perror(\"fopen err\"); //打印错误原因的字符串\n        //perror和printf(\"%d\\n\",strerror(errno));实现效果相同。\n    &#125;\n    return 0;\n&#125;\n\n虚拟地址空间每个进程都会分配虚拟地址空间，在32位机器上，该地址空间为4G。Linux每个运行的程序（进程），操作系统就会为其分配一个04G的地址空间（虚拟地址空间）。03G是用户区，3G~4G是内核区。在进程里平时所说的指针变量，保存的就是虚拟地址，当应用程序使用虚拟地址访问内存时，处理器会将其转换为物理地址（MMU）MMU将虚拟地址转换为物理地址。这样做的好处在于：进程隔离，更好的保护系统安全运行，屏蔽物理差异带来的麻烦，方便操作系统和编译器安排进程地址。\n文件描述符打开现存文件或新建文件时，系统内核会返回一个文件描述符，文件描述符用来指定已打开的的文件。这个文件描述符相当于已打开文件的标号，文件描述符是非负整数，是文件的标识，操作这个文件描述符相当于操作这个描述符所指定的文件。\n程序运行起来后（每个进程）都有一张文件描述符的表，标准输入，标准输出，标准错误输出设备文件被打开，对应的文件描述符0，1，2记录在表中。程序运行起来后这三个文件描述符是默认打开的。\n在程序运行起来后，打开其他文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中。\n最大打开的文件个数：​\tLinux中一个进程最多只能打开NR_OPEN_DEFAULT(即1024)个文件（当然这个数量的设定是可以修改的），故当文件不再使用时应该及时调用close()函数关闭文件。\n常用文件IO函数open函数#include&lt;sys/types.h>\n#include &lt;sys/stat.h>\n#include &lt;fcntl.h>\nint open(const char *pathname,int flags);\nint open(const char *pathname,int flags,mode_t mode);\n\n功能：\n​\t打开文件，如果文件不存在则可以选择创建。\nclose函数#include &lt;unistd.h>\n\nint close(int fd)\n\n功能：\n​\t关闭已打开的文件。\n需要说明的是，当一个进程终止时，内核对该进程所有未关闭的文件描述符调用close关闭，所以即使用户程序不调用close,在终止时内核也会自动关闭它打开的文件。\n但是对于一个常年累月的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量的文件描述符和系统资源。\n#include&lt;stdio.h>\n#include&lt;string.h>\n#include&lt;sys/type.h>\n#include&lt;sys/stat.h>\n#include&lt;fcntl.h>\n//打开和关闭文件\nint main()&#123;\n    int fd=-1;\n    //以只读的方式打开一个文件，如果文件不存在就报错。\n    //fd=open(\"txt\",O_RDONLY);\n    //以只写的方式打开一个文件 如果文件存在就直接打开 如果文件不存在就新建一个文件。\n    //fd=open(\"txt\",O_WRONLY|O_CREAT,644);\n    //以只写的方式打开一个文件，如果文件存在就报错，如果文件不存在就新建一个。\n    //fd=open(\"txt\",O_WRONLY|O_CREAT|O_EXCL,644);\n    //以读写方式打开一个文件，如果文件存在就打开，如果文件不存在就新建一个文件。\n    //fd=open(\"txt\",O_RDWR|O_CREAT,644);\n    //O_TRUNC 清空文件内容,如果文件存在，打开并清空，不存在就新建一个文件。\n    //fd=open(\"txt\",O_WRONLY|O_TRUNC|O_CREAT,644);\n    //O_APPEND 追加的方式\n    //以只写的方式和追加的方式打开一个文件 如果文件不存在会报错。\n    fd=open(\"txt\",O_WRONLY|O_APPEND)\n    if(fd==-1)&#123;\n        perror(\"open\");\n        return 1;\n    &#125;\n    //关闭文件\n    close(fd);\n    return 0;\n&#125;\n\nwrite函数#include&lt;unistd.h>\nssize_t write(int fd,const void* buf,size_t count);\n功能：\n    把指定数目的数据写到文件（fd）\n参数：\n    fd: 文件描述符\n    buf:数据首地址\n    count:写入数据的长度（字节）\n返回值：\n    成功：实际写入数据的字节个数\n    失败：-1\n\nread函数#include&lt;unistd.h>\nssize_t read(int fd,void *buf,size_t count);\n功能：\n    把指定数目的数据读到内存（缓冲区）\n参数：\n    fd:文件描述符\n    buf:内存首地址\n    count:读取的字节个数\n返回值：\n    成功：实际读取的字节个数\n    失败：-1\n\n","categories":["计算机学习"],"tags":["Linux"]}]