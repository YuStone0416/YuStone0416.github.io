<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="YuStone"><meta name="copyright" content="YuStone"><meta name="generator" content="Hexo 7.3.0"><meta name="theme" content="hexo-theme-yun"><title>Linux系统编程 | YuStone Blogs</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/png" href="/favicon1.ico"><link rel="mask-icon" href="/favicon1.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"yustonerain.top","root":"/","title":"跟着梦走过时光","version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"local_search":{"path":"/search.json"},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="alternate" href="/atom.xml" title="YuStone Blogs" type="application/atom+xml"><link rel="stylesheet" href="/css/custom.css"><meta name="description" content="Linux常见目录   目录 说明    &#x2F; 根目录，所有目录的起点，Linux 文件系统的顶级目录   &#x2F;bin 存放常用的二进制可执行文件（如 ls、cp、mv 等），普通用户和系统都可使用   &#x2F;sbin 系统管理命令，只有 root 用户可用（如 reboot、ifconfig）   &#x2F;etc 配置文件目录（如 &#x2F;etc&#x2F;passwd、&#x2F;etc&#x2F;fstab、&#x2F;etc&#x2F;ssh&#x2F;sshd_co">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程">
<meta property="og:url" content="http://yustonerain.top/2025/06/20/Linux-System%20Programming.html">
<meta property="og:site_name" content="YuStone Blogs">
<meta property="og:description" content="Linux常见目录   目录 说明    &#x2F; 根目录，所有目录的起点，Linux 文件系统的顶级目录   &#x2F;bin 存放常用的二进制可执行文件（如 ls、cp、mv 等），普通用户和系统都可使用   &#x2F;sbin 系统管理命令，只有 root 用户可用（如 reboot、ifconfig）   &#x2F;etc 配置文件目录（如 &#x2F;etc&#x2F;passwd、&#x2F;etc&#x2F;fstab、&#x2F;etc&#x2F;ssh&#x2F;sshd_co">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yustonerain.top/2025/06/20/Linux-System%20Programming/1.png">
<meta property="og:image" content="http://yustonerain.top/2025/06/20/Linux-System%20Programming/2.png">
<meta property="og:image" content="http://yustonerain.top/2025/06/20/Linux-System%20Programming/3.png">
<meta property="og:image" content="http://yustonerain.top/2025/06/20/Linux-System%20Programming/4.png">
<meta property="article:published_time" content="2025-06-20T13:26:00.000Z">
<meta property="article:modified_time" content="2025-06-28T13:26:00.000Z">
<meta property="article:author" content="YuStone">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yustonerain.top/2025/06/20/Linux-System%20Programming/1.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="YuStone"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="YuStone"><span class="site-author-status" title="四季花开">☺️</span></a><div class="site-author-name"><a href="/about/">YuStone</a></div><span class="site-name">YuStone Blogs</span><sub class="site-subtitle">the world</sub><div class="site-description">圭璋学习总结</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">3</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">2</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">3</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><span class="icon iconify" data-icon="ri:rss-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YuStone0416" title="GitHub" target="_blank" style="color:#181717"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:2754523646@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/436681227?spm_id_from=333.1387.0.0" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">Linux常见目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bash%E8%A7%A3%E6%9E%90%E5%99%A8%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">2.</span> <span class="toc-text">Bash解析器常用快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E7%9B%B8%E5%85%B3%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">3.</span> <span class="toc-text">终端相关快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4%E5%92%8C%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94"><span class="toc-number">4.</span> <span class="toc-text">内建命令和外部命令对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">Linux命令格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">帮助文档查看方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">7.</span> <span class="toc-text">目录相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pwd"><span class="toc-number">7.1.</span> <span class="toc-text">pwd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cd"><span class="toc-number">7.2.</span> <span class="toc-text">cd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mkdir"><span class="toc-number">7.3.</span> <span class="toc-text">mkdir</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rmdir"><span class="toc-number">7.4.</span> <span class="toc-text">rmdir</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">Linux文件类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">9.</span> <span class="toc-text">文件相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ls%E5%91%BD%E4%BB%A4"><span class="toc-number">9.1.</span> <span class="toc-text">ls命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">什么是通配符？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#touch%E5%91%BD%E4%BB%A4"><span class="toc-number">9.3.</span> <span class="toc-text">touch命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cp%E5%91%BD%E4%BB%A4"><span class="toc-number">9.4.</span> <span class="toc-text">cp命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rm%E5%91%BD%E4%BB%A4"><span class="toc-number">9.5.</span> <span class="toc-text">rm命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mv%E5%91%BD%E4%BB%A4"><span class="toc-number">9.6.</span> <span class="toc-text">mv命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">10.</span> <span class="toc-text">文件内容查看相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cat%E5%91%BD%E4%BB%A4"><span class="toc-number">10.1.</span> <span class="toc-text">cat命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#less%E5%91%BD%E4%BB%A4"><span class="toc-number">10.2.</span> <span class="toc-text">less命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#head%E5%91%BD%E4%BB%A4"><span class="toc-number">10.3.</span> <span class="toc-text">head命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tail%E5%91%BD%E4%BB%A4"><span class="toc-number">10.4.</span> <span class="toc-text">tail命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#du%E5%92%8Cdf%E5%91%BD%E4%BB%A4"><span class="toc-number">11.</span> <span class="toc-text">du和df命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#du%E5%91%BD%E4%BB%A4"><span class="toc-number">11.1.</span> <span class="toc-text">du命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#df%E5%91%BD%E4%BB%A4"><span class="toc-number">11.2.</span> <span class="toc-text">df命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">12.</span> <span class="toc-text">查找相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#find"><span class="toc-number">12.1.</span> <span class="toc-text">find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-number">12.2.</span> <span class="toc-text">grep</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">13.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">压缩包管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tar"><span class="toc-number">14.1.</span> <span class="toc-text">tar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip"><span class="toc-number">14.2.</span> <span class="toc-text">gzip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bzip2"><span class="toc-number">14.3.</span> <span class="toc-text">bzip2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zip%E5%92%8Cunzip"><span class="toc-number">14.4.</span> <span class="toc-text">zip和unzip</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text">文件权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chmod"><span class="toc-number">15.1.</span> <span class="toc-text">chmod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chown"><span class="toc-number">15.2.</span> <span class="toc-text">chown</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="toc-number">16.</span> <span class="toc-text">软件安装和卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="toc-number">16.1.</span> <span class="toc-text">使用包管理器安装和卸载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">17.</span> <span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-number">18.</span> <span class="toc-text">其他命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tree"><span class="toc-number">18.1.</span> <span class="toc-text">tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ln"><span class="toc-number">18.2.</span> <span class="toc-text">ln</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vim"><span class="toc-number">19.</span> <span class="toc-text">vim</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vim%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">19.1.</span> <span class="toc-text">vim的三种模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gcc%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">20.</span> <span class="toc-text">gcc编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">21.</span> <span class="toc-text">静态链接和动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E5%AF%B9%E6%AF%94"><span class="toc-number">21.1.</span> <span class="toc-text">静态和动态编译对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">22.</span> <span class="toc-text">静态库和动态库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C%EF%BC%9A"><span class="toc-number">22.1.</span> <span class="toc-text">静态库制作：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">22.2.</span> <span class="toc-text">静态库使用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C"><span class="toc-number">22.3.</span> <span class="toc-text">动态库制作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E4%BD%BF%E7%94%A8"><span class="toc-number">22.4.</span> <span class="toc-text">动态库使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">22.5.</span> <span class="toc-text">动态库加载失败问题解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-number">23.</span> <span class="toc-text">GDB调试器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="toc-number">23.1.</span> <span class="toc-text">生成调试信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8GDB"><span class="toc-number">23.2.</span> <span class="toc-text">启动GDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">23.3.</span> <span class="toc-text">显示源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">23.4.</span> <span class="toc-text">断点操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-number">23.5.</span> <span class="toc-text">条件断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E6%96%AD%E7%82%B9"><span class="toc-number">23.6.</span> <span class="toc-text">维护断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">23.7.</span> <span class="toc-text">调试代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E7%9C%8B"><span class="toc-number">23.8.</span> <span class="toc-text">数据查看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%98%BE%E7%A4%BA"><span class="toc-number">23.9.</span> <span class="toc-text">自动显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-number">23.10.</span> <span class="toc-text">查看修改变量的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7Makefile"><span class="toc-number">24.</span> <span class="toc-text">自动化编译工具Makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">24.1.</span> <span class="toc-text">Makefile语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">24.2.</span> <span class="toc-text">make命令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E7%A4%BA%E4%BE%8B"><span class="toc-number">24.3.</span> <span class="toc-text">Makefile示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">24.4.</span> <span class="toc-text">Makefile中的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">24.4.1.</span> <span class="toc-text">自定义变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="toc-number">24.4.2.</span> <span class="toc-text">自动变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-number">24.4.3.</span> <span class="toc-text">模式规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">24.5.</span> <span class="toc-text">Makefile的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E4%B8%AD%E7%9A%84%E4%BC%AA%E7%9B%AE%E6%A0%87"><span class="toc-number">24.6.</span> <span class="toc-text">Makefile中的伪目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">25.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.1.</span> <span class="toc-text">系统调用和库函数的区别</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://yustonerain.top/2025/06/20/Linux-System%20Programming.html"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="YuStone"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="YuStone Blogs"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Linux系统编程</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2025-06-20 21:26:00" itemprop="dateCreated datePublished" datetime="2025-06-20T21:26:00+08:00">2025-06-20</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2025-06-28 21:26:00" itemprop="dateModified" datetime="2025-06-28T21:26:00+08:00">2025-06-28</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%B9%A0/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">计算机学习</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/Linux/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">Linux</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="Linux常见目录"><a href="#Linux常见目录" class="headerlink" title="Linux常见目录"></a>Linux常见目录</h2><table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/</code></td>
<td>根目录，所有目录的起点，Linux 文件系统的顶级目录</td>
</tr>
<tr>
<td><code>/bin</code></td>
<td>存放常用的二进制可执行文件（如 <code>ls</code>、<code>cp</code>、<code>mv</code> 等），普通用户和系统都可使用</td>
</tr>
<tr>
<td><code>/sbin</code></td>
<td>系统管理命令，只有 root 用户可用（如 <code>reboot</code>、<code>ifconfig</code>）</td>
</tr>
<tr>
<td><code>/etc</code></td>
<td>配置文件目录（如 <code>/etc/passwd</code>、<code>/etc/fstab</code>、<code>/etc/ssh/sshd_config</code>）</td>
</tr>
<tr>
<td><code>/home</code></td>
<td>普通用户的家目录（如 <code>/home/user1</code>）</td>
</tr>
<tr>
<td><code>/root</code></td>
<td>超级用户（root）的家目录</td>
</tr>
<tr>
<td><code>/lib</code></td>
<td>核心共享库和驱动模块，供 <code>/bin</code> 和 <code>/sbin</code> 下的程序使用</td>
</tr>
<tr>
<td><code>/usr</code></td>
<td>存放用户应用程序和文件，子目录中包括 <code>/usr/bin</code>、<code>/usr/lib</code> 等</td>
</tr>
<tr>
<td><code>/usr/bin</code></td>
<td>普通用户使用的应用程序（非基本命令）</td>
</tr>
<tr>
<td><code>/usr/sbin</code></td>
<td>非系统引导时使用的系统管理员命令</td>
</tr>
<tr>
<td><code>/var</code></td>
<td>可变数据，如日志文件 <code>/var/log</code>、邮件、缓存、锁等</td>
</tr>
<tr>
<td><code>/tmp</code></td>
<td>临时文件，系统重启后可能会被清空</td>
</tr>
<tr>
<td><code>/opt</code></td>
<td>第三方软件安装目录（如 Chrome、VMware 等）</td>
</tr>
<tr>
<td><code>/dev</code></td>
<td>设备文件（如硬盘 <code>/dev/sda</code>，终端 <code>/dev/tty</code>）</td>
</tr>
<tr>
<td><code>/proc</code></td>
<td>虚拟文件系统，内核和进程信息（如 <code>/proc/cpuinfo</code>、<code>/proc/meminfo</code>）</td>
</tr>
<tr>
<td><code>/sys</code></td>
<td>另一种虚拟文件系统，提供与内核、设备驱动的交互接口</td>
</tr>
<tr>
<td><code>/boot</code></td>
<td>存放启动相关文件，如内核、grub 等（如 <code>/boot/vmlinuz-*</code>）</td>
</tr>
<tr>
<td><code>/media</code></td>
<td>可移动媒体挂载点（如 U 盘、光盘）</td>
</tr>
<tr>
<td><code>/mnt</code></td>
<td>临时挂载点，一般管理员手动挂载文件系统用</td>
</tr>
<tr>
<td><code>/run</code></td>
<td>系统运行时临时文件（如 PID、Socket）</td>
</tr>
<tr>
<td><code>/srv</code></td>
<td>提供服务的数据目录（如 Web 服务、FTP 服务的数据）</td>
</tr>
</tbody></table>
<h2 id="Bash解析器常用快捷键"><a href="#Bash解析器常用快捷键" class="headerlink" title="Bash解析器常用快捷键"></a>Bash解析器常用快捷键</h2><p>1.tap键</p>
<p>补齐命令，补齐路径，显示当前目录下的所有目录</p>
<p>2.清屏 clear</p>
<p>3.中断进程 ctrl+c</p>
<p>4 遍历输入的历史命令箭头上（ctrl+p）箭头下(ctrl+n)</p>
<p>5 光标相关操作</p>
<p>光标左移： ctrl+b（箭头左）</p>
<p>光标右移： ctrl+f(箭头右)</p>
<p>移动到头部: ctrl+a(home键)</p>
<p>移动到尾部：ctrl+e(end键)</p>
<p>6字符删除</p>
<p>删除光标前面的字符：ctrl+h(Backspace)</p>
<p>删除光标后面的字符：ctrl+d</p>
<p>光标后面的字符即光标覆盖的字符</p>
<p>删除光标前的所有内容：ctrl+u</p>
<p>删除光标后的所有内容：ctrl+k</p>
<h2 id="终端相关快捷键"><a href="#终端相关快捷键" class="headerlink" title="终端相关快捷键"></a>终端相关快捷键</h2><p>（终端一定要选中）</p>
<p>ctrl+shift+N 新建一个终端</p>
<p>ctrl+shift+T 在终端里新建一个标签</p>
<p>ctrl+D 关闭当前一个终端</p>
<h2 id="内建命令和外部命令对比"><a href="#内建命令和外部命令对比" class="headerlink" title="内建命令和外部命令对比"></a>内建命令和外部命令对比</h2><p>内建命令 vs 外部命令 对比总结</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>内建命令（Builtin Command）</th>
<th>外部命令（External Command）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>由 Shell 内部直接实现的命令</td>
<td>是文件系统中的可执行程序（如 <code>/bin/ls</code>）</td>
</tr>
<tr>
<td><strong>执行速度</strong></td>
<td>快（不需新建进程）</td>
<td>较慢（需 fork 子进程执行）</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>少，执行在当前 Shell 进程中</td>
<td>多，执行时创建子进程</td>
</tr>
<tr>
<td><strong>路径查找</strong></td>
<td>不需要依赖 <code>PATH</code> 环境变量</td>
<td>需要从 <code>PATH</code> 中查找可执行文件</td>
</tr>
<tr>
<td><strong>是否可以替换</strong></td>
<td>一般不推荐重定义</td>
<td>可以覆盖、替换或删改（如 alias 覆盖）</td>
</tr>
<tr>
<td><strong>是否常驻内存</strong></td>
<td>是，Shell 启动时加载</td>
<td>否，执行时加载，执行完释放</td>
</tr>
<tr>
<td><strong>例子</strong></td>
<td><code>cd</code>, <code>echo</code>, <code>exit</code>, <code>pwd</code>, <code>type</code></td>
<td><code>ls</code>, <code>cp</code>, <code>gcc</code>, <code>vim</code>, <code>python</code></td>
</tr>
<tr>
<td><strong>查看方法</strong></td>
<td><code>type cd</code> → builtin</td>
<td><code>type ls</code> → file</td>
</tr>
</tbody></table>
<p>命令类型查看方法</p>
<p>使用type命令</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">type</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 命令名</code></pre>

<p>使用 -a 显示所有同名命令（包括 alias、builtin、文件）</p>
<p>使用 -t 显示类型（简洁）</p>
<h2 id="Linux命令格式"><a href="#Linux命令格式" class="headerlink" title="Linux命令格式"></a>Linux命令格式</h2><pre class="language-bash" data-language="bash"><code class="language-bash">命令 <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span></code></pre>

<table>
<thead>
<tr>
<th>部分</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>命令</strong></td>
<td>要执行的操作，如 <code>ls</code>、<code>cp</code>、<code>mkdir</code> 等</td>
</tr>
<tr>
<td><strong>选项</strong></td>
<td>用于控制命令行为的开关，通常以 <code>-</code> 或 <code>--</code> 开头，例如 <code>-l</code>、<code>--help</code></td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td>命令作用的对象，通常是文件名、目录名、用户名等</td>
</tr>
</tbody></table>
<p>选项类型说明</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>短选项</td>
<td><code>-l</code></td>
<td>通常是一个字母，多个可组合（如 <code>-al</code>）</td>
</tr>
<tr>
<td>长选项</td>
<td><code>--help</code></td>
<td>更易读，通常不可组合</td>
</tr>
<tr>
<td>组合选项</td>
<td><code>-avz</code></td>
<td>相当于 <code>-a -v -z</code></td>
</tr>
</tbody></table>
<h2 id="帮助文档查看方法"><a href="#帮助文档查看方法" class="headerlink" title="帮助文档查看方法"></a>帮助文档查看方法</h2><p>如果是内建命令（可以通过之前的type命令查看）使用 help +内建命令</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">help</span> <span class="token builtin class-name">pwd</span></code></pre>

<p>如果是外部命令 对应命令名 –help</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">--help</span></code></pre>

<p><code>man</code> 是 Linux 中最常用的命令之一，全称是 <strong>manual（手册）</strong>，用于查看各种命令、函数、配置文件的使用说明。它是学习和查找 Linux 命令最权威的工具。</p>
<p><code>man</code> 命令基本语法：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">man</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>命令名或函数名<span class="token punctuation">]</span></code></pre>

<p> man 手册的 9 个部分（章节）</p>
<table>
<thead>
<tr>
<th>章节号</th>
<th>内容</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>用户命令（常见终端命令）</td>
<td><code>man ls</code></td>
</tr>
<tr>
<td>2</td>
<td>系统调用（内核提供的函数）</td>
<td><code>man 2 open</code></td>
</tr>
<tr>
<td>3</td>
<td>C 库函数</td>
<td><code>man 3 printf</code></td>
</tr>
<tr>
<td>4</td>
<td>设备文件和特殊文件</td>
<td><code>man 4 tty</code></td>
</tr>
<tr>
<td>5</td>
<td>配置文件格式</td>
<td><code>man 5 crontab</code></td>
</tr>
<tr>
<td>6</td>
<td>游戏与趣味（极少）</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>杂项（宏定义、协议、约定等）</td>
<td><code>man 7 signal</code></td>
</tr>
<tr>
<td>8</td>
<td>系统管理员命令（只能 root 执行）</td>
<td><code>man 8 ifconfig</code></td>
</tr>
<tr>
<td>9</td>
<td>内核开发接口（不常见）</td>
<td></td>
</tr>
</tbody></table>
<p>常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>-k 关键词</code></td>
<td>搜索相关命令（相当于 <code>apropos</code>）</td>
</tr>
<tr>
<td><code>-f 命令名</code></td>
<td>显示命令属于哪个章节（相当于 <code>whatis</code>）</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>显示所有章节中匹配的 man 页</td>
</tr>
<tr>
<td><code>-M</code></td>
<td>指定手册路径</td>
</tr>
<tr>
<td><code>--help</code></td>
<td>查看 man 自身帮助信息</td>
</tr>
</tbody></table>
<h2 id="目录相关命令"><a href="#目录相关命令" class="headerlink" title="目录相关命令"></a>目录相关命令</h2><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>用于显示当前终端所在的<strong>工作目录</strong>（即当前绝对路径）。</p>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token punctuation">[</span>目录路径<span class="token punctuation">]</span></code></pre>

<p>常见用法示例</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>cd /home/user</code></td>
<td>切换到绝对路径 <code>/home/user</code> 目录</td>
</tr>
<tr>
<td><code>cd ..</code></td>
<td>切换到上一级目录</td>
</tr>
<tr>
<td><code>cd</code> 或 <code>cd ~</code></td>
<td>切换到当前用户的主目录</td>
</tr>
<tr>
<td><code>cd -</code></td>
<td>切换到上一次所在的目录（切换目录的“切换”）</td>
</tr>
<tr>
<td><code>cd ./folder</code></td>
<td>切换到当前目录下的子目录 <code>folder</code></td>
</tr>
</tbody></table>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>用于<strong>创建新目录</strong>的命令，创建不了已存在目录。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 目录名</code></pre>

<p>mkdir test 在当前目录下创建test文件夹</p>
<p>mkdir &#x2F;tmp&#x2F;test</p>
<p>mkdir file{1..100}在当前目录创建100个文件夹，file1,file2,file3…file100</p>
<p>mkdir “file{1..100}”在当前目录创建file{1..100}文件夹，只会创建一个。</p>
<p>mkdir “a b” 在当前目录创建a b一个文件夹。</p>
<p>mkdir a b 在当前目录创建a b两个文件夹。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-p</code></td>
<td>递归创建目录（父目录不存在时自动创建）</td>
</tr>
<tr>
<td><code>-m MODE</code></td>
<td>设置新建目录的权限，如 <code>-m 755</code></td>
</tr>
<tr>
<td><code>-v</code></td>
<td>显示详细创建过程（verbose）</td>
</tr>
</tbody></table>
<h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>用法和mkdir相同</p>
<p>用于<strong>删除空目录</strong>的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>rmdir testdir</code></td>
<td>删除当前目录下的 <code>testdir</code>（需为空）</td>
</tr>
<tr>
<td><code>rmdir -p a/b/c</code></td>
<td>递归删除空目录链：先删 <code>c</code>，再删 <code>b</code>，再删 <code>a</code></td>
</tr>
<tr>
<td><code>rmdir ./mydir/</code></td>
<td>删除当前目录中的 <code>mydir</code>（需为空）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-p</code></td>
<td>递归删除路径中的所有空目录（从子到父）</td>
</tr>
<tr>
<td><code>--ignore-fail-on-non-empty</code></td>
<td>删除目录时忽略非空目录导致的错误</td>
</tr>
</tbody></table>
<h2 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h2><p>常用的文件类型有七种：普通文件，目录文件，设备文件，管道文件，链接文件和套接字。</p>
<p><img src="/2025/06/20/Linux-System%20Programming/1.png" alt="1" loading="lazy"></p>
<p><strong>普通文件</strong> 是 Linux 中最常见的一类文件，主要用于存储用户数据。包括：</p>
<ul>
<li>文本文件（如 <code>.txt</code>, <code>.c</code>, <code>.py</code>）</li>
<li>二进制文件（如 可执行程序、图片、音频等）</li>
<li>脚本文件（如 <code>.sh</code>, <code>.py</code>，可以被解释执行）</li>
</ul>
<p>在 Linux 中，<strong>目录文件（Directory File）</strong> 是一种特殊的文件类型，用来组织和存放文件和其他目录（子目录）。<br> 它本质上是一个<strong>保存了文件名和 inode 编号之间映射关系</strong>的文件。</p>
<p><strong>设备文件</strong>（Device File）是 Linux 中用于访问硬件设备的接口，本质上就是一种特殊的文件，程序通过它来与硬件设备通信。</p>
<p>设备文件通常位于 <code>/dev</code> 目录中。</p>
<p>常见设备文件举例</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>类型</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>/dev/sda</code></td>
<td>块设备</td>
<td>第一块硬盘</td>
</tr>
<tr>
<td><code>/dev/tty</code></td>
<td>字符设备</td>
<td>当前终端</td>
</tr>
<tr>
<td><code>/dev/null</code></td>
<td>字符设备</td>
<td>写入数据会被丢弃</td>
</tr>
<tr>
<td><code>/dev/zero</code></td>
<td>字符设备</td>
<td>会源源不断输出 0</td>
</tr>
<tr>
<td><code>/dev/random</code></td>
<td>字符设备</td>
<td>伪随机数生成器</td>
</tr>
</tbody></table>
<p><strong>管道文件</strong>（或称命名管道，FIFO &#x3D; First In First Out）是一种特殊文件，用于<strong>在不同进程之间传输数据</strong>。<br> 写入管道的数据会按顺序被读取，类似“排队喝水”的水管，先进先出。</p>
<p>管道文件与匿名管道不同之处在于它有名字，存在于文件系统中（通常创建在某个路径下），因此<strong>不同进程不必有父子关系</strong>也能通信。</p>
<p><strong>链接文件</strong> 是指向另一个文件的引用，常用于：</p>
<ul>
<li>创建多个路径指向同一个文件（节省空间）</li>
<li>为长路径或常用文件创建别名（提高效率）</li>
<li>实现共享与替代功能</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th><code>ls -l</code> 标识</th>
</tr>
</thead>
<tbody><tr>
<td><strong>软链接</strong>（符号链接）</td>
<td>类似 Windows 快捷方式，是一个指向目标路径的独立文件</td>
<td><code>l</code></td>
</tr>
<tr>
<td><strong>硬链接</strong></td>
<td>直接指向目标文件的 inode，本质上是同一个文件的另一个名字</td>
<td><code>-</code></td>
</tr>
</tbody></table>
<p>在 Linux 中，你可以使用 <code>ls -l</code> 命令来区分各种文件类型。<code>ls -l</code> 输出的每一行开头的第一个字符表示文件类型。下面是 <strong>七种常见文件类型及其 <code>ls -l</code> 显示符号</strong>：</p>
<p>七种常见文件类型及其标识</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th><code>ls -l</code> 类型字符</th>
<th>示例路径</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>普通文件</strong></td>
<td><code>-</code></td>
<td><code>-rw-r--r-- file.txt</code></td>
<td>常见的文本、二进制、可执行文件等</td>
</tr>
<tr>
<td><strong>目录文件</strong></td>
<td><code>d</code></td>
<td><code>drwxr-xr-x dir/</code></td>
<td>存储文件的容器</td>
</tr>
<tr>
<td><strong>字符设备文件</strong></td>
<td><code>c</code></td>
<td><code>crw------- /dev/tty</code></td>
<td>逐字符访问设备，如终端、串口等</td>
</tr>
<tr>
<td><strong>块设备文件</strong></td>
<td><code>b</code></td>
<td><code>brw-rw---- /dev/sda</code></td>
<td>按块访问设备，如硬盘、U 盘等</td>
</tr>
<tr>
<td><strong>管道文件</strong></td>
<td><code>p</code></td>
<td><code>prw-r--r-- mypipe</code></td>
<td>用于进程间通信的 FIFO 管道</td>
</tr>
<tr>
<td><strong>链接文件</strong></td>
<td><code>l</code></td>
<td><code>lrwxrwxrwx link -&gt; target</code></td>
<td>指向其他文件的软链接</td>
</tr>
<tr>
<td><strong>套接字文件</strong></td>
<td><code>s</code></td>
<td><code>srwxrwxrwx socket</code></td>
<td>进程间网络通信接口，如 <code>/tmp/.X11-unix/X0</code></td>
</tr>
</tbody></table>
<h2 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h2><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>简单列出当前目录内容</td>
</tr>
<tr>
<td><code>ls -a</code></td>
<td>显示所有文件，包括隐藏文件（以<code>.</code>开头）</td>
</tr>
<tr>
<td><code>ls -l</code></td>
<td>以长格式列出，显示权限、类型、时间等</td>
</tr>
<tr>
<td><code>ls -lh</code></td>
<td>长格式 + 人类可读大小（如 KB, MB）</td>
</tr>
<tr>
<td><code>ls -lt</code></td>
<td>按修改时间排序，最新的在前</td>
</tr>
<tr>
<td><code>ls -r</code></td>
<td>反向排序</td>
</tr>
<tr>
<td><code>ls -R</code></td>
<td>递归列出子目录</td>
</tr>
<tr>
<td><code>ls -d */</code></td>
<td>只列出目录 ls -d只显示一个.</td>
</tr>
</tbody></table>
<p>ls -l命令会输出长格式</p>
<pre class="language-none"><code class="language-none">权限       硬链接数 拥有者 所属组  大小    修改日期      文件名
drwxr-xr-x   2    user   user  4096   Jun 21 13:00  mydir</code></pre>

<p>对权限部分说明一下权限部分总共10个字符</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>文件类型标识</td>
</tr>
<tr>
<td>2-4</td>
<td><strong>拥有者（user）</strong>权限</td>
</tr>
<tr>
<td>5-7</td>
<td><strong>同组用户（group）</strong>权限</td>
</tr>
<tr>
<td>8-10</td>
<td><strong>其他用户（others）</strong>权限</td>
</tr>
</tbody></table>
<p>文件类型标识（第1个字符）</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>-</code></td>
<td>普通文件</td>
</tr>
<tr>
<td><code>d</code></td>
<td>目录</td>
</tr>
<tr>
<td><code>l</code></td>
<td>软链接</td>
</tr>
<tr>
<td><code>c</code></td>
<td>字符设备文件</td>
</tr>
<tr>
<td><code>b</code></td>
<td>块设备文件</td>
</tr>
<tr>
<td><code>p</code></td>
<td>管道（FIFO）</td>
</tr>
<tr>
<td><code>s</code></td>
<td>套接字</td>
</tr>
</tbody></table>
<p>权限字符说明（2-10位置）</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>r</code></td>
<td>读权限 (read)</td>
</tr>
<tr>
<td><code>w</code></td>
<td>写权限 (write)</td>
</tr>
<tr>
<td><code>x</code></td>
<td>执行权限 (execute)</td>
</tr>
<tr>
<td><code>-</code></td>
<td>无该权限</td>
</tr>
<tr>
<td><code>s</code></td>
<td>setuid&#x2F;setgid 位（特殊执行权限）</td>
</tr>
<tr>
<td><code>t</code></td>
<td>粘滞位（sticky bit）</td>
</tr>
</tbody></table>
<p>三组权限详解</p>
<table>
<thead>
<tr>
<th>组别</th>
<th>位置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>拥有者</strong></td>
<td>2~4 字符</td>
<td>拥有该文件&#x2F;目录的用户权限</td>
</tr>
<tr>
<td><strong>组用户</strong></td>
<td>5~7 字符</td>
<td>属于该文件组的用户权限</td>
</tr>
<tr>
<td><strong>其他用户</strong></td>
<td>8~10 字符</td>
<td>系统中除拥有者和组以外的所有用户权限</td>
</tr>
</tbody></table>
<h3 id="什么是通配符？"><a href="#什么是通配符？" class="headerlink" title="什么是通配符？"></a>什么是通配符？</h3><p>通配符是一种简化文件名匹配的符号，用于在命令中匹配多个文件或目录。它可以让你不用输入完整文件名，就能选中符合规则的文件。</p>
<p>常用的通配符类型</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
<th>例子</th>
<th>匹配结果示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配任意数量的任意字符（包括0个）</td>
<td><code>ls *.txt</code></td>
<td>匹配所有以 <code>.txt</code> 结尾的文件</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配任意一个单字符</td>
<td><code>ls file?.txt</code></td>
<td>匹配 <code>file1.txt</code>、<code>fileA.txt</code>，但不匹配 <code>file10.txt</code></td>
</tr>
<tr>
<td><code>[abc]</code></td>
<td>匹配括号内的任意一个字符</td>
<td><code>ls file[123].txt</code></td>
<td>匹配 <code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code></td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td>匹配指定范围内的任意一个字符</td>
<td><code>ls file[a-c].txt</code></td>
<td>匹配 <code>filea.txt</code>、<code>fileb.txt</code>、<code>filec.txt</code></td>
</tr>
<tr>
<td><code>[!abc]</code></td>
<td>匹配不在括号内的任意一个字符</td>
<td><code>ls file[!123].txt</code></td>
<td>匹配除 <code>file1.txt</code>、<code>file2.txt</code>、<code>file3.txt</code> 以外的文件</td>
</tr>
</tbody></table>
<h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><p><code>touch</code> 是用来 <strong>创建空文件</strong> 或 <strong>更新已有文件的时间戳</strong> 的命令。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> file.txt</code></pre>

<p>如果 <code>file.txt</code> 不存在，会被创建为空文件；如果存在，文件时间被更新。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> file1.txt file2.txt file3.txt</code></pre>

<p>一次创建或更新多个文件。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> file<span class="token punctuation">&#123;</span><span class="token number">2,3</span>,4<span class="token punctuation">&#125;</span><span class="token comment">#同时创建file2,file3,file4三个空文件和mkdir file&#123;1..100&#125;用法是一样的。</span>
<span class="token function">touch</span> <span class="token string">"file&#123;2,3,4&#125;"</span>#创建file<span class="token punctuation">&#123;</span><span class="token number">2,3</span>,4<span class="token punctuation">&#125;</span>这一个文件。</code></pre>

<h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p><code>cp</code> 是 Linux 中用于 <strong>复制文件或目录</strong> 的命令。</p>
<table>
<thead>
<tr>
<th>任务</th>
<th>命令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>复制文件</td>
<td><code>cp file1.txt file2.txt</code></td>
<td>把 <code>file1.txt</code> 内容复制为 <code>file2.txt</code></td>
</tr>
<tr>
<td>复制文件到目录</td>
<td><code>cp file1.txt /home/user/docs/</code></td>
<td>把 <code>file1.txt</code> 复制进目录</td>
</tr>
<tr>
<td>复制目录（加 <code>-r</code>）</td>
<td><code>cp -r dir1/ dir2/</code></td>
<td>递归复制整个目录 <code>dir1</code> 到 <code>dir2</code> 中</td>
</tr>
<tr>
<td>保留属性复制文件</td>
<td><code>cp -p file1.txt file2.txt</code></td>
<td>保留原文件的时间戳、权限等信息</td>
</tr>
<tr>
<td>强制覆盖目标文件</td>
<td><code>cp -f file1.txt file2.txt</code></td>
<td>如果 <code>file2.txt</code> 存在，强制覆盖</td>
</tr>
<tr>
<td>复制并提示</td>
<td><code>cp -i file1.txt file2.txt</code></td>
<td>有冲突时会提示确认</td>
</tr>
<tr>
<td>显示复制过程</td>
<td><code>cp -v file1.txt file2.txt</code></td>
<td>复制时显示详细过程（verbose 模式）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-r</code></td>
<td>递归复制目录（必须用于复制目录）</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>覆盖文件前提示确认</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>强制覆盖目标文件而不提示</td>
</tr>
<tr>
<td><code>-p</code></td>
<td>保留原文件的属性（权限、时间等）</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>只在源文件较新时才复制</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>显示复制过程（verbose）</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>归档模式，等价于 <code>-dpR</code>，用于备份</td>
</tr>
<tr>
<td><code>--parents</code></td>
<td>保留源路径结构复制文件（适用于目录结构迁移）</td>
</tr>
</tbody></table>
<h3 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h3><p>是用于在 Linux 中 <strong>删除文件和目录</strong> 的命令。注意：<code>rm</code> 删除后不会进入回收站，<strong>无法轻易恢复</strong>，请务必小心使用。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>删除单个文件</td>
<td><code>rm file.txt</code></td>
<td>删除文件 <code>file.txt</code></td>
</tr>
<tr>
<td>删除多个文件</td>
<td><code>rm file1.txt file2.txt</code></td>
<td>一次删除多个文件</td>
</tr>
<tr>
<td>递归删除目录及内容</td>
<td><code>rm -r mydir/</code></td>
<td>删除目录 <code>mydir</code> 及其所有子目录和文件</td>
</tr>
<tr>
<td>强制删除文件&#x2F;目录</td>
<td><code>rm -f file.txt</code> &#x2F; <code>rm -rf mydir/</code></td>
<td>忽略不存在的文件，且不提示确认</td>
</tr>
<tr>
<td>删除前确认</td>
<td><code>rm -i file.txt</code></td>
<td>删除前逐一询问确认</td>
</tr>
<tr>
<td>显示正在删除的文件</td>
<td><code>rm -v file.txt</code></td>
<td>显示被删除的文件名</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-r</code> 或 <code>--recursive</code></td>
<td>递归删除目录及其内容（删除整个目录树）</td>
</tr>
<tr>
<td><code>-f</code> 或 <code>--force</code></td>
<td>强制删除，不提示，即使目标不存在也不报错</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>删除前询问确认，适合新手使用以防误删</td>
</tr>
<tr>
<td><code>-I</code></td>
<td>删除多个文件或目录时才询问一次，比 <code>-i</code> 安全且不烦人</td>
</tr>
<tr>
<td><code>-v</code> 或 <code>--verbose</code></td>
<td>显示正在删除的每一个文件或目录</td>
</tr>
<tr>
<td><code>--preserve-root</code></td>
<td>默认保护根目录 <code>/</code> 不被删除（系统安全机制，防止 <code>rm -rf /</code> 误操作）</td>
</tr>
</tbody></table>
<h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p><strong>移动文件或目录</strong> 到新位置，<strong>重命名</strong> 文件或目录。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>移动文件</td>
<td><code>mv a.txt /home/user/docs/</code></td>
<td>把 <code>a.txt</code> 移动到 <code>/home/user/docs/</code> 目录</td>
</tr>
<tr>
<td>重命名文件</td>
<td><code>mv old.txt new.txt</code></td>
<td>将 <code>old.txt</code> 重命名为 <code>new.txt</code></td>
</tr>
<tr>
<td>移动并重命名</td>
<td><code>mv a.txt /home/user/docs/b.txt</code></td>
<td>移动 <code>a.txt</code> 到新目录并改名为 <code>b.txt</code></td>
</tr>
<tr>
<td>移动目录</td>
<td><code>mv dir1/ /home/user/backup/</code></td>
<td>移动整个目录到新的路径</td>
</tr>
<tr>
<td>覆盖已有文件</td>
<td><code>mv -f a.txt b.txt</code></td>
<td>如果 <code>b.txt</code> 存在，则强制覆盖</td>
</tr>
<tr>
<td>覆盖前确认</td>
<td><code>mv -i a.txt b.txt</code></td>
<td>如果 <code>b.txt</code> 存在，移动前会询问是否覆盖</td>
</tr>
<tr>
<td>显示移动过程</td>
<td><code>mv -v a.txt b.txt</code></td>
<td>显示正在移动的内容</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-f</code></td>
<td>强制覆盖已有目标文件，不提示</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>如果目标文件存在，提示是否覆盖（interactive）</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>不覆盖已有的目标文件（no-clobber）</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>显示移动过程（verbose）</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>仅在源文件较新或目标文件不存在时才移动</td>
</tr>
</tbody></table>
<h2 id="文件内容查看相关命令"><a href="#文件内容查看相关命令" class="headerlink" title="文件内容查看相关命令"></a>文件内容查看相关命令</h2><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><p>用于 <strong>查看、创建、合并文件</strong> 内容，常用于快速查看文本文件内容。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-n</code></td>
<td>给所有行编号</td>
</tr>
<tr>
<td><code>-b</code></td>
<td>只对非空行编号</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>压缩连续空白行为一行</td>
</tr>
<tr>
<td><code>-T</code></td>
<td>显示 Tab 为 <code>^I</code></td>
</tr>
<tr>
<td><code>-E</code></td>
<td>显示每行结尾的 <code>$</code>（换行符可见）</td>
</tr>
<tr>
<td><code>-A</code></td>
<td>相当于 <code>-vET</code>，显示所有不可见字符</td>
</tr>
</tbody></table>
<h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p>用于<strong>分页显示文件内容</strong>的命令，支持 <strong>向前&#x2F;向后翻页浏览</strong>，适合查看<strong>大型文本文件</strong>。它比 <code>cat</code> 更强大，且不会一次性加载全部内容到内存中。</p>
<p>使用时常用快捷键（进入 less 后）</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>空格</code></td>
<td>向下翻一页</td>
</tr>
<tr>
<td><code>b</code></td>
<td>向上翻一页</td>
</tr>
<tr>
<td><code>Enter</code></td>
<td>向下滚动一行</td>
</tr>
<tr>
<td><code>k</code></td>
<td>向上一行（vi 风格）</td>
</tr>
<tr>
<td><code>j</code></td>
<td>向下一行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>跳到文件末尾</td>
</tr>
<tr>
<td><code>g</code></td>
<td>跳到文件开头</td>
</tr>
<tr>
<td><code>/关键词</code></td>
<td>向下搜索（如 <code>/error</code>）</td>
</tr>
<tr>
<td><code>?关键词</code></td>
<td>向上搜索</td>
</tr>
<tr>
<td><code>n</code></td>
<td>重复上一次搜索</td>
</tr>
<tr>
<td><code>N</code></td>
<td>反向重复搜索</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出 less</td>
</tr>
</tbody></table>
<h3 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h3><p><code>head</code> 用于<strong>查看文件的前几行内容</strong>，默认显示前 10 行。适合快速预览文件开头，尤其是大型文件或日志文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-n N</code></td>
<td>显示前 N 行（如 <code>head -n 15 file.txt</code>）</td>
</tr>
<tr>
<td><code>-c N</code></td>
<td>显示前 N 个<strong>字节</strong>（如 <code>head -c 100 file.txt</code>）</td>
</tr>
<tr>
<td><code>-q</code></td>
<td>多文件时不显示文件名头部（quiet）</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>总是显示文件名头部（verbose）</td>
</tr>
</tbody></table>
<h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>用于<strong>显示文件的最后几行内容</strong>，默认是最后 10 行。常用于：</p>
<ul>
<li>查看日志尾部；</li>
<li>实时监控文件内容变化（配合 <code>-f</code> 选项）；</li>
<li>截取文件结尾部分数据。</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tail</span> /etc/passwd <span class="token comment">#默认显示后十行</span>
<span class="token function">tail</span> <span class="token parameter variable">-n</span> <span class="token number">30</span> 文件名 <span class="token comment">#显示后30行内容</span>
<span class="token function">tail</span> <span class="token parameter variable">-c</span> <span class="token number">30</span> 文件名 <span class="token comment">#显示后30个字符</span></code></pre>

<h2 id="du和df命令"><a href="#du和df命令" class="headerlink" title="du和df命令"></a>du和df命令</h2><h3 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h3><p>查看<strong>目录或文件占用的磁盘空间</strong>，会考虑磁盘块对齐、文件系统元数据、软链接等因素。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-h</code></td>
<td>以<strong>人类可读的方式</strong>显示（如 KB、MB）</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>显示指定文件&#x2F;目录占用的数据块</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>显示所有文件和目录的大小（默认只显示目录）</td>
</tr>
<tr>
<td><code>--max-depth=N</code></td>
<td>显示目录深度（限制递归层数）</td>
</tr>
</tbody></table>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">du</span> <span class="token parameter variable">-sh</span> 文件名/目录</code></pre>

<table>
<thead>
<tr>
<th>项目</th>
<th><code>ls -l</code></th>
<th><code>du -sh</code></th>
</tr>
</thead>
<tbody><tr>
<td>显示内容</td>
<td>文件本身大小（内容字节数）</td>
<td>实际磁盘占用（包含对齐和元数据）</td>
</tr>
<tr>
<td>对目录</td>
<td>显示目录结构本身大小</td>
<td>显示目录下所有内容实际占用</td>
</tr>
<tr>
<td>单位</td>
<td>字节（Bytes）</td>
<td>自动转换为 KB&#x2F;MB&#x2F;GB</td>
</tr>
<tr>
<td>应用场景</td>
<td>看文件大小&#x2F;属性</td>
<td>查哪些文件&#x2F;目录占空间最多</td>
</tr>
</tbody></table>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"hello"</span> <span class="token operator">></span> file.txt
<span class="token function">ls</span> <span class="token parameter variable">-l</span> file.txt      <span class="token comment"># 显示 6 bytes</span>
<span class="token function">du</span> <span class="token parameter variable">-sh</span> file.txt     <span class="token comment"># 显示 4.0K</span></code></pre>

<h3 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h3><p>查看<strong>整个磁盘的使用情况</strong></p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">df</span> <span class="token parameter variable">-h</span> <span class="token comment"># 显示所有文件系统的使用情况（人类可读格式）</span>
<span class="token function">df</span> <span class="token parameter variable">-h</span> /home <span class="token comment"># 查看 /home 所在分区的磁盘使用情况</span></code></pre>

<h2 id="查找相关命令"><a href="#查找相关命令" class="headerlink" title="查找相关命令"></a>查找相关命令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find</code> 是 Linux 中功能非常强大的文件搜索命令，它可以根据名称、类型、时间、大小、权限等多种条件在目录中递归查找文件，还可以执行删除、移动、打印等操作。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> <span class="token punctuation">[</span>搜索路径<span class="token punctuation">]</span> <span class="token punctuation">[</span>搜索条件<span class="token punctuation">]</span> <span class="token punctuation">[</span>处理动作<span class="token punctuation">]</span></code></pre>

<p>按文件名查询：使用参数 -name</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./ <span class="token parameter variable">-name</span> <span class="token string">"*.txt"</span> <span class="token comment">#查找当前路径下符合后缀是。txt的文件</span></code></pre>

<p>按文件大小查询：使用参数 -size</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./ <span class="token parameter variable">-size</span> +100k</code></pre>

<p>+100k 表示大于100k的文件</p>
<p>-100k表示小于100k的文件</p>
<p>100k 表示等于100k的文件</p>
<p>大小方面：k小写，M大写</p>
<p>查询大小范围</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./ <span class="token parameter variable">-size</span> +50k <span class="token parameter variable">-size</span> <span class="token parameter variable">-100k</span></code></pre>

<p>按文件类型查询：使用参数 -type</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> ./ <span class="token parameter variable">-type</span> f <span class="token comment">#查询当前的普通文件</span></code></pre>

<table>
<thead>
<tr>
<th>类型代号</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>f</code></td>
<td>普通文件</td>
<td><code>find . -type f</code> 查找所有普通文件（这里不是-，要和ls -l的文件类型区分）</td>
</tr>
<tr>
<td><code>d</code></td>
<td>目录</td>
<td><code>find . -type d</code> 查找所有目录</td>
</tr>
<tr>
<td><code>l</code></td>
<td>符号链接（软链接）</td>
<td><code>find . -type l</code> 查找所有软链接</td>
</tr>
<tr>
<td><code>c</code></td>
<td>字符设备文件</td>
<td><code>/dev/null</code> 等</td>
</tr>
<tr>
<td><code>b</code></td>
<td>块设备文件</td>
<td>硬盘等块设备</td>
</tr>
<tr>
<td><code>s</code></td>
<td>套接字文件</td>
<td>Socket 类型文件</td>
</tr>
<tr>
<td><code>p</code></td>
<td>命名管道（FIFO）</td>
<td>通信用的特殊文件</td>
</tr>
</tbody></table>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p><code>grep</code> 是 Linux 中非常常用的文本搜索工具，用于<strong>在文件或标准输出中查找匹配的字符串</strong>，功能强大，灵活，适合日志分析、配置文件搜索、编程辅助等场景。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token string">"模式"</span> <span class="token punctuation">[</span>文件<span class="token punctuation">]</span></code></pre>

<table>
<thead>
<tr>
<th>选项</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-n</code></td>
<td>显示匹配行的行号</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>忽略大小写</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>反向匹配（即显示不包含该字符串的行）</td>
</tr>
<tr>
<td><code>-r</code> or <code>-R</code></td>
<td>递归搜索目录下的所有文件</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>只列出匹配的文件名</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>统计匹配的行数</td>
</tr>
<tr>
<td><code>--color=auto</code></td>
<td>高亮显示匹配的内容</td>
</tr>
</tbody></table>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">"root"</span> /etc/passwd <span class="token comment">#不分大小写，在passwd查找root</span>
<span class="token function">grep</span> <span class="token parameter variable">-w</span> <span class="token string">"hello"</span> /etc/passwd <span class="token comment">#在passwd查找完全匹配hello单词的行</span>
<span class="token function">grep</span> <span class="token parameter variable">-r</span> <span class="token string">"u_char"</span> ./  <span class="token comment">#递归搜索当前目录下的符合u_char的行</span>
<span class="token function">grep</span> <span class="token parameter variable">-i</span> <span class="token string">"hello"</span> /etc/passwd <span class="token parameter variable">--color</span><span class="token operator">=</span>auto <span class="token comment">#在/etc/passwd文件中找hello并且忽略大小写，然后高亮显示匹配的关键字</span></code></pre>

<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道（|）一个命令的输出可以通过管道作为另一个命令的输入。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ifconfig</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"ens33"</span> <span class="token comment">#在ifconfig输出的文字查找存在ens33的行</span></code></pre>

<h2 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>把一系列文件归档到一个文件，也可以把档案文件解开以恢复数据。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token parameter variable">-f</span> <span class="token punctuation">[</span>文件名.tar<span class="token punctuation">]</span> <span class="token punctuation">[</span>要打包或解压的文件/目录<span class="token punctuation">]</span><span class="token comment">#f必须放到选项的最后</span></code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-cvf</span> sysctl.tar <span class="token function">sysctl</span> <span class="token comment">#打包文件，但是不压缩</span>
<span class="token function">tar</span> <span class="token parameter variable">-xvf</span> sysctl.tar <span class="token comment">#解包文件</span>
<span class="token function">tar</span> <span class="token parameter variable">-tvf</span> sysctl.tar <span class="token comment">#查看压缩文件内容</span></code></pre>

<h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p><strong>对单个文件进行压缩或解压</strong>，压缩率高、速度快，默认生成 <code>.gz</code> 文件。</p>
<p>tar和gzip命令结合使用实现文件打包，压缩。</p>
<p>tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般为xxx.tar.gz。</p>
<p>gzip单独使用，只可以对文件压缩和解压，不可以对目录。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">gzip</span> test1 test2 <span class="token comment">#不保留源文件压缩。 </span></code></pre>

<p>tar和gzip结合对目录压缩</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-czvf</span> sysctl.tar.gz <span class="token function">sysctl</span> <span class="token comment">#打包和压缩文件</span>
<span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> sysctl.tar.gz <span class="token comment">#解包和解压文件</span>
<span class="token function">tar</span> <span class="token parameter variable">-xzvf</span> sysctl.tar.gz <span class="token parameter variable">-C</span> /temp <span class="token comment">#解包和解压文件到temp目录</span></code></pre>

<h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>和gzip一样和tar结合。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-cjvf</span> test.tar.bz2 <span class="token builtin class-name">test</span> <span class="token comment">#生成一个bz2压缩包</span>
<span class="token function">tar</span> <span class="token parameter variable">-xjvf</span> share.tar.bz2 <span class="token comment">#解压</span></code></pre>

<h3 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h3><p>通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">zip</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 目标文件（没有扩展名）源文件/目录
<span class="token function">unzip</span> <span class="token parameter variable">-d</span> 解压后目录文件 压缩文件 <span class="token comment">#-d解压到指定目录</span></code></pre>

<h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><p>访问权限说明：</p>
<p>读权限（r）</p>
<p>对文件而言，具有读取文件内容的权限；对目录而言，具有浏览目录的权限。</p>
<p>写权限（w）</p>
<p>对文件而言，具有新增，修改文件内容的权限；对目录而言，具有删除，移动目录内文件的权限。</p>
<p>可执行权限（x）</p>
<p>对文件而言，具有执行文件的权限；对目录而言，该用户具有进入目录的权限。</p>
<p>通常。Unix&#x2F;Linux系统只允许文件的属主（所有者）或root用户改变文件的读写权限。</p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p><code>chmod</code>（<strong>change mode</strong>）是 Linux&#x2F;Unix 系统中用于<strong>修改文件或目录权限</strong>的命令。它支持两种权限设置方式：<strong>数字方式</strong>和<strong>符号方式</strong>。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> 模式 文件名</code></pre>

<p>符号方式：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> u/g/o/a +/-/<span class="token operator">=</span> rwx 文件 <span class="token comment">#+添加权限 -撤销权限 =设定权限 u/g/o对应的是拥有者，同属组，其他。</span>
chomd o+w a <span class="token comment">#向a的其他用户添加写权限</span>
chomd <span class="token assign-left variable">u</span><span class="token operator">=</span>rw,g<span class="token operator">=</span>r,o<span class="token operator">=</span>r a<span class="token comment">#把a的拥有者权限为re,同属组权限为r,其他用户权限为r。</span></code></pre>

<p>数字方式：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#由于rwx通过二进制来区分 rwx就是111，十进制为7</span>
<span class="token comment">#rwx   7</span>
<span class="token comment">#rw-   6</span>
<span class="token comment">#r--   4</span>
<span class="token comment">#r-x   5</span>
chomd <span class="token number">777</span> a<span class="token comment">#把a的对应用户的权限变为rwx.</span></code></pre>

<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p><code>chown</code> 是 Linux&#x2F;Unix 中用于更改文件或目录 <strong>所属用户（owner）</strong> 和 <strong>所属用户组（group）</strong> 的命令。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>新用户<span class="token punctuation">]</span><span class="token punctuation">[</span>:<span class="token punctuation">[</span>新用户组<span class="token punctuation">]</span><span class="token punctuation">]</span> 文件/目录</code></pre>

<p><code>新用户</code>：新的文件拥有者</p>
<p><code>新用户组</code>：新的用户组（可选）</p>
<p>需要 <code>sudo</code> 权限（普通用户只能修改自己拥有的文件）</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#把文件所有者修改为root用户</span>
<span class="token function">sudo</span> <span class="token function">chown</span> root a
<span class="token comment">#把文件所属者改为yustone,所属组改为root</span>
<span class="token function">sudo</span> <span class="token function">chown</span> yustone:root a</code></pre>

<h2 id="软件安装和卸载"><a href="#软件安装和卸载" class="headerlink" title="软件安装和卸载"></a>软件安装和卸载</h2><h3 id="使用包管理器安装和卸载"><a href="#使用包管理器安装和卸载" class="headerlink" title="使用包管理器安装和卸载"></a>使用包管理器安装和卸载</h3><p>Ubuntu &#x2F; Debian 系列</p>
<p>安装</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update          <span class="token comment"># 更新软件源</span>
<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> 软件名  <span class="token comment"># 安装软件</span></code></pre>

<p>卸载</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> remove 软件名           <span class="token comment"># 删除程序但保留配置文件</span>
<span class="token function">sudo</span> <span class="token function">apt</span> purge 软件名            <span class="token comment"># 连配置文件一并删除</span></code></pre>

<p>离线软件包安装：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg <span class="token parameter variable">-i</span> package.deb</code></pre>

<p>离线软件包卸载：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg <span class="token parameter variable">-r</span> 软件名</code></pre>

<p>使用 Snap 安装（跨平台容器化安装方式）</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> snap <span class="token function">install</span> 软件名</code></pre>

<p>使用 Snap 卸载（跨平台容器化安装方式）</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> snap remove 软件名</code></pre>

<p>从源代码编译安装</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">./configure
<span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span></code></pre>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>主要是把命令输出的内容（之前是屏幕）输入到文件里。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /etc/passwd <span class="token operator">></span> output.txt <span class="token comment">#标准正确输出重定向到output.txt（这里是覆盖原文件）</span>
<span class="token function">ls</span> /etc/passwd <span class="token operator">>></span> output.txt <span class="token comment">#标准正确输出追加重定向到output.txt(这里是追加)</span>
llll <span class="token operator"><span class="token file-descriptor important">2</span>></span> error.txt <span class="token comment">#标准错误输出重定向到error.txt(这里是覆盖原文件)</span>
llll <span class="token operator"><span class="token file-descriptor important">2</span>>></span> error.txt <span class="token comment">#标准错误输出追加重定向到error.txt</span>
lll <span class="token operator"><span class="token file-descriptor important">2</span>></span> /dev/null <span class="token comment">#标准错误输出重定向到黑洞</span>
<span class="token function">ls</span> ddddd /etc/passwd <span class="token operator">&amp;></span> /dev/null <span class="token comment">#标准正确输出和标准错误输出全部重定向到黑洞。</span>
<span class="token function">ls</span> ddddd /etc/passwd <span class="token operator">&amp;>></span> output.txt <span class="token comment">#标准正确输出和标准错误输出以追加的方式全部重定向到output.txt.</span></code></pre>

<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>tree以树状形式查看指定目录内容。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">tree 目录</code></pre>

<h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>ln命令主要用于创建链接文件。</p>
<p>链接文件分为软链接和硬链接：</p>
<p>硬链接只能链接普通文件，不能链接目录。软链接不占用磁盘空间，源文件删除则链接失效。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ln</span> 源文件 链接文件 <span class="token comment">#硬链接</span>
<span class="token function">ln</span> <span class="token parameter variable">-s</span> 源文件 链接文件 <span class="token comment">#软链接</span></code></pre>

<p>如果没有-s选项代表建立一个硬链接文件，两个文件占用同一块的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s比较常用。如果软链接文件和源文件不在同一目录，源文件最好使用绝对路径，不要使用相对路径。软链接文件存储的是目标文件的路径。</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p><code>vim</code> 是一款强大的 <strong>文本编辑器</strong>，常用于 <strong>Linux &#x2F; Unix 系统编程、脚本编辑、配置文件修改等场景</strong>。它是 <code>vi</code> 的增强版本，具有更强的功能，比如语法高亮、代码折叠、多窗口、多标签支持等。</p>
<h3 id="vim的三种模式"><a href="#vim的三种模式" class="headerlink" title="vim的三种模式"></a>vim的三种模式</h3><p><strong>普通模式</strong>（Normal Mode）</p>
<p><strong>默认启动模式</strong>，你一打开 Vim 就是在这个模式。</p>
<p><strong>作用</strong>：浏览、复制、剪切、粘贴、删除、移动光标、跳转、执行命令等。</p>
<p>常用命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>h</code>&#x2F;<code>l</code></td>
<td>左&#x2F;右移动光标</td>
</tr>
<tr>
<td><code>j</code>&#x2F;<code>k</code></td>
<td>下&#x2F;上移动光标</td>
</tr>
<tr>
<td><code>[n]dd</code></td>
<td>删除当前行开始的n行（准确说是剪切）</td>
</tr>
<tr>
<td>[n]x</td>
<td>删除光标后n个字符</td>
</tr>
<tr>
<td>[n]X</td>
<td>删除光标前n个字符</td>
</tr>
<tr>
<td><code>[n]yy</code></td>
<td>复制从当前行开始的n行</td>
</tr>
<tr>
<td><code>p</code></td>
<td>粘贴</td>
</tr>
<tr>
<td><code>u</code></td>
<td>撤销前一个命令</td>
</tr>
<tr>
<td><code>Ctrl + r</code></td>
<td>还原（恢复）</td>
</tr>
<tr>
<td><code>:</code></td>
<td>进入命令模式</td>
</tr>
<tr>
<td><code>i</code>、<code>a</code></td>
<td>进入插入模式</td>
</tr>
<tr>
<td>mG&#x2F;mgg</td>
<td>到指定行，m为目标行数</td>
</tr>
<tr>
<td>&#x2F;字符串</td>
<td>从当前光标位置向下查找（n,N查找内容切换）</td>
</tr>
<tr>
<td>?字符串</td>
<td>从当前光标位置向上查找（n,N查找内容切换）</td>
</tr>
</tbody></table>
<p><strong>插入模式</strong>（Insert Mode）</p>
<p><strong>按 <code>i</code>、<code>a</code>、<code>o</code> 等从普通模式进入插入模式。</strong></p>
<p><strong>作用</strong>：输入文字、写代码、编辑内容。</p>
<p>常用进入方式：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>i</code></td>
<td>在光标前插入</td>
</tr>
<tr>
<td><code>a</code></td>
<td>在光标后插入</td>
</tr>
<tr>
<td><code>o</code></td>
<td>在当前行下方新开一行并插入</td>
</tr>
<tr>
<td><code>I</code></td>
<td>跳到行首插入</td>
</tr>
<tr>
<td><code>A</code></td>
<td>跳到行尾插入</td>
</tr>
</tbody></table>
<p><strong>退出插入模式</strong>：按 <code>Esc</code> 返回普通模式。</p>
<p><strong>命令模式</strong>（Command-Line Mode）</p>
<p><strong>按 <code>:</code> 从普通模式进入命令模式。</strong></p>
<p>用于输入各种操作命令，如保存、退出、查找、替换等。</p>
<p>常用命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>:w</code></td>
<td>保存</td>
</tr>
<tr>
<td><code>:q</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>:wq</code> 或 <code>ZZ</code></td>
<td>保存并退出</td>
</tr>
<tr>
<td><code>:q!</code></td>
<td>强制退出（不保存）</td>
</tr>
<tr>
<td><code>:x</code></td>
<td>等同于 <code>:wq</code></td>
</tr>
<tr>
<td><code>:/关键字</code></td>
<td>向下查找关键字</td>
</tr>
<tr>
<td><code>:s/旧/新/g</code></td>
<td>当前行替换所有匹配项</td>
</tr>
<tr>
<td>:1,10s&#x2F;abc&#x2F;123&#x2F;g</td>
<td>把第一行到第十行之间的abc全部替换为123</td>
</tr>
<tr>
<td><code>:%s/旧/新/g</code></td>
<td>全文替换所有匹配项</td>
</tr>
<tr>
<td>:w filename</td>
<td>保存到指定文件（绝对路径）</td>
</tr>
<tr>
<td>:sp 文件名</td>
<td>当前文件和另一个文件水平分屏</td>
</tr>
<tr>
<td>:vsp 文件名</td>
<td>当前文件和另一个文件垂直分屏</td>
</tr>
<tr>
<td>ctrl+w+w</td>
<td>在多个窗口切换光标</td>
</tr>
</tbody></table>
<h2 id="gcc编译器"><a href="#gcc编译器" class="headerlink" title="gcc编译器"></a>gcc编译器</h2><p>GCC（<strong>GNU Compiler Collection</strong>）是由 GNU 项目开发的一组编译器，最初是为了 C 语言开发的，现在支持多种编程语言</p>
<p>gcc编译器从拿到一个c源文件到生成一个可执行文件，中间一共经历了四个步骤：</p>
<p><img src="/2025/06/20/Linux-System%20Programming/2.png" alt="2" loading="lazy"></p>
<pre class="language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-E</span> hello.c <span class="token parameter variable">-o</span> hello.i
gcc <span class="token parameter variable">-S</span> hello.i <span class="token parameter variable">-o</span> hello.s
gcc <span class="token parameter variable">-c</span> hello.s <span class="token parameter variable">-o</span> hello.o
gcc hello.o <span class="token parameter variable">-o</span> hello
./hello <span class="token comment">#执行</span>
gcc 源文件 <span class="token parameter variable">-o</span> 可执行文件 <span class="token comment">#一步到位</span>
gcc hello.c <span class="token parameter variable">-o</span> hello
./hello</code></pre>

<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-o</code></td>
<td>指定输出文件名</td>
</tr>
<tr>
<td><code>-Wall</code></td>
<td>打开所有警告信息</td>
</tr>
<tr>
<td><code>-g</code></td>
<td>生成调试信息，用于 GDB 调试</td>
</tr>
<tr>
<td><code>-O0/-O1/-O2/-O3</code></td>
<td>优化等级（0 表示无优化）</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>只编译不链接，生成 <code>.o</code> 目标文件</td>
</tr>
<tr>
<td><code>-I</code></td>
<td>添加头文件搜索路径</td>
</tr>
<tr>
<td><code>-L</code></td>
<td>添加库文件搜索路径</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>链接指定的库（例如 <code>-lm</code> 表示链接 <code>math</code> 库）</td>
</tr>
<tr>
<td>-v&#x2F;–version</td>
<td>查看gcc版本号</td>
</tr>
<tr>
<td>-D</td>
<td>编译时定义宏</td>
</tr>
</tbody></table>
<pre class="language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-Wall</span> test.c <span class="token comment">#显示所有的警告信息</span>
gcc <span class="token parameter variable">-Wall</span> <span class="token parameter variable">-Werror</span> test.c <span class="token comment">#把警告信息当作错误处理</span>
gcc tmp.c <span class="token parameter variable">-DDEBUG</span> <span class="token comment">#可以用来区分测试版和发布版,DEBUG是定义的宏</span></code></pre>

<h2 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h2><p>静态链接：由链接器在<strong>链接</strong>时把<strong>库的内容加入到可执行程序中。</strong></p>
<p>优点：对运行环境的依赖较小，具有较好的兼容性。</p>
<p>缺点：生成的程序比较大，在装入内存消耗更多的时间。库函数有了更新，必须重新编译。</p>
<p>动态链接：链接器在<strong>链接时仅仅建立和所需库函数的链接关系，在程序运行时才将所需资源调入可执行程序</strong>。</p>
<p>优点：在需要的时候才会调入对应的资源函数。简化程序的升级，有着较小的程序体积，实现进程间的资源共享（避免重复拷贝）</p>
<p>缺点：依赖动态库，不能独立运行，动态库依赖版本问题严重。</p>
<h3 id="静态和动态编译对比"><a href="#静态和动态编译对比" class="headerlink" title="静态和动态编译对比"></a>静态和动态编译对比</h3><p>我们编写的应用程序大量用到了库函数，系统默认采用动态链接的方式进行编译程序，若想采用静态编译，加入-static参数。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">gcc test.c <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>
gcc <span class="token parameter variable">-static</span> test.c <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span></code></pre>

<p>静态编译是要比动态编译程序大的多。</p>
<h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><p>静态库可以认为是一些目标代码的集合，是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分。按照习惯，一般以”.a”作为文件后缀名。静态库的命名一般分为三个部分：前缀：lib,库名称：自己定义。后缀：.a。最终静态库的名字为libxxx.a</p>
<h3 id="静态库制作："><a href="#静态库制作：" class="headerlink" title="静态库制作："></a>静态库制作：</h3><p><img src="/2025/06/20/Linux-System%20Programming/3.png" alt="3" loading="lazy"></p>
<pre class="language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-c</span> add.c <span class="token parameter variable">-o</span> add.o <span class="token comment">#-c是只编译不链接输出.o文件</span>
gcc <span class="token parameter variable">-c</span> sub.c <span class="token parameter variable">-o</span> sub.o
gcc <span class="token parameter variable">-c</span> mul.c <span class="token parameter variable">-o</span> mul.o
gcc <span class="token parameter variable">-c</span> div.c <span class="token parameter variable">-o</span> dic.o
ar <span class="token parameter variable">-rcs</span> libtest.a add.o sub.o mul.o div.o<span class="token comment">#使用打包工具ar将准备好的.o文件打包为.a文件libtest.a</span></code></pre>

<p>在使用ar工具需要添加参数：rcs </p>
<p>r更新，c创建，s建立索引</p>
<h3 id="静态库使用："><a href="#静态库使用：" class="headerlink" title="静态库使用："></a>静态库使用：</h3><p>静态库制作完成之后，需要将.a文件和头文件一起发布给用户。假设测试文件是main.c,静态库文件为libtest.a，头文件为head.h</p>
<p>编译命令：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">gcc main.c -L./ -I./ <span class="token parameter variable">-ltest</span> <span class="token parameter variable">-o</span> main<span class="token comment">#注意这里链接库的名字</span></code></pre>

<p>-L：表示要连接的库所在目录。</p>
<p>-ltest:指定链接时需要的库，去掉前缀和后缀</p>
<p>-I(这里是大写的i):表示要连接的头文件目录</p>
<h3 id="动态库制作"><a href="#动态库制作" class="headerlink" title="动态库制作"></a>动态库制作</h3><p>共享库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。</p>
<p>动态库在程序运行时才被载入，也解决了静态库对程序的更新，部署和发布的再次编译的问题，用户只需要更新动态库即可，增量更新。</p>
<p>一般以”.so”作为文件后缀名。共享库的命名一般分为三个部分：前缀lib,库名称:自己定义，后缀：.so。所以最终的动态库的名字应该为：libxxx.so。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#生成目标文件，此时要加编译选项：-fPIC(fpic)参数-fPIC创建与地址无关的编译程序（pic,position independent code）,是为了能在多个应用程序间共享。</span>
gcc <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-c</span> add.c
gcc <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-c</span> sub.c
gcc <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-c</span> mul.c
gcc <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-c</span> div.c
<span class="token comment">#生成共享库，此时要加链接器选项：-shared(指定生成动态链接库)</span>
gcc <span class="token parameter variable">-shared</span> add.o sub.o mul.o div.o <span class="token parameter variable">-o</span> libtest.so
<span class="token comment">#通过nm命令查看对应的函数</span>
nm libtest.so <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"add"</span>
<span class="token comment">#通过ldd命令查看可执行文件依赖的动态库</span>
ldd <span class="token builtin class-name">test</span></code></pre>

<h3 id="动态库使用"><a href="#动态库使用" class="headerlink" title="动态库使用"></a>动态库使用</h3><p>引用动态库编译成可执行文件（和静态库一样）</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">gcc main.c -L./ -I./ <span class="token parameter variable">-ltest</span> <span class="token parameter variable">-o</span> main<span class="token comment">#注意这里链接库的名字</span></code></pre>

<p>这一步是可以过的，但是到了，执行main时发现找不到对应文件。第一种就是把libtest.so复制到&#x2F;lib里（需要sudo,这个方法不推荐，最好不要动Linux原本文件，覆盖了就不好玩了。）</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">gcc main.c -I./ <span class="token parameter variable">-ltest</span> <span class="token parameter variable">-o</span> main<span class="token comment">#注意这里链接库的名字,执行可执行文件就可以执行了，这种方法不推荐</span></code></pre>

<h3 id="动态库加载失败问题解决"><a href="#动态库加载失败问题解决" class="headerlink" title="动态库加载失败问题解决"></a>动态库加载失败问题解决</h3><p>当系统加载可执行代码，能够知道其所依赖的库的名字，但还需要知道其绝对路径。此时就需要系统动态载入器（dynamic linker&#x2F;loader）。对于elf格式的可执行程序，是由ld-linux.so*来完成，他先后搜索elf文件的DT_RPATH段—环境变量LD_LIBRARY_PATH—&#x2F;etc&#x2F;ld.so.cache文件列表—&#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib目录找到库文件后将其载入内存。</p>
<p>拷贝自己制作的共享库到&#x2F;lib或者&#x2F;usr&#x2F;lib(不能是&#x2F;lib64目录)</p>
<p>临时设置LD_LIBRARY_PATH(只在当前终端生效):</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:库路径<span class="token comment">#在原环境变量追加新的变量，库路径为绝对路径。</span></code></pre>

<p>永久设置:把export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:库路径这段话，设置到~&#x2F;.bashrc </p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.bashrc <span class="token comment">#让配置文件生效</span></code></pre>

<p>除了以上三种还有两种将其添加到&#x2F;etc&#x2F;ld.so.conf,这里只需要添加绝对路径，然后sudo ldconfig -v使路径生效。</p>
<p>还有使用符号链接，但一定要使用绝对路径。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> 库文件的绝对路径 /lib/库文件</code></pre>

<h2 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h2><p>GDB主要完成下面四个功能：</p>
<p>1.启动程序，可以按照你的自定义的要求随心所欲的运行程序。</p>
<p>2.可让被调试的程序在你指定的断点停住。</p>
<p>3.当程序被停住时，可以检查此时你的程序中所发生的事。</p>
<p>4.动态的改变你程序的执行环境。</p>
<h3 id="生成调试信息"><a href="#生成调试信息" class="headerlink" title="生成调试信息"></a>生成调试信息</h3><p>一般来说GDB主要调试的是C&#x2F;C++的程序，要调试C&#x2F;C++的程序，首先在编译时，我们必须把调试信息加到可执行文件中。使用编译器（cc&#x2F;gcc&#x2F;g++）的-g参数可以做到这一点。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-g</span> hello.c <span class="token parameter variable">-o</span> hello
g++ <span class="token parameter variable">-g</span> hello.c <span class="token parameter variable">-o</span> hello</code></pre>

<h3 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h3><p>启动gdb:<strong>gdb program</strong></p>
<p>program也就是你的执行文件，一般在当前目录下。</p>
<p>设置启动参数:启动后设置</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">set</span> args <span class="token comment">#可指定运行参数</span>
<span class="token builtin class-name">set</span> args <span class="token number">10</span> <span class="token number">20</span> <span class="token number">30</span> <span class="token number">40</span> <span class="token string">"hello world"</span>
show args <span class="token comment">#命令可以查看设置好的运行参数</span></code></pre>

<p><strong>启动程序：</strong></p>
<p>run:程序开始执行，如果有断点，停在第一个断点处。</p>
<p>start:程序向下执行一行。</p>
<p>n:执行下一步。</p>
<h3 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h3><p>用list（也可直接打l）命令来打印程序的源代码。默认打印10行。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">list <span class="token keyword">function</span><span class="token comment">#显示函数名为function的函数的源码</span>
<span class="token builtin class-name">set</span> listsize count <span class="token comment">#设置一次显示源码的行数默认是10行</span>
show listsize <span class="token comment">#查看当前listsize的设置</span></code></pre>

<h3 id="断点操作"><a href="#断点操作" class="headerlink" title="断点操作"></a>断点操作</h3><p>简单断点:</p>
<p>break设置断点，可以简写为b</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">b <span class="token number">10</span> <span class="token comment">#设置断点，在源程序第十行</span>
b func <span class="token comment">#设置断点，在func函数入口处</span></code></pre>

<p>多文件设置断点</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">break</span> filename:linenum <span class="token comment">#在源文件filename的linenum行处停住</span>
<span class="token builtin class-name">break</span> filename:function <span class="token comment">#在源文件filename的function函数的入口处停住</span>
<span class="token builtin class-name">break</span> class::function或者function<span class="token punctuation">(</span>type,type<span class="token punctuation">)</span> <span class="token comment">#在类class的function函数入口处停住</span>
<span class="token builtin class-name">break</span> namespace::class::function <span class="token comment">#在名称空间为namespace的类class的function函数的入口处停住。</span></code></pre>

<p>查询所有断点</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">info b
info <span class="token builtin class-name">break</span>
i <span class="token builtin class-name">break</span>
i b</code></pre>

<h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。</p>
<p>设置一个条件断点：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">b test.c:8 <span class="token keyword">if</span> Value <span class="token operator">==</span> <span class="token number">5</span> <span class="token comment">#对test.c文件的当变量Value满足为5时，在test.c文件的第8行产生断点</span></code></pre>

<h3 id="维护断点"><a href="#维护断点" class="headerlink" title="维护断点"></a>维护断点</h3><p>delete 范围 删除指定的断点，其简写命令为d。如果不指定断点号，则表示删除所有的断点。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">d <span class="token number">10</span>-12 <span class="token comment">#删除编号为10-12的断点。编号可以使用i b命令查看</span></code></pre>

<p>比删除更好的一种方法时disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">disable 断点编号 <span class="token comment">#使指定断点无效，简写命令是dis。如果什么都不指定，表示disable所有的停止点。</span>
<span class="token builtin class-name">enable</span> 断点编号 <span class="token comment">#使无效断点生效，简写命令是ena。如果什么都不指定，表示enable所有的停止点</span></code></pre>

<h3 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h3><pre class="language-bash" data-language="bash"><code class="language-bash">run <span class="token comment">#运行程序，可简写为r。程序开始执行，如果有断点，停在第一个断点处。</span>
next <span class="token comment">#单步跟踪，函数调用当作一条简单语句执行，可简写为n。</span>
step <span class="token comment">#单步跟踪，函数调用进入被调用函数体内，可简写为s。</span>
finish <span class="token comment">#退出进入的函数</span>
<span class="token keyword">until</span> <span class="token comment">#在一个循环体单步跟踪时，这个命令可以运行程序直到退出循环体，可简写为u。</span>
<span class="token builtin class-name">continue</span> <span class="token comment">#继续运行程序，停在下一个断点的位置，可简写为c。</span>
quit <span class="token comment">#退出gdb,可简写为q。</span></code></pre>

<h3 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看运行时的数据</span>
<span class="token comment">#print打印变量，字符串，表达式等的值，可简写为p。</span>
p count <span class="token comment">#打印count的值</span></code></pre>

<h3 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h3><p>可以设置一些自动显示的变量，当程序停住时，或在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">display 变量名 <span class="token comment">#在run启动程序后，使用该命令。</span>
info display <span class="token comment">#查看display设置的自动显示的信息（可以看到对应变量名的编号）</span>
undisplay num <span class="token comment">#info display是显示的编号 使对应编号的自动显示功能失效。</span>
delete display dnums <span class="token comment">#删除自动显示，dnums意为所设置好了的自动显示的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围的编号，可以用减号表示。</span>
disable display dnums
<span class="token builtin class-name">enable</span> display dnums
disable和enable<span class="token comment">#不删除自动显示的设置，而只是让其失效和恢复。</span></code></pre>

<h3 id="查看修改变量的值"><a href="#查看修改变量的值" class="headerlink" title="查看修改变量的值"></a>查看修改变量的值</h3><pre class="language-bash" data-language="bash"><code class="language-bash">ptype width <span class="token comment">#查看变量width的类型</span>
p width <span class="token comment">#打印变量width的值 p是print命令的缩写。</span>
<span class="token builtin class-name">set</span> var <span class="token assign-left variable">width</span><span class="token operator">=</span><span class="token number">47</span> <span class="token comment">#将变量var值设置为47。在改变程序变量取值时，最好都使用set var格式的GDB命令。</span></code></pre>

<h2 id="自动化编译工具Makefile"><a href="#自动化编译工具Makefile" class="headerlink" title="自动化编译工具Makefile"></a>自动化编译工具Makefile</h2><p>make是个命令工具。</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">make</span> <span class="token comment">#下载make命令</span></code></pre>

<h3 id="Makefile语法规则"><a href="#Makefile语法规则" class="headerlink" title="Makefile语法规则"></a>Makefile语法规则</h3><p>一条规则：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">目标：依赖文件列表
<span class="token operator">&lt;</span>Tab<span class="token operator">></span>命令列表</code></pre>

<pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">all</span><span class="token punctuation">:</span>test1 test2
	echo <span class="token string">"hello all"</span>
	
<span class="token target symbol">test1</span><span class="token punctuation">:</span>
	echo <span class="token string">"hello test1"</span>

<span class="token target symbol">test2</span><span class="token punctuation">:</span>
	echo <span class="token string">"hello test2"</span>
<span class="token comment">#总共三条规则</span>
<span class="token comment">#执行结果：make -f 1.mk</span>
echo <span class="token string">"hello test1"</span>
hello test1
echo <span class="token string">"hello test2"</span>
hello test2
echo <span class="token string">"hello all"</span>
hello all</code></pre>

<p>Makefile基本规则三要素：</p>
<p>目标:</p>
<p>​	通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作的名称。</p>
<p>依赖文件：</p>
<p>​	用来输入从而产生目标的文件。</p>
<p>​	一个目标通常有几个依赖文件（可以没有）</p>
<p>命令：</p>
<p>​	make执行的动作，一个规则可以含几个命令（可以没有）</p>
<p>​	有多个命令，每个命令占一行。</p>
<h3 id="make命令格式"><a href="#make命令格式" class="headerlink" title="make命令格式"></a>make命令格式</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token punctuation">[</span>-f file<span class="token punctuation">]</span><span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">[</span>targets<span class="token punctuation">]</span>
<span class="token punctuation">[</span>-f file<span class="token punctuation">]</span>:
make默认在工作目录中寻找为GNUmakefile,makefile,Makefile的文件作为makefile输入文件。
-f可以指定以上名字以外的文件作为makefile输入文件。
<span class="token punctuation">[</span>options<span class="token punctuation">]</span>:
<span class="token parameter variable">-v</span> 显示make工具的版本
<span class="token parameter variable">-w</span> 在处理makefile之前和之后显示工作路径
<span class="token parameter variable">-C</span> <span class="token function">dir</span> 读取makefile之前改变工作路径至dir目录
<span class="token parameter variable">-n</span> 只打印要执行的命令但不执行
<span class="token parameter variable">-s</span> 执行但不显示执行的命令
<span class="token punctuation">[</span>targets<span class="token punctuation">]</span>:
若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个规则
指定了make工具要实现的目标，目标可以是一个或多个（多个目标用空格隔开）
<span class="token function">make</span> test1 <span class="token parameter variable">-f</span> <span class="token number">1</span>.mk <span class="token comment">#就会执行目标为test1对应的语句。</span></code></pre>

<h3 id="Makefile示例"><a href="#Makefile示例" class="headerlink" title="Makefile示例"></a>Makefile示例</h3><p>测试程序：test.c add.c sub.c mul.c div.c add.h sub.h mul.h div.h</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#最简单的Makefile(首先vim Makefile)</span>
<span class="token target symbol">test</span><span class="token punctuation">:</span>test.c add.c sub.c mul.c div.c
	gcc test.c add.c sub.c mul.c div.c -o test</code></pre>

<p>缺点：效率低，修改一个文件，所有文件都要重新编译。</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">test</span><span class="token punctuation">:</span>test.o add.o sub.o mul.o div.o 
	gcc test.o add.o sub.o mul.o div.o -o test
<span class="token target symbol">add.o</span><span class="token punctuation">:</span>add.c
	gcc -c add.c -o add.o
<span class="token target symbol">sub.o</span><span class="token punctuation">:</span>sub.c
	gcc -c sub.c -o sub.o
<span class="token target symbol">mul.o</span><span class="token punctuation">:</span>mul.c
	gcc -c mul.c -o mul.o
<span class="token target symbol">div.o</span><span class="token punctuation">:</span>div.c
	gcc -c div.c -o div.o
<span class="token target symbol">test.o</span><span class="token punctuation">:</span>test.c
	gcc -c test.c -o test.o</code></pre>

<p>这样，下次编译，他只会编译你修改的文件，最后再链接，这样是比较高效的。</p>
<h3 id="Makefile中的变量"><a href="#Makefile中的变量" class="headerlink" title="Makefile中的变量"></a>Makefile中的变量</h3><p>在Makefile中使用变量有点类似c语言的宏定义，使用该变量相当于内容替换，使用变量可以使Makefile易于维护。如果.o文件很多，难道我们要一个一个打吗，这也未免太麻烦，还可能漏打。</p>
<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><p>定义变量：</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile">变量名<span class="token operator">=</span>变量值</code></pre>

<p>引用变量：</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span>变量名<span class="token punctuation">)</span>或<span class="token variable">$</span><span class="token punctuation">&#123;</span>变量名<span class="token punctuation">&#125;</span></code></pre>

<p>makefile的变量名：</p>
<p>makefile变量名可以以数字开头。</p>
<p>变量是大小写敏感的。</p>
<p>变量一般在makefile的头部定义</p>
<p>变量几乎可在makefile的任何地方使用</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile">OBJS <span class="token operator">=</span> test.o add.o sub.o mul.o div.o
<span class="token target symbol">test</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>
	gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> -o test
<span class="token target symbol">add.o</span><span class="token punctuation">:</span>add.c
	gcc -c add.c -o add.o
<span class="token target symbol">sub.o</span><span class="token punctuation">:</span>sub.c
	gcc -c sub.c -o sub.o
<span class="token target symbol">mul.o</span><span class="token punctuation">:</span>mul.c
	gcc -c mul.c -o mul.o
<span class="token target symbol">div.o</span><span class="token punctuation">:</span>div.c
	gcc -c div.c -o div.o
<span class="token target symbol">test.o</span><span class="token punctuation">:</span>test.c
	gcc -c test.c -o test.o</code></pre>

<p>除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户使用，我们可以直接对其进行赋值。</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile">CC<span class="token operator">=</span>gcc
<span class="token target symbol">CPPFLAGS</span><span class="token punctuation">:</span>
<span class="token target symbol">CFLAGS</span><span class="token punctuation">:</span>
<span class="token target symbol">LDFLAGS</span><span class="token punctuation">:</span></code></pre>

<h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#这些变量不能单独使用 必须在命令中使用</span>
<span class="token comment"># $@ 表示目标</span>
<span class="token comment"># $^ 表示所有的依赖</span>
<span class="token comment"># $&lt; 表示第一个依赖</span></code></pre>

<pre class="language-makefile" data-language="makefile"><code class="language-makefile">OBJS <span class="token operator">=</span> test.o add.o sub.o mul.o div.o
TARGET<span class="token operator">=</span>test
<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>
	gcc <span class="token variable">$^</span> -o <span class="token variable">$@</span>
<span class="token target symbol">add.o</span><span class="token punctuation">:</span>add.c
	gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>
<span class="token target symbol">sub.o</span><span class="token punctuation">:</span>sub.c
	gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>
<span class="token target symbol">mul.o</span><span class="token punctuation">:</span>mul.c
	gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>
<span class="token target symbol">div.o</span><span class="token punctuation">:</span>div.c
	gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>
<span class="token target symbol">test.o</span><span class="token punctuation">:</span>test.c
	gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span></code></pre>

<h4 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h4><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#模式规则匹配示例</span>
<span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.c
<span class="token variable">$</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span></code></pre>

<pre class="language-makefile" data-language="makefile"><code class="language-makefile">OBJS<span class="token operator">=</span>test.o add.o sub.o mul.o div.o
TARGET<span class="token operator">=</span>test
<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>
	gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>
<span class="token comment">#模式匹配 所有的.o都依赖对应的.c</span>
<span class="token comment">#将所有的.c生成对应的.o</span>
<span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.c
	gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span></code></pre>

<h3 id="Makefile的函数"><a href="#Makefile的函数" class="headerlink" title="Makefile的函数"></a>Makefile的函数</h3><p>常用的函数</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile">wildcard <span class="token comment">#查找指定目录下的指定类型的文件</span>
src<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.c<span class="token punctuation">)</span> <span class="token comment">#找到当前目录下所有后缀为.c的文件，赋值给src</span>
patsubst <span class="token comment">#匹配替换</span>
obj<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,<span class="token variable">$</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#把src变量里所有后缀为.c的文件替换成.o</span></code></pre>

<p>在makefile中所有的函数都是有返回值的。</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#获取当前目录下所有的.c文件</span>
SRC<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> ./*.c<span class="token punctuation">)</span>
<span class="token comment">#将SRC中所有出现的.c的替换成.o</span>
OBJS<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,<span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span class="token punctuation">)</span>
TARGET<span class="token operator">=</span>test
<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>
	gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>
<span class="token comment">#模式匹配 所有的.o都依赖对应的.c</span>
<span class="token comment">#将所有的.c生成对应的.o</span>
<span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.c
	gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>
<span class="token comment">#clean目标清除编译生成的中间文件</span>
<span class="token comment">#执行命令 make clean</span>
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span></code></pre>

<h3 id="Makefile中的伪目标"><a href="#Makefile中的伪目标" class="headerlink" title="Makefile中的伪目标"></a>Makefile中的伪目标</h3><p>clean用途：清除编译生成的中间.o文件和最终目标文件</p>
<p>make clean 如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：</p>
<p>伪目标声明：.PHONY:clean 声明目标为伪目标之后，makefile将不会判断目标是否存在或者该目标是否需要更新。</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment">#获取当前目录下所有的.c文件</span>
SRC<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> ./*.c<span class="token punctuation">)</span>
<span class="token comment">#将SRC中所有出现的.c的替换成.o</span>
OBJS<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">patsubst</span> %.c,%.o,<span class="token variable">$</span><span class="token punctuation">(</span>SRC<span class="token punctuation">)</span><span class="token punctuation">)</span>
TARGET<span class="token operator">=</span>test
<span class="token target symbol"><span class="token variable">$</span>(TARGET)</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>
	gcc <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span>
<span class="token comment">#模式匹配 所有的.o都依赖对应的.c</span>
<span class="token comment">#将所有的.c生成对应的.o</span>
<span class="token target symbol">%.o</span><span class="token punctuation">:</span>%.c
	gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span>
<span class="token comment">#clean目标清除编译生成的中间文件</span>
<span class="token comment">#执行命令 make clean</span>
<span class="token comment">#声明clean为伪目标</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>clean
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	rm -rf <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>TARGET<span class="token punctuation">)</span></code></pre>

<p>上面这个版本就是最终版。</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token operator">@</span>gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span> <span class="token comment">#在命令前加上@符号，表示不显示命令本身（默认显示），只显示结果</span>
-gcc -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span> <span class="token comment">#加上-符号，此条命令出错，make也会继续执行后续的命令。</span></code></pre>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用说的是操作系统提供给用户程序调用的一组”特殊”接口</p>
<h3 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a>系统调用和库函数的区别</h3><p>Linux下对文件操作有两种方式：系统调用和库函数调用</p>
<p>库函数调用有两类函数组成：</p>
<p>不需要系统调用：不需要切换到内核空间即可完成函数全部功能，并且结果反馈给应用程序，如strcpy,bzero等字符串操作函数。</p>
<p>需要调用系统调用：需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如printf,fread等。</p>
<p><img src="/2025/06/20/Linux-System%20Programming/4.png" alt="4" loading="lazy"></p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">能白嫖就白嫖</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/wechatpay.png"><img loading="lazy" src="/images/wechatpay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><span class="icon iconify" data-icon="ri:wechat-pay-line"></span></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>YuStone</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://yustonerain.top/2025/06/20/Linux-System%20Programming.html" title="Linux系统编程">http://yustonerain.top/2025/06/20/Linux-System%20Programming.html</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2025/06/03/data-structure-100.html" rel="next" title="数据结构100题"><span class="post-nav-text">数据结构100题</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，可以直接联系我</span><br></div><style>.utterances {
  max-width: 100%;
}</style><script src="https://utteranc.es/client.js" repo="YuStone0416/YuStone0416.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2025 </span><a class="with-love" id="animate" href="http://yustonerain.top" title="YuStone Blog"><span class="icon iconify" data-icon="ri:cloud-line"></span></a><span class="author"> YuStone</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.3.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div><div class="live-time"><span>感谢陪伴</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2025-06-02T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div><div class="footer-custom-text">YuStoneblog Description</div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="https://fastly.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div class="search-result-container"></div></div><script src="https://fastly.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style></body></html>