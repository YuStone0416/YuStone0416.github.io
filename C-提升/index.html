
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>C++提升 - YuStone</title>

  
    <meta name="description" content="C++提升学习">
<meta property="og:type" content="article">
<meta property="og:title" content="C++提升">
<meta property="og:url" content="http://yustonerain.top/C-%E6%8F%90%E5%8D%87/">
<meta property="og:site_name" content="YuStone">
<meta property="og:description" content="C++提升学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yustonerain.top/images/avatar.jpg">
<meta property="article:published_time" content="2025-08-20T22:54:16.000Z">
<meta property="article:modified_time" content="2025-08-26T21:26:16.000Z">
<meta property="article:author" content="YuStone">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yustonerain.top/images/avatar.jpg">
  
  
  
  <meta name="keywords" content="C++">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="YuStone" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  
    <link rel="shortcut icon" href="/favicon1.ico">
  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"YuStone","sameAs":[],"image":"/images/avatar.jpg"},"dateCreated":"2025-08-21T06:54:16+08:00","dateModified":"2025-08-27T05:26:16+08:00","datePublished":"2025-08-21T06:54:16+08:00","description":"C++提升学习","headline":"C++提升","mainEntityOfPage":{"@type":"WebPage","@id":"http://yustonerain.top/C-%E6%8F%90%E5%8D%87/"},"publisher":{"@type":"Organization","name":"YuStone","sameAs":[],"image":"/images/avatar.jpg","logo":{"@type":"ImageObject","url":"/images/avatar.jpg"}},"url":"http://yustonerain.top/C-%E6%8F%90%E5%8D%87/","keywords":"C++","image":[]}</script>
  
</head>
<body>

<div class="l_body content" id="start" layout="post" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main">YuStone</div><div class="sub normal cap">我的独立博客</div><div class="sub hover cap" style="opacity:0"> 欢迎来到我的博客</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="关于" href="/about/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="朋友" href="/friends/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>



<widget class="widget-wrapper recent post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/%E5%89%96%E6%9E%90muduo%E7%BD%91%E7%BB%9C%E5%BA%93%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81/"><span class="title">剖析muduo网络库核心代码</span></a><a class="item title" href="/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/"><span class="title">mysql连接池</span></a><a class="item title" href="/C-%E6%8F%90%E5%8D%87/"><span class="title">C++提升</span></a><a class="item title" href="/C-basiclearning/"><span class="title">C++basiclearning</span></a><a class="item title" href="/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"><span class="title">git必知必会</span></a><a class="item title" href="/MYSQLlearning/"><span class="title">MYSQLlearning</span></a><a class="item title" href="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="title">Linux网络编程</span></a><a class="item title" href="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"><span class="title">Linux系统编程</span></a><a class="item title" href="/c-%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="title">c++实现集群聊天服务器</span></a><a class="item title" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84100%E9%A2%98/"><span class="title">数据结构100题</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/YuStone0416" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder/social/08a41b181ce68.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder/social/3845874.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder/social/3616429.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder/social/942ebbf1a4b91.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/C-%E6%8F%90%E5%8D%87/">C++提升</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2025-08-20T22:54:16.000Z">2025-08-21</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2025-08-26T21:26:16.000Z">2025-08-27</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>C++提升</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h2 id="C-对象应用优化"><a href="#C-对象应用优化" class="headerlink" title="C++对象应用优化"></a>C++对象应用优化</h2><h3 id="对象使用过程背后调用了那些方法？"><a href="#对象使用过程背后调用了那些方法？" class="headerlink" title="对象使用过程背后调用了那些方法？"></a>对象使用过程背后调用了那些方法？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">5</span>, <span class="type">int</span> b = <span class="number">5</span>) :<span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test(int,int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t) :<span class="built_in">ma</span>(t.ma),<span class="built_in">mb</span>(t.mb) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; operator=&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        ma = t.ma;</span><br><span class="line">        mb = t.mb;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;<span class="comment">//1.Test(int,int)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;<span class="comment">//3.Test(int,int)</span></span><br><span class="line">    Test t3 = t2;<span class="comment">//4.Test(const Test&amp;)</span></span><br><span class="line">    <span class="type">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>);<span class="comment">//5.Test(int,int)</span></span><br><span class="line">    t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>);<span class="comment">//6.Test(int,int) operator= ~Test()</span></span><br><span class="line">    <span class="comment">//逗号表达式 (50,50)=50</span></span><br><span class="line">    t2 = (Test)(<span class="number">50</span>, <span class="number">50</span>);<span class="comment">//=&gt;Test(50) 7.Test(int,int) operator= ~Test()</span></span><br><span class="line">    t2 = <span class="number">60</span>;<span class="comment">//8.Test(int,int) operator= ~Test()</span></span><br><span class="line">    Test* p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>);<span class="comment">//9.Test(int,int)</span></span><br><span class="line">    Test* p2 = <span class="keyword">new</span> Test[<span class="number">2</span>];<span class="comment">//10.Test(int,int) Test(int,int)</span></span><br><span class="line">    <span class="comment">//Test* p3 = &amp;Test(80,80);</span></span><br><span class="line">    <span class="type">const</span> Test&amp; p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>);<span class="comment">//11 Test(int,int) 生命周期延长</span></span><br><span class="line">    <span class="keyword">delete</span> p1;<span class="comment">//12.~Test()</span></span><br><span class="line">    <span class="keyword">delete</span>[] p2;<span class="comment">//13 ~Test() ~Test()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;<span class="comment">//2.Test(int,int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">10</span>) :<span class="built_in">ma</span>(a)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t) :<span class="built_in">ma</span>(t.ma) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; operator=&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        ma = t.ma;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line">    Test t3 = t1;</span><br><span class="line">    <span class="comment">//Test(20) 显式生成临时对象 生存周期：所在的语句</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    C++编译器对于对象构造的优化：用临时对象生成新对象的时候，临时对象就不产生了，直接构造新对象就可以了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Test t4 = <span class="built_in">Test</span>(<span class="number">20</span>);<span class="comment">//Test t4(20);没有区别</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    t4 = t2;</span><br><span class="line">    <span class="comment">//t4.operator=(const Test &amp;t)</span></span><br><span class="line">    <span class="comment">//显式生成临时对象</span></span><br><span class="line">    t4 = <span class="built_in">Test</span>(<span class="number">30</span>);</span><br><span class="line">    t4 = (Test)<span class="number">30</span>;<span class="comment">//int -&gt;Test(int) 显式转换，但是得有Test(int)这种类型的构造函数才可以转</span></span><br><span class="line">    <span class="comment">//隐式生成临时对象</span></span><br><span class="line">    t4 = <span class="number">30</span>;<span class="comment">//int -&gt;Test(int) 隐式转换，但是得有Test(int)这种类型的构造函数才可以转</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//const Test* p = &amp;Test(40);</span></span><br><span class="line">    <span class="comment">//语句结束，p指向的是一个已经析构的临时对象,所以指针指向临时对象是不安全的</span></span><br><span class="line">    <span class="type">const</span> Test&amp; ref = <span class="built_in">Test</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">//按道理说，这句结束，Test要析构了，但是这个临时对象有名字了，所以延长了生命周期</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象的构造函数，拷贝构造，析构函数调用过程</span><br><span class="line">临时对象</span><br></pre></td></tr></table></figure>

<h3 id="函数调用过程中背后调用的方法"><a href="#函数调用过程中背后调用的方法" class="headerlink" title="函数调用过程中背后调用的方法"></a>函数调用过程中背后调用的方法</h3><p><img src="/C-%E6%8F%90%E5%8D%87/1.png" alt="1"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> data = <span class="number">10</span>):<span class="built_in">ma</span>(data)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test(int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t) :<span class="built_in">ma</span>(t.ma)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        ma = t.ma;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ma;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不能返回局部的或者临时对象的指针或者引用</span></span><br><span class="line"><span class="function">Test <span class="title">GetObject</span><span class="params">(Test t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">    <span class="function">Test <span class="title">tmp</span><span class="params">(val)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    Test t2;</span><br><span class="line">    t2 = <span class="built_in">GetObject</span>(t1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test</span>(<span class="type">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">const</span> Test&amp;)</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span>)</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="keyword">operator</span>=</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">这里看出函数调用背后方法有点多，要优化</span><br></pre></td></tr></table></figure>

<h3 id="三条对象优化的原则"><a href="#三条对象优化的原则" class="headerlink" title="三条对象优化的原则"></a>三条对象优化的原则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> data = <span class="number">10</span>) :<span class="built_in">ma</span>(data)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test(int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; t) :<span class="built_in">ma</span>(t.ma)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Test&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        ma = t.ma;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ma;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不能返回局部的或者临时对象的指针或者引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.函数参数传递过程中，对象优先按引用传递，不要按值传递</span></span><br><span class="line"><span class="comment">2.函数返回对象的时候，应该优先返回一个临时对象，而不要返回一个定义过的对象</span></span><br><span class="line"><span class="comment">3.接收返回值是对象的函数调用的时候，优先按初始化的方式接收，不要按赋值的方式接收。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Test <span class="title">GetObject</span><span class="params">(Test &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">    <span class="comment">/*Test tmp(val);</span></span><br><span class="line"><span class="comment">    return tmp;*/</span></span><br><span class="line">    <span class="comment">//返回临时对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    Test t2 = <span class="built_in">GetObject</span>(t1);</span><br><span class="line">    <span class="comment">//t2 = GetObject(t1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test</span>(<span class="type">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span>)</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br></pre></td></tr></table></figure>

<h3 id="右值引用参数的成员方法"><a href="#右值引用参数的成员方法" class="headerlink" title="右值引用参数的成员方法"></a>右值引用参数的成员方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>)<span class="comment">//普通构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//strlen计算字符串长度时，是不计入&#x27;\0&#x27;的</span></span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_data, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里不能直接把m_data赋值为nullptr，如果这里赋值</span></span><br><span class="line">            <span class="comment">//后面的构造函数都要判断地址为空的条件。</span></span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(const char *)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)<span class="comment">//拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(const String&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>(<span class="type">void</span>)<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~String()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    String&amp; <span class="keyword">operator</span> = (<span class="type">const</span> String&amp; other)<span class="comment">//赋值重载函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String&amp; operator=(const String&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;<span class="comment">//用于保存字符串</span></span><br><span class="line">    <span class="keyword">friend</span> String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">String <span class="title">GetString</span><span class="params">(String&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">String <span class="title">tmp</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">str1</span><span class="params">(<span class="string">&quot;aaaaaaaaaaaaaa&quot;</span>)</span></span>;</span><br><span class="line">    String str2;</span><br><span class="line">    str2 = <span class="built_in">GetString</span>(str1);</span><br><span class="line">    std::cout &lt;&lt; str<span class="number">2.</span><span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    C++17之前</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    String(const String&amp;) =&gt;tmp拷贝构造main函数栈帧上的临时对象</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    String&amp; operator=(const String&amp;)=》main函数栈帧上的临时对象给str2赋值</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    aaaaaaaaaaaaaa</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">str2 = <span class="built_in">GetString</span>(str1);</span><br><span class="line">这里需要解决的是当返回值是String,如何优化其中的临时对象，老是创建对象，如果还有申请别的空间，是很耗费效率的。所以我们应该利用临时对象，节省资源。下一节，使用右值引用解决问题</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *)</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp;) =&gt;tmp拷贝构造main函数栈帧上的临时对象</span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp;)=》main函数栈帧上的临时对象给str2赋值</span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">所以在C+<span class="number">+17</span>之后进行了强制优化，叫做</span><br><span class="line">    <span class="built_in">RVO</span>(返回值优化)：在函数返回一个临时对象时，编译器可以直接在调用者的栈帧上构造这个返回值，而不在函数内部再创建一个临时对象。</span><br><span class="line">所以这是在C+<span class="number">+17</span>之后的效果：所以是直接在main函数上栈帧完成构造，所以就没有拷贝函数出现</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *)</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *)</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *)</span><br><span class="line">String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp;)</span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">aaaaaaaaaaaaaa</span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">这里还是会构造一个临时对象，因为str2存在，所以在main函数上构造了，所以会产生一个临时对象</span><br><span class="line">如果</span><br><span class="line">String str2 = <span class="built_in">GetString</span>(str1);</span><br><span class="line">结果就大不一样了，这句会直接在str2上构造</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *)</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *)</span><br><span class="line">aaaaaaaaaaaaaa</span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">这样就不会有临时对象了。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>写法</th>
<th>会发生什么</th>
<th>调用情况</th>
</tr>
</thead>
<tbody><tr>
<td><code>str2 = GetString(str1);</code></td>
<td>返回值临时对象 → <code>operator=</code> 赋值给已有的 <code>str2</code> → 临时对象析构</td>
<td>构造 + 赋值 + 析构</td>
</tr>
<tr>
<td><code>String str2 = GetString(str1);</code></td>
<td>返回值直接在 <code>str2</code> 上构造（RVO）</td>
<td>只有一次构造</td>
</tr>
</tbody></table>
<h3 id="使用带右值引用参数的赋值重载函数解决临时对象的使用"><a href="#使用带右值引用参数的赋值重载函数解决临时对象的使用" class="headerlink" title="使用带右值引用参数的赋值重载函数解决临时对象的使用"></a>使用带右值引用参数的赋值重载函数解决临时对象的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>)<span class="comment">//普通构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//strlen计算字符串长度时，是不计入&#x27;\0&#x27;的</span></span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_data, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里不能直接把m_data赋值为nullptr，如果这里赋值</span></span><br><span class="line">            <span class="comment">//后面的构造函数都要判断地址为空的条件。</span></span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(const char *)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带左值引用参数的拷贝构造</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)<span class="comment">//拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(const String&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带右值引用参数的拷贝构造</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other)<span class="comment">//拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(String&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>(<span class="type">void</span>)<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~String()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带左值引用参数的赋值重载函数</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span> = (<span class="type">const</span> String&amp; other)<span class="comment">//赋值重载函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String&amp; operator=(const String&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带右值引用参数的赋值重载函数</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span> = (String&amp;&amp; other)<span class="comment">//赋值重载函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String&amp; operator=(String&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;<span class="comment">//用于保存字符串</span></span><br><span class="line">    <span class="keyword">friend</span> String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">String <span class="title">GetString</span><span class="params">(String&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">String <span class="title">tmp</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//右值引用</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; b = a;<span class="comment">//左值：有内存，有名字 右值：没名字(临时量)、没内存</span></span><br><span class="line">    <span class="comment">//int&amp;&amp; c = a;//无法将左值绑定到右值引用上</span></span><br><span class="line">    <span class="comment">//int&amp; c = 20;//不能用左值引用绑定一个右值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; c = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; d= <span class="number">20</span>;<span class="comment">//可以把一个右值绑定到一个右值引用上</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    const int&amp; c = 20;</span></span><br><span class="line"><span class="comment">    int&amp;&amp; d= 20;</span></span><br><span class="line"><span class="comment">    这两的区别一个可以修改，一个不可以，c不可以，d可以</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String&amp;&amp; e = <span class="built_in">String</span>(<span class="string">&quot;aaa&quot;</span>);<span class="comment">//=》这是个临时量，所以是个右值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; f = d;<span class="comment">//一个右值引用变量，本身是一个左值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">str1</span><span class="params">(<span class="string">&quot;aaaaaaaaaaaaaa&quot;</span>)</span></span>;</span><br><span class="line">    String str2;</span><br><span class="line">    str2 = <span class="built_in">GetString</span>(str1);</span><br><span class="line">    std::cout &lt;&lt; str<span class="number">2.</span><span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    C++17以前</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    String(String&amp;&amp;)</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    String&amp; operator=(String&amp;&amp;)</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    aaaaaaaaaaaaaa</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">我们使用带有右值引用的拷贝构造和赋值重载函数，解决临时对象的使用问题</span><br><span class="line">str2 = <span class="built_in">GetString</span>(str1);</span><br><span class="line">如果没有重载带右值引用的函数，编译器会使用带左值引用的函数。</span><br><span class="line"><span class="comment">//带右值引用参数的拷贝构造</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other)<span class="comment">//拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(String&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//带右值引用参数的赋值重载函数</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span> = (String&amp;&amp; other)<span class="comment">//赋值重载函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String&amp; operator=(String&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">这里重载就是为了把临时对象的资源弄到手，不用先申请赋值后再释放后，太浪费资源。</span><br><span class="line">但是这里使用后，并没有调用带右值引用参数的拷贝构造</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *)</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *)</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *)</span><br><span class="line">String&amp; <span class="keyword">operator</span>=(String&amp;&amp;)</span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">aaaaaaaaaaaaaa</span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">~<span class="built_in">String</span>()</span><br><span class="line">C+<span class="number">+17</span>之后引入<span class="built_in">RVO</span>(返回值优化),所以没有拷贝调用出现</span><br></pre></td></tr></table></figure>

<h3 id="自定义对象在vector容器上的应用"><a href="#自定义对象在vector容器上的应用" class="headerlink" title="自定义对象在vector容器上的应用"></a>自定义对象在vector容器上的应用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>)<span class="comment">//普通构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//strlen计算字符串长度时，是不计入&#x27;\0&#x27;的</span></span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_data, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里不能直接把m_data赋值为nullptr，如果这里赋值</span></span><br><span class="line">            <span class="comment">//后面的构造函数都要判断地址为空的条件。</span></span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(const char *)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带左值引用参数的拷贝构造</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)<span class="comment">//拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(const String&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带右值引用参数的拷贝构造</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other)<span class="comment">//拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(String&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>(<span class="type">void</span>)<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~String()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带左值引用参数的赋值重载函数</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span> = (<span class="type">const</span> String&amp; other)<span class="comment">//赋值重载函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String&amp; operator=(const String&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带右值引用参数的赋值重载函数</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span> = (String&amp;&amp; other)<span class="comment">//赋值重载函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String&amp; operator=(String&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;<span class="comment">//用于保存字符串</span></span><br><span class="line">    <span class="keyword">friend</span> String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs);</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> String&amp; str);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">String <span class="title">GetString</span><span class="params">(String&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">String <span class="title">tmp</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*char* ptmp = new char[strlen(lhs.m_data) + strlen(rhs.m_data) + 1];</span></span><br><span class="line"><span class="comment">    //这里需要释放，所以不能直接返回</span></span><br><span class="line"><span class="comment">    strcpy(ptmp, lhs.m_data);</span></span><br><span class="line"><span class="comment">    strcat(ptmp, rhs.m_data);</span></span><br><span class="line"><span class="comment">    String tmpstr(ptmp);</span></span><br><span class="line"><span class="comment">    delete[]ptmp;</span></span><br><span class="line"><span class="comment">    //return String(ptmp);</span></span><br><span class="line"><span class="comment">    return tmpstr;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//虽然上面这么写，已经很行了，但是还要优化</span></span><br><span class="line">    String tmpStr;</span><br><span class="line">    tmpStr.m_data= <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(lhs.m_data) + <span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr.m_data, lhs.m_data);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr.m_data, rhs.m_data);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; str.m_data;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String str1 = &quot;hello&quot;;</span></span><br><span class="line"><span class="comment">    String str2 = &quot;world&quot;;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;-------------------------------------------------&quot;&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">    String str3 = str1 + str2;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;-------------------------------------------------&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; str3 &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    -------------------------------------------------</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    -------------------------------------------------</span></span><br><span class="line"><span class="comment">    helloworld</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    String str1 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    std::vector&lt;String&gt; vec;</span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------------------------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(str1);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">String</span>(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------------------------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    -------------------------------------------------</span></span><br><span class="line"><span class="comment">    String(const String&amp;)</span></span><br><span class="line"><span class="comment">    String(const char *)</span></span><br><span class="line"><span class="comment">    String(String&amp;&amp;)</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    -------------------------------------------------</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    ~String()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="move和forward"><a href="#move和forward" class="headerlink" title="move和forward"></a>move和forward</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">nullptr</span>)<span class="comment">//普通构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//strlen计算字符串长度时，是不计入&#x27;\0&#x27;的</span></span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_data, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里不能直接把m_data赋值为nullptr，如果这里赋值</span></span><br><span class="line">            <span class="comment">//后面的构造函数都要判断地址为空的条件。</span></span><br><span class="line">            m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(const char *)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带左值引用参数的拷贝构造</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other)<span class="comment">//拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(const String&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带右值引用参数的拷贝构造</span></span><br><span class="line">    <span class="built_in">String</span>(String&amp;&amp; other)<span class="comment">//拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String(String&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>(<span class="type">void</span>)<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~String()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带左值引用参数的赋值重载函数</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span> = (<span class="type">const</span> String&amp; other)<span class="comment">//赋值重载函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String&amp; operator=(const String&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带右值引用参数的赋值重载函数</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span> = (String&amp;&amp; other)<span class="comment">//赋值重载函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String&amp; operator=(String&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//防止自赋值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[]m_data;</span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_data;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;<span class="comment">//用于保存字符串</span></span><br><span class="line">    <span class="keyword">friend</span> String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs);</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> String&amp; str);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">String <span class="title">GetString</span><span class="params">(String&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">String <span class="title">tmp</span><span class="params">(pstr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; lhs, <span class="type">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*char* ptmp = new char[strlen(lhs.m_data) + strlen(rhs.m_data) + 1];</span></span><br><span class="line"><span class="comment">    //这里需要释放，所以不能直接返回</span></span><br><span class="line"><span class="comment">    strcpy(ptmp, lhs.m_data);</span></span><br><span class="line"><span class="comment">    strcat(ptmp, rhs.m_data);</span></span><br><span class="line"><span class="comment">    String tmpstr(ptmp);</span></span><br><span class="line"><span class="comment">    delete[]ptmp;</span></span><br><span class="line"><span class="comment">    //return String(ptmp);</span></span><br><span class="line"><span class="comment">    return tmpstr;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//虽然上面这么写，已经很行了，但是还要优化</span></span><br><span class="line">    String tmpStr;</span><br><span class="line">    tmpStr.m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(lhs.m_data) + <span class="built_in">strlen</span>(rhs.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr.m_data, lhs.m_data);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr.m_data, rhs.m_data);</span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; str.m_data;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Allocator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span><span class="comment">//负责内存开辟</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(T) * size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p)</span><span class="comment">//负责内存释放</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void construct(T* p, const T&amp; val)//负责对象构造</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        new (p) T(val);//定位new:在指定地址去构造值为val的对象</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void construct(T* p, T&amp;&amp; val)//负责对象构造</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        new (p) T(std::move(val));//定位new:在指定地址去构造值为val的对象</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">construct</span><span class="params">(T* p, Ty&amp;&amp; val)</span><span class="comment">//负责对象构造</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> (p) <span class="built_in">T</span>(std::forward&lt;Ty&gt;(val));<span class="comment">//定位new:在指定地址去构造值为val的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(T* p)</span><span class="comment">//负责对象析构</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;~<span class="built_in">T</span>(); <span class="comment">//~T()代表T类型的析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">容器底层内存开辟，内存释放，对象构造和析构，都通过allocator空间配置器来实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>(<span class="type">int</span> size = <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//需要把内存开辟和对象构造分开处理，不然我使用vector&lt;Test&gt; vec;</span></span><br><span class="line">        <span class="comment">//自动创建10个Test对象</span></span><br><span class="line">        <span class="comment">//_first = new T[size];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//析构容器有效的元素，然后释放_first指针指向的堆内存</span></span><br><span class="line">        <span class="comment">//delete[]_first;</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first;p != _last;p++)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);<span class="comment">//把_first指针指向的数组的有效元素进行析构操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);<span class="comment">//释放堆上的数组内存</span></span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> size = rhs._end - rhs._first;</span><br><span class="line">        <span class="comment">//_first = new T[size];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        <span class="type">int</span> len = rhs._last - rhs._first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//_first[i] = rhs._first[i];</span></span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i.rhs._first[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//delete[]_first;</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first;p != _last;p++)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);<span class="comment">//把_first指针指向的数组的有效元素进行析构操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);<span class="comment">//释放堆上的数组内存</span></span><br><span class="line">        <span class="type">int</span> size = rhs._end - rhs._first;</span><br><span class="line">        <span class="comment">//_first = new T[size];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(size);</span><br><span class="line">        <span class="type">int</span> len = rhs._last - rhs._first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//_first[i] = rhs._first[i];</span></span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i.rhs._first[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + size;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span><span class="comment">//从容器末尾删除元素</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//--_last;</span></span><br><span class="line">        <span class="comment">//不仅要把_last指针--，还要析构删除的元素</span></span><br><span class="line">        --_last;</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(_last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="type">const</span><span class="comment">//返回容器末尾的元素值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _last == _end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _first == _last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _last - _first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //接收左值</span></span><br><span class="line"><span class="comment">    void push_back(const T&amp; val)//向容器末尾添加元素</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (full())</span></span><br><span class="line"><span class="comment">            expand();</span></span><br><span class="line"><span class="comment">        //*_last++ = val;</span></span><br><span class="line"><span class="comment">        //_last指针指向的内存构造一个值为val的对象</span></span><br><span class="line"><span class="comment">        _allocator.construct(_last, val);</span></span><br><span class="line"><span class="comment">        _last++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //接收右值</span></span><br><span class="line"><span class="comment">    void push_back(T&amp;&amp; val)//一个右值引用变量本身是一个左值，所以调用construct是使用左值的construct</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (full())</span></span><br><span class="line"><span class="comment">            expand();</span></span><br><span class="line"><span class="comment">        _allocator.construct(_last, std::move(val));</span></span><br><span class="line"><span class="comment">        _last++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt; <span class="comment">//函数模板的类型推演 + 引用折叠，就可以实现一个函数相当于两个函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span> <span class="comment">//Ty String &amp;&amp; + &amp; =String&amp; 引用折叠</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        <span class="comment">//move:移动语义，得到右值类型</span></span><br><span class="line">        <span class="comment">//std::forward&lt;Ty&gt;：类型的完美转发，能够识别左值和右值类型，并以对应的类型转发</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, std::forward&lt;Ty&gt;(val));</span><br><span class="line">        _last++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first;<span class="comment">//指向数组起始的位置</span></span><br><span class="line">    T* _last;<span class="comment">//指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;<span class="comment">//指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;<span class="comment">//定义容器的空间配置器对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span><span class="comment">//容器的二倍扩容</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = _end - _first;</span><br><span class="line">        <span class="comment">//T* ptmp = new T[2 * size];</span></span><br><span class="line">        T* ptmp = _allocator.<span class="built_in">allocate</span>(<span class="number">2</span> * size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ptmp[i] = _first[i];</span></span><br><span class="line">            _allocator.<span class="built_in">construct</span>(ptmp + i, _first[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//delete[]_first;</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first;p != _last;p++)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = ptmp;</span><br><span class="line">        _last = _first + size;</span><br><span class="line">        _end = _first + <span class="number">2</span> * size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    vector&lt;String&gt; vec;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------------------------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(str1);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">String</span>(<span class="string">&quot;bbb&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;-------------------------------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">construct</span><span class="params">(T* p, Ty&amp;&amp; val)</span><span class="comment">//负责对象构造</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> (p) <span class="built_in">T</span>(std::forward&lt;Ty&gt;(val));<span class="comment">//定位new:在指定地址去构造值为val的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(T* p)</span><span class="comment">//负责对象析构</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;~<span class="built_in">T</span>(); <span class="comment">//~T()代表T类型的析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt; <span class="comment">//函数模板的类型推演 + 引用折叠，就可以实现一个函数相当于两个函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span> <span class="comment">//Ty String &amp;&amp; + &amp; =String&amp; 引用折叠</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        <span class="comment">//move:移动语义，得到右值类型</span></span><br><span class="line">        <span class="comment">//std::forward&lt;Ty&gt;：类型的完美转发，能够识别左值和右值类型，并以对应的类型转发</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last, std::forward&lt;Ty&gt;(val));</span><br><span class="line">        _last++;</span><br><span class="line">    &#125;</span><br><span class="line">这两段代码的重写</span><br></pre></td></tr></table></figure>

<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//智能指针 保证能做到资源的自动释放</span></span><br><span class="line"><span class="comment">//利用栈上的对象出作用域自动析构的特征，来做到资源的自动释放</span></span><br><span class="line"><span class="comment">//智能指针不能使其构造在堆上 CSmartPtr&lt;int&gt; *p=new CSmartPtr&lt;int&gt;(new int); delete p;这样就浪费了智能指针的意义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        :<span class="built_in">mptr</span>(ptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> mptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *mptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* mptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*int* p = new int(10);</span></span><br><span class="line"><span class="comment">    *p = 30;</span></span><br><span class="line"><span class="comment">    delete p;*/</span></span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    *ptr = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;call Test::test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">CSmartPtr&lt;Test&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line">    <span class="comment">//(ptr2.operator-&gt;())-&gt;test();</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不带引用计数的智能指针"><a href="#不带引用计数的智能指针" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        :<span class="built_in">mptr</span>(ptr) &#123;&#125;</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="type">const</span> CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//mptr = new T(*src.mptr);</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> mptr;</span><br><span class="line">        mptr=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *mptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* mptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    不带引用计数的智能指针：本身只会让一个智能指针管理资源</span></span><br><span class="line"><span class="comment">    auto_ptr:C++库里面</span></span><br><span class="line"><span class="comment">    C++11:</span></span><br><span class="line"><span class="comment">    scoped_ptr</span></span><br><span class="line"><span class="comment">    scoped_ptr(const scope_ptr&lt;T&gt;&amp;)=dekete;</span></span><br><span class="line"><span class="comment">    scope_ptr&lt;T&gt; &amp; operator=(const scope_ptr&lt;T&gt;&amp;)=delete;</span></span><br><span class="line"><span class="comment">    直接禁用对应拷贝和赋值，就不会发生之前auto_ptr的问题</span></span><br><span class="line"><span class="comment">    推荐使用：</span></span><br><span class="line"><span class="comment">    unique_ptr</span></span><br><span class="line"><span class="comment">    unique_ptr(const unique_ptr&lt;T&gt;&amp;)=dekete;</span></span><br><span class="line"><span class="comment">    unique_ptr&lt;T&gt; &amp; operator=(const unique_ptr&lt;T&gt;&amp;)=delete;</span></span><br><span class="line"><span class="comment">    和scope_ptr不同的是，提供了带右值引用的赋值和拷贝</span></span><br><span class="line"><span class="comment">    unique_ptr(const unique_ptr&lt;T&gt;&amp;&amp;);</span></span><br><span class="line"><span class="comment">    unique_ptr&lt;T&gt; &amp; operator=(const unique_ptr&lt;T&gt;&amp;&amp;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    怎么解决浅拷贝问题？不解决，会出现double free</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//CSmartPtr&lt;int&gt; p1(new int);</span></span><br><span class="line">    <span class="comment">//CSmartPtr&lt;int&gt; p2(p1);</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::auto_ptr&lt;int&gt; ptr1(new int);</span></span><br><span class="line"><span class="comment">    std::auto_ptr&lt;int&gt; ptr2(new int);</span></span><br><span class="line"><span class="comment">    *ptr2 = 20;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//auto_ptr是保证最后一个使用智能指针的可以使用，前面使用的底层地址全部置空，来解决浅拷贝问题。</span></span><br><span class="line">    <span class="comment">//不推荐使用auto_ptr，如果把auto_ptr放在容器当中，只要有拷贝构造调用，就会把前一个置为空，这样是很危险的，</span></span><br><span class="line">    <span class="comment">//vector&lt;auto_ptr&lt;int&gt;&gt; vec1;vec2(vec1);</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(std::move(p1))</span></span>;<span class="comment">//显式调用std::move，不会出现auto_ptr可能无意识就调用了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现带引用计数的智能指针"><a href="#实现带引用计数的智能指针" class="headerlink" title="实现带引用计数的智能指针"></a>实现带引用计数的智能指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对资源进行引用计数的类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefCnt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RefCnt</span>(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        :<span class="built_in">mptr</span>(ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mptr != <span class="literal">nullptr</span>)</span><br><span class="line">            mcount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addRef</span><span class="params">()</span><span class="comment">//增加资源的引用计数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mcount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">delRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> --mcount;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* mptr;</span><br><span class="line">    <span class="type">int</span> mcount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSmartPtr</span> <span class="comment">//shared_ptr weak_ptr都是线程安全的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">        :<span class="built_in">mptr</span>(ptr) </span><br><span class="line">    &#123;</span><br><span class="line">        mpRefCnf = <span class="keyword">new</span> <span class="built_in">RefCnt</span>&lt;T&gt;(mptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="type">const</span> CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">        :<span class="built_in">mptr</span>(src.mptr),<span class="built_in">mpRefCnf</span>(src.mpRefCnf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mptr != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mpRefCnf-&gt;<span class="built_in">addRef</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    CSmartPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;src)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == mpRefCnf-&gt;<span class="built_in">delRef</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> mptr;</span><br><span class="line">        &#125;</span><br><span class="line">        mptr = src.mptr;</span><br><span class="line">        mpRefCnf = src.mpRefCnf;</span><br><span class="line">        mpRefCnf-&gt;<span class="built_in">addRef</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == mpRefCnf-&gt;<span class="built_in">delRef</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> mptr;</span><br><span class="line">            mptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *mptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mptr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* mptr;<span class="comment">//执行资源的指针</span></span><br><span class="line">    RefCnt&lt;T&gt;* mpRefCnf;<span class="comment">//指向该资源引用计数对象的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    带引用计数的智能指针shared_ptr和weak_ptr</span></span><br><span class="line"><span class="comment">    都是线程安全的</span></span><br><span class="line"><span class="comment">    带引用计数：多个智能指针可以管理同一个资源</span></span><br><span class="line"><span class="comment">    带引用计数：给每一个对象资源，匹配一个引用计数；</span></span><br><span class="line"><span class="comment">    智能指针 =》获取资源时 =》引用计数+1</span></span><br><span class="line"><span class="comment">    智能指针 =》本身指针释放=》引用计数-1</span></span><br><span class="line"><span class="comment">    如果最后一个使用资源的智能指针不用了，释放该资源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">    CSmartPtr&lt;<span class="type">int</span>&gt; ptr3;</span><br><span class="line">    ptr3 = ptr2;</span><br><span class="line">    *ptr1 = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; *ptr2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *ptr3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是，我这个自定义的还不是线程安全的。</span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr的交叉引用问题"><a href="#shared-ptr的交叉引用问题" class="headerlink" title="shared_ptr的交叉引用问题"></a>shared_ptr的交叉引用问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shared_ptr:强智能指针 可以改变资源的引用计数</span></span><br><span class="line"><span class="comment">weak_ptr:弱智能指针  不会改变资源的引用计数 它只会观察资源，不会使用，本身就没有*和-&gt;的重载函数，</span></span><br><span class="line"><span class="comment">所以需要把弱智能指针提升为强智能指针，才可以使用。</span></span><br><span class="line"><span class="comment">weak_ptr =&gt;shared_ptr =&gt;资源（内存）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">强智能指针循环引用是什么问题？什么结果？如何解决？</span></span><br><span class="line"><span class="comment">造成new出来的资源无法释放,资源泄露</span></span><br><span class="line"><span class="comment">定义对象的地方，用强智能指针；引用对象的地方使用弱智能指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;非常好用的方法！&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::weak_ptr&lt;B&gt; _ptrb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//_ptra-&gt;testA();</span></span><br><span class="line">        std::shared_ptr&lt;A&gt;ps = _ptra.<span class="built_in">lock</span>();<span class="comment">//提升方法,可能失败</span></span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ps-&gt;<span class="built_in">testA</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::weak_ptr&lt;A&gt; _ptra;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    pa-&gt;_ptrb = pb;</span><br><span class="line">    pb-&gt;_ptra = pa;</span><br><span class="line">    std::cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    pb-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建议用make-shared代替shared-ptr"><a href="#建议用make-shared代替shared-ptr" class="headerlink" title="建议用make_shared代替shared_ptr"></a>建议用make_shared代替shared_ptr</h3><p><img src="/C-%E6%8F%90%E5%8D%87/2.png" alt="2"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Test&gt; <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line">    <span class="comment">//std::shared_ptr&lt;int&gt; sp3 = std::make_shared&lt;int&gt;(10);</span></span><br><span class="line">    <span class="keyword">auto</span> sp3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    *sp3 = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; *sp3 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程访问共享对象的线程安全问题"><a href="#多线程访问共享对象的线程安全问题" class="headerlink" title="多线程访问共享对象的线程安全问题"></a>多线程访问共享对象的线程安全问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多线程访问共享对象的线程安全问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">testA</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;非常好用的方法！&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler01</span><span class="params">(std::weak_ptr&lt;A&gt; pw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//q访问A对象的时候，需要侦测A对象是否存活</span></span><br><span class="line">    std::shared_ptr&lt;A&gt; sp = pw.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (sp != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sp-&gt;<span class="built_in">testA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A对象已经析构，不能在访问&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;A&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">        <span class="function">std::thread <span class="title">t1</span><span class="params">(handler01, std::weak_ptr&lt;A&gt;(p))</span></span>;</span><br><span class="line">        t<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">20</span>));</span><br><span class="line">    <span class="comment">//阻塞等待子线程结束</span></span><br><span class="line">    <span class="comment">//t1.join();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义删除器"><a href="#自定义删除器" class="headerlink" title="自定义删除器"></a>自定义删除器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">智能指针的删除器 deletor</span></span><br><span class="line"><span class="comment">智能指针：能够保证资源绝对的释放 除了堆上的，文件资源等可以通过自定义删除器,因为底层的删除器是delete ptr;</span></span><br><span class="line"><span class="comment">所以可以根据实际情况，自定义删除器，满足析构要求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//unique_ptr shared_ptr</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">~unique_ptr()&#123;是一个函数对象的调用 deletor(ptr);&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">class default_delete</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    void operator()(T *ptr)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        delete ptr;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeletor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;call MyDeletor.operator()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[]ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFILEDeletor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;call MyFILEDeletor.operator()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">fclose</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;int,MyDeletor&lt;int&gt;&gt; ptr1(new int[100]);    //delete []ptr;</span></span><br><span class="line">    <span class="comment">//std::unique_ptr&lt;FILE, MyFILEDeletor&lt;FILE&gt;&gt; ptr2(fopen(&quot;data.txt&quot;,&quot;w&quot;));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是每一次都要自定义，太麻烦了，用一次就没用了，所以可以使用lambda表达式来实现，更方便</span></span><br><span class="line">    <span class="comment">//lambda表达式 -》函数对象 function</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>, std::function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>],</span><br><span class="line">        [](<span class="type">int</span>* p)-&gt;<span class="type">void</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;call lambda release new int [100]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">delete</span>[]p;</span><br><span class="line">        &#125;);</span><br><span class="line">    std::unique_ptr&lt;FILE, std::function&lt;<span class="type">void</span>(FILE*)&gt;&gt; <span class="built_in">ptr2</span>(<span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>),</span><br><span class="line">        [](FILE* p)-&gt;<span class="type">void</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;call lambda release new fopen&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">fclose</span>(p);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-绑定器和函数对象"><a href="#C-绑定器和函数对象" class="headerlink" title="C++绑定器和函数对象"></a>C++绑定器和函数对象</h2><h3 id="bind1st和bind2nd的使用"><a href="#bind1st和bind2nd的使用" class="headerlink" title="bind1st和bind2nd的使用"></a>bind1st和bind2nd的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 绑定器和函数对象operator()</span></span><br><span class="line"><span class="comment">1.C++ STL的绑定器</span></span><br><span class="line"><span class="comment">bind1st:operator()的第一个形参变量绑定成一个确定的值</span></span><br><span class="line"><span class="comment">bind2nd:operator()的第二个形参变量绑定成一个确定的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.C++11从boost库中引入bind绑定器和function函数对象机制</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.lambda表达式 底层依赖函数对象的机制实现的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showContainer</span><span class="params">(Container &amp;con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Container::iterator it = con.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (;it != con.<span class="built_in">end</span>();++it)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());<span class="comment">//默认升序</span></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    <span class="comment">//std::greater&lt;int&gt; 二元函数对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//降序</span></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把70按顺序插入到vec容器当中 找第一个小于70的数字</span></span><br><span class="line">    <span class="comment">//需要一个一元函数对象</span></span><br><span class="line">    <span class="comment">//绑定器+二元函数对象 =》一元函数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it=<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), std::<span class="built_in">bind1st</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">insert</span>(it, <span class="number">70</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现find-if和bind1st"><a href="#实现find-if和bind1st" class="headerlink" title="实现find_if和bind1st"></a>实现find_if和bind1st</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showContainer</span><span class="params">(Container&amp; con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> Container::iterator it = con.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (;it != con.<span class="built_in">end</span>();++it)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first, Iterator last, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;first != last;++first)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(*first))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_mybind1st</span> <span class="comment">//绑定器是函数对象的一个应用</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _mybind1st(Compare comp, T val)</span><br><span class="line">        :_comp(comp), _val(val)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _comp(_val, second);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _comp;</span><br><span class="line">    T _val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_mybind1st&lt;Compare, T&gt; <span class="title">mybind1st</span><span class="params">(Compare comp, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//直接使用函数模板，好处是，可以进行类型的推演</span></span><br><span class="line">    <span class="keyword">return</span> _mybind1st&lt;Compare, T&gt;(comp, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());<span class="comment">//默认升序</span></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    <span class="comment">//std::greater&lt;int&gt; 二元函数对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//降序</span></span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把70按顺序插入到vec容器当中 找第一个小于70的数字</span></span><br><span class="line">    <span class="comment">//需要一个一元函数对象</span></span><br><span class="line">    <span class="comment">//绑定器+二元函数对象 =》一元函数对象</span></span><br><span class="line">    <span class="comment">//auto it = find_if(vec.begin(), vec.end(), std::bind1st(std::greater&lt;int&gt;(), 70));</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">my_find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">mybind1st</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">insert</span>(it, <span class="number">70</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">showContainer</span>(vec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 16.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ 11 bind绑定器 =》 返回的结果还是一个函数对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(std::string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//bind()是函数模板 可以自动推演模板类型参数</span></span><br><span class="line">    std::<span class="built_in">bind</span>(hello, <span class="string">&quot;hello bind&quot;</span>)();</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">bind</span>(sum, <span class="number">10</span>, <span class="number">20</span>)() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">bind</span>(&amp;Test::sum, <span class="built_in">Test</span>(), <span class="number">20</span>, <span class="number">30</span>)() &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//参数占位符 绑定器出了语句，无法继续使用保存</span></span><br><span class="line">    std::<span class="built_in">bind</span>(hello, std::placeholders::_1)(<span class="string">&quot;hello bind 2&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">bind</span>(sum, std::placeholders::_1, std::placeholders::_2)(<span class="number">200</span>, <span class="number">300</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//此处把bind返回的绑定器就复用起来了</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>(std::string)&gt; func1 = std::<span class="built_in">bind</span>(hello, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">&quot;hello china&quot;</span>);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">&quot;hello china&quot;</span>);</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">&quot;hello china&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">muduo源码文件 threadpool.cc thread.cc bind function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Thread</span>(std::function&lt;<span class="built_in">void</span>()&gt; func)</span><br><span class="line">        :_func(func)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function">std::thread <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">(_func)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; _func;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 线程池类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//释放Thread对象占用的堆资源</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; _pool.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> _pool[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开启线程池</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startPool</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _pool.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(std::<span class="built_in">bind</span>(&amp;ThreadPool::runIThread,<span class="keyword">this</span>,i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _handler.<span class="built_in">push_back</span>(_pool[i]-&gt;<span class="built_in">start</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (std::thread&amp; t : _handler)</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Thread*&gt; _pool;</span><br><span class="line">    std::vector&lt;std::thread&gt; _handler;</span><br><span class="line">    <span class="comment">//把runIThread这个成员方法充当线程函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">runIThread</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;call runIThread! id:&quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line">    pool.<span class="built_in">startPool</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="function的应用"><a href="#function的应用" class="headerlink" title="function的应用"></a>function的应用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++提供的绑定器和函数对象</span></span><br><span class="line"><span class="comment">         bind   function</span></span><br><span class="line"><span class="comment">         C++ STL bind1st和bind2nd =&gt;本身还是一个函数对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello2</span><span class="params">(std::string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//调用函数必须依赖一个对象 void (Test::*pfunc)(string)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(std::string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.用函数类型实例化function</span></span><br><span class="line"><span class="comment">    2.通过function调用operator()函数的时候，需要根据函数类型传入相应的参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//从function的类模板定义处，看到希望用一个函数类型实例化function</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func1 = hello1;</span><br><span class="line">    <span class="built_in">func1</span>();<span class="comment">//func1.operator() =&gt;hello1()</span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(std::string)&gt; func2 = hello2;</span><br><span class="line">    <span class="built_in">func2</span>(<span class="string">&quot;hello2&quot;</span>);<span class="comment">//func2.operator()(string str)=&gt;hello2(str)</span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func3 = sum;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func3</span>(<span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func4 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func4</span>(<span class="number">100</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(Test*, std::string)&gt; func5 = &amp;Test::hello;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">func5</span>(&amp;t, <span class="string">&quot;call Test::hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doShowAllBooks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;查看所有书籍信息&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doBorrow</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;借书&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doBack</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;还书&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doQueryBooks</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;查询书籍&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doLoginOut</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;注销&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> choice = <span class="number">0</span>;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::function&lt;<span class="type">void</span>()&gt;&gt; actionMap;</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(&#123; <span class="number">1</span>,doShowAllBooks &#125;);</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(&#123; <span class="number">2</span>,doBorrow &#125;);</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(&#123; <span class="number">3</span>,doBack &#125;);</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(&#123; <span class="number">4</span>,doQueryBooks &#125;);</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(&#123; <span class="number">5</span>,doLoginOut &#125;);</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;1.查看所有书籍信息&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;2.借书&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;3.还书&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;4.查询书籍&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;5.注销&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;请选择：&quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = actionMap.<span class="built_in">find</span>(choice);</span><br><span class="line">        <span class="keyword">if</span> (it == actionMap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;输入数字无效，重新选择！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            it-&gt;<span class="built_in">second</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        switch (choice) //不好，因为这块代码无法闭合 无法做到&quot;开闭原则&quot;</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">        case 1:</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        case 2:</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        case 3:</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        case 4:</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        case 5:</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        default:</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板的完全特例化和非完全-部分-特例化"><a href="#模板的完全特例化和非完全-部分-特例化" class="headerlink" title="模板的完全特例化和非完全(部分)特例化"></a>模板的完全特例化和非完全(部分)特例化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">模板的完全特例化和非完全(部分)特例化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">模板的实参推演</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;template compare &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">compare</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;template compare&lt;const char*&gt; &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">compare</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;call Vector template init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面这个是对char *类型提供的完全特例化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="type">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;call Vector&lt;char *&gt; template init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面这个是对指针类型提供的部分特例化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;Ty*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;call Vector&lt;Ty*&gt; template init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//函数指针（有返回值，有两个形参变量）提供的部分特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="built_in">R</span>(*)(A1, A2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;call Vector&lt;R(*)(A1, A2)&gt; template init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//针对函数类型（有返回值，有两个形参变量）类型提供的部分特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>&lt;<span class="built_in">R</span>(A1, A2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;call Vector&lt;R(A1, A2)&gt; template init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector&lt;<span class="type">int</span>&gt; vec1;</span><br><span class="line">    Vector&lt;<span class="type">char</span> *&gt; vec2;</span><br><span class="line">    Vector&lt;<span class="type">int</span>*&gt; vec3;</span><br><span class="line">    Vector&lt;<span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>)&gt; vec4;</span><br><span class="line">    Vector&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; vec5;<span class="comment">//function</span></span><br><span class="line">    <span class="comment">//区分函数类型和函数指针类型</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*PFUNC1)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    PFUNC1 pfunc1 = sum;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">pfunc1</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title">PFUNC2</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    PFUNC2* pfunc2 = sum;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">pfunc2</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    call Vector template init</span></span><br><span class="line"><span class="comment">    call Vector&lt;char *&gt; template init</span></span><br><span class="line"><span class="comment">    call Vector&lt;Ty*&gt; template init</span></span><br><span class="line"><span class="comment">    call Vector&lt;R(*)(A1, A2)&gt; template init</span></span><br><span class="line"><span class="comment">    call Vector&lt;R(A1, A2)&gt; template init</span></span><br><span class="line"><span class="comment">    30</span></span><br><span class="line"><span class="comment">    30</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板的实参推演</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="comment">//T 包含所有的大的类型 那如果我要把返回值，所有形参的类型都取出来</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(R (*a)(A1,A2))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(R).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(A1).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(A2).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> T,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(R(T::* a)(A1, A2))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(R).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(A1).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(A2).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    <span class="built_in">func</span>(sum);<span class="comment">//T int (*)(int,int)</span></span><br><span class="line">    <span class="built_in">func2</span>(sum);</span><br><span class="line">    <span class="built_in">func</span>(&amp;Test::sum); <span class="comment">//int (__cdecl Test::*)(int,int)</span></span><br><span class="line">    <span class="built_in">func3</span>(&amp;Test::sum);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int</span></span><br><span class="line"><span class="comment">    char const * __ptr64</span></span><br><span class="line"><span class="comment">    int (__cdecl*)(int,int)</span></span><br><span class="line"><span class="comment">    int</span></span><br><span class="line"><span class="comment">    int</span></span><br><span class="line"><span class="comment">    int</span></span><br><span class="line"><span class="comment">    int (__cdecl Test::*)(int,int) __ptr64</span></span><br><span class="line"><span class="comment">    int</span></span><br><span class="line"><span class="comment">    class Test</span></span><br><span class="line"><span class="comment">    int</span></span><br><span class="line"><span class="comment">    int</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="function的实现原理"><a href="#function的实现原理" class="headerlink" title="function的实现原理"></a>function的实现原理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 18.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function函数对象类型的实现原理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(std::string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span> &#123;&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;typename R,typename A1&gt;</span></span><br><span class="line"><span class="comment">class myfunction&lt;R(A1)&gt;</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    //typedef R(*PFUNC)(A1);</span></span><br><span class="line"><span class="comment">    using PFUNC = R(*)(A1);</span></span><br><span class="line"><span class="comment">    myfunction(PFUNC Pfunc)</span></span><br><span class="line"><span class="comment">        :_pfunc(Pfunc)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    R operator()(A1 arg)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return _pfunc(arg);//hello(arg)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">private:</span></span><br><span class="line"><span class="comment">    PFUNC _pfunc;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">template&lt;typename R, typename A1,typename A2&gt;</span></span><br><span class="line"><span class="comment">class myfunction&lt;R(A1,A2)&gt;</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    //typedef R(*PFUNC)(A1);</span></span><br><span class="line"><span class="comment">    using PFUNC = R(*)(A1,A2);</span></span><br><span class="line"><span class="comment">    myfunction(PFUNC Pfunc)</span></span><br><span class="line"><span class="comment">        :_pfunc(Pfunc)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    R operator()(A1 arg1,A2 arg2)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return _pfunc(arg1,arg2);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">private:</span></span><br><span class="line"><span class="comment">    PFUNC _pfunc;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//利用可变参类型参数来解决上面写两个的问题</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... A&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myfunction</span>&lt;<span class="built_in">R</span>(A...)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//typedef R(*PFUNC)(A1);</span></span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(A...);</span><br><span class="line">    <span class="built_in">myfunction</span>(PFUNC Pfunc)</span><br><span class="line">        :_pfunc(Pfunc)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A... arg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _pfunc(arg...);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myfunction&lt;<span class="built_in">void</span>(std::string)&gt; func1 = hello;</span><br><span class="line">    <span class="built_in">func1</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    myfunction&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;<span class="built_in">func2</span>(sum);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式的实现原理"><a href="#lambda表达式的实现原理" class="headerlink" title="lambda表达式的实现原理"></a>lambda表达式的实现原理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++11 函数对象的升级版 =》lambda表达式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">lambda表达式语法：</span></span><br><span class="line"><span class="comment">[捕获外部变量](形参列表)-&gt;返回值&#123;操作代码&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果lambda表达式的返回值不需要，那么&quot;-&gt;返回值&quot;可以省略的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[捕获外部变量]</span></span><br><span class="line"><span class="comment">[]:不捕获任何外部变量</span></span><br><span class="line"><span class="comment">[=]:以传值的方式捕获外部所有变量</span></span><br><span class="line"><span class="comment">[&amp;]:以传引用的方式捕获外部的所有变量</span></span><br><span class="line"><span class="comment">[this]:捕获外部的this指针</span></span><br><span class="line"><span class="comment">[=,&amp;a]:以传值的方式捕获外部所有变量，但是a变量以传引用的方式捕获</span></span><br><span class="line"><span class="comment">[a,b]:以值传递的方式捕获外部变量a和b</span></span><br><span class="line"><span class="comment">[a,&amp;b]:a以值传递捕获，b以传引用的方式捕获</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> TestLambda01</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestLambda01</span>() &#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">operator</span>()()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> TestLambda02</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestLambda02</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">operator</span>()(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;typename T = int&gt;</span></span><br><span class="line"><span class="comment">class TestLambda03</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    TestLambda03(int a,int b):ma(a),mb(b) &#123;&#125;</span></span><br><span class="line"><span class="comment">    void operator()()const //常方法中不可以做修改，但是如果把变量加上mutable就可以</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int tmp = ma;</span></span><br><span class="line"><span class="comment">        ma = mb;</span></span><br><span class="line"><span class="comment">        mb = tmp;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">private:</span></span><br><span class="line"><span class="comment">    mutable int ma;</span></span><br><span class="line"><span class="comment">    mutable int mb;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> TestLambda03</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestLambda03</span>(<span class="type">int</span> a, <span class="type">int</span> b) :<span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b) &#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">operator</span>()()<span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = ma;</span><br><span class="line">        ma = mb;</span><br><span class="line">        mb = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> &amp;ma;</span><br><span class="line">    <span class="type">int</span> &amp;mb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">auto</span> func1 = []()-&gt;<span class="type">void</span> &#123;std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;&#125;;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    <span class="keyword">auto</span> func2 = [](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span> &#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br><span class="line">    TestLambda01&lt;&gt; t1;</span><br><span class="line">    <span class="built_in">t1</span>();</span><br><span class="line">    TestLambda02&lt;&gt; t2;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">t2</span>(<span class="number">20</span>, <span class="number">30</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    auto func3 = [a,b]()mutable //“a” : 无法在非可变 lambda 中修改通过复制捕获,这里要做声明mutable</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int tmp = a;</span></span><br><span class="line"><span class="comment">        a = b;</span></span><br><span class="line"><span class="comment">        b = tmp;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    func3();</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    TestLambda03&lt;&gt; t3(a,b);</span></span><br><span class="line"><span class="comment">    t3();</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;========================================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> func3 = [&amp;a, &amp;b]() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">func3</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    TestLambda03&lt;&gt; <span class="built_in">t3</span>(a, b);</span><br><span class="line">    <span class="built_in">t3</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt;<span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : vec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//65按序插入 要找第一个小于65的</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">int</span> a)-&gt;<span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a &lt; <span class="number">65</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">if</span>(it!=vec.<span class="built_in">end</span>())</span><br><span class="line">        vec.<span class="built_in">insert</span>(it, <span class="number">65</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : vec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式的应用实践"><a href="#lambda表达式的应用实践" class="headerlink" title="lambda表达式的应用实践"></a>lambda表达式的应用实践</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">既然lambda表达式只能使用在语句当中，如果想跨语句使用之前定义好的lambda表达式怎么办？</span></span><br><span class="line"><span class="comment">当然使用function类型来表示函数对象的类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">lambda表达式 =》函数对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    std::map&lt;int, std::function&lt;int(int, int)&gt;&gt; caculateMap;</span></span><br><span class="line"><span class="comment">    caculateMap[1] = [](int a, int b)-&gt;int &#123;return a + b;&#125;;</span></span><br><span class="line"><span class="comment">    caculateMap[2] = [](int a, int b)-&gt;int &#123;return a - b;&#125;;</span></span><br><span class="line"><span class="comment">    caculateMap[3] = [](int a, int b)-&gt;int &#123;return a * b;&#125;;</span></span><br><span class="line"><span class="comment">    caculateMap[4] = [](int a, int b)-&gt;int &#123;return a / b;&#125;;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;10+15:&quot; &lt;&lt; caculateMap[1](10, 15) &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> val1 = <span class="number">10</span>, <span class="type">int</span> val2 = <span class="number">10</span>) :<span class="built_in">ma</span>(val1), <span class="built_in">mb</span>(val2) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//智能指针自定义删除器 delete p</span></span><br><span class="line">    std::unique_ptr&lt;FILE, std::function&lt;<span class="type">void</span>(FILE*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>), [](FILE* pf) &#123;<span class="built_in">fclose</span>(pf);&#125;);</span><br><span class="line">    <span class="comment">//优先级队列</span></span><br><span class="line">    <span class="comment">//std::priority_queue&lt;Data&gt; queue;</span></span><br><span class="line">    <span class="keyword">using</span> FUNC = std::function&lt;<span class="built_in">bool</span>(Data&amp;, Data&amp;)&gt;;</span><br><span class="line">    std::priority_queue&lt;Data, std::vector&lt;Data&gt;, FUNC&gt; </span><br><span class="line">        <span class="built_in">maxHeap</span>([](Data&amp; d1, Data&amp; d2)-&gt;<span class="type">bool</span> </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> d<span class="number">1.</span>ma &gt; d<span class="number">1.</span>mb;</span><br><span class="line">        &#125;);</span><br><span class="line">    maxHeap.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    maxHeap.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line">    maxHeap.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">20</span>, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-11内容总结"><a href="#C-11内容总结" class="headerlink" title="C++11内容总结"></a>C++11内容总结</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++11相关的内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一：关键字和语法</span></span><br><span class="line"><span class="comment">auto :可以根据右值，推导出右值的类型，然后左边变量的类型也就已知了</span></span><br><span class="line"><span class="comment">nullptr:给指针专用(能够和整数进行区别) #define NULL 0</span></span><br><span class="line"><span class="comment">foreach:可以遍历数组，容器等</span></span><br><span class="line"><span class="comment">for(Type val:container) =&gt;底层就是通过指针或者迭代器来实现的</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    std::cout&lt;&lt;val&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">右值引用：move移动语义函数和forward类型完美转发函数</span></span><br><span class="line"><span class="comment">模板的新特性：typename... A 表示可变参(类型参数)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二：绑定器和函数对象</span></span><br><span class="line"><span class="comment">function:函数对象</span></span><br><span class="line"><span class="comment">bind：绑定器</span></span><br><span class="line"><span class="comment">lambda表达式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三：智能指针</span></span><br><span class="line"><span class="comment">shared_ptr和weak_ptr</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四：容器</span></span><br><span class="line"><span class="comment">set和map:红黑树 O(log2n)</span></span><br><span class="line"><span class="comment">unordered_set和unordered_map：哈希表 O(1)</span></span><br><span class="line"><span class="comment">array:数组 vector</span></span><br><span class="line"><span class="comment">forward_list:前向链表 list</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五：C++语言级别支持的多线程编程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-语言级别的多线程编程"><a href="#C-语言级别的多线程编程" class="headerlink" title="C++语言级别的多线程编程"></a>C++语言级别的多线程编程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 24.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++语言级别的多线程编程 =》代码可以跨平台</span></span><br><span class="line"><span class="comment">thread/mutex/condition_variable</span></span><br><span class="line"><span class="comment">lock_guard/unique_lock</span></span><br><span class="line"><span class="comment">atomic 原子类型 基于CAS操作的原子类型 线程安全的</span></span><br><span class="line"><span class="comment">sleep_for</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">线程内容：</span></span><br><span class="line"><span class="comment">一：怎么创建启动一个线程</span></span><br><span class="line"><span class="comment">std::thread定义一个线程对象，传入线程所需要的线程函数和参数，线程自动开启</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二：子线程如何结束</span></span><br><span class="line"><span class="comment">子线程函数运行完成，线程就结束了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三：主线程如何处理子线程</span></span><br><span class="line"><span class="comment">t.join:</span></span><br><span class="line"><span class="comment">t.detach:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//让子线程睡眠2秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello thread1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个线程对象 传入一个线程函数，新线程就开始运行了</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadHandler)</span></span>;</span><br><span class="line">    <span class="comment">//主线程等待子线程结束，主线程继续往下运行</span></span><br><span class="line">    <span class="comment">//t1.join();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//把子线程设置为分离线程</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main thread done&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mutex互斥锁和lock-guard"><a href="#mutex互斥锁和lock-guard" class="headerlink" title="mutex互斥锁和lock_guard"></a>mutex互斥锁和lock_guard</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ thread 模拟车站三个窗口卖票的程序</span></span><br><span class="line"><span class="comment">线程间的互斥 =》互斥锁mutex =&gt;lock_guard封装mutex</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">100</span>;<span class="comment">//车站有100张车票，由三个窗口一起卖票</span></span><br><span class="line">std::mutex mtx;<span class="comment">//全局的一把互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多线程程序</span></span><br><span class="line"><span class="comment">竞态条件：多线程程序执行的结果是一致的，不会随着CPU对线程不同的调用顺序，而产生不同的运行结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//模拟卖票的线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sellTicket</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>)<span class="comment">//ticketCount=1时，三个线程都进入循环，就会出现卖0，-1张票的bug,所以需要锁+双重判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//mtx.lock();</span></span><br><span class="line">            <span class="comment">//std::lock_guard&lt;std::mutex&gt; lock(mtx); //和scope_ptr不支持拷贝和赋值</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">//和unique_ptr支持右值的拷贝和赋值</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>)<span class="comment">//第二次判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//临界区代码段 =》原子操作 =》线程间互斥操作了=》mutex</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;窗口：&quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;卖出第：&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;张票！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">//std::cout &lt;&lt; count &lt;&lt; std::endl;</span></span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对于mtx.unlock();这里还有一个bug,如果临界区代码突然return出去了，那这个锁就没有释放，就造成死锁，所以使用类似智能指针，lock_guard:通过加局部作用域来实现及时自动析构。unique_lock自动加锁，解锁和lock_guard用法相同</span></span><br><span class="line">            <span class="comment">//mtx.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;std::thread&gt; tlist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">3</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tlist.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(sellTicket,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; t : tlist)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有的卖票结束了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程间同步通信-生产者消费者模型"><a href="#线程间同步通信-生产者消费者模型" class="headerlink" title="线程间同步通信-生产者消费者模型"></a>线程间同步通信-生产者消费者模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">//C++ STL容器都不是线程安全的</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++多线程编程 - 线程间同步通信机制</span></span><br><span class="line"><span class="comment">多线程编程两个问题：</span></span><br><span class="line"><span class="comment">1.线程间的互斥</span></span><br><span class="line"><span class="comment">    竞态条件 =》临界区代码 =》保证原子操作 =》互斥锁mutex 轻量级的无锁实现CAS</span></span><br><span class="line"><span class="comment">2.线程间的同步通信</span></span><br><span class="line"><span class="comment">生产者，消费者线程模型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::mutex mtx;<span class="comment">//定义互斥锁，做线程间的互斥操作</span></span><br><span class="line">std::condition_variable cv;<span class="comment">//定义条件变量，做线程间的同步通信操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者生产一个物品，通知消费者消费一个；消费完了，消费者再通知生产者继续生产。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> val)</span><span class="comment">//生产物品</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//std::lock_guard&lt;std::mutex&gt; guard(mtx);//如果再用unique_lock会上两遍锁。</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//que不为空，生产者应该通知消费者去消费，消费完了，再继续生产</span></span><br><span class="line">            <span class="comment">//生产者线程进入1.等待状态，2.并且把mtx互斥锁释放掉</span></span><br><span class="line">            cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        notify_one:通知另外的一个线程的</span></span><br><span class="line"><span class="comment">        notify_all:通知其他所有线程的</span></span><br><span class="line"><span class="comment">        通知其他所有的线程，我生产了一个物品，可以消费了</span></span><br><span class="line"><span class="comment">        其他线程得到该通知，就会从等待状态=》阻塞状态 =》获取互斥锁才能继续执行(这里得等待其他线程把锁放开，之后再抢)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;生产者 生产：&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;号物品&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//消费物品</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//std::lock_guard&lt;std::mutex&gt; guard(mtx);</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//消费者线程发现que是空的，通知生产者线程先生产商品</span></span><br><span class="line">            <span class="comment">//1.进入等待状态，2.把互斥锁mtx释放 </span></span><br><span class="line">            cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> val = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();<span class="comment">//通知其他线程，消费完了，赶紧生产</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;消费者 消费：&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;号物品&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(Queue* que)</span><span class="comment">//生产者线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        que-&gt;<span class="built_in">put</span>(i);</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(Queue* que)</span><span class="comment">//消费者线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        que-&gt;<span class="built_in">get</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue que;<span class="comment">//两个线程共享的队列</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer,&amp;que)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer, &amp;que)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生产者 生产：1号物品</span></span><br><span class="line"><span class="comment">消费者 消费：1号物品</span></span><br><span class="line"><span class="comment">生产者 生产：2号物品</span></span><br><span class="line"><span class="comment">消费者 消费：2号物品</span></span><br><span class="line"><span class="comment">生产者 生产：3号物品</span></span><br><span class="line"><span class="comment">消费者 消费：3号物品</span></span><br><span class="line"><span class="comment">生产者 生产：4号物品</span></span><br><span class="line"><span class="comment">消费者 消费：4号物品</span></span><br><span class="line"><span class="comment">生产者 生产：5号物品</span></span><br><span class="line"><span class="comment">消费者 消费：5号物品</span></span><br><span class="line"><span class="comment">生产者 生产：6号物品</span></span><br><span class="line"><span class="comment">消费者 消费：6号物品</span></span><br><span class="line"><span class="comment">生产者 生产：7号物品</span></span><br><span class="line"><span class="comment">消费者 消费：7号物品</span></span><br><span class="line"><span class="comment">生产者 生产：8号物品</span></span><br><span class="line"><span class="comment">消费者 消费：8号物品</span></span><br><span class="line"><span class="comment">生产者 生产：9号物品</span></span><br><span class="line"><span class="comment">消费者 消费：9号物品</span></span><br><span class="line"><span class="comment">生产者 生产：10号物品</span></span><br><span class="line"><span class="comment">消费者 消费：10号物品</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="lock-guard和unique-lock"><a href="#lock-guard和unique-lock" class="headerlink" title="lock_guard和unique_lock"></a>lock_guard和unique_lock</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">unique_lock condition_variable</span></span><br><span class="line"><span class="comment">1.lock_guard和unique_lock</span></span><br><span class="line"><span class="comment">2.condition_variable:wait和notify_all方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//mtx.lock();</span></span><br><span class="line">    <span class="comment">//mtx.unlock();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不可能用在函数参数传递或者返回过程中，只能用在简单的临界区代码段的互斥操作中</span></span><br><span class="line">    <span class="comment">//std::lock_guard&lt;std::mutex&gt; guard(mtx);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不仅可以使用在简单的临界区代码段的互斥操作中，还能用在函数调用过程中</span></span><br><span class="line">    <span class="comment">//std::unique_lock&lt;std::mutex&gt; lck(mtx);</span></span><br><span class="line">    <span class="comment">//cv.wait(lck);//=&gt;1.使线程进入等待状态 2.lck.unlock可以把mtx给释放掉</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通知在cv上等待的线程，条件成立了，起来干活了</span></span><br><span class="line"><span class="comment">    其他在cv上等待的线程，收到通知，从等待状态 =》阻塞状态 =》获取互斥锁 =》线程继续往下执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于CAS操作的atomic原子类型"><a href="#基于CAS操作的atomic原子类型" class="headerlink" title="基于CAS操作的atomic原子类型"></a>基于CAS操作的atomic原子类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span><span class="comment">//包含了很多原子类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++11</span></span><br><span class="line"><span class="comment">窗口卖票 int count=100;</span></span><br><span class="line"><span class="comment">lock_guard&lt;std::mutex&gt;guard(mtx);</span></span><br><span class="line"><span class="comment">count++;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">lock_guard&lt;std::mutex&gt;guard(mtx);</span></span><br><span class="line"><span class="comment">count--;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">互斥锁是比较重的，需要临界区代码做的事情稍稍复杂，多</span></span><br><span class="line"><span class="comment">系统理论:CAS来保证上面++ --操作的 ，原子特性就足够了。无锁操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">volatile</span> std::atomic_bool isReady = <span class="literal">false</span>;<span class="comment">//volatile防止多线程对共享变量进行缓存</span></span><br><span class="line"><span class="keyword">volatile</span> std::atomic_int count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!isReady)</span><br><span class="line">    &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();<span class="comment">//线程出让当前的CPU时间片，等待下一次调度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;std::thread&gt; tlist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tlist.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(task));</span><br><span class="line">    &#125;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    isReady = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::thread&amp; t : tlist)</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="emplace方法"><a href="#emplace方法" class="headerlink" title="emplace方法"></a>emplace方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ STL容器 push/insert =&gt;emplace新的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(int)&quot;</span> &lt;&lt; std::endl; &#125;;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(int,int)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(Test&amp;&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::vector&lt;Test&gt; v;</span><br><span class="line">    v.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//直接插入对象，push_back和emplace_back是没有区别的，都是调用拷贝构造函数</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(t1);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Test(const Test&amp;)</span></span><br><span class="line"><span class="comment">    Test(const Test&amp;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//直接插入对象，push_back和emplace_back是没有区别的，都是调用拷贝构造函数</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">Test</span>(<span class="number">20</span>));</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="built_in">Test</span>(<span class="number">20</span>));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Test(int)</span></span><br><span class="line"><span class="comment">    Test(Test&amp;&amp;)</span></span><br><span class="line"><span class="comment">    ~Test()</span></span><br><span class="line"><span class="comment">    Test(int)</span></span><br><span class="line"><span class="comment">    Test(Test&amp;&amp;)</span></span><br><span class="line"><span class="comment">    ~Test()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//给emplace传入Test对象构造所需要的参数，直接在容器底层构造对象即可</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Test(int)</span></span><br><span class="line"><span class="comment">    Test(int,int)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::map&lt;int, std::string&gt; m;</span></span><br><span class="line"><span class="comment">    m.insert(std::make_pair(10, &quot;张三&quot;));</span></span><br><span class="line"><span class="comment">    //在map底层直接调用普通构造函数，生成对象</span></span><br><span class="line"><span class="comment">    m.emplace(10, &quot;张三&quot;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="emplace方法的简单实现"><a href="#emplace方法的简单实现" class="headerlink" title="emplace方法的简单实现"></a>emplace方法的简单实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 29.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ STL容器 push/insert =&gt;emplace新的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(int)&quot;</span> &lt;&lt; std::endl; &#125;;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(int,int)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Test(Test&amp;&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实现容器的空间配置器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAllocator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//allocate deallocate</span></span><br><span class="line">    <span class="comment">//contruct destroy</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(size * <span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">construct</span><span class="params">(T* ptr, Types&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> (ptr) <span class="built_in">T</span>(std::forward&lt;Types&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ptr-&gt;~<span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc=MyAllocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>() :<span class="built_in">vec_</span>(<span class="literal">nullptr</span>), <span class="built_in">size_</span>(<span class="number">0</span>), <span class="built_in">idx_</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">reserve</span>(<span class="type">size_t</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        vec_ = allocator_.<span class="built_in">allocate</span>(size);</span><br><span class="line">        size_ = size;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; idx_;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator_.<span class="built_in">destroy</span>(vec_ + i);</span><br><span class="line">        &#125;</span><br><span class="line">        allocator_.<span class="built_in">deallocate</span>(vec_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push_back</span></span><br><span class="line">    <span class="comment">/*void push_back(const T&amp; val)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        allocator_.construct(vec_ + idx_, val);</span></span><br><span class="line"><span class="comment">        idx_++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void push_back(T&amp;&amp; val)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        allocator_.construct(vec_ + idx_, std::move(val));</span></span><br><span class="line"><span class="comment">        idx_++;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">push_back</span><span class="params">(Type&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        allocator_.<span class="built_in">construct</span>(vec_ + idx_, std::forward&lt;Type&gt;(val));</span><br><span class="line">        idx_++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.引用折叠 </span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Types&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//不管是左值应用，右值引用变量，它本身是个左值，传递过程要保持args的引用类型需要类型的完美转发</span></span><br><span class="line">        allocator_.<span class="built_in">construct</span>(vec_ + idx_, std::forward&lt;Types&gt;(args)...);</span><br><span class="line">        idx_++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* vec_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line">    <span class="type">int</span> idx_;</span><br><span class="line">    Alloc allocator_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    vector&lt;Test&gt; v;</span><br><span class="line">    v.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//直接插入对象，push_back和emplace_back是没有区别的，都是调用拷贝构造函数</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(t1);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Test(const Test&amp;)</span></span><br><span class="line"><span class="comment">    Test(const Test&amp;)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//直接插入对象，push_back和emplace_back是没有区别的，都是调用拷贝构造函数</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">Test</span>(<span class="number">20</span>));</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="built_in">Test</span>(<span class="number">20</span>));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Test(int)</span></span><br><span class="line"><span class="comment">    Test(Test&amp;&amp;)</span></span><br><span class="line"><span class="comment">    ~Test()</span></span><br><span class="line"><span class="comment">    Test(int)</span></span><br><span class="line"><span class="comment">    Test(Test&amp;&amp;)</span></span><br><span class="line"><span class="comment">    ~Test()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//给emplace传入Test对象构造所需要的参数，直接在容器底层构造对象即可</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Test(int)</span></span><br><span class="line"><span class="comment">    Test(int,int)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=====================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单例模式：一个类不管创建多少次对象，永远只能得到该类型一个对象的实例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">常用到的：日志模块，数据库模块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">单例模式：</span></span><br><span class="line"><span class="comment">饿汉式单例模式：还没有获取实例对象，实例对象就已经产生了</span></span><br><span class="line"><span class="comment">懒汉式单例模式：唯一的实例对象，直到第一次获取它的时候，才产生</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//饿汉式单例模式 一定是线程安全的，但是有时候没有必要一开始就实例化对象，浪费启动资源。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span><span class="comment">//3.获取类的唯一实例对象的接口方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton instance;<span class="comment">//2.定义一个唯一的类的实例对象</span></span><br><span class="line">    <span class="built_in">Singleton</span>()<span class="comment">//1.构造函数私有化</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::instance;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//懒汉式单例模式 不是线程安全的,通过加锁成为线程安全</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//是不是可重入函数(在多线程环境下，函数没执行完，是否其他线程再调用，可以保证线程安全)，当然不是</span></span><br><span class="line">    <span class="comment">//所以要对函数中的临界区代码做互斥</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span><span class="comment">//3.获取类的唯一实例对象的接口方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//std::lock_guard&lt;std::mutex&gt;guard(mtx);//锁的粒度太大了，单线程调用一次就会加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt;<span class="built_in">guard</span>(mtx);<span class="comment">//单加锁，在多线程环境下有问题，锁+双重判断</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            开辟内存</span></span><br><span class="line"><span class="comment">            构造对象</span></span><br><span class="line"><span class="comment">            给instance赋值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton * <span class="keyword">volatile</span> instance;<span class="comment">//2.定义一个唯一的类的实例对象</span></span><br><span class="line">    <span class="built_in">Singleton</span>()<span class="comment">//1.构造函数私有化</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* <span class="keyword">volatile</span> Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式单例模式另一种写法(线程安全)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span><span class="comment">//2.获取类的唯一实例对象的接口方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//函数静态局部变量的初始化(执行这段代码才会初始化)，在汇编指令上已经自动添加线程互斥指令了，C++11保证线程安全</span></span><br><span class="line">        <span class="comment">//关于初始化的时机，全局静态变量，函数内静态变量，类内静态变量的初始化时机是不同的。</span></span><br><span class="line">        <span class="type">static</span> Singleton instance;<span class="comment">//2.定义一个唯一的类的实例对象</span></span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()<span class="comment">//1.构造函数私有化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//很多初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton* p1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* p2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* p3 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态变量初始化时机</strong></p>
<table>
<thead>
<tr>
<th>位置</th>
<th>内存位置</th>
<th>初始化时机</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数内 static</strong></td>
<td>静态存储区</td>
<td>第一次执行到时</td>
<td>程序开始 → 结束</td>
</tr>
<tr>
<td><strong>全局 static</strong></td>
<td>静态存储区</td>
<td><code>main()</code> 前</td>
<td>程序开始 → 结束</td>
</tr>
<tr>
<td><strong>类内 static</strong></td>
<td>静态存储区</td>
<td><code>main()</code> 前</td>
<td>程序开始 → 结束</td>
</tr>
<tr>
<td><strong>带构造函数的局部 static</strong></td>
<td>静态存储区</td>
<td>第一次执行到时（线程安全，C++11+）</td>
<td>程序开始 → 结束</td>
</tr>
</tbody></table>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">简单工厂 Simple Factory :把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象。</span></span><br><span class="line"><span class="comment">优点：客户不用自己负责new对象，不用了解对象创建的详细过程</span></span><br><span class="line"><span class="comment">缺点：提供创建对象实例的接口函数不闭合，不能对修改关闭</span></span><br><span class="line"><span class="comment">工厂方法 Factory Method：Factory基类，提供了一个纯虚函数(创建产品)，定义派生类(具体产品的工厂)负责创建对应的产品。</span></span><br><span class="line"><span class="comment">优点：可以做到不同的产品，在不同的工厂创建，能够对现有工厂，以及产品的修改关闭</span></span><br><span class="line"><span class="comment">缺点：实际上，很多产品是有关联关系的，属于一个产品簇，不应该放在不同的工厂里面去创建，这样一是不符合实际的产品对象创建逻辑，二是工厂类太多了，不好维护。</span></span><br><span class="line"><span class="comment">抽象工厂 Abstract Factory：把有关联关系的，属于一个产品簇的所有产品创建的接口函数，放在一个抽象工厂里面AbstractFactory，派生类(具体的产品的工厂)应该负责创建该产品簇里面所有的产品。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">工厂模式：主要是封装了对象的创建</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>(std::string name) :_name(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bmw</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bmw</span>(std::string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取了一辆宝马汽车&quot;</span> &lt;&lt;_name&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Audi</span>(std::string name) :<span class="built_in">Car</span>(name)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取了一辆奥迪汽车&quot;</span> &lt;&lt;_name&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//简单工厂</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CarType</span></span><br><span class="line">&#123;</span><br><span class="line">    BMW,AUDI</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car* <span class="title">createCar</span><span class="params">(CarType ct)</span> <span class="comment">//不满足软件设计 &quot;开闭原则&quot;而且一般来说一种工厂生产同一类产品，应该分开</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (ct)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> BMW:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(<span class="string">&quot;X1&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> AUDI:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(<span class="string">&quot;A6&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;传入工厂的参数不正确：&quot;</span> &lt;&lt; ct &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Car* p1 = new BMW(&quot;X1&quot;);</span></span><br><span class="line">    <span class="comment">//Car* p2 = new Audi(&quot;A6&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;SimpleFactory&gt; <span class="title">factory</span><span class="params">(<span class="keyword">new</span> SimpleFactory())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(factory-&gt;createCar(BMW))</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(factory-&gt;createCar(AUDI))</span></span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//工厂方法 满足开闭原则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car* <span class="title">createCar</span><span class="params">(std::string name)</span> </span>= <span class="number">0</span>;<span class="comment">//工厂方法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//宝马工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWFactory</span> :<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car* <span class="title">createCar</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//奥迪工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiFactory</span>:<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car* <span class="title">createCar</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//现在考虑产品 一类产品(有关联关系的系列产品(同一个牌子的手机，耳机等))</span></span><br><span class="line">    <span class="comment">//如果同一个牌子都要分开建厂，厂太多了，所以用到抽象工厂，把系列产品都放在一个厂里</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Factory&gt; <span class="title">bmwfty</span><span class="params">(<span class="keyword">new</span> BMWFactory())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Factory&gt; <span class="title">audifty</span><span class="params">(<span class="keyword">new</span> AudiFactory())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwfty-&gt;createCar(<span class="string">&quot;X6&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(audifty-&gt;createCar(<span class="string">&quot;A8&quot;</span>))</span></span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Light</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BmwLight</span>:<span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BmwLight</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;宝马车灯&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiLight</span> :<span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AudiLight</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;奥迪车灯&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂（对有一组关联关系的产品簇提供产品对象的统一创建）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Car* <span class="title">createCar</span><span class="params">(std::string name)</span> </span>= <span class="number">0</span>;<span class="comment">//工厂方法 创建汽车</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Light* <span class="title">createCarLight</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//工厂方法 创建汽车关联的产品，车灯</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//宝马工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMWFactory</span> :<span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car* <span class="title">createCar</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Light* <span class="title">createCarLight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BmwLight</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//奥迪工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudiFactory</span> :<span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Car* <span class="title">createCar</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Light* <span class="title">createCarLight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudiLight</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//现在考虑产品 一类产品(有关联关系的系列产品(同一个牌子的手机，耳机等))</span></span><br><span class="line">    <span class="comment">//如果同一个牌子都要分开建厂，厂太多了，所以用到抽象工厂</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;AbstractFactory&gt; <span class="title">bmwfty</span><span class="params">(<span class="keyword">new</span> BMWFactory())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;AbstractFactory&gt; <span class="title">audifty</span><span class="params">(<span class="keyword">new</span> AudiFactory())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwfty-&gt;createCar(<span class="string">&quot;X6&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(audifty-&gt;createCar(<span class="string">&quot;A8&quot;</span>))</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Light&gt; <span class="title">p3</span><span class="params">(bmwfty-&gt;createCarLight())</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Light&gt; <span class="title">p4</span><span class="params">(audifty-&gt;createCarLight())</span></span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p3-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p4-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代理Proxy模式:通过代理类，来控制实际对象的访问权限</span></span><br><span class="line"><span class="comment">客户    助理Proxy    老板:委托类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSite</span> <span class="comment">//抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//免费电影</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//vip电影</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//用券观看电影</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BossVideoSite</span>:<span class="keyword">public</span> VideoSite <span class="comment">//委托类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span> <span class="comment">//免费电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;观看免费电影&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span> <span class="comment">//vip电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;观看vip电影&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span> <span class="comment">//用券观看电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;观看用券观看电影&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//代理类 代理BossVideoSite,实现只能使用免费电影的服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeVideoSiteProxy</span> :<span class="keyword">public</span> VideoSite</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreeVideoSiteProxy</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pVideo = <span class="keyword">new</span> <span class="built_in">BossVideoSite</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FreeVideoSiteProxy</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pVideo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span><span class="comment">//免费电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pVideo-&gt;<span class="built_in">freeMovie</span>();<span class="comment">//通过代理对象的freeMovie，来访问真正委托类对象的freeMovie方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span><span class="comment">//vip电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你目前只是普通游客，需要VIP&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span><span class="comment">//用券观看电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你目前只是普通游客，需要购买券&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VideoSite* pVideo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类 代理BossVideoSite，实现使用免费电影和VIP电影的服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VIPVideoSiteProxy</span> :<span class="keyword">public</span> VideoSite</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VIPVideoSiteProxy</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pVideo = <span class="keyword">new</span> <span class="built_in">BossVideoSite</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">VIPVideoSiteProxy</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pVideo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeMovie</span><span class="params">()</span><span class="comment">//免费电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pVideo-&gt;<span class="built_in">freeMovie</span>();<span class="comment">//通过代理对象的freeMovie，来访问真正委托类对象的freeMovie方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vipMovie</span><span class="params">()</span><span class="comment">//vip电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pVideo-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ticketMovie</span><span class="params">()</span><span class="comment">//用券观看电影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;你目前只是普通游客，需要购买券&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    VideoSite* pVideo;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">watchMovie</span><span class="params">(std::unique_ptr&lt;VideoSite&gt; &amp;ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">freeMovie</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">vipMovie</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">ticketMovie</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;VideoSite&gt;<span class="built_in">p1</span>(<span class="keyword">new</span> <span class="built_in">FreeVideoSiteProxy</span>());</span><br><span class="line">    std::unique_ptr&lt;VideoSite&gt;<span class="built_in">p2</span>(<span class="keyword">new</span> <span class="built_in">VIPVideoSiteProxy</span>());</span><br><span class="line">    <span class="built_in">watchMovie</span>(p1);</span><br><span class="line">    <span class="built_in">watchMovie</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">装饰器模式 Decorator:主要是增加现有类的功能。：通过把功能实现为Car的子类，引入Car的指针，在传下来的虚函数重写加入对应实体的show后，再实现具体的功能。</span></span><br><span class="line"><span class="comment">但是，增加现有类的功能，还有一个方法：新增加一个子类</span></span><br><span class="line"><span class="comment">通过子类实现功能增强的问题：为了增强现有类的功能，通过实现子类的方式，重写接口，是可以实现功能，但是代码中添加子类太多</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span><span class="comment">//抽象基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//三个实体的汽车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bmw</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;这是一辆宝马,配置有：基本配置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;这是一辆奥迪,配置有：基本配置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;这是一辆奔驰,配置有：基本配置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//装饰器1 定速巡航</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorate01</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorate01</span>(Car* p) :<span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;,定速巡航&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//装饰器2 自动刹车</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorate02</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorate02</span>(Car* p) :<span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;,自动刹车&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//装饰器3 车道偏离</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorate03</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorate03</span>(Car* p) :<span class="built_in">pCar</span>(p) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pCar-&gt;<span class="built_in">show</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;,车道偏离&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Car* pCar;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car* p1 =<span class="keyword">new</span> <span class="built_in">ConcreteDecorate01</span>(<span class="keyword">new</span> <span class="built_in">Bmw</span>());</span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorate02</span>(p1);</span><br><span class="line">    Car* p2 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorate02</span>(<span class="keyword">new</span> <span class="built_in">Audi</span>());</span><br><span class="line">    Car* p3 = <span class="keyword">new</span> <span class="built_in">ConcreteDecorate03</span>(<span class="keyword">new</span> <span class="built_in">Benz</span>());</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p3-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">适配器模式：让不兼容的接口可以在一起工作</span></span><br><span class="line"><span class="comment">电脑 =》投影到 =》投影仪上    VGA  HDMI TypeC</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">VGA接口的电脑，投影仪也是VGA接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGA</span> <span class="comment">//VGA接口类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//TV01表示支持VGA接口的投影仪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV01</span> :<span class="keyword">public</span> VGA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;通过VGA接口连接投影仪&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实现一个电脑类(只支持VGA)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer01</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//由于只支持VGA,所以参数只能是VGA接口的指针/引用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playVideo</span><span class="params">(VGA* pVGA)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pVGA-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">computer.playVideo(new TV02());</span></span><br><span class="line"><span class="comment">如何解决只支持VGA,而不支持HDMI</span></span><br><span class="line"><span class="comment">方法1：换一个支持HDMI接口的电脑，这个就叫代码重构</span></span><br><span class="line"><span class="comment">方法2：买一个转换头(适配器)，能够把VGA信号转成HDMI信号，这个叫做添加适配器类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//进了一批新的投影仪，但是投影仪都是只支持HDMI接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HDMI</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV02</span>:<span class="keyword">public</span> HDMI</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;通过HDMI接口连接投影仪&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//由于电脑(VGA接口)和投影仪(HDMI接口)无法直接相连，所以需要添加适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VGAToHDMIAdapter</span> :<span class="keyword">public</span> VGA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VGAToHDMIAdapter</span>(HDMI* p) :<span class="built_in">pHdmi</span>(p)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span><span class="comment">//该方法相当于转换头，做不同接口的信号转换</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pHdmi-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HDMI* pHdmi;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Computer01 computer;</span><br><span class="line">    <span class="comment">//computer.playVideo(new TV01());</span></span><br><span class="line">    computer.<span class="built_in">playVideo</span>(<span class="keyword">new</span> <span class="built_in">VGAToHDMIAdapter</span>(<span class="keyword">new</span> <span class="built_in">TV02</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 行为型模式:主要关注的是对象之间的通信</span></span><br><span class="line"><span class="comment">观察者(发布-订阅模式)设计模式：主要关注的是对象的一对多的关系，也就是多个对象都依赖一个对象，当该对象的状态发生改变时，其他对象都能接收到相应的通知</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一组数据(数据对象)  =》通过这一组数据 =&gt; 曲线图(对象1)/柱状图(对象2)/圆饼图(对象3)</span></span><br><span class="line"><span class="comment">当数据对象改变时，对象1，对象2，对象3应该及时的收到相应的通知</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//观察者抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//处理消息的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer1</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msgid)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Observer1 recv 1 msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Observer1 recv 2 msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Observer1 recv unknow msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第二个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer2</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msgid)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Observer2 recv 2 msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Observer2 recv unknow msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第三个观察者实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer3</span> :<span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msgid)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Observer3 recv 1 msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Observer3 recv 3 msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Observer3 recv unknow msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//给主题增加观察者对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addObserver</span><span class="params">(Observer* obser, <span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _subMap[msgid].<span class="built_in">push_back</span>(obser);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主题检测发生改变，通知相应的观察者对象处理事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">(<span class="type">int</span> msgid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = _subMap.<span class="built_in">find</span>(msgid);</span><br><span class="line">        <span class="keyword">if</span> (it != _subMap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (Observer* pObser : it-&gt;second)</span><br><span class="line">            &#123;</span><br><span class="line">                pObser-&gt;<span class="built_in">handle</span>(msgid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::list&lt;Observer*&gt;&gt; _subMap;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subject subject;</span><br><span class="line">    Observer* p1 = <span class="keyword">new</span> <span class="built_in">Observer1</span>();</span><br><span class="line">    Observer* p2 = <span class="keyword">new</span> <span class="built_in">Observer2</span>();</span><br><span class="line">    Observer* p3 = <span class="keyword">new</span> <span class="built_in">Observer3</span>();</span><br><span class="line">    subject.<span class="built_in">addObserver</span>(p1, <span class="number">1</span>);</span><br><span class="line">    subject.<span class="built_in">addObserver</span>(p1, <span class="number">2</span>);</span><br><span class="line">    subject.<span class="built_in">addObserver</span>(p2, <span class="number">2</span>);</span><br><span class="line">    subject.<span class="built_in">addObserver</span>(p3, <span class="number">1</span>);</span><br><span class="line">    subject.<span class="built_in">addObserver</span>(p3, <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> msgid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;输入消息id&quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; msgid;</span><br><span class="line">        <span class="keyword">if</span> (msgid == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        subject.<span class="built_in">dispatch</span>(msgid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article>
<div class="article-footer">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    


    <section id="share">
      <div class="header"><span>分享文章</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="http://yustonerain.top/C-%E6%8F%90%E5%8D%87/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot;)"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=http://yustonerain.top/C-%E6%8F%90%E5%8D%87/&title=C++提升 - YuStone&summary=C++提升学习"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg" /></a><a class="social share-item email" href="mailto:?subject=C++提升 - YuStone&amp;body=http://yustonerain.top/C-%E6%8F%90%E5%8D%87/"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img  src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=http://yustonerain.top/C-%E6%8F%90%E5%8D%87/"/>
        </div>
        
      </div>
    </section>
    </div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">git必知必会</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/C-basiclearning/">C++basiclearning</a></div></section></div>

<div class="related-wrap" id="related-posts">
    <section class='header'>
      <div class='title cap theme'>您可能感兴趣的文章</div>
    </section>
    <section class='body'>
    <div class="related-posts"><a class="item" href="/C-basiclearning/" title="C++basiclearning"><span class="title">C++basiclearning</span><span class="excerpt">C++基础学习</span></a></div></section></div>


  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body utterances'>
      

<svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="utterances" repo="YuStone0416/YuStone0416.github.io" issue-term="pathname" theme="preferred-color-scheme"></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">YuStone</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1">Stellar 1.33.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%AF%B9%E8%B1%A1%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-text">C++对象应用优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E8%83%8C%E5%90%8E%E8%B0%83%E7%94%A8%E4%BA%86%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">对象使用过程背后调用了那些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%83%8C%E5%90%8E%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">函数调用过程中背后调用的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%9D%A1%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">三条对象优化的原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">右值引用参数的成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B8%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">使用带右值引用参数的赋值重载函数解决临时对象的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E5%9C%A8vector%E5%AE%B9%E5%99%A8%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">自定义对象在vector容器上的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move%E5%92%8Cforward"><span class="toc-text">move和forward</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D"><span class="toc-text">基础介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">不带引用计数的智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">实现带引用计数的智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E7%9A%84%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">shared_ptr的交叉引用问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E7%94%A8make-shared%E4%BB%A3%E6%9B%BFshared-ptr"><span class="toc-text">建议用make_shared代替shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">多线程访问共享对象的线程安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-text">自定义删除器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">C++绑定器和函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bind1st%E5%92%8Cbind2nd%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">bind1st和bind2nd的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0find-if%E5%92%8Cbind1st"><span class="toc-text">实现find_if和bind1st</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind"><span class="toc-text">bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#function%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">function的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%8C%E5%85%A8%E7%89%B9%E4%BE%8B%E5%8C%96%E5%92%8C%E9%9D%9E%E5%AE%8C%E5%85%A8-%E9%83%A8%E5%88%86-%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-text">模板的完全特例化和非完全(部分)特例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#function%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">function的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">lambda表达式的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5"><span class="toc-text">lambda表达式的应用实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93"><span class="toc-text">C++11内容总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E7%BA%A7%E5%88%AB%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">C++语言级别的多线程编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mutex%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8Clock-guard"><span class="toc-text">mutex互斥锁和lock_guard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-text">线程间同步通信-生产者消费者模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-guard%E5%92%8Cunique-lock"><span class="toc-text">lock_guard和unique_lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ECAS%E6%93%8D%E4%BD%9C%E7%9A%84atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-text">基于CAS操作的atomic原子类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#emplace%E6%96%B9%E6%B3%95"><span class="toc-text">emplace方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#emplace%E6%96%B9%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">emplace方法的简单实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">观察者模式</span></a></li></ol></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5" d="M8 10.5h8M8 14h5.5M17 3.338A9.95 9.95 0 0 0 12 2C6.477 2 2 6.477 2 12c0 1.6.376 3.112 1.043 4.453c.178.356.237.763.134 1.148l-.595 2.226a1.3 1.3 0 0 0 1.591 1.592l2.226-.596a1.63 1.63 0 0 1 1.149.133A9.96 9.96 0 0 0 12 22c5.523 0 10-4.477 10-10c0-1.821-.487-3.53-1.338-5"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->

  <script type="module">
  const el = document.querySelector("#comments #utterances");
  util.viewportLazyload(el, load_utterances, false);

  function load_utterances() {
    if (!el) return;
    try {
      el.innerHTML = '';
    } catch (error) {
      console.error(error);
    }
    const script = document.createElement('script');
    script.src = 'https://utteranc.es/client.js';
    script.async = true;
    for (const key of Object.keys(el.attributes)) {
      const attr = el.attributes[key];
      if (['class', 'id'].includes(attr.name) === false) {
        script.setAttribute(attr.name, attr.value);
      }
    }
    el.appendChild(script);
  }
</script>




<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
